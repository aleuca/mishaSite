/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/app/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/app/css/index.css":
/*!*********************************************************!*\
  !*** ./node_modules/css-loader!./src/app/css/index.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(/*! ../../../node_modules/css-loader/lib/url/escape.js */ \"./node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"html, body {\\n    margin: 0;\\n    height: 100%;\\n    background-color: #f7f7f7;\\n}\\n\\n.nav {\\n    z-index: 3;\\n}\\n\\n/* homepage style */\\n\\n.homepage-header {\\n    font-family: 'PT Sans', sans-serif;\\n    font-size: 25px;\\n    text-align: center;\\n    color: #f7f7f7;\\n    padding-top: 120px;\\n    padding-bottom: 0;\\n    margin-bottom: 0;\\n    padding-left: 15px;\\n}\\n\\n.homepage-subheader {\\n    font-family: 'PT Sans', sans-serif;\\n    font-size: 25px;\\n    text-align: center;\\n    color: #f7f7f7;\\n    margin-top: 0;\\n    padding-top: -8px;\\n    padding-bottom: 0;\\n    margin-bottom: 0;\\n    padding-left: 15px;\\n}\\n\\n\\n.homepage-body {\\n    background-image: url(\" + escape(__webpack_require__(/*! ./images/bb8.jpeg */ \"./src/app/css/images/bb8.jpeg\")) + \");\\n    z-index: 2;\\n    background-size: cover;\\n    height: 100%;\\n    margin-top: 0;\\n    width: 100%;\\n    position: absolute;\\n}\\n\\n/* project page style */\\n\\n.container {\\n    padding-top: 60px;\\n}\\n\\n/* navbar style */\\n\\n.nav {\\n    top: 0;\\n    left: 0;\\n    margin: 0;\\n    width: 100%;\\n    position: fixed;\\n    padding: 0;\\n    height: 50px;\\n    background-color: #1e1f26;\\n    justify-content: center;\\n}\\n\\na.nav-element {\\n    text-align: center;\\n    vertical-align: center;\\n}\\n\\nli {\\n    display: table;\\n    text-decoration: none;\\n    align-content: center;\\n    height: 100%;\\n    padding-left: 15px;\\n    padding-right: 15px;\\n    font-size: 18px;\\n    margin: auto;\\n    text-align: center;\\n}\\n\\n\\nli:hover {\\n    background-color: #4d648d;\\n    height: 100%;\\n    font-weight:bold;\\n    box-shadow: 8px 5px 5px #283655;\\n}\\n\\n.external {\\n    float: right;\\n}\\n\\n.internal {\\n    float: left;\\n}\\n\\n/* .logo {\\n    color: white;\\n    text-align: center;\\n} */\\n\\na {\\n    font-family: 'PT Sans', sans-serif;\\n    text-decoration: none;\\n    color: #f7f7f7;\\n    vertical-align: middle;\\n    display: table-cell;\\n}\\n\\n\\n/* about page style*/\\n\\n.img {\\n    height: 50px;\\n    width: 50px;\\n}\\n\\n.about-me {\\n    display: inline-block;\\n    text-align: center;\\n}\\n\\n/* admin page style */\\n\\nform {\\n    padding-top: 300px;\\n}\\n\\nlabel {\\n    display: block;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9hcHAvY3NzL2luZGV4LmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvY3NzL2luZGV4LmNzcz85NmU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImh0bWwsIGJvZHkge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y3ZjdmNztcXG59XFxuXFxuLm5hdiB7XFxuICAgIHotaW5kZXg6IDM7XFxufVxcblxcbi8qIGhvbWVwYWdlIHN0eWxlICovXFxuXFxuLmhvbWVwYWdlLWhlYWRlciB7XFxuICAgIGZvbnQtZmFtaWx5OiAnUFQgU2FucycsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogMjVweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBjb2xvcjogI2Y3ZjdmNztcXG4gICAgcGFkZGluZy10b3A6IDEyMHB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbn1cXG5cXG4uaG9tZXBhZ2Utc3ViaGVhZGVyIHtcXG4gICAgZm9udC1mYW1pbHk6ICdQVCBTYW5zJywgc2Fucy1zZXJpZjtcXG4gICAgZm9udC1zaXplOiAyNXB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGNvbG9yOiAjZjdmN2Y3O1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBwYWRkaW5nLXRvcDogLThweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgIHBhZGRpbmctbGVmdDogMTVweDtcXG59XFxuXFxuXFxuLmhvbWVwYWdlLWJvZHkge1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vaW1hZ2VzL2JiOC5qcGVnXCIpKSArIFwiKTtcXG4gICAgei1pbmRleDogMjtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4vKiBwcm9qZWN0IHBhZ2Ugc3R5bGUgKi9cXG5cXG4uY29udGFpbmVyIHtcXG4gICAgcGFkZGluZy10b3A6IDYwcHg7XFxufVxcblxcbi8qIG5hdmJhciBzdHlsZSAqL1xcblxcbi5uYXYge1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgaGVpZ2h0OiA1MHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWUxZjI2O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuYS5uYXYtZWxlbWVudCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgdmVydGljYWwtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxubGkge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNXB4O1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIG1hcmdpbjogYXV0bztcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG5cXG5saTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0ZDY0OGQ7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZm9udC13ZWlnaHQ6Ym9sZDtcXG4gICAgYm94LXNoYWRvdzogOHB4IDVweCA1cHggIzI4MzY1NTtcXG59XFxuXFxuLmV4dGVybmFsIHtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5cXG4uaW50ZXJuYWwge1xcbiAgICBmbG9hdDogbGVmdDtcXG59XFxuXFxuLyogLmxvZ28ge1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59ICovXFxuXFxuYSB7XFxuICAgIGZvbnQtZmFtaWx5OiAnUFQgU2FucycsIHNhbnMtc2VyaWY7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgY29sb3I6ICNmN2Y3Zjc7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxufVxcblxcblxcbi8qIGFib3V0IHBhZ2Ugc3R5bGUqL1xcblxcbi5pbWcge1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxuICAgIHdpZHRoOiA1MHB4O1xcbn1cXG5cXG4uYWJvdXQtbWUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLyogYWRtaW4gcGFnZSBzdHlsZSAqL1xcblxcbmZvcm0ge1xcbiAgICBwYWRkaW5nLXRvcDogMzAwcHg7XFxufVxcblxcbmxhYmVsIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/app/css/index.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzP2IwNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICB9XG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG4gICAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICsgJ1wiJ1xuICAgIH1cblxuICAgIHJldHVybiB1cmxcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/url/escape.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanM/YzRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/ExecutionEnvironment.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelize.js":
/*!*******************************************!*\
  !*** ./node_modules/fbjs/lib/camelize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanM/MzYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelize.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelizeStyleName.js":
/*!****************************************************!*\
  !*** ./node_modules/fbjs/lib/camelizeStyleName.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar camelize = __webpack_require__(/*! ./camelize */ \"./node_modules/fbjs/lib/camelize.js\");\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanM/OTU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelizeStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/containsNode.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/containsNode.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = __webpack_require__(/*! ./isTextNode */ \"./node_modules/fbjs/lib/isTextNode.js\");\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcz80ZDZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/containsNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzP2EyMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyFunction.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (true) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanM/Yjc3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyObject.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/getActiveElement.js":
/*!***************************************************!*\
  !*** ./node_modules/fbjs/lib/getActiveElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzPzhlNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/getActiveElement.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenate.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcz9mOWExIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenate.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenateStyleName.js":
/*!*****************************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenateStyleName.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar hyphenate = __webpack_require__(/*! ./hyphenate */ \"./node_modules/fbjs/lib/hyphenate.js\");\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcz9mYmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenateStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcz9kOGRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/invariant.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isNode.js":
/*!*****************************************!*\
  !*** ./node_modules/fbjs/lib/isNode.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcz9mNzg2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isTextNode.js":
/*!*********************************************!*\
  !*** ./node_modules/fbjs/lib/isTextNode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = __webpack_require__(/*! ./isNode */ \"./node_modules/fbjs/lib/isNode.js\");\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzPzQ5MGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isTextNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/shallowEqual.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcz9hZjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/shallowEqual.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzP2RhNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/warning.js\n");

/***/ }),

/***/ "./node_modules/history/DOMUtils.js":
/*!******************************************!*\
  !*** ./node_modules/history/DOMUtils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nvar canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nvar addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nvar removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nvar getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = exports.supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nvar isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzP2I4NDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgZ2V0Q29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbnZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZXhwb3J0cy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xudmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xudmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBleHBvcnRzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/DOMUtils.js\n");

/***/ }),

/***/ "./node_modules/history/LocationUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/history/LocationUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.locationsAreEqual = exports.createLocation = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _resolvePathname = __webpack_require__(/*! resolve-pathname */ \"./node_modules/resolve-pathname/index.js\");\n\nvar _resolvePathname2 = _interopRequireDefault(_resolvePathname);\n\nvar _valueEqual = __webpack_require__(/*! value-equal */ \"./node_modules/value-equal/index.js\");\n\nvar _valueEqual2 = _interopRequireDefault(_valueEqual);\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = (0, _PathUtils.parsePath)(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nvar locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qcz9jYjNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZSA9IHJlcXVpcmUoJ3Jlc29sdmUtcGF0aG5hbWUnKTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVzb2x2ZVBhdGhuYW1lKTtcblxudmFyIF92YWx1ZUVxdWFsID0gcmVxdWlyZSgndmFsdWUtZXF1YWwnKTtcblxudmFyIF92YWx1ZUVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbHVlRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAoMCwgX3Jlc29sdmVQYXRobmFtZTIuZGVmYXVsdCkobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgKDAsIF92YWx1ZUVxdWFsMi5kZWZhdWx0KShhLnN0YXRlLCBiLnN0YXRlKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/LocationUtils.js\n");

/***/ }),

/***/ "./node_modules/history/PathUtils.js":
/*!*******************************************!*\
  !*** ./node_modules/history/PathUtils.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nvar addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nvar stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nvar hasBasename = exports.hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nvar stripBasename = exports.stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nvar stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nvar parsePath = exports.parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar createPath = exports.createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanM/OTM5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5hZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxudmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG52YXIgaGFzQmFzZW5hbWUgPSBleHBvcnRzLmhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZXhwb3J0cy5zdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG52YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxudmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/PathUtils.js\n");

/***/ }),

/***/ "./node_modules/history/createBrowserHistory.js":
/*!******************************************************!*\
  !*** ./node_modules/history/createBrowserHistory.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _LocationUtils = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/LocationUtils.js\");\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nvar _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/createTransitionManager.js\");\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nvar _DOMUtils = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/DOMUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = (0, _DOMUtils.supportsHistory)();\n  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);\n\n    return (0, _LocationUtils.createLocation)(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + (0, _PathUtils.createPath)(location);\n  };\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createBrowserHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzPzZlOTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhKDAsIF9ET01VdGlscy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKSgpO1xuXG4gIHZhciBfcHJvcHMkZm9yY2VSZWZyZXNoID0gcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyAoMCwgX1BhdGhVdGlscy5zdHJpcFRyYWlsaW5nU2xhc2gpKCgwLCBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCkocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG5cblxuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKCgwLCBfRE9NVXRpbHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCkoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcblxuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/createBrowserHistory.js\n");

/***/ }),

/***/ "./node_modules/history/createHashHistory.js":
/*!***************************************************!*\
  !*** ./node_modules/history/createHashHistory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _LocationUtils = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/LocationUtils.js\");\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nvar _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/createTransitionManager.js\");\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nvar _DOMUtils = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/DOMUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: _PathUtils.stripLeadingSlash,\n    decodePath: _PathUtils.addLeadingSlash\n  },\n  slash: {\n    encodePath: _PathUtils.addLeadingSlash,\n    decodePath: _PathUtils.addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);\n\n    return (0, _LocationUtils.createLocation)(path);\n  };\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));\n  };\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = (0, _PathUtils.createPath)(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = (0, _PathUtils.createPath)(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createHashHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzP2U3ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyAoMCwgX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCkocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/createHashHistory.js\n");

/***/ }),

/***/ "./node_modules/history/createMemoryHistory.js":
/*!*****************************************************!*\
  !*** ./node_modules/history/createMemoryHistory.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nvar _LocationUtils = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/LocationUtils.js\");\n\nvar _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/createTransitionManager.js\");\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar clamp = function clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n};\n\n/**\n * Creates a history object that stores locations in memory.\n */\nvar createMemoryHistory = function createMemoryHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var getUserConfirmation = props.getUserConfirmation,\n      _props$initialEntries = props.initialEntries,\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());\n  });\n\n  // Public interface\n\n  var createHref = _PathUtils.createPath;\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n\n      var nextEntries = history.entries.slice(0);\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      history.entries[history.index] = location;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var canGo = function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  };\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return transitionManager.setPrompt(prompt);\n  };\n\n  var listen = function listen(listener) {\n    return transitionManager.appendListener(listener);\n  };\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createMemoryHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcz84NWZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IF9QYXRoVXRpbHMuY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/createMemoryHistory.js\n");

/***/ }),

/***/ "./node_modules/history/createTransitionManager.js":
/*!*********************************************************!*\
  !*** ./node_modules/history/createTransitionManager.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexports.default = createTransitionManager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzPzA0NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/history/createTransitionManager.js\n");

/***/ }),

/***/ "./node_modules/history/es/DOMUtils.js":
/*!*********************************************!*\
  !*** ./node_modules/history/es/DOMUtils.js ***!
  \*********************************************/
/*! exports provided: canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, supportsGoWithoutReloadUsingHash, isExtraneousPopstateEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canUseDOM\", function() { return canUseDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addEventListener\", function() { return addEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeEventListener\", function() { return removeEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getConfirmation\", function() { return getConfirmation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsHistory\", function() { return supportsHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsPopStateOnHashChange\", function() { return supportsPopStateOnHashChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsGoWithoutReloadUsingHash\", function() { return supportsGoWithoutReloadUsingHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isExtraneousPopstateEvent\", function() { return isExtraneousPopstateEvent; });\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nvar addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nvar removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nvar getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nvar isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzPzViZTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnQgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciBnZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuZXhwb3J0IHZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/es/DOMUtils.js\n");

/***/ }),

/***/ "./node_modules/history/es/LocationUtils.js":
/*!**************************************************!*\
  !*** ./node_modules/history/es/LocationUtils.js ***!
  \**************************************************/
/*! exports provided: createLocation, locationsAreEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLocation\", function() { return createLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"locationsAreEqual\", function() { return locationsAreEqual; });\n/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resolve-pathname */ \"./node_modules/resolve-pathname/index.js\");\n/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! value-equal */ \"./node_modules/value-equal/index.js\");\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\nvar createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_2__[\"parsePath\"])(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = Object(resolve_pathname__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nvar locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.state, b.state);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9Mb2NhdGlvblV0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcz9kMjgwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCByZXNvbHZlUGF0aG5hbWUgZnJvbSAncmVzb2x2ZS1wYXRobmFtZSc7XG5pbXBvcnQgdmFsdWVFcXVhbCBmcm9tICd2YWx1ZS1lcXVhbCc7XG5pbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IHJlc29sdmVQYXRobmFtZShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxuZXhwb3J0IHZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiB2YWx1ZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/es/LocationUtils.js\n");

/***/ }),

/***/ "./node_modules/history/es/PathUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/history/es/PathUtils.js ***!
  \**********************************************/
/*! exports provided: addLeadingSlash, stripLeadingSlash, hasBasename, stripBasename, stripTrailingSlash, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLeadingSlash\", function() { return addLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripLeadingSlash\", function() { return stripLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasBasename\", function() { return hasBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripBasename\", function() { return stripBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripTrailingSlash\", function() { return stripTrailingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parsePath\", function() { return parsePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPath\", function() { return createPath; });\nvar addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nvar stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nvar hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nvar stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nvar stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nvar parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanM/NWEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxuZXhwb3J0IHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/es/PathUtils.js\n");

/***/ }),

/***/ "./node_modules/history/es/createBrowserHistory.js":
/*!*********************************************************!*\
  !*** ./node_modules/history/es/createBrowserHistory.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/es/createTransitionManager.js\");\n/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/es/DOMUtils.js\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\n\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"canUseDOM\"], 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"supportsHistory\"])();\n  var needsHashChangeListener = !Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"supportsPopStateOnHashChange\"])();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"getConfirmation\"] : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripTrailingSlash\"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"])(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"hasBasename\"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripBasename\"])(path, basename);\n\n    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"isExtraneousPopstateEvent\"])(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location);\n  };\n\n  var push = function push(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"addEventListener\"])(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"addEventListener\"])(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"removeEventListener\"])(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"removeEventListener\"])(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createBrowserHistory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzP2NjNzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0hpc3RvcnksIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UsIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQnJvd3Nlckhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/es/createBrowserHistory.js\n");

/***/ }),

/***/ "./node_modules/history/es/createHashHistory.js":
/*!******************************************************!*\
  !*** ./node_modules/history/es/createHashHistory.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/es/createTransitionManager.js\");\n/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/es/DOMUtils.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\n\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripLeadingSlash\"])(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripLeadingSlash\"],\n    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"]\n  },\n  slash: {\n    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"],\n    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"]\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"canUseDOM\"], 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"supportsGoWithoutReloadUsingHash\"])();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"getConfirmation\"] : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripTrailingSlash\"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"])(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"hasBasename\"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripBasename\"])(path, basename);\n\n    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path);\n  };\n\n  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"locationsAreEqual\"])(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location));\n  };\n\n  var push = function push(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"addEventListener\"])(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"removeEventListener\"])(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createHashHistory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVIYXNoSGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzPzAyNjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgc3RyaXBMZWFkaW5nU2xhc2gocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IHN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxudmFyIGdldEhhc2hQYXRoID0gZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59O1xuXG52YXIgcHVzaEhhc2hQYXRoID0gZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn07XG5cbnZhciByZXBsYWNlSGFzaFBhdGggPSBmdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaEluZGV4ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGhhc2hJbmRleCA+PSAwID8gaGFzaEluZGV4IDogMCkgKyAnIycgKyBwYXRoKTtcbn07XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGludmFyaWFudChjYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IHByb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiBsb2NhdGlvbnNBcmVFcXVhbChwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aCh0b0xvY2F0aW9uKSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbY3JlYXRlUGF0aChpbml0aWFsTG9jYXRpb24pXTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcblxuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHdhcm5pbmcoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJyk7XG5cbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVIYXNoSGlzdG9yeTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/es/createHashHistory.js\n");

/***/ }),

/***/ "./node_modules/history/es/createMemoryHistory.js":
/*!********************************************************!*\
  !*** ./node_modules/history/es/createMemoryHistory.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/es/createTransitionManager.js\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\nvar clamp = function clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n};\n\n/**\n * Creates a history object that stores locations in memory.\n */\nvar createMemoryHistory = function createMemoryHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var getUserConfirmation = props.getUserConfirmation,\n      _props$initialEntries = props.initialEntries,\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n\n  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(entry, undefined, createKey()) : Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(entry, undefined, entry.key || createKey());\n  });\n\n  // Public interface\n\n  var createHref = _PathUtils__WEBPACK_IMPORTED_MODULE_1__[\"createPath\"];\n\n  var push = function push(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n\n      var nextEntries = history.entries.slice(0);\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      history.entries[history.index] = location;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var canGo = function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  };\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return transitionManager.setPrompt(prompt);\n  };\n\n  var listen = function listen(listener) {\n    return transitionManager.appendListener(listener);\n  };\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createMemoryHistory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcz83ZmUzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgeyBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcblxuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/history/es/createMemoryHistory.js\n");

/***/ }),

/***/ "./node_modules/history/es/createTransitionManager.js":
/*!************************************************************!*\
  !*** ./node_modules/history/es/createTransitionManager.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createTransitionManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzPzdkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5cbnZhciBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICB2YXIgc2V0UHJvbXB0ID0gZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKTtcblxuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgdmFyIGFwcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/history/es/createTransitionManager.js\n");

/***/ }),

/***/ "./node_modules/history/es/index.js":
/*!******************************************!*\
  !*** ./node_modules/history/es/index.js ***!
  \******************************************/
/*! exports provided: createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserHistory */ \"./node_modules/history/es/createBrowserHistory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createBrowserHistory\", function() { return _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _createHashHistory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createHashHistory */ \"./node_modules/history/es/createHashHistory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createHashHistory\", function() { return _createHashHistory__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createMemoryHistory */ \"./node_modules/history/es/createMemoryHistory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createMemoryHistory\", function() { return _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createLocation\", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__[\"createLocation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"locationsAreEqual\", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__[\"locationsAreEqual\"]; });\n\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parsePath\", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"parsePath\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPath\", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"createPath\"]; });\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2luZGV4LmpzPzYwNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/es/index.js\n");

/***/ }),

/***/ "./node_modules/hoist-non-react-statics/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n(function (global, factory) {\n     true ? module.exports = factory() :\n    undefined;\n}(this, (function () {\n    'use strict';\n    \n    var REACT_STATICS = {\n        childContextTypes: true,\n        contextTypes: true,\n        defaultProps: true,\n        displayName: true,\n        getDefaultProps: true,\n        getDerivedStateFromProps: true,\n        mixins: true,\n        propTypes: true,\n        type: true\n    };\n    \n    var KNOWN_STATICS = {\n        name: true,\n        length: true,\n        prototype: true,\n        caller: true,\n        callee: true,\n        arguments: true,\n        arity: true\n    };\n    \n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var getPrototypeOf = Object.getPrototypeOf;\n    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n    \n    return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n        if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n            \n            if (objectPrototype) {\n                var inheritedComponent = getPrototypeOf(sourceComponent);\n                if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                    hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n                }\n            }\n            \n            var keys = getOwnPropertyNames(sourceComponent);\n            \n            if (getOwnPropertySymbols) {\n                keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n            }\n            \n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                    var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                    try { // Avoid failures from read-only properties\n                        defineProperty(targetComponent, key, descriptor);\n                    } catch (e) {}\n                }\n            }\n            \n            return targetComponent;\n        }\n        \n        return targetComponent;\n    };\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanM/ZmNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuaG9pc3ROb25SZWFjdFN0YXRpY3MgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBcbiAgICB2YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICAgICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgICAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICAgICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gICAgICAgIG1peGluczogdHJ1ZSxcbiAgICAgICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgICAgICB0eXBlOiB0cnVlXG4gICAgfTtcbiAgICBcbiAgICB2YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgbGVuZ3RoOiB0cnVlLFxuICAgICAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgICAgIGNhbGxlcjogdHJ1ZSxcbiAgICAgICAgY2FsbGVlOiB0cnVlLFxuICAgICAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgICAgIGFyaXR5OiB0cnVlXG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICB2YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG4gICAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH07XG59KSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hoist-non-react-statics/index.js\n");

/***/ }),

/***/ "./node_modules/invariant/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (true) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanM/NDBiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/invariant/browser.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzPzMyMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  var invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\n  var warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzP2ExNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (\"development\" !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : undefined;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2IwNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(isValidElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2Q3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FJQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.3.2\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar ExecutionEnvironment = __webpack_require__(/*! fbjs/lib/ExecutionEnvironment */ \"./node_modules/fbjs/lib/ExecutionEnvironment.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\nvar getActiveElement = __webpack_require__(/*! fbjs/lib/getActiveElement */ \"./node_modules/fbjs/lib/getActiveElement.js\");\nvar shallowEqual = __webpack_require__(/*! fbjs/lib/shallowEqual */ \"./node_modules/fbjs/lib/shallowEqual.js\");\nvar containsNode = __webpack_require__(/*! fbjs/lib/containsNode */ \"./node_modules/fbjs/lib/containsNode.js\");\nvar emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\nvar hyphenateStyleName = __webpack_require__(/*! fbjs/lib/hyphenateStyleName */ \"./node_modules/fbjs/lib/hyphenateStyleName.js\");\nvar camelizeStyleName = __webpack_require__(/*! fbjs/lib/camelizeStyleName */ \"./node_modules/fbjs/lib/camelizeStyleName.js\");\n\n// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  this._hasCaughtError = false;\n  this._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this._caughtError = error;\n    this._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;\n      var evt = document.createEvent('Event');\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        this._hasCaughtError = true;\n        this._caughtError = error;\n      } else {\n        this._hasCaughtError = false;\n        this._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallback$1 = invokeGuardedCallback;\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar EventPluginRegistry = Object.freeze({\n\tplugins: plugins,\n\teventNameDispatchConfigs: eventNameDispatchConfigs,\n\tregistrationNameModules: registrationNameModules,\n\tregistrationNameDependencies: registrationNameDependencies,\n\tpossibleRegistrationNames: possibleRegistrationNames,\n\tinjectEventPluginOrder: injectEventPluginOrder,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      !(getNodeFromInstance && getInstanceFromNode) ? warning(false, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n    }\n  }\n};\n\n\n\n\n\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warning(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventsInBatch(events, false);\n}\n\nvar EventPluginHub = Object.freeze({\n\tinjection: injection,\n\tgetListener: getListener,\n\trunEventsInBatch: runEventsInBatch,\n\trunExtractedEventsInBatch: runExtractedEventsInBatch\n});\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\nvar Mode = 11;\nvar ContextConsumer = 12;\nvar ContextProvider = 13;\nvar ForwardRef = 14;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode$1(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps$1(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = Object.freeze({\n\tprecacheFiberNode: precacheFiberNode$1,\n\tgetClosestInstanceFromNode: getClosestInstanceFromNode,\n\tgetInstanceFromNode: getInstanceFromNode$1,\n\tgetNodeFromInstance: getNodeFromInstance$1,\n\tgetFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n\tupdateFiberProps: updateFiberProps$1\n});\n\nfunction getParent(inst) {\n  do {\n    inst = inst['return'];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warning(false, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EventPropagators = Object.freeze({\n\taccumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n\taccumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n\taccumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n\taccumulateDirectDispatches: accumulateDirectDispatches\n});\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nfunction initialize(nativeEventTarget) {\n  compositionState._root = nativeEventTarget;\n  compositionState._startText = getText();\n  return true;\n}\n\nfunction reset() {\n  compositionState._root = null;\n  compositionState._startText = null;\n  compositionState._fallbackText = null;\n}\n\nfunction getData() {\n  if (compositionState._fallbackText) {\n    return compositionState._fallbackText;\n  }\n\n  var start = void 0;\n  var startValue = compositionState._startText;\n  var startLength = startValue.length;\n  var end = void 0;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  compositionState._fallbackText = endValue.slice(start, sliceTail);\n  return compositionState._fallbackText;\n}\n\nfunction getText() {\n  if ('value' in compositionState._root) {\n    return compositionState._root.value;\n  }\n  return compositionState._root[getTextContentAccessor()];\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  var isProxySupported = typeof Proxy === 'function' &&\n  // https://github.com/facebook/react/issues/12011\n  !Object.isSealed(new Proxy({}, {}));\n\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              !(didWarnForAddedNewProperty || target.isPersistent()) ? warning(false, \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warning(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar SyntheticCompositionEvent = SyntheticEvent$1.extend({\n  data: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar SyntheticInputEvent = SyntheticEvent$1.extend({\n  data: null\n});\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case 'topCompositionStart':\n      return eventTypes.compositionStart;\n    case 'topCompositionEnd':\n      return eventTypes.compositionEnd;\n    case 'topCompositionUpdate':\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topKeyUp':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'topKeyDown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'topKeyPress':\n    case 'topMouseDown':\n    case 'topBlur':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType = void 0;\n  var fallbackData = void 0;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topCompositionEnd':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'topKeyPress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'topTextInput':\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case 'topPaste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'topKeyPress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'topCompositionEnd':\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars = void 0;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n}\n\nvar injection$2 = ReactControlledComponentInjection;\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\nvar ReactControlledComponent = Object.freeze({\n\tinjection: injection$2,\n\tenqueueStateRestore: enqueueStateRestore,\n\tneedsStateRestore: needsStateRestore,\n\trestoreStateIfNeeded: restoreStateIfNeeded\n});\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdates = function (fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdates = function () {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdates();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction interactiveUpdates(fn, a, b) {\n  return _interactiveUpdates(fn, a, b);\n}\n\n\n\nvar injection$3 = {\n  injectRenderer: function (renderer) {\n    _batchedUpdates = renderer.batchedUpdates;\n    _interactiveUpdates = renderer.interactiveUpdates;\n    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;\n  }\n};\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n\n  Object.defineProperty(node, valueField, {\n    configurable: true,\n    get: function () {\n      return descriptor.get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      descriptor.set.call(this, value);\n    }\n  });\n  // We could've passed this the first time\n  // but it triggers a bug in IE11 and Edge 14/15.\n  // Calling defineProperty() again should be equivalent.\n  // https://github.com/facebook/react/issues/11768\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol['for']('react.strict_mode') : 0xeacc;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol['for']('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol['for']('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol['for']('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol['for']('react.forward_ref') : 0xead0;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'ReactFragment';\n    case REACT_PORTAL_TYPE:\n      return 'ReactPortal';\n    case REACT_CALL_TYPE:\n      return 'ReactCall';\n    case REACT_RETURN_TYPE:\n      return 'ReactReturn';\n  }\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || '';\n        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    }\n  }\n  return null;\n}\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum$1;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName$1,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum$1\n};\n\n// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED = 0;\n\n// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nvar STRING = 1;\n\n// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING = 2;\n\n// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN = 3;\n\n// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN = 4;\n\n// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC = 5;\n\n// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC = 6;\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\n\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\nfunction shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null) {\n    return propertyInfo.type === RESERVED;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return true;\n  }\n  return false;\n}\n\nfunction shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n    return false;\n  }\n  switch (typeof value) {\n    case 'function':\n    // $FlowIssue symbol is perfectly valid here\n    case 'symbol':\n      // eslint-disable-line\n      return true;\n    case 'boolean':\n      {\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (propertyInfo !== null) {\n          return !propertyInfo.acceptsBooleans;\n        } else {\n          var prefix = name.toLowerCase().slice(0, 5);\n          return prefix !== 'data-' && prefix !== 'aria-';\n        }\n      }\n    default:\n      return false;\n  }\n}\n\nfunction shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n  if (value === null || typeof value === 'undefined') {\n    return true;\n  }\n  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n    return true;\n  }\n  if (propertyInfo !== null) {\n    switch (propertyInfo.type) {\n      case BOOLEAN:\n        return !value;\n      case OVERLOADED_BOOLEAN:\n        return value === false;\n      case NUMERIC:\n        return isNaN(value);\n      case POSITIVE_NUMERIC:\n        return isNaN(value) || value < 1;\n    }\n  }\n  return false;\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {\n  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n  this.attributeName = attributeName;\n  this.attributeNamespace = attributeNamespace;\n  this.mustUseProperty = mustUseProperty;\n  this.propertyName = name;\n  this.type = type;\n}\n\n// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties = {};\n\n// These props are reserved by React. They shouldn't be written to the DOM.\n['children', 'dangerouslySetInnerHTML',\n// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\n  name, // attributeName\n  null);\n});\n\n// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {\n  var name = _ref[0],\n      attributeName = _ref[1];\n\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, // attributeName\n  null);\n});\n\n// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse', 'externalResourcesRequired', 'preserveAlpha'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name, // attributeName\n  null);\n});\n\n// These are HTML boolean attributes.\n['allowFullScreen', 'async',\n// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',\n// Microdata\n'itemScope'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',\n// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple', 'muted', 'selected'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture', 'download'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are HTML attributes that must be positive numbers.\n['cols', 'rows', 'size', 'span'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are HTML attributes that must be numbers.\n['rowSpan', 'start'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\n// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, null);\n});\n\n// String SVG attributes with the xlink namespace.\n['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/1999/xlink');\n});\n\n// String SVG attributes with the xml namespace.\n['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/XML/1998/namespace');\n});\n\n// Special case: this attribute exists both in HTML and SVG.\n// Its \"tabindex\" attribute name is case-sensitive in SVG so we can't just use\n// its React `tabIndex` name, like we do for attributes that exist only in HTML.\nproperties.tabIndex = new PropertyInfoRecord('tabIndex', STRING, false, // mustUseProperty\n'tabindex', // attributeName\nnull);\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value, isCustomComponentTag) {\n  var propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      var _attributeName = name;\n      if (value === null) {\n        node.removeAttribute(_attributeName);\n      } else {\n        node.setAttribute(_attributeName, '' + value);\n      }\n    }\n    return;\n  }\n  var mustUseProperty = propertyInfo.mustUseProperty;\n\n  if (mustUseProperty) {\n    var propertyName = propertyInfo.propertyName;\n\n    if (value === null) {\n      var type = propertyInfo.type;\n\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  var attributeName = propertyInfo.attributeName,\n      attributeNamespace = propertyInfo.attributeNamespace;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    var _type = propertyInfo.type;\n\n    var attributeValue = void 0;\n    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = '' + value;\n    }\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var checked = props.checked;\n\n  var hostProps = _assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var node = element;\n  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getSafeValue(props.value != null ? props.value : defaultValue),\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var _controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {\n      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum());\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {\n      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum());\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = getSafeValue(props.value);\n\n  if (value != null) {\n    if (props.type === 'number') {\n      if (value === 0 && node.value === '' ||\n      // eslint-disable-next-line\n      node.value != value) {\n        node.value = '' + value;\n      }\n    } else if (node.value !== '' + value) {\n      node.value = '' + value;\n    }\n  }\n\n  if (props.hasOwnProperty('value')) {\n    setDefaultValue(node, props.type, value);\n  } else if (props.hasOwnProperty('defaultValue')) {\n    setDefaultValue(node, props.type, getSafeValue(props.defaultValue));\n  }\n\n  if (props.checked == null && props.defaultChecked != null) {\n    node.defaultChecked = !!props.defaultChecked;\n  }\n}\n\nfunction postMountWrapper(element, props) {\n  var node = element;\n\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n    if (node.value === '') {\n      node.value = '' + node._wrapperState.initialValue;\n    }\n\n    // value must be assigned before defaultValue. This fixes an issue where the\n    // visually displayed value of date inputs disappears on mobile Safari and Chrome:\n    // https://github.com/facebook/react/issues/7233\n    node.defaultValue = '' + node._wrapperState.initialValue;\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n  node.defaultChecked = !node.defaultChecked;\n  node.defaultChecked = !node.defaultChecked;\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node, type, value) {\n  if (\n  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n  type !== 'number' || node.ownerDocument.activeElement !== node) {\n    if (value == null) {\n      node.defaultValue = '' + node._wrapperState.initialValue;\n    } else if (node.defaultValue !== '' + value) {\n      node.defaultValue = '' + value;\n    }\n  }\n}\n\nfunction getSafeValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'object':\n    case 'string':\n    case 'undefined':\n      return value;\n    default:\n      // function, symbol are assigned as empty strings\n      return '';\n  }\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event, false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  setDefaultValue(node, 'number', node.value);\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc = void 0,\n        handleEventFunc = void 0;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\nvar SyntheticUIEvent = SyntheticEvent$1.extend({\n  view: null,\n  detail: null\n});\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticMouseEvent = SyntheticUIEvent.extend({\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n});\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (topLevelType === 'topMouseOut') {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */0;\nvar PerformedWork = /*         */1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */2;\nvar Update = /*                */4;\nvar PlacementAndUpdate = /*    */6;\nvar Deletion = /*              */8;\nvar ContentReset = /*          */16;\nvar Callback = /*              */32;\nvar DidCapture = /*            */64;\nvar Ref = /*                   */128;\nvar ErrLog = /*                */256;\nvar Snapshot = /*              */2048;\n\n// Union of all host effects\nvar HostEffectMask = /*        */2559;\n\nvar Incomplete = /*            */512;\nvar ShouldCapture = /*         */1024;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender ? warning(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component') : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction addEventBubbleListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, false);\n}\n\nfunction addEventCaptureListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, true);\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar SyntheticAnimationEvent = SyntheticEvent$1.extend({\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar SyntheticClipboardEvent = SyntheticEvent$1.extend({\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n});\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticFocusEvent = SyntheticUIEvent.extend({\n  relatedTarget: null\n});\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode = void 0;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n  // report Enter as charCode 10 when ctrl is pressed.\n  if (charCode === 10) {\n    charCode = 13;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticKeyboardEvent = SyntheticUIEvent.extend({\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n});\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticDragEvent = SyntheticMouseEvent.extend({\n  dataTransfer: null\n});\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar SyntheticTouchEvent = SyntheticUIEvent.extend({\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar SyntheticTransitionEvent = SyntheticEvent$1.extend({\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticWheelEvent = SyntheticMouseEvent.extend({\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n});\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: ['topAbort'],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = {\n *   'topAbort': { sameConfig }\n * };\n */\nvar interactiveEventTypeNames = ['blur', 'cancel', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'dragEnd', 'dragStart', 'drop', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'mouseDown', 'mouseUp', 'paste', 'pause', 'play', 'rateChange', 'reset', 'seeked', 'submit', 'touchCancel', 'touchEnd', 'touchStart', 'volumeChange'];\nvar nonInteractiveEventTypeNames = ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'canPlay', 'canPlayThrough', 'drag', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseMove', 'mouseOut', 'mouseOver', 'playing', 'progress', 'scroll', 'seeking', 'stalled', 'suspend', 'timeUpdate', 'toggle', 'touchMove', 'transitionEnd', 'waiting', 'wheel'];\n\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n\nfunction addEventTypeNameToConfig(event, isInteractive) {\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n  var topEvent = 'top' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent],\n    isInteractive: isInteractive\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n}\n\ninteractiveEventTypeNames.forEach(function (eventTypeName) {\n  addEventTypeNameToConfig(eventTypeName, true);\n});\nnonInteractiveEventTypeNames.forEach(function (eventTypeName) {\n  addEventTypeNameToConfig(eventTypeName, false);\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  isInteractiveTopLevelEventType: function (topLevelType) {\n    var config = topLevelEventsToDispatchConfig[topLevelType];\n    return config !== undefined && config.isInteractive === true;\n  },\n\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor = void 0;\n    switch (topLevelType) {\n      case 'topKeyPress':\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case 'topKeyDown':\n      case 'topKeyUp':\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case 'topBlur':\n      case 'topFocus':\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case 'topClick':\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case 'topDoubleClick':\n      case 'topMouseDown':\n      case 'topMouseMove':\n      case 'topMouseUp':\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case 'topMouseOut':\n      case 'topMouseOver':\n      case 'topContextMenu':\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case 'topDrag':\n      case 'topDragEnd':\n      case 'topDragEnter':\n      case 'topDragExit':\n      case 'topDragLeave':\n      case 'topDragOver':\n      case 'topDragStart':\n      case 'topDrop':\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case 'topTouchCancel':\n      case 'topTouchEnd':\n      case 'topTouchMove':\n      case 'topTouchStart':\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case 'topAnimationEnd':\n      case 'topAnimationIteration':\n      case 'topAnimationStart':\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case 'topTransitionEnd':\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case 'topCopy':\n      case 'topCut':\n      case 'topPaste':\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent$1;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nvar isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;\n\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst['return']) {\n    inst = inst['return'];\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventBubbleListener(element, handlerBaseName,\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventCaptureListener(element, handlerBaseName,\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\nfunction dispatchInteractiveEvent(topLevelType, nativeEvent) {\n  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nvar ReactDOMEventListener = Object.freeze({\n\tget _enabled () { return _enabled; },\n\tsetEnabled: setEnabled,\n\tisEnabled: isEnabled,\n\ttrapBubbledEvent: trapBubbledEvent,\n\ttrapCapturedEvent: trapCapturedEvent,\n\tdispatchEvent: dispatchEvent\n});\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return eventName;\n}\n\n/**\n * Types of raw signals from the browser caught at the top level.\n *\n * For events like 'submit' or audio/video events which don't consistently\n * bubble (which we trap at a lower node than `document`), binding\n * at `document` would cause duplicate events so we don't include them here.\n */\nvar topLevelTypes = {\n  topAnimationEnd: getVendorPrefixedEventName('animationend'),\n  topAnimationIteration: getVendorPrefixedEventName('animationiteration'),\n  topAnimationStart: getVendorPrefixedEventName('animationstart'),\n  topBlur: 'blur',\n  topCancel: 'cancel',\n  topChange: 'change',\n  topClick: 'click',\n  topClose: 'close',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoad: 'load',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topScroll: 'scroll',\n  topSelectionChange: 'selectionchange',\n  topTextInput: 'textInput',\n  topToggle: 'toggle',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topTransitionEnd: getVendorPrefixedEventName('transitionend'),\n  topWheel: 'wheel'\n};\n\n// There are so many media events, it makes sense to just\n// maintain a list of them. Note these aren't technically\n// \"top-level\" since they don't bubble. We should come up\n// with a better naming convention if we come to refactoring\n// the event system.\nvar mediaEventTypes = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} contentDocumentHandle Document which owns the container\n */\nfunction listenTo(registrationName, contentDocumentHandle) {\n  var mountAt = contentDocumentHandle;\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      if (dependency === 'topScroll') {\n        trapCapturedEvent('topScroll', 'scroll', mountAt);\n      } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n        trapCapturedEvent('topFocus', 'focus', mountAt);\n        trapCapturedEvent('topBlur', 'blur', mountAt);\n\n        // to make sure blur and focus event listeners are only attached once\n        isListening.topBlur = true;\n        isListening.topFocus = true;\n      } else if (dependency === 'topCancel') {\n        if (isEventSupported('cancel', true)) {\n          trapCapturedEvent('topCancel', 'cancel', mountAt);\n        }\n        isListening.topCancel = true;\n      } else if (dependency === 'topClose') {\n        if (isEventSupported('close', true)) {\n          trapCapturedEvent('topClose', 'close', mountAt);\n        }\n        isListening.topClose = true;\n      } else if (topLevelTypes.hasOwnProperty(dependency)) {\n        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n      }\n\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElement();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElement();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    priorFocusedElem.focus();\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case 'topFocus':\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case 'topBlur':\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case 'topMouseDown':\n        mouseDown = true;\n        break;\n      case 'topContextMenu':\n      case 'topMouseUp':\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case 'topSelectionChange':\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case 'topKeyDown':\n      case 'topKeyUp':\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(DOMEventPluginOrder);\ninjection$1.injectComponentTree(ReactDOMComponentTree);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\n\n// TODO: Use an opaque type once ESLint et al support the syntax\n\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = MAX_SIGNED_31_BIT_INT;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === 'function') {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_CALL_TYPE:\n        fiberTag = CallComponent;\n        break;\n      case REACT_RETURN_TYPE:\n        fiberTag = ReturnComponent;\n        break;\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break;\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break;\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n                break;\n              default:\n                if (typeof type.tag === 'number') {\n                  // Currently assumed to be a continuation and therefore is a\n                  // fiber already.\n                  // TODO: The yield system is currently broken for updates in\n                  // some cases. The reified yield stores a fiber, but we don't\n                  // know which fiber that is; the current or a workInProgress?\n                  // When the continuation gets rendered here we don't know if we\n                  // can reuse that fiber or if we need to clone it. There is\n                  // probably a clever way to restructure this.\n                  fiber = type;\n                  fiber.pendingProps = pendingProps;\n                  fiber.expirationTime = expirationTime;\n                  return fiber;\n                } else {\n                  throwOnInvalidElementType(type, owner);\n                }\n                break;\n            }\n          } else {\n            throwOnInvalidElementType(type, owner);\n          }\n        }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction throwOnInvalidElementType(type, owner) {\n  var info = '';\n  {\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n    }\n    var ownerName = owner ? getComponentName(owner) : null;\n    if (ownerName) {\n      info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n    }\n  }\n  invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target['return'] = source['return'];\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.alternate = source.alternate;\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n// TODO: This should be lifted into the renderer.\n\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    pendingCommitExpirationTime: NoWork,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    remainingExpirationTime: NoWork,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function () {},\n  flushPendingDeprecationWarnings: function () {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordDeprecationWarnings: function (fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: 'componentDidMount',\n    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',\n    UNSAFE_componentWillUpdate: 'componentDidUpdate'\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function (fiber) {\n            componentNames.add(getComponentName(fiber) || 'Component');\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace('UNSAFE_', '');\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(strictRoot);\n\n        warning(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\\n\\n%s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMesages.join('\\n\\n'));\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var getStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n\n    while (fiber !== null) {\n      if (fiber.mode & StrictMode) {\n        maybeStrictRoot = fiber;\n      }\n\n      fiber = fiber['return'];\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        _uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        _uniqueNames2.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    var strictRoot = getStrictRoot(fiber);\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    // Note that it is sufficient to check for the presence of a\n    // single lifecycle, componentWillMount, with the polyfill flag.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning === true) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (typeof instance.componentWillMount === 'function' || typeof instance.UNSAFE_componentWillMount === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillMount');\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');\n    }\n    if (typeof instance.componentWillUpdate === 'function' || typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillUpdate');\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function (lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n}\n\n// Exports ReactDOM.createRoot\nvar enableUserTimingAPI = true;\n\n// Mutating mode (React DOM, React ART, React Native):\nvar enableMutatingReconciler = true;\n// Experimental noop mode (currently unused):\nvar enableNoopReconciler = false;\n// Experimental persistent mode (Fabric):\nvar enablePersistentReconciler = false;\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\nvar enableGetDerivedStateFromCatch = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\nvar debugRenderPhaseSideEffectsForStrictMode = true;\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\nvar warnAboutDeprecatedLifecycles = false;\n\nvar alwaysUseRequestIdleCallbackPolyfill = false;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case CallComponent:\n    case ReturnComponent:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber['return'];\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber['return'] !== null) {\n    resumeTimersRecursively(fiber['return']);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\nvar didWarnUpdateInsideUpdate = void 0;\n\n{\n  didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false,\n    capturedValues: null\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nvar q1 = void 0;\nvar q2 = void 0;\nfunction ensureUpdateQueues(fiber) {\n  q1 = q2 = null;\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Use module variables instead of returning a tuple\n  q1 = queue1;\n  q2 = queue2;\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  ensureUpdateQueues(fiber);\n  var queue1 = q1;\n  var queue2 = q2;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n    case ClassComponent:\n      var updateQueue = fiber.updateQueue;\n      if (updateQueue === null) {\n        return NoWork;\n      }\n      return updateQueue.expirationTime;\n    default:\n      return NoWork;\n  }\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    return partialState.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      capturedValues: currentQueue.capturedValues,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    // Ignore the return value in this case.\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      getStateFromUpdate(update, instance, state, props);\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    if (update.capturedValue !== null) {\n      var _capturedValues = queue.capturedValues;\n      if (_capturedValues === null) {\n        queue.capturedValues = [update.capturedValue];\n      } else {\n        _capturedValues.push(update.capturedValue);\n      }\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate && queue.capturedValues === null) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar warnOnInvalidCallback$1 = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback$1 = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    var key = callerName + '_' + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warning(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\nfunction callGetDerivedStateFromCatch(ctor, capturedValues) {\n  var resultState = {};\n  for (var i = 0; i < capturedValues.length; i++) {\n    var capturedValue = capturedValues[i];\n    var error = capturedValue.value;\n    var partialState = ctor.getDerivedStateFromCatch.call(null, error);\n    if (partialState !== null && partialState !== undefined) {\n      _assign(resultState, partialState);\n    }\n  }\n  return resultState;\n}\n\nvar ReactFiberClassComponent = function (legacyContext, scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  var cacheContext = legacyContext.cacheContext,\n      getMaskedContext = legacyContext.getMaskedContext,\n      getUnmaskedContext = legacyContext.getUnmaskedContext,\n      isContextConsumer = legacyContext.isContextConsumer,\n      hasContextChanged = legacyContext.hasContextChanged;\n\n  // Class component state updater\n\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback$1(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback$1(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback$1(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var ctor = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      stopPhaseTimer();\n\n      {\n        !(shouldUpdate !== undefined) ? warning(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Component') : void 0;\n      }\n\n      return shouldUpdate;\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress) || 'Component';\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      !noGetInitialStateOnES6 ? warning(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      !noGetDefaultPropsOnES6 ? warning(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;\n      var noInstancePropTypes = !instance.propTypes;\n      !noInstancePropTypes ? warning(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;\n      var noInstanceContextTypes = !instance.contextTypes;\n      !noInstanceContextTypes ? warning(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      !noComponentShouldUpdate ? warning(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      !noComponentDidUnmount ? warning(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;\n      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n      !noComponentDidReceiveProps ? warning(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      !noComponentWillRecieveProps ? warning(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;\n      var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n      !noUnsafeComponentWillRecieveProps ? warning(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      !(instance.props === undefined || !hasMutatedProps) ? warning(false, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name) : void 0;\n      var noInstanceDefaultProps = !instance.defaultProps;\n      !noInstanceDefaultProps ? warning(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;\n\n      if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type)) {\n        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type);\n        warning(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(workInProgress));\n      }\n\n      var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';\n      !noInstanceGetDerivedStateFromProps ? warning(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n      var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== 'function';\n      !noInstanceGetDerivedStateFromCatch ? warning(false, '%s: getDerivedStateFromCatch() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n      var noStaticGetSnapshotBeforeUpdate = typeof type.getSnapshotBeforeUpdate !== 'function';\n      !noStaticGetSnapshotBeforeUpdate ? warning(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;\n      var _state = instance.state;\n      if (_state && (typeof _state !== 'object' || isArray(_state))) {\n        warning(false, '%s.state: must be set to an object or null', name);\n      }\n      if (typeof instance.getChildContext === 'function') {\n        !(typeof type.childContextTypes === 'object') ? warning(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;\n      }\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n\n    // Instantiate twice to help detect side-effects.\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n\n    var instance = new ctor(props, context);\n    var state = instance.state !== null && instance.state !== undefined ? instance.state : null;\n    adoptClassInstance(workInProgress, instance);\n\n    {\n      if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutUninitializedState.has(componentName)) {\n          didWarnAboutUninitializedState.add(componentName);\n          warning(false, '%s: Did not properly initialize state during construction. ' + 'Expected state to be an object, but it was %s.', componentName, instance.state === null ? 'null' : 'undefined');\n        }\n      }\n\n      // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n      // Warn about these lifecycles if they are present.\n      // Don't warn about react-lifecycles-compat polyfilled methods though.\n      if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n        var foundWillMountName = null;\n        var foundWillReceivePropsName = null;\n        var foundWillUpdateName = null;\n        if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n          foundWillMountName = 'componentWillMount';\n        } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n          foundWillMountName = 'UNSAFE_componentWillMount';\n        }\n        if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n          foundWillReceivePropsName = 'componentWillReceiveProps';\n        } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n          foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n        }\n        if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n          foundWillUpdateName = 'componentWillUpdate';\n        } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n          foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n        }\n        if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n          var _componentName = getComponentName(workInProgress) || 'Component';\n          var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n          if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n            warning(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '');\n          }\n        }\n      }\n    }\n\n    workInProgress.memoizedState = state;\n\n    var partialState = callGetDerivedStateFromProps(workInProgress, instance, props, state);\n\n    if (partialState !== null && partialState !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      workInProgress.memoizedState = _assign({}, workInProgress.memoizedState, partialState);\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, 'componentWillMount');\n    var oldState = instance.state;\n\n    if (typeof instance.componentWillMount === 'function') {\n      instance.componentWillMount();\n    }\n    if (typeof instance.UNSAFE_componentWillMount === 'function') {\n      instance.UNSAFE_componentWillMount();\n    }\n\n    stopPhaseTimer();\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress) || 'Component');\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    var oldState = instance.state;\n    startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n    if (typeof instance.componentWillReceiveProps === 'function') {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n    if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      instance.UNSAFE_componentWillReceiveProps(newProps, newContext);\n    }\n    stopPhaseTimer();\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n          didWarnAboutStateAssignmentForComponent.add(componentName);\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callGetDerivedStateFromProps(workInProgress, instance, nextProps, prevState) {\n    var type = workInProgress.type;\n\n\n    if (typeof type.getDerivedStateFromProps === 'function') {\n      if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        // Invoke method an extra time to help detect side-effects.\n        type.getDerivedStateFromProps.call(null, nextProps, prevState);\n      }\n\n      var partialState = type.getDerivedStateFromProps.call(null, nextProps, prevState);\n\n      {\n        if (partialState === undefined) {\n          var componentName = getComponentName(workInProgress) || 'Component';\n          if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n            didWarnAboutUndefinedDerivedState.add(componentName);\n            warning(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n          }\n        }\n      }\n\n      return partialState;\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    {\n      if (workInProgress.mode & StrictMode) {\n        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n      }\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);\n      }\n    }\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  function resumeMountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    var hasNewLifecycles = typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(null, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null && updateQueue.capturedValues !== null && enableGetDerivedStateFromCatch && typeof ctor.getDerivedStateFromCatch === 'function') {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(ctor, capturedValues);\n      }\n    } else {\n      newState = oldState;\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      // The prevState parameter should be the partially updated state.\n      // Otherwise, spreading state in return values could override updates.\n      derivedStateFromProps = callGetDerivedStateFromProps(workInProgress, instance, newProps, newState);\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromProps : _assign({}, newState, derivedStateFromProps);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue = workInProgress.updateQueue;\n      if (_updateQueue !== null) {\n        _updateQueue.baseState = _assign({}, _updateQueue.baseState, derivedStateFromProps);\n      }\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromCatch : _assign({}, newState, derivedStateFromCatch);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue2 = workInProgress.updateQueue;\n      if (_updateQueue2 !== null) {\n        _updateQueue2.baseState = _assign({}, _updateQueue2.baseState, derivedStateFromCatch);\n      }\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for components using the new APIs.\n      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n        startPhaseTimer(workInProgress, 'componentWillMount');\n        if (typeof instance.componentWillMount === 'function') {\n          instance.componentWillMount();\n        }\n        if (typeof instance.UNSAFE_componentWillMount === 'function') {\n          instance.UNSAFE_componentWillMount();\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidMount === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    var hasNewLifecycles = typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null && updateQueue.capturedValues !== null && enableGetDerivedStateFromCatch && typeof ctor.getDerivedStateFromCatch === 'function') {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(ctor, capturedValues);\n      }\n    } else {\n      newState = oldState;\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      // The prevState parameter should be the partially updated state.\n      // Otherwise, spreading state in return values could override updates.\n      derivedStateFromProps = callGetDerivedStateFromProps(workInProgress, instance, newProps, newState);\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromProps : _assign({}, newState, derivedStateFromProps);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue3 = workInProgress.updateQueue;\n      if (_updateQueue3 !== null) {\n        _updateQueue3.baseState = _assign({}, _updateQueue3.baseState, derivedStateFromProps);\n      }\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromCatch : _assign({}, newState, derivedStateFromCatch);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue4 = workInProgress.updateQueue;\n      if (_updateQueue4 !== null) {\n        _updateQueue4.baseState = _assign({}, _updateQueue4.baseState, derivedStateFromCatch);\n      }\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Snapshot;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for components using the new APIs.\n      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        if (typeof instance.componentWillUpdate === 'function') {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n        if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n          instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n        workInProgress.effectTag |= Snapshot;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Snapshot;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    callGetDerivedStateFromProps: callGetDerivedStateFromProps,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    resumeMountClassInstance: resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\nvar getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function (child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$2() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$2());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber) || 'Component';\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warning(false, 'A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\\n%s' + '\\n\\nLearn more about using refs safely here:' + '\\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackAddendumByWorkInProgressFiber(returnFiber));\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a functional component\\n2. You may be adding a ref to a component that was not created inside a component\\'s render method\\n3. You have multiple copies of React loaded\\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$2() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$2() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$2() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created['return'] = returnFiber;\n            return _created;\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            _created2['return'] = returnFiber;\n            return _created2;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        _created3['return'] = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$2());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$2()) : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4['return'] = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, legacyContext, newContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var pushProvider = newContext.pushProvider;\n  var getMaskedContext = legacyContext.getMaskedContext,\n      getUnmaskedContext = legacyContext.getUnmaskedContext,\n      hasLegacyContextChanged = legacyContext.hasContextChanged,\n      pushLegacyContextProvider = legacyContext.pushContextProvider,\n      pushTopLevelContextObject = legacyContext.pushTopLevelContextObject,\n      invalidateContextProvider = legacyContext.invalidateContextProvider;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(legacyContext, scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      callGetDerivedStateFromProps = _ReactFiberClassCompo.callGetDerivedStateFromProps,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      resumeMountClassInstance = _ReactFiberClassCompo.resumeMountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateForwardRef(current, workInProgress) {\n    var render = workInProgress.type.render;\n    var nextChildren = render(workInProgress.pendingProps, workInProgress.ref);\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateMode(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps.children;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (current === null && ref !== null || current !== null && current.ref !== ref) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else {\n      if (workInProgress.memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren = void 0;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushLegacyContextProvider(workInProgress);\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (workInProgress.stateNode === null) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n\n        shouldUpdate = true;\n      } else {\n        // In a resume, we'll already have an instance we can reuse.\n        shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n\n    // We processed the update queue inside updateClassInstance. It may have\n    // included some errors that were dispatched during the commit phase.\n    // TODO: Refactor class components so this is less awkward.\n    var didCaptureError = false;\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null && updateQueue.capturedValues !== null) {\n      shouldUpdate = true;\n      didCaptureError = true;\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, didCaptureError, renderExpirationTime);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext, didCaptureError, renderExpirationTime) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate && !didCaptureError) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof ctor.getDerivedStateFromCatch !== 'function')) {\n      // If we captured an error, but getDerivedStateFrom catch is not defined,\n      // unmount all the children. componentDidCatch will schedule an update to\n      // re-render a fallback. This is temporary until we migrate everyone to\n      // the new API.\n      // TODO: Warn in a future release.\n      nextChildren = null;\n    } else {\n      {\n        ReactDebugCurrentFiber.setCurrentPhase('render');\n        nextChildren = instance.render();\n        if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n          instance.render();\n        }\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n    }\n\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    if (didCaptureError) {\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildrenAtExpirationTime(current, workInProgress, null, renderExpirationTime);\n      workInProgress.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    }\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      memoizeState(workInProgress, state);\n      updateQueue = workInProgress.updateQueue;\n\n      var element = void 0;\n      if (updateQueue !== null && updateQueue.capturedValues !== null) {\n        // There's an uncaught error. Unmount the whole root.\n        element = null;\n      } else if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      } else {\n        element = state.element;\n      }\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (memoizedProps === nextProps) {\n      var isHidden = workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps);\n      if (isHidden) {\n        // Before bailing out, make sure we've deprioritized a hidden component.\n        workInProgress.expirationTime = Never;\n      }\n      if (!isHidden || renderExpirationTime !== Never) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // If we're rendering a hidden node at hidden priority, don't bailout. The\n      // parent is complete, but the children may not be.\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      workInProgress.memoizedProps = nextProps;\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value = void 0;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress) || 'Unknown';\n\n        if (!didWarnAboutBadClass[componentName]) {\n          warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n          didWarnAboutBadClass[componentName] = true;\n        }\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      var Component = workInProgress.type;\n\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n\n      if (typeof Component.getDerivedStateFromProps === 'function') {\n        var partialState = callGetDerivedStateFromProps(workInProgress, value, props, workInProgress.memoizedState);\n\n        if (partialState !== null && partialState !== undefined) {\n          workInProgress.memoizedState = _assign({}, workInProgress.memoizedState, partialState);\n        }\n      }\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushLegacyContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext, false, renderExpirationTime);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var _Component = workInProgress.type;\n\n        if (_Component) {\n          !!_Component.childContextTypes ? warning(false, '%s(...): childContextTypes cannot be defined on a functional component.', _Component.displayName || _Component.name || 'Component') : void 0;\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!didWarnAboutStatelessRefs[warningKey]) {\n            didWarnAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n\n        if (typeof fn.getDerivedStateFromProps === 'function') {\n          var _componentName = getComponentName(workInProgress) || 'Unknown';\n\n          if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n            warning(false, '%s: Stateless functional components do not support getDerivedStateFromProps.', _componentName);\n            didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextProps = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextProps) {\n      nextProps = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, current.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextProps);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {\n    var fiber = workInProgress.child;\n    if (fiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      fiber['return'] = workInProgress;\n    }\n    while (fiber !== null) {\n      var nextFiber = void 0;\n      // Visit this fiber.\n      switch (fiber.tag) {\n        case ContextConsumer:\n          // Check if the context matches.\n          var observedBits = fiber.stateNode | 0;\n          if (fiber.type === context && (observedBits & changedBits) !== 0) {\n            // Update the expiration time of all the ancestors, including\n            // the alternates.\n            var node = fiber;\n            while (node !== null) {\n              var alternate = node.alternate;\n              if (node.expirationTime === NoWork || node.expirationTime > renderExpirationTime) {\n                node.expirationTime = renderExpirationTime;\n                if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n                  alternate.expirationTime = renderExpirationTime;\n                }\n              } else if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n                alternate.expirationTime = renderExpirationTime;\n              } else {\n                // Neither alternate was updated, which means the rest of the\n                // ancestor path already has sufficient priority.\n                break;\n              }\n              node = node['return'];\n            }\n            // Don't scan deeper than a matching consumer. When we render the\n            // consumer, we'll continue scanning from that point. This way the\n            // scanning work is time-sliced.\n            nextFiber = null;\n          } else {\n            // Traverse down.\n            nextFiber = fiber.child;\n          }\n          break;\n        case ContextProvider:\n          // Don't scan deeper if this is a matching provider\n          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n          break;\n        default:\n          // Traverse down.\n          nextFiber = fiber.child;\n          break;\n      }\n      if (nextFiber !== null) {\n        // Set the return pointer of the child to the work-in-progress fiber.\n        nextFiber['return'] = fiber;\n      } else {\n        // No child. Traverse to next sibling.\n        nextFiber = fiber;\n        while (nextFiber !== null) {\n          if (nextFiber === workInProgress) {\n            // We're back to the root of this subtree. Exit.\n            nextFiber = null;\n            break;\n          }\n          var sibling = nextFiber.sibling;\n          if (sibling !== null) {\n            nextFiber = sibling;\n            break;\n          }\n          // No more siblings. Traverse up.\n          nextFiber = nextFiber['return'];\n        }\n      }\n      fiber = nextFiber;\n    }\n  }\n\n  function updateContextProvider(current, workInProgress, renderExpirationTime) {\n    var providerType = workInProgress.type;\n    var context = providerType._context;\n\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (oldProps === newProps) {\n      workInProgress.stateNode = 0;\n      pushProvider(workInProgress);\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var newValue = newProps.value;\n    workInProgress.memoizedProps = newProps;\n\n    var changedBits = void 0;\n    if (oldProps === null) {\n      // Initial render\n      changedBits = MAX_SIGNED_31_BIT_INT;\n    } else {\n      if (oldProps.value === newProps.value) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children) {\n          workInProgress.stateNode = 0;\n          pushProvider(workInProgress);\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        changedBits = 0;\n      } else {\n        var oldValue = oldProps.value;\n        // Use Object.is to compare the new context value to the old value.\n        // Inlined Object.is polyfill.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n        if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue // eslint-disable-line no-self-compare\n        ) {\n            // No change. Bailout early if children are the same.\n            if (oldProps.children === newProps.children) {\n              workInProgress.stateNode = 0;\n              pushProvider(workInProgress);\n              return bailoutOnAlreadyFinishedWork(current, workInProgress);\n            }\n            changedBits = 0;\n          } else {\n          changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n          {\n            !((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits) ? warning(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;\n          }\n          changedBits |= 0;\n\n          if (changedBits === 0) {\n            // No change. Bailout early if children are the same.\n            if (oldProps.children === newProps.children) {\n              workInProgress.stateNode = 0;\n              pushProvider(workInProgress);\n              return bailoutOnAlreadyFinishedWork(current, workInProgress);\n            }\n          } else {\n            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n          }\n        }\n      }\n    }\n\n    workInProgress.stateNode = changedBits;\n    pushProvider(workInProgress);\n\n    var newChildren = newProps.children;\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  function updateContextConsumer(current, workInProgress, renderExpirationTime) {\n    var context = workInProgress.type;\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    var newValue = context._currentValue;\n    var changedBits = context._changedBits;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (changedBits === 0 && oldProps === newProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    workInProgress.memoizedProps = newProps;\n\n    var observedBits = newProps.unstable_observedBits;\n    if (observedBits === undefined || observedBits === null) {\n      // Subscribe to all changes by default\n      observedBits = MAX_SIGNED_31_BIT_INT;\n    }\n    // Store the observedBits on the fiber's stateNode for quick access.\n    workInProgress.stateNode = observedBits;\n\n    if ((changedBits & observedBits) !== 0) {\n      // Context change propagation stops at matching consumers, for time-\n      // slicing. Continue the propagation here.\n      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n    } else if (oldProps === newProps) {\n      // Skip over a memoized parent with a bitmask bailout even\n      // if we began working on it because of a deeper matching child.\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    // There is no bailout on `children` equality because we expect people\n    // to often pass a bound method as a child, but it may reference\n    // `this.state` or `this.props` (and thus needs to re-render on `setState`).\n\n    var render = newProps.children;\n\n    {\n      !(typeof render === 'function') ? warning(false, 'A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;\n    }\n\n    var newChildren = render(newValue);\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushLegacyContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n      case ContextProvider:\n        pushProvider(workInProgress);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case ForwardRef:\n        return updateForwardRef(current, workInProgress);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      case Mode:\n        return updateMode(current, workInProgress);\n      case ContextProvider:\n        return updateContextProvider(current, workInProgress, renderExpirationTime);\n      case ContextConsumer:\n        return updateContextConsumer(current, workInProgress, renderExpirationTime);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    beginWork: beginWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, legacyContext, newContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var popLegacyContextProvider = legacyContext.popContextProvider,\n      popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject;\n  var popProvider = newContext.popProvider;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // a PlacementAndUpdate.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.pendingProps.value);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var props = workInProgress.memoizedProps;\n    !props ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = props.handler;\n    var childProps = props.props;\n    var nextChildren = fn(childProps, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          portalOrRoot.pendingChildren = newChildSet;\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n          finalizeContainerChildren(container, newChildSet);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    var newProps = workInProgress.pendingProps;\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popLegacyContextProvider(workInProgress);\n\n          // If this component caught an error, schedule an error log effect.\n          var instance = workInProgress.stateNode;\n          var updateQueue = workInProgress.updateQueue;\n          if (updateQueue !== null && updateQueue.capturedValues !== null) {\n            workInProgress.effectTag &= ~DidCapture;\n            if (typeof instance.componentDidCatch === 'function') {\n              workInProgress.effectTag |= ErrLog;\n            } else {\n              // Normally we clear this in the commit phase, but since we did not\n              // schedule an effect, we need to reset it here.\n              updateQueue.capturedValues = null;\n            }\n          }\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelLegacyContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n\n          var _updateQueue = workInProgress.updateQueue;\n          if (_updateQueue !== null && _updateQueue.capturedValues !== null) {\n            workInProgress.effectTag |= ErrLog;\n          }\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var _instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            // TODO: Experiencing an error where oldProps is null. Suggests a host\n            // component is hitting the resume path. Figure out why. Possibly\n            // related to `hidden`.\n            var updatePayload = prepareUpdate(_instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance2 = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance2, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance2, type, newProps, rootContainerInstance, _currentHostContext)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance2;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case ForwardRef:\n        return null;\n      case Fragment:\n        return null;\n      case Mode:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        // Pop provider fiber\n        popProvider(workInProgress);\n        return null;\n      case ContextConsumer:\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackAddendumByWorkInProgressFiber(source)\n  };\n}\n\nvar ReactFiberUnwindWork = function (hostContext, legacyContext, newContext, scheduleWork, isAlreadyFailedLegacyErrorBoundary) {\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext;\n  var popLegacyContextProvider = legacyContext.popContextProvider,\n      popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject;\n  var popProvider = newContext.popProvider;\n\n\n  function throwException(returnFiber, sourceFiber, rawValue) {\n    // The source fiber did not complete.\n    sourceFiber.effectTag |= Incomplete;\n    // Its effect list is no longer valid.\n    sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n    var value = createCapturedValue(rawValue, sourceFiber);\n\n    var workInProgress = returnFiber;\n    do {\n      switch (workInProgress.tag) {\n        case HostRoot:\n          {\n            // Uncaught error\n            var errorInfo = value;\n            ensureUpdateQueues(workInProgress);\n            var updateQueue = workInProgress.updateQueue;\n            updateQueue.capturedValues = [errorInfo];\n            workInProgress.effectTag |= ShouldCapture;\n            return;\n          }\n        case ClassComponent:\n          // Capture and retry\n          var ctor = workInProgress.type;\n          var _instance = workInProgress.stateNode;\n          if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === 'function' && enableGetDerivedStateFromCatch || _instance !== null && typeof _instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(_instance))) {\n            ensureUpdateQueues(workInProgress);\n            var _updateQueue = workInProgress.updateQueue;\n            var capturedValues = _updateQueue.capturedValues;\n            if (capturedValues === null) {\n              _updateQueue.capturedValues = [value];\n            } else {\n              capturedValues.push(value);\n            }\n            workInProgress.effectTag |= ShouldCapture;\n            return;\n          }\n          break;\n        default:\n          break;\n      }\n      workInProgress = workInProgress['return'];\n    } while (workInProgress !== null);\n  }\n\n  function unwindWork(workInProgress) {\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        {\n          popLegacyContextProvider(workInProgress);\n          var effectTag = workInProgress.effectTag;\n          if (effectTag & ShouldCapture) {\n            workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;\n            return workInProgress;\n          }\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelLegacyContextObject(workInProgress);\n          var _effectTag = workInProgress.effectTag;\n          if (_effectTag & ShouldCapture) {\n            workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;\n            return workInProgress;\n          }\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          return null;\n        }\n      case HostPortal:\n        popHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        popProvider(workInProgress);\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  function unwindInterruptedWork(interruptedWork) {\n    switch (interruptedWork.tag) {\n      case ClassComponent:\n        {\n          popLegacyContextProvider(interruptedWork);\n          break;\n        }\n      case HostRoot:\n        {\n          popHostContainer(interruptedWork);\n          popTopLevelLegacyContextObject(interruptedWork);\n          break;\n        }\n      case HostComponent:\n        {\n          popHostContext(interruptedWork);\n          break;\n        }\n      case HostPortal:\n        popHostContainer(interruptedWork);\n        break;\n      case ContextProvider:\n        popProvider(interruptedWork);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return {\n    throwException: throwException,\n    unwindWork: unwindWork,\n    unwindInterruptedWork: unwindInterruptedWork\n  };\n};\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(capturedError) {\n  return true;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$3 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null) {\n    stack = getStackAddendumByWorkInProgressFiber(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // Prevent cycle if logCapturedError() throws.\n    // A cycle may still occur if logCapturedError renders a component that throws.\n    var suppressLogging = e && e.suppressReactErrorLogging;\n    if (!suppressLogging) {\n      console.error(e);\n    }\n  }\n}\n\nvar ReactFiberCommitWork = function (config, captureError, scheduleWork, computeExpirationForFiber, markLegacyErrorBoundaryAsFailed, recalculateCurrentTime) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  var callComponentWillUnmountWithTimer = function (current, instance) {\n    startPhaseTimer(current, 'componentWillUnmount');\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$3(null, callComponentWillUnmountWithTimer, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      if (typeof ref === 'function') {\n        {\n          invokeGuardedCallback$3(null, ref, null, null);\n          if (hasCaughtError$1()) {\n            var refError = clearCaughtError$1();\n            captureError(current, refError);\n          }\n        }\n      } else {\n        ref.current = null;\n      }\n    }\n  }\n\n  function commitBeforeMutationLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          if (finishedWork.effectTag & Snapshot) {\n            if (current !== null) {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n              var _instance = finishedWork.stateNode;\n              _instance.props = finishedWork.memoizedProps;\n              _instance.state = finishedWork.memoizedState;\n              var snapshot = _instance.getSnapshotBeforeUpdate(prevProps, prevState);\n              {\n                var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                  didWarnSet.add(finishedWork.type);\n                  warning(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork));\n                }\n              }\n              _instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n              stopPhaseTimer();\n            }\n          }\n          return;\n        }\n      case HostRoot:\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n        // Nothing to do for these component types\n        return;\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitLifeCycles(finishedRoot, current, finishedWork, currentTime, committedExpirationTime) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n              _instance2.props = finishedWork.memoizedProps;\n              _instance2.state = finishedWork.memoizedState;\n              _instance2.componentDidMount();\n              stopPhaseTimer();\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n              _instance2.props = finishedWork.memoizedProps;\n              _instance2.state = finishedWork.memoizedState;\n              _instance2.componentDidUpdate(prevProps, prevState, _instance2.__reactInternalSnapshotBeforeUpdate);\n              stopPhaseTimer();\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, _instance2);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance3 = null;\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  _instance3 = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n                case ClassComponent:\n                  _instance3 = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n            commitCallbacks(_updateQueue, _instance3);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance4 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance4, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitErrorLogging(finishedWork, onUncaughtError) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var ctor = finishedWork.type;\n          var _instance5 = finishedWork.stateNode;\n          var updateQueue = finishedWork.updateQueue;\n          !(updateQueue !== null && updateQueue.capturedValues !== null) ? invariant(false, 'An error logging effect should not have been scheduled if no errors were captured. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var capturedErrors = updateQueue.capturedValues;\n          updateQueue.capturedValues = null;\n\n          if (typeof ctor.getDerivedStateFromCatch !== 'function') {\n            // To preserve the preexisting retry behavior of error boundaries,\n            // we keep track of which ones already failed during this batch.\n            // This gets reset before we yield back to the browser.\n            // TODO: Warn in strict mode if getDerivedStateFromCatch is\n            // not defined.\n            markLegacyErrorBoundaryAsFailed(_instance5);\n          }\n\n          _instance5.props = finishedWork.memoizedProps;\n          _instance5.state = finishedWork.memoizedState;\n          for (var i = 0; i < capturedErrors.length; i++) {\n            var errorInfo = capturedErrors[i];\n            var _error = errorInfo.value;\n            var stack = errorInfo.stack;\n            logError(finishedWork, errorInfo);\n            _instance5.componentDidCatch(_error, {\n              componentStack: stack !== null ? stack : ''\n            });\n          }\n        }\n        break;\n      case HostRoot:\n        {\n          var _updateQueue2 = finishedWork.updateQueue;\n          !(_updateQueue2 !== null && _updateQueue2.capturedValues !== null) ? invariant(false, 'An error logging effect should not have been scheduled if no errors were captured. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var _capturedErrors = _updateQueue2.capturedValues;\n          _updateQueue2.capturedValues = null;\n          for (var _i = 0; _i < _capturedErrors.length; _i++) {\n            var _errorInfo = _capturedErrors[_i];\n            logError(finishedWork, _errorInfo);\n            onUncaughtError(_errorInfo.value);\n          }\n          break;\n        }\n      default:\n        invariant(false, 'This unit of work tag cannot capture errors.  This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var _instance6 = finishedWork.stateNode;\n      var instanceToUse = void 0;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          instanceToUse = getPublicInstance(_instance6);\n          break;\n        default:\n          instanceToUse = _instance6;\n      }\n      if (typeof ref === 'function') {\n        ref(instanceToUse);\n      } else {\n        {\n          if (!ref.hasOwnProperty('current')) {\n            warning(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork), getStackAddendumByWorkInProgressFiber(finishedWork));\n          }\n        }\n\n        ref.current = instanceToUse;\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      if (typeof currentRef === 'function') {\n        currentRef(null);\n      } else {\n        currentRef.current = null;\n      }\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var _instance7 = current.stateNode;\n          if (typeof _instance7.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, _instance7);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  var emptyPortalContainer = void 0;\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitBeforeMutationLifeCycles: commitBeforeMutationLifeCycles,\n        commitErrorLogging: commitErrorLogging,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance8 = finishedWork.stateNode;\n          if (_instance8 != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(_instance8, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitBeforeMutationLifeCycles: commitBeforeMutationLifeCycles,\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitErrorLogging: commitErrorLogging,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config, stack) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n  var createCursor = stack.createCursor,\n      push = stack.push,\n      pop = stack.pop;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n\n    // Finally, we need to push the host context to the stack.\n    // However, we can't just call getRootHostContext() and push it because\n    // we'd have a different number of entries on the stack depending on\n    // whether getRootHostContext() throws somewhere in renderer code or not.\n    // So we push an empty value first. This lets us safely unwind on errors.\n    push(contextStackCursor, NO_CONTEXT, fiber);\n    var nextRootContext = getRootHostContext(nextRootInstance);\n    // Now that we know this function doesn't throw, replace it.\n    pop(contextStackCursor, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext\n  };\n};\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          var instance = canHydrateInstance(nextInstance, type, props);\n          if (instance !== null) {\n            fiber.stateNode = instance;\n            return true;\n          }\n          return false;\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          var textInstance = canHydrateTextInstance(nextInstance, text);\n          if (textInstance !== null) {\n            fiber.stateNode = textInstance;\n            return true;\n          }\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar ReactFiberLegacyContext = function (stack) {\n  var createCursor = stack.createCursor,\n      push = stack.push,\n      pop = stack.pop;\n\n  // A cursor to the current merged context object on the stack.\n\n  var contextStackCursor = createCursor(emptyObject);\n  // A cursor to a boolean indicating whether the context has changed.\n  var didPerformWorkStackCursor = createCursor(false);\n  // Keep track of the previous context object that was on the stack.\n  // We use this to get access to the parent context after we have already\n  // pushed the next context provider, and now need to merge their contexts.\n  var previousContext = emptyObject;\n\n  function getUnmaskedContext(workInProgress) {\n    var hasOwnContext = isContextProvider(workInProgress);\n    if (hasOwnContext) {\n      // If the fiber is a context provider itself, when we read its context\n      // we have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n    return contextStackCursor.current;\n  }\n\n  function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n    var instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n\n  function getMaskedContext(workInProgress, unmaskedContext) {\n    var type = workInProgress.type;\n    var contextTypes = type.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n\n    // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n    var instance = workInProgress.stateNode;\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    var context = {};\n    for (var key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    {\n      var name = getComponentName(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n\n  function hasContextChanged() {\n    return didPerformWorkStackCursor.current;\n  }\n\n  function isContextConsumer(fiber) {\n    return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n  }\n\n  function isContextProvider(fiber) {\n    return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n  }\n\n  function popContextProvider(fiber) {\n    if (!isContextProvider(fiber)) {\n      return;\n    }\n\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n\n  function popTopLevelContextObject(fiber) {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n\n  function pushTopLevelContextObject(fiber, context, didChange) {\n    !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n\n  function processChildContext(fiber, parentContext) {\n    var instance = fiber.stateNode;\n    var childContextTypes = fiber.type.childContextTypes;\n\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n    if (typeof instance.getChildContext !== 'function') {\n      {\n        var componentName = getComponentName(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n      return parentContext;\n    }\n\n    var childContext = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n    }\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    {\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    for (var contextKey in childContext) {\n      !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n    }\n    {\n      var name = getComponentName(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n    }\n\n    return _assign({}, parentContext, childContext);\n  }\n\n  function pushContextProvider(workInProgress) {\n    if (!isContextProvider(workInProgress)) {\n      return false;\n    }\n\n    var instance = workInProgress.stateNode;\n    // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n    // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n    return true;\n  }\n\n  function invalidateContextProvider(workInProgress, didChange) {\n    var instance = workInProgress.stateNode;\n    !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      var mergedContext = processChildContext(workInProgress, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n      // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress);\n      // Now push the new context and mark that it has changed.\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n\n  function findCurrentUnmaskedContext(fiber) {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var node = fiber;\n    while (node.tag !== HostRoot) {\n      if (isContextProvider(node)) {\n        return node.stateNode.__reactInternalMemoizedMergedChildContext;\n      }\n      var parent = node['return'];\n      !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      node = parent;\n    }\n    return node.stateNode.context;\n  }\n\n  return {\n    getUnmaskedContext: getUnmaskedContext,\n    cacheContext: cacheContext,\n    getMaskedContext: getMaskedContext,\n    hasContextChanged: hasContextChanged,\n    isContextConsumer: isContextConsumer,\n    isContextProvider: isContextProvider,\n    popContextProvider: popContextProvider,\n    popTopLevelContextObject: popTopLevelContextObject,\n    pushTopLevelContextObject: pushTopLevelContextObject,\n    processChildContext: processChildContext,\n    pushContextProvider: pushContextProvider,\n    invalidateContextProvider: invalidateContextProvider,\n    findCurrentUnmaskedContext: findCurrentUnmaskedContext\n  };\n};\n\nvar ReactFiberNewContext = function (stack) {\n  var createCursor = stack.createCursor,\n      push = stack.push,\n      pop = stack.pop;\n\n\n  var providerCursor = createCursor(null);\n  var valueCursor = createCursor(null);\n  var changedBitsCursor = createCursor(0);\n\n  var rendererSigil = void 0;\n  {\n    // Use this to detect multiple renderers using the same context\n    rendererSigil = {};\n  }\n\n  function pushProvider(providerFiber) {\n    var context = providerFiber.type._context;\n\n    push(changedBitsCursor, context._changedBits, providerFiber);\n    push(valueCursor, context._currentValue, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue = providerFiber.pendingProps.value;\n    context._changedBits = providerFiber.stateNode;\n\n    {\n      !(context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warning(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  }\n\n  function popProvider(providerFiber) {\n    var changedBits = changedBitsCursor.current;\n    var currentValue = valueCursor.current;\n\n    pop(providerCursor, providerFiber);\n    pop(valueCursor, providerFiber);\n    pop(changedBitsCursor, providerFiber);\n\n    var context = providerFiber.type._context;\n    context._currentValue = currentValue;\n    context._changedBits = changedBits;\n  }\n\n  return {\n    pushProvider: pushProvider,\n    popProvider: popProvider\n  };\n};\n\nvar ReactFiberStack = function () {\n  var valueStack = [];\n\n  var fiberStack = void 0;\n\n  {\n    fiberStack = [];\n  }\n\n  var index = -1;\n\n  function createCursor(defaultValue) {\n    return {\n      current: defaultValue\n    };\n  }\n\n  function isEmpty() {\n    return index === -1;\n  }\n\n  function pop(cursor, fiber) {\n    if (index < 0) {\n      {\n        warning(false, 'Unexpected pop.');\n      }\n      return;\n    }\n\n    {\n      if (fiber !== fiberStack[index]) {\n        warning(false, 'Unexpected Fiber popped.');\n      }\n    }\n\n    cursor.current = valueStack[index];\n\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n\n  function push(cursor, value, fiber) {\n    index++;\n\n    valueStack[index] = cursor.current;\n\n    {\n      fiberStack[index] = fiber;\n    }\n\n    cursor.current = value;\n  }\n\n  function checkThatStackIsEmpty() {\n    {\n      if (index !== -1) {\n        warning(false, 'Expected an empty stack. Something was not reset properly.');\n      }\n    }\n  }\n\n  function resetStackAfterFatalErrorInDev() {\n    {\n      index = -1;\n      valueStack.length = 0;\n      fiberStack.length = 0;\n    }\n  }\n\n  return {\n    createCursor: createCursor,\n    isEmpty: isEmpty,\n    pop: pop,\n    push: push,\n    checkThatStackIsEmpty: checkThatStackIsEmpty,\n    resetStackAfterFatalErrorInDev: resetStackAfterFatalErrorInDev\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function (fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, \"Can't call setState (or forceUpdate) on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in the ' + 'componentWillUnmount method.%s', getStackAddendumByWorkInProgressFiber(fiber));\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var stack = ReactFiberStack();\n  var hostContext = ReactFiberHostContext(config, stack);\n  var legacyContext = ReactFiberLegacyContext(stack);\n  var newContext = ReactFiberNewContext(stack);\n  var popHostContext = hostContext.popHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject,\n      popLegacyContextProvider = legacyContext.popContextProvider;\n  var popProvider = newContext.popProvider;\n\n  var hydrationContext = ReactFiberHydrationContext(config);\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, legacyContext, newContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, legacyContext, newContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberUnwindWork = ReactFiberUnwindWork(hostContext, legacyContext, newContext, scheduleWork, isAlreadyFailedLegacyErrorBoundary),\n      throwException = _ReactFiberUnwindWork.throwException,\n      unwindWork = _ReactFiberUnwindWork.unwindWork,\n      unwindInterruptedWork = _ReactFiberUnwindWork.unwindInterruptedWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, onCommitPhaseError, scheduleWork, computeExpirationForFiber, markLegacyErrorBoundaryAsFailed, recalculateCurrentTime),\n      commitBeforeMutationLifeCycles = _ReactFiberCommitWork.commitBeforeMutationLifeCycles,\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitErrorLogging = _ReactFiberCommitWork.commitErrorLogging,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      cancelDeferredCallback = config.cancelDeferredCallback,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var originalStartTimeMs = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n  var mostRecentCurrentTimeMs = originalStartTimeMs;\n\n  // Used to ensure computeUniqueAsyncExpiration is monotonically increases.\n  var lastUniqueAsyncExpiration = 0;\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  var isCommitting = false;\n\n  var isRootReadyForCommit = false;\n\n  var legacyErrorBoundariesThatAlreadyFailed = null;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  var stashedWorkInProgressProperties = void 0;\n  var replayUnitOfWork = void 0;\n  var isReplayingFailedUnitOfWork = void 0;\n  var originalReplayError = void 0;\n  var rethrowOriginalError = void 0;\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = null;\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    replayUnitOfWork = function (failedUnitOfWork, error, isAsync) {\n      // Restore the original state of the work-in-progress\n      assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);\n      switch (failedUnitOfWork.tag) {\n        case HostRoot:\n          popHostContainer(failedUnitOfWork);\n          popTopLevelLegacyContextObject(failedUnitOfWork);\n          break;\n        case HostComponent:\n          popHostContext(failedUnitOfWork);\n          break;\n        case ClassComponent:\n          popLegacyContextProvider(failedUnitOfWork);\n          break;\n        case HostPortal:\n          popHostContainer(failedUnitOfWork);\n          break;\n        case ContextProvider:\n          popProvider(failedUnitOfWork);\n          break;\n      }\n      // Replay the begin phase.\n      isReplayingFailedUnitOfWork = true;\n      originalReplayError = error;\n      invokeGuardedCallback$2(null, workLoop, null, isAsync);\n      isReplayingFailedUnitOfWork = false;\n      originalReplayError = null;\n      if (hasCaughtError()) {\n        clearCaughtError();\n      } else {\n        // If the begin phase did not fail the second time, set this pointer\n        // back to the original value.\n        nextUnitOfWork = failedUnitOfWork;\n      }\n    };\n    rethrowOriginalError = function () {\n      throw originalReplayError;\n    };\n  }\n\n  function resetStack() {\n    if (nextUnitOfWork !== null) {\n      var interruptedWork = nextUnitOfWork['return'];\n      while (interruptedWork !== null) {\n        unwindInterruptedWork(interruptedWork);\n        interruptedWork = interruptedWork['return'];\n      }\n    }\n\n    {\n      ReactStrictModeWarnings.discardPendingWarnings();\n      stack.checkThatStackIsEmpty();\n    }\n\n    nextRoot = null;\n    nextRenderExpirationTime = NoWork;\n    nextUnitOfWork = null;\n\n    isRootReadyForCommit = false;\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            commitDeletion(nextEffect);\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitBeforeMutationLifecycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & Snapshot) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitBeforeMutationLifeCycles(current, nextEffect);\n      }\n\n      // Don't cleanup effects yet;\n      // This will be done by commitAllLifeCycles()\n      nextEffect = nextEffect.nextEffect;\n    }\n  }\n\n  function commitAllLifeCycles(finishedRoot, currentTime, committedExpirationTime) {\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n      }\n    }\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(finishedRoot, current, nextEffect, currentTime, committedExpirationTime);\n      }\n\n      if (effectTag & ErrLog) {\n        commitErrorLogging(nextEffect, onUncaughtError);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function isAlreadyFailedLegacyErrorBoundary(instance) {\n    return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n  }\n\n  function markLegacyErrorBoundaryAsFailed(instance) {\n    if (legacyErrorBoundariesThatAlreadyFailed === null) {\n      legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n    } else {\n      legacyErrorBoundariesThatAlreadyFailed.add(instance);\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var committedExpirationTime = root.pendingCommitExpirationTime;\n    !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.pendingCommitExpirationTime = NoWork;\n\n    var currentTime = recalculateCurrentTime();\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit(root.containerInfo);\n\n    // Invoke instances of getSnapshotBeforeUpdate before mutation.\n    nextEffect = firstEffect;\n    startCommitSnapshotEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitBeforeMutationLifecycles, null);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        onCommitPhaseError(nextEffect, error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitSnapshotEffectsTimer();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        onCommitPhaseError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError2 = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$2(null, commitAllLifeCycles, null, root, currentTime, committedExpirationTime);\n        if (hasCaughtError()) {\n          _didError2 = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError2) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        onCommitPhaseError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    var remainingTime = root.current.expirationTime;\n    if (remainingTime === NoWork) {\n      // If there's no remaining work, we can clear the set of already failed\n      // error boundaries.\n      legacyErrorBoundariesThatAlreadyFailed = null;\n    }\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    // Attempt to complete the current unit of work, then move to the\n    // next sibling. If there are no more siblings, return to the\n    // parent fiber.\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n        // This fiber completed.\n        var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n        stopWorkTimer(workInProgress);\n        resetExpirationTime(workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          return next;\n        }\n\n        if (returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect) {\n          // Append all the effects of the subtree and this fiber onto the effect\n          // list of the parent. The completion order of the children affects the\n          // side-effect order.\n          if (returnFiber.firstEffect === null) {\n            returnFiber.firstEffect = workInProgress.firstEffect;\n          }\n          if (workInProgress.lastEffect !== null) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n            }\n            returnFiber.lastEffect = workInProgress.lastEffect;\n          }\n\n          // If this fiber had side-effects, we append it AFTER the children's\n          // side-effects. We can perform certain side-effects earlier if\n          // needed, by doing multiple passes over the effect list. We don't want\n          // to schedule our own side-effect on our own list because if end up\n          // reusing children we'll schedule this effect onto itself since we're\n          // at the end.\n          var effectTag = workInProgress.effectTag;\n          // Skip both NoWork and PerformedWork tags when creating the effect list.\n          // PerformedWork effect is read by React DevTools but shouldn't be committed.\n          if (effectTag > PerformedWork) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress;\n            } else {\n              returnFiber.firstEffect = workInProgress;\n            }\n            returnFiber.lastEffect = workInProgress;\n          }\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          // We've reached the root.\n          isRootReadyForCommit = true;\n          return null;\n        }\n      } else {\n        // This fiber did not complete because something threw. Pop values off\n        // the stack without entering the complete phase. If this is a boundary,\n        // capture values if possible.\n        var _next = unwindWork(workInProgress);\n        // Because this fiber did not complete, don't reset its expiration time.\n        if (workInProgress.effectTag & DidCapture) {\n          // Restarting an error boundary\n          stopFailedWorkTimer(workInProgress);\n        } else {\n          stopWorkTimer(workInProgress);\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (_next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          // Since we're restarting, remove anything that is not a host effect\n          // from the effect tag.\n          _next.effectTag &= HostEffectMask;\n          return _next;\n        }\n\n        if (returnFiber !== null) {\n          // Mark the parent fiber as incomplete and clear its effect list.\n          returnFiber.firstEffect = returnFiber.lastEffect = null;\n          returnFiber.effectTag |= Incomplete;\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n      stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);\n    }\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n      if (isReplayingFailedUnitOfWork) {\n        // Currently replaying a failed unit of work. This should be unreachable,\n        // because the render phase is meant to be idempotent, and it should\n        // have thrown again. Since it didn't, rethrow the original error, so\n        // React's internal stack is not misaligned.\n        rethrowOriginalError();\n      }\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(isAsync) {\n    if (!isAsync) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function renderRoot(root, expirationTime, isAsync) {\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {\n      // Reset the stack and start working from the root.\n      resetStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);\n      root.pendingCommitExpirationTime = NoWork;\n    }\n\n    var didFatal = false;\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    do {\n      try {\n        workLoop(isAsync);\n      } catch (thrownValue) {\n        if (nextUnitOfWork === null) {\n          // This is a fatal error.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          var failedUnitOfWork = nextUnitOfWork;\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);\n        }\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber['return'];\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n        throwException(returnFiber, sourceFiber, thrownValue);\n        nextUnitOfWork = completeUnitOfWork(sourceFiber);\n      }\n      break;\n    } while (true);\n\n    // We're done performing work. Time to clean up.\n    var didCompleteRoot = false;\n    isWorking = false;\n\n    // Yield back to main thread.\n    if (didFatal) {\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // There was a fatal error.\n      {\n        stack.resetStackAfterFatalErrorInDev();\n      }\n      return null;\n    } else if (nextUnitOfWork === null) {\n      // We reached the root.\n      if (isRootReadyForCommit) {\n        didCompleteRoot = true;\n        stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n        interruptedBy = null;\n        // The root successfully completed. It's ready for commit.\n        root.pendingCommitExpirationTime = expirationTime;\n        var finishedWork = root.current.alternate;\n        return finishedWork;\n      } else {\n        // The root did not complete.\n        stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n        interruptedBy = null;\n        invariant(false, 'Expired work should have completed. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } else {\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // There's more work to do, but we ran out of time. Yield back to\n      // the renderer.\n      return null;\n    }\n  }\n\n  function scheduleCapture(sourceFiber, boundaryFiber, value, expirationTime) {\n    // TODO: We only support dispatching errors.\n    var capturedValue = createCapturedValue(value, sourceFiber);\n    var update = {\n      expirationTime: expirationTime,\n      partialState: null,\n      callback: null,\n      isReplace: false,\n      isForced: false,\n      capturedValue: capturedValue,\n      next: null\n    };\n    insertUpdateIntoFiber(boundaryFiber, update);\n    scheduleWork(boundaryFiber, expirationTime);\n  }\n\n  function dispatch(sourceFiber, value, expirationTime) {\n    !(!isWorking || isCommitting) ? invariant(false, 'dispatch: Cannot dispatch during the render phase.') : void 0;\n\n    // TODO: Handle arrays\n\n    var fiber = sourceFiber['return'];\n    while (fiber !== null) {\n      switch (fiber.tag) {\n        case ClassComponent:\n          var ctor = fiber.type;\n          var instance = fiber.stateNode;\n          if (typeof ctor.getDerivedStateFromCatch === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n            scheduleCapture(sourceFiber, fiber, value, expirationTime);\n            return;\n          }\n          break;\n        // TODO: Handle async boundaries\n        case HostRoot:\n          scheduleCapture(sourceFiber, fiber, value, expirationTime);\n          return;\n      }\n      fiber = fiber['return'];\n    }\n\n    if (sourceFiber.tag === HostRoot) {\n      // Error was thrown at the root. There is no parent, so the root\n      // itself should capture it.\n      scheduleCapture(sourceFiber, sourceFiber, value, expirationTime);\n    }\n  }\n\n  function onCommitPhaseError(fiber, error) {\n    return dispatch(fiber, error, Sync);\n  }\n\n  function computeAsyncExpiration(currentTime) {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var expirationMs = 5000;\n    var bucketSizeMs = 250;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeInteractiveExpiration(currentTime) {\n    var expirationMs = void 0;\n    // We intentionally set a higher expiration time for interactive updates in\n    // dev than in production.\n    // If the main thread is being blocked so long that you hit the expiration,\n    // it's a problem that could be solved with better scheduling.\n    // People will be more likely to notice this and fix it with the long\n    // expiration time in development.\n    // In production we opt for better UX at the risk of masking scheduling\n    // problems, by expiring fast.\n    {\n      // Should complete within ~500ms. 600ms max.\n      expirationMs = 500;\n    }\n    var bucketSizeMs = 100;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  // Creates a unique async expiration time.\n  function computeUniqueAsyncExpiration() {\n    var currentTime = recalculateCurrentTime();\n    var result = computeAsyncExpiration(currentTime);\n    if (result <= lastUniqueAsyncExpiration) {\n      // Since we assume the current time monotonically increases, we only hit\n      // this branch when computeUniqueAsyncExpiration is fired multiple times\n      // within a 200ms window (or whatever the async bucket size is).\n      result = lastUniqueAsyncExpiration + 1;\n    }\n    lastUniqueAsyncExpiration = result;\n    return lastUniqueAsyncExpiration;\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (fiber.mode & AsyncMode) {\n        if (isBatchingInteractiveUpdates) {\n          // This is an interactive update\n          var currentTime = recalculateCurrentTime();\n          expirationTime = computeInteractiveExpiration(currentTime);\n        } else {\n          // This is an async update\n          var _currentTime = recalculateCurrentTime();\n          expirationTime = computeAsyncExpiration(_currentTime);\n        }\n      } else {\n        // This is a sync update\n        expirationTime = Sync;\n      }\n    }\n    if (isBatchingInteractiveUpdates) {\n      // This is an interactive update. Keep track of the lowest pending\n      // interactive expiration time. This allows us to synchronously flush\n      // all interactive updates when needed.\n      if (lowestPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPendingInteractiveExpirationTime) {\n        lowestPendingInteractiveExpirationTime = expirationTime;\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n          if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {\n            // This is an interruption. (Used for performance tracking.)\n            interruptedBy = fiber;\n            resetStack();\n          }\n          if (\n          // If we're in the render phase, we don't need to schedule this root\n          // for an update, because we'll do it before we exit...\n          !isWorking || isCommitting ||\n          // ...unless this is a different root than the one we're rendering.\n          nextRoot !== root) {\n            // Add this root to the root schedule.\n            requestWork(root, expirationTime);\n          }\n          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n            invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n          }\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    mostRecentCurrentTimeMs = now() - originalStartTimeMs;\n    mostRecentCurrentTime = msToExpirationTime(mostRecentCurrentTimeMs);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    var currentTime = recalculateCurrentTime();\n    expirationContext = computeAsyncExpiration(currentTime);\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n  function syncUpdates(fn, a, b, c, d) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn(a, b, c, d);\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var lowestPendingInteractiveExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n  var isBatchingInteractiveUpdates = false;\n\n  var completedBatches = null;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - originalStartTimeMs;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    addRootToSchedule(root, expirationTime);\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(root, Sync, false);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performSyncWork();\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function addRootToSchedule(root, expirationTime) {\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot && highestPriorityWork === Sync) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, true, dl);\n  }\n\n  function performSyncWork() {\n    performWork(Sync, false, null);\n  }\n\n  function performWork(minExpirationTime, isAsync, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    if (isAsync) {\n      while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || recalculateCurrentTime() >= nextFlushedExpirationTime)) {\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !deadlineDidExpire);\n        findHighestPriorityRoot();\n      }\n    } else {\n      while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n        findHighestPriorityRoot();\n      }\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n\n    finishRendering();\n  }\n\n  function flushRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;\n    // Perform work on root as if the given expiration time is the current time.\n    // This has the effect of synchronously flushing all work up to and\n    // including the given time.\n    nextFlushedRoot = root;\n    nextFlushedExpirationTime = expirationTime;\n    performWorkOnRoot(root, expirationTime, false);\n    // Flush any sync work that was scheduled by lifecycles\n    performSyncWork();\n    finishRendering();\n  }\n\n  function finishRendering() {\n    nestedUpdateCount = 0;\n\n    if (completedBatches !== null) {\n      var batches = completedBatches;\n      completedBatches = null;\n      for (var i = 0; i < batches.length; i++) {\n        var batch = batches[i];\n        try {\n          batch._onComplete();\n        } catch (error) {\n          if (!hasUnhandledError) {\n            hasUnhandledError = true;\n            unhandledError = error;\n          }\n        }\n      }\n    }\n\n    if (hasUnhandledError) {\n      var error = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw error;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime, isAsync) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    if (!isAsync) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime, false);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          completeRoot(root, finishedWork, expirationTime);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, _finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime, true);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            completeRoot(root, _finishedWork, expirationTime);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  function completeRoot(root, finishedWork, expirationTime) {\n    // Check if there's a batch that matches this expiration time.\n    var firstBatch = root.firstBatch;\n    if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n      if (completedBatches === null) {\n        completedBatches = [firstBatch];\n      } else {\n        completedBatches.push(firstBatch);\n      }\n      if (firstBatch._defer) {\n        // This root is blocked from committing by a batch. Unschedule it until\n        // we receive another update.\n        root.finishedWork = finishedWork;\n        root.remainingExpirationTime = NoWork;\n        return;\n      }\n    }\n\n    // Commit the root.\n    root.finishedWork = null;\n    root.remainingExpirationTime = commitRoot(finishedWork);\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn, a) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn(a);\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn(a);\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn, a) {\n    !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn, a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      performSyncWork();\n    }\n  }\n\n  function interactiveUpdates(fn, a, b) {\n    if (isBatchingInteractiveUpdates) {\n      return fn(a, b);\n    }\n    // If there are any pending interactive updates, synchronously flush them.\n    // This needs to happen before we read any handlers, because the effect of\n    // the previous event may influence which handlers are called during\n    // this event.\n    if (!isBatchingUpdates && !isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n    var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingInteractiveUpdates = true;\n    isBatchingUpdates = true;\n    try {\n      return fn(a, b);\n    } finally {\n      isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  function flushInteractiveUpdates() {\n    if (!isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n  }\n\n  function flushControlled(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, false, null);\n      }\n    }\n  }\n\n  return {\n    recalculateCurrentTime: recalculateCurrentTime,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    requestWork: requestWork,\n    flushRoot: flushRoot,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    flushControlled: flushControlled,\n    deferredUpdates: deferredUpdates,\n    syncUpdates: syncUpdates,\n    interactiveUpdates: interactiveUpdates,\n    flushInteractiveUpdates: flushInteractiveUpdates,\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n    legacyContext: legacyContext\n  };\n};\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nvar ReactFiberReconciler$1 = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeUniqueAsyncExpiration = _ReactFiberScheduler.computeUniqueAsyncExpiration,\n      recalculateCurrentTime = _ReactFiberScheduler.recalculateCurrentTime,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      requestWork = _ReactFiberScheduler.requestWork,\n      flushRoot = _ReactFiberScheduler.flushRoot,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      flushControlled = _ReactFiberScheduler.flushControlled,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates,\n      syncUpdates = _ReactFiberScheduler.syncUpdates,\n      interactiveUpdates = _ReactFiberScheduler.interactiveUpdates,\n      flushInteractiveUpdates = _ReactFiberScheduler.flushInteractiveUpdates,\n      legacyContext = _ReactFiberScheduler.legacyContext;\n\n  var findCurrentUnmaskedContext = legacyContext.findCurrentUnmaskedContext,\n      isContextProvider = legacyContext.isContextProvider,\n      processChildContext = legacyContext.processChildContext;\n\n\n  function getContextForSubtree(parentComponent) {\n    if (!parentComponent) {\n      return emptyObject;\n    }\n\n    var fiber = get(parentComponent);\n    var parentContext = findCurrentUnmaskedContext(fiber);\n    return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n  }\n\n  function scheduleRootUpdate(current, element, currentTime, expirationTime, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      !(callback === null || typeof callback === 'function') ? warning(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      capturedValue: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n  }\n\n  function updateContainerAtExpirationTime(element, container, parentComponent, currentTime, expirationTime, callback) {\n    // TODO: If this is a nested container, this won't be the root.\n    var current = container.current;\n\n    {\n      if (ReactFiberInstrumentation_1.debugTool) {\n        if (current.alternate === null) {\n          ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n        } else if (element === null) {\n          ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n        } else {\n          ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n        }\n      }\n    }\n\n    var context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n      container.context = context;\n    } else {\n      container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(current, element, currentTime, expirationTime, callback);\n  }\n\n  function findHostInstance(component) {\n    var fiber = get(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n      }\n    }\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function (containerInfo, isAsync, hydrate) {\n      return createFiberRoot(containerInfo, isAsync, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      var current = container.current;\n      var currentTime = recalculateCurrentTime();\n      var expirationTime = computeExpirationForFiber(current);\n      return updateContainerAtExpirationTime(element, container, parentComponent, currentTime, expirationTime, callback);\n    },\n    updateContainerAtExpirationTime: function (element, container, parentComponent, expirationTime, callback) {\n      var currentTime = recalculateCurrentTime();\n      return updateContainerAtExpirationTime(element, container, parentComponent, currentTime, expirationTime, callback);\n    },\n\n\n    flushRoot: flushRoot,\n\n    requestWork: requestWork,\n\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    syncUpdates: syncUpdates,\n\n    interactiveUpdates: interactiveUpdates,\n\n    flushInteractiveUpdates: flushInteractiveUpdates,\n\n    flushControlled: flushControlled,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function (devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(_assign({}, devToolsConfig, {\n        findHostInstanceByFiber: function (fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        },\n        findFiberByHostInstance: function (instance) {\n          if (!findFiberByHostInstance) {\n            // Might not be implemented by the renderer.\n            return null;\n          }\n          return findFiberByHostInstance(instance);\n        }\n      }));\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n\tdefault: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.3.2';\n\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n{\n  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n}\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar now = void 0;\nif (hasNativePerformanceNow) {\n  now = function () {\n    return performance.now();\n  };\n} else {\n  now = function () {\n    return Date.now();\n  };\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nvar rIC = void 0;\nvar cIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    return setTimeout(function () {\n      frameCallback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n  };\n  cIC = function (timeoutID) {\n    clearTimeout(timeoutID);\n  };\n} else if (alwaysUseRequestIdleCallbackPolyfill || typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback and cancelIdleCallback\n\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = void 0;\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = frameDeadline - performance.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // Fallback to Date.now()\n        var remaining = frameDeadline - Date.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  }\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = now();\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        frameDeadlineObject.didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrame(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    } else {\n      // There's still time left in this idle period.\n      frameDeadlineObject.didTimeout = false;\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  rIC = function (callback, options) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = now() + options.timeout;\n    }\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n\n  cIC = function () {\n    scheduledRICCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n} else {\n  rIC = window.requestIdleCallback;\n  cIC = window.cancelIdleCallback;\n}\n\nvar didWarnSelectedSetOnOption = false;\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  // TODO (yungsters): Remove support for `selected` in <option>.\n  {\n    if (props.selected != null && !didWarnSelectedSetOnOption) {\n      warning(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n      didWarnSelectedSetOnOption = true;\n    }\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', props.value);\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnValueDefaultValue$1 = void 0;\n\n{\n  didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$3();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  var value = props.value;\n  node._wrapperState = {\n    initialValue: value != null ? value : props.defaultValue,\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  // After the initial mount, we control selected-ness manually so don't pass\n  // this value down\n  node._wrapperState.initialValue = undefined;\n\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: '' + node._wrapperState.initialValue\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: '' + initialValue\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = props.value;\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = '' + value;\n\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = props.defaultValue;\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar warnValidStyle = emptyFunction;\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n  };\n\n  var warnBadVendoredStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, getStack) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n  };\n\n  var warnStyleValueIsNaN = function (name, value, getStack) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, getStack) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  warnValidStyle = function (name, value, getStack) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, getStack);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, getStack);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, getStack);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, getStack);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, getStack);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles, getStack) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName], getStack);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\nvar HTML$1 = '__html';\n\nfunction assertValidProps(tag, props, getStack) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack()) : void 0;\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  'class': 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  'default': 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  'for': 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nomodule: 'noModule',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  'in': 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  'typeof': 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getStackAddendum() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  } else if (invalidProps.length > 1) {\n    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n    } else {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n    }\n  }\n}\n\nfunction getStackAddendum$2() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nvar validateProperty$1 = function () {};\n\n{\n  var warnedProperties$1 = {};\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var propertyInfo = getPropertyInfo(name);\n    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      if (value) {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n      } else {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  } else if (unknownProps.length > 1) {\n    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar getStack = emptyFunction.thatReturns('');\n\nvar warnedUnknownTags = void 0;\nvar suppressHydrationWarning = void 0;\n\nvar validatePropertiesInDevelopment = void 0;\nvar warnForTextDifference = void 0;\nvar warnForPropDifference = void 0;\nvar warnForExtraAttributes = void 0;\nvar warnForInvalidEventListener = void 0;\n\nvar normalizeMarkupForTextOrAttribute = void 0;\nvar normalizeHTML = void 0;\n\n{\n  getStack = getCurrentFiberStackAddendum$3;\n\n  warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true\n  };\n\n  validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning(false, 'Extra attributes from the server: %s', names);\n  };\n\n  warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$3());\n    } else {\n      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$3());\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We blacklist it here rather than in the property list because we emit it in SSR.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (nextProp != null) {\n      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {\n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n    }\n  }\n}\n\nfunction createElement$1(type, props, rootContainerElement, parentNamespace) {\n  var isCustomComponentTag = void 0;\n\n  // We create tags in the namespace of their parent container, except HTML\n  // tags get no namespace.\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement = void 0;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      !(isCustomComponentTag || type === type.toLowerCase()) ? warning(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode$1(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$2() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props = void 0;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEventTypes) {\n        if (mediaEventTypes.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEventTypes[event], domElement);\n        }\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props, getStack);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps = void 0;\n  var nextProps = void 0;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps, getStack);\n\n  var propKey = void 0;\n  var styleName = void 0;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction getPossibleStandardName(propName) {\n  {\n    var lowerCasedName = propName.toLowerCase();\n    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      return null;\n    }\n    return possibleStandardNames[lowerCasedName] || null;\n  }\n  return null;\n}\n\nfunction diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  var isCustomComponentTag = void 0;\n  var extraAttributeNames = void 0;\n\n  {\n    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$2() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEventTypes) {\n        if (mediaEventTypes.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEventTypes[event], domElement);\n        }\n      }\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps, getStack);\n\n  {\n    extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var i = 0; i < attributes.length; i++) {\n      var name = attributes[i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (true &&\n    // Convince Flow we've calculated it (it's DEV-only in this method.)\n    typeof isCustomComponentTag === 'boolean') {\n      // Validate that the properties correspond to their expected values.\n      var serverValue = void 0;\n      var propertyInfo = getPropertyInfo(propKey);\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n        var serverHTML = domElement.innerHTML;\n        var expectedHTML = normalizeHTML(domElement, rawHtml);\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey);\n        var expectedStyle = createDangerousStringForStyles(nextProp);\n        serverValue = domElement.getAttribute('style');\n        if (expectedStyle !== serverValue) {\n          warnForPropDifference(propKey, serverValue, expectedStyle);\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n        var isMismatchDueToBadCasing = false;\n        if (propertyInfo !== null) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey.toLowerCase());\n          } else {\n            var standardName = getPossibleStandardName(propKey);\n            if (standardName !== null && standardName !== propKey) {\n              // If an SVG prop is supplied with bad casing, it will\n              // be successfully parsed from HTML, but will produce a mismatch\n              // (and would be incorrectly rendered on the client).\n              // However, we already warn about bad casing elsewhere.\n              // So we'll skip the misleading extra mismatch warning in this case.\n              isMismatchDueToBadCasing = true;\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](standardName);\n            }\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText$1(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText$1(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement$1(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText$1(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState$1(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\nvar ReactDOMFiberComponent = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateTextNode: createTextNode$1,\n\tsetInitialProperties: setInitialProperties$1,\n\tdiffProperties: diffProperties$1,\n\tupdateProperties: updateProperties$1,\n\tdiffHydratedProperties: diffHydratedProperties$1,\n\tdiffHydratedText: diffHydratedText$1,\n\twarnForUnmatchedText: warnForUnmatchedText$1,\n\twarnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n\twarnForDeletedHydratableText: warnForDeletedHydratableText$1,\n\twarnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n\twarnForInsertedHydratedText: warnForInsertedHydratedText$1,\n\trestoreControlledState: restoreControlledState$1\n});\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar validateDOMNesting = emptyFunction;\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      !(childTag == null) ? warning(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackAddendum$6();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  // TODO: turn this into a named export\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;\n}\n\nvar validateDOMNesting$1 = validateDOMNesting;\n\n// TODO: This type is shared between the reconciler and ReactDOM, but will\n// eventually be lifted out to the renderer.\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar createElement = createElement$1;\nvar createTextNode = createTextNode$1;\nvar setInitialProperties = setInitialProperties$1;\nvar diffProperties = diffProperties$1;\nvar updateProperties = updateProperties$1;\nvar diffHydratedProperties = diffHydratedProperties$1;\nvar diffHydratedText = diffHydratedText$1;\nvar warnForUnmatchedText = warnForUnmatchedText$1;\nvar warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\nvar warnForDeletedHydratableText = warnForDeletedHydratableText$1;\nvar warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\nvar warnForInsertedHydratedText = warnForInsertedHydratedText$1;\nvar updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\nvar precacheFiberNode = precacheFiberNode$1;\nvar updateFiberProps = updateFiberProps$1;\n\n\nvar SUPPRESS_HYDRATION_WARNING = void 0;\nvar topLevelUpdateWarnings = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutUnstableCreatePortal = false;\n\n{\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n\n  topLevelUpdateWarnings = function (container) {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n      if (hostInstance) {\n        !(hostInstance.parentNode === container) ? warning(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warning(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\n\n    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warning(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\n  };\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    !(callback === null || typeof callback === 'function') ? warning(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;\n  };\n}\n\ninjection$2.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\nfunction ReactBatch(root) {\n  var expirationTime = DOMRenderer.computeUniqueAsyncExpiration();\n  this._expirationTime = expirationTime;\n  this._root = root;\n  this._next = null;\n  this._callbacks = null;\n  this._didComplete = false;\n  this._hasChildren = false;\n  this._children = null;\n  this._defer = true;\n}\nReactBatch.prototype.render = function (children) {\n  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;\n  this._hasChildren = true;\n  this._children = children;\n  var internalRoot = this._root._internalRoot;\n  var expirationTime = this._expirationTime;\n  var work = new ReactWork();\n  DOMRenderer.updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);\n  return work;\n};\nReactBatch.prototype.then = function (onComplete) {\n  if (this._didComplete) {\n    onComplete();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onComplete);\n};\nReactBatch.prototype.commit = function () {\n  var internalRoot = this._root._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n\n  if (!this._hasChildren) {\n    // This batch is empty. Return.\n    this._next = null;\n    this._defer = false;\n    return;\n  }\n\n  var expirationTime = this._expirationTime;\n\n  // Ensure this is the first batch in the list.\n  if (firstBatch !== this) {\n    // This batch is not the earliest batch. We need to move it to the front.\n    // Update its expiration time to be the expiration time of the earliest\n    // batch, so that we can flush it without flushing the other batches.\n    if (this._hasChildren) {\n      expirationTime = this._expirationTime = firstBatch._expirationTime;\n      // Rendering this batch again ensures its children will be the final state\n      // when we flush (updates are processed in insertion order: last\n      // update wins).\n      // TODO: This forces a restart. Should we print a warning?\n      this.render(this._children);\n    }\n\n    // Remove the batch from the list.\n    var previous = null;\n    var batch = firstBatch;\n    while (batch !== this) {\n      previous = batch;\n      batch = batch._next;\n    }\n    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n    previous._next = batch._next;\n\n    // Add it to the front.\n    this._next = firstBatch;\n    firstBatch = internalRoot.firstBatch = this;\n  }\n\n  // Synchronously flush all the work up to this batch's expiration time.\n  this._defer = false;\n  DOMRenderer.flushRoot(internalRoot, expirationTime);\n\n  // Pop the batch from the list.\n  var next = this._next;\n  this._next = null;\n  firstBatch = internalRoot.firstBatch = next;\n\n  // Append the next earliest batch's children to the update queue.\n  if (firstBatch !== null && firstBatch._hasChildren) {\n    firstBatch.render(firstBatch._children);\n  }\n};\nReactBatch.prototype._onComplete = function () {\n  if (this._didComplete) {\n    return;\n  }\n  this._didComplete = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback = callbacks[i];\n    _callback();\n  }\n};\n\nfunction ReactWork() {\n  this._callbacks = null;\n  this._didCommit = false;\n  // TODO: Avoid need to bind by replacing callbacks in the update queue with\n  // list of Work objects.\n  this._onCommit = this._onCommit.bind(this);\n}\nReactWork.prototype.then = function (onCommit) {\n  if (this._didCommit) {\n    onCommit();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onCommit);\n};\nReactWork.prototype._onCommit = function () {\n  if (this._didCommit) {\n    return;\n  }\n  this._didCommit = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback2 = callbacks[i];\n    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;\n    _callback2();\n  }\n};\n\nfunction ReactRoot(container, isAsync, hydrate) {\n  var root = DOMRenderer.createContainer(container, isAsync, hydrate);\n  this._internalRoot = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  DOMRenderer.updateContainer(children, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  DOMRenderer.updateContainer(null, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  DOMRenderer.updateContainer(children, root, parentComponent, work._onCommit);\n  return work;\n};\nReactRoot.prototype.createBatch = function () {\n  var batch = new ReactBatch(this);\n  var expirationTime = batch._expirationTime;\n\n  var internalRoot = this._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  if (firstBatch === null) {\n    internalRoot.firstBatch = batch;\n    batch._next = null;\n  } else {\n    // Insert sorted by expiration time then insertion order\n    var insertAfter = null;\n    var insertBefore = firstBatch;\n    while (insertBefore !== null && insertBefore._expirationTime <= expirationTime) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore._next;\n    }\n    batch._next = insertBefore;\n    if (insertAfter !== null) {\n      insertAfter._next = batch;\n    }\n  }\n\n  return batch;\n};\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nvar DOMRenderer = reactReconciler({\n  getRootHostContext: function (rootContainerInstance) {\n    var type = void 0;\n    var namespace = void 0;\n    var nodeType = rootContainerInstance.nodeType;\n    switch (nodeType) {\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        {\n          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n          var root = rootContainerInstance.documentElement;\n          namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n          break;\n        }\n      default:\n        {\n          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n          var ownNamespace = container.namespaceURI || null;\n          type = container.tagName;\n          namespace = getChildNamespace(ownNamespace, type);\n          break;\n        }\n    }\n    {\n      var validatedTag = type.toLowerCase();\n      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n      return { namespace: namespace, ancestorInfo: _ancestorInfo };\n    }\n    return namespace;\n  },\n  getChildHostContext: function (parentHostContext, type) {\n    {\n      var parentHostContextDev = parentHostContext;\n      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n    }\n    var parentNamespace = parentHostContext;\n    return getChildNamespace(parentNamespace, type);\n  },\n  getPublicInstance: function (instance) {\n    return instance;\n  },\n  prepareForCommit: function () {\n    eventsEnabled = isEnabled();\n    selectionInformation = getSelectionInformation();\n    setEnabled(false);\n  },\n  resetAfterCommit: function () {\n    restoreSelection(selectionInformation);\n    selectionInformation = null;\n    setEnabled(eventsEnabled);\n    eventsEnabled = null;\n  },\n  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    var parentNamespace = void 0;\n    {\n      // TODO: take namespace into account when validating.\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        var string = '' + props.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n      parentNamespace = hostContextDev.namespace;\n    }\n    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n    precacheFiberNode(internalInstanceHandle, domElement);\n    updateFiberProps(domElement, props);\n    return domElement;\n  },\n  appendInitialChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n    setInitialProperties(domElement, type, props, rootContainerInstance);\n    return shouldAutoFocusHostComponent(type, props);\n  },\n  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    {\n      var hostContextDev = hostContext;\n      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n        var string = '' + newProps.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n    }\n    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n  },\n  shouldSetTextContent: function (type, props) {\n    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n  },\n  shouldDeprioritizeSubtree: function (type, props) {\n    return !!props.hidden;\n  },\n  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n    {\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n    }\n    var textNode = createTextNode(text, rootContainerInstance);\n    precacheFiberNode(internalInstanceHandle, textNode);\n    return textNode;\n  },\n\n\n  now: now,\n\n  mutation: {\n    commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n      // Despite the naming that might imply otherwise, this method only\n      // fires if there is an `Update` effect scheduled during mounting.\n      // This happens if `finalizeInitialChildren` returns `true` (which it\n      // does to implement the `autoFocus` attribute on the client). But\n      // there are also other cases when this might happen (such as patching\n      // up text content during hydration mismatch). So we'll check this again.\n      if (shouldAutoFocusHostComponent(type, newProps)) {\n        domElement.focus();\n      }\n    },\n    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n      // Update the props handle so that we know which props are the ones with\n      // with current event handlers.\n      updateFiberProps(domElement, newProps);\n      // Apply the diff to the DOM node.\n      updateProperties(domElement, updatePayload, type, oldProps, newProps);\n    },\n    resetTextContent: function (domElement) {\n      setTextContent(domElement, '');\n    },\n    commitTextUpdate: function (textInstance, oldText, newText) {\n      textInstance.nodeValue = newText;\n    },\n    appendChild: function (parentInstance, child) {\n      parentInstance.appendChild(child);\n    },\n    appendChildToContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, container);\n      } else {\n        container.appendChild(child);\n      }\n    },\n    insertBefore: function (parentInstance, child, beforeChild) {\n      parentInstance.insertBefore(child, beforeChild);\n    },\n    insertInContainerBefore: function (container, child, beforeChild) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, beforeChild);\n      } else {\n        container.insertBefore(child, beforeChild);\n      }\n    },\n    removeChild: function (parentInstance, child) {\n      parentInstance.removeChild(child);\n    },\n    removeChildFromContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.removeChild(child);\n      } else {\n        container.removeChild(child);\n      }\n    }\n  },\n\n  hydration: {\n    canHydrateInstance: function (instance, type, props) {\n      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n        return null;\n      }\n      // This has now been refined to an element node.\n      return instance;\n    },\n    canHydrateTextInstance: function (instance, text) {\n      if (text === '' || instance.nodeType !== TEXT_NODE) {\n        // Empty strings are not parsed by HTML so there won't be a correct match here.\n        return null;\n      }\n      // This has now been refined to a text node.\n      return instance;\n    },\n    getNextHydratableSibling: function (instance) {\n      var node = instance.nextSibling;\n      // Skip non-hydratable nodes.\n      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    },\n    getFirstHydratableChild: function (parentInstance) {\n      var next = parentInstance.firstChild;\n      // Skip non-hydratable nodes.\n      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n        next = next.nextSibling;\n      }\n      return next;\n    },\n    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, instance);\n      // TODO: Possibly defer this until the commit phase where all the events\n      // get attached.\n      updateFiberProps(instance, props);\n      var parentNamespace = void 0;\n      {\n        var hostContextDev = hostContext;\n        parentNamespace = hostContextDev.namespace;\n      }\n      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n    },\n    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, textInstance);\n      return diffHydratedText(textInstance, text);\n    },\n    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {\n      {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotHydrateContainerInstance: function (parentContainer, instance) {\n      {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentContainer, instance);\n        } else {\n          warnForDeletedHydratableText(parentContainer, instance);\n        }\n      }\n    },\n    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentInstance, instance);\n        } else {\n          warnForDeletedHydratableText(parentInstance, instance);\n        }\n      }\n    },\n    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {\n      {\n        warnForInsertedHydratedElement(parentContainer, type, props);\n      }\n    },\n    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {\n      {\n        warnForInsertedHydratedText(parentContainer, text);\n      }\n    },\n    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedElement(parentInstance, type, props);\n      }\n    },\n    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedText(parentInstance, text);\n      }\n    }\n  },\n\n  scheduleDeferredCallback: rIC,\n  cancelDeferredCallback: cIC\n});\n\ninjection$3.injectRenderer(DOMRenderer);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    var warned = false;\n    var rootSibling = void 0;\n    while (rootSibling = container.lastChild) {\n      {\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n  // Legacy roots are not async by default.\n  var isAsync = false;\n  return new ReactRoot(container, isAsync, shouldHydrate);\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // TODO: Ensure all entry points contain this check\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    topLevelUpdateWarnings(container);\n  }\n\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  var root = container._reactRootContainer;\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = DOMRenderer.getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = DOMRenderer.getPublicRootInstance(root._internalRoot);\n        _originalCallback.call(instance);\n      };\n    }\n    // Update\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return DOMRenderer.getPublicRootInstance(root._internalRoot);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null && owner.stateNode !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        !warnedAboutRefsInRender ? warning(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component') : void 0;\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    return DOMRenderer.findHostInstance(componentOrElement);\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        !!renderedByDifferentReact ? warning(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.') : void 0;\n      }\n\n      // Unmount should not be batched.\n      DOMRenderer.unbatchedUpdates(function () {\n        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        !!hasNonRootReactChild ? warning(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: function () {\n    if (!didWarnAboutUnstableCreatePortal) {\n      didWarnAboutUnstableCreatePortal = true;\n      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the \"unstable_\" prefix.');\n    }\n    return createPortal.apply(undefined, arguments);\n  },\n\n\n  unstable_batchedUpdates: DOMRenderer.batchedUpdates,\n\n  unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n\n  flushSync: DOMRenderer.flushSync,\n\n  unstable_flushControlled: DOMRenderer.flushControlled,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry,\n    EventPropagators: EventPropagators,\n    ReactControlledComponent: ReactControlledComponent,\n    ReactDOMComponentTree: ReactDOMComponentTree,\n    ReactDOMEventListener: ReactDOMEventListener\n  }\n};\n\nReactDOM.unstable_createRoot = function createRoot(container, options) {\n  var hydrate = options != null && options.hydrate === true;\n  return new ReactRoot(container, true, hydrate);\n};\n\nvar foundDevTools = DOMRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/NjFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjMuMlxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcblxuLy8gUmVseWluZyBvbiB0aGUgYGludmFyaWFudCgpYCBpbXBsZW1lbnRhdGlvbiBsZXRzIHVzXG4vLyBoYXZlIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHRoaXMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIHRoaXMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIHRoaXMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICAhKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy4nKSA6IHZvaWQgMDtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuICAgICAgICAvLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbiAgICAgICAgLy8gbmVzdGVkIGNhbGwgd291bGQgdHJpZ2dlciB0aGUgZmFrZSBldmVudCBoYW5kbGVycyBvZiBhbnkgY2FsbCBoaWdoZXJcbiAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuICAgICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWNyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSBPYmplY3QuZnJlZXplKHtcblx0cGx1Z2luczogcGx1Z2lucyxcblx0ZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cdHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblx0cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcblx0cG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcblx0aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblx0aW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn0pO1xuXG52YXIgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IEluamVjdGVkLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7XG4gICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICAhKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSkgPyB3YXJuaW5nKGZhbHNlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cblxuXG5cblxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSB2b2lkIDA7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgIShpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4pID8gd2FybmluZyhmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudHNJbkJhdGNoKGV2ZW50cywgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudHMgIT09IG51bGwpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxuXG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnRzLCBmYWxzZSk7XG59XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbixcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRydW5FdmVudHNJbkJhdGNoOiBydW5FdmVudHNJbkJhdGNoLFxuXHRydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoOiBydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xudmFyIE1vZGUgPSAxMTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSAxMjtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSAxMztcbnZhciBGb3J3YXJkUmVmID0gMTQ7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlJDEoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIsIHRoaXMgd2lsbCBhbHdheXMgYmUgdGhlIGRlZXBlc3Qgcm9vdC5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUkMShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlJDEoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMkMShub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcblx0Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuXHRnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEsXG5cdGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSxcblx0Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuXHR1cGRhdGVGaWJlclByb3BzOiB1cGRhdGVGaWJlclByb3BzJDFcbn0pO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgIWluc3QgPyB3YXJuaW5nKGZhbHNlLCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSBPYmplY3QuZnJlZXplKHtcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuXHRhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzXG59KTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICovXG5TeW50aGV0aWNFdmVudC5leHRlbmQgPSBmdW5jdGlvbiAoSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIGZ1bmN0aW9uIENsYXNzKCkge1xuICAgIHJldHVybiBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG5cbiAgcmV0dXJuIENsYXNzO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIHZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nICYmXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTIwMTFcbiAgIU9iamVjdC5pc1NlYWxlZChuZXcgUHJveHkoe30sIHt9KSk7XG5cbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAhKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSkgPyB3YXJuaW5nKGZhbHNlLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvbiA/IHdhcm5pbmcoZmFsc2UsIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb29sZWRFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucG9wKCk7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgIShldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IpID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gZXZlbnQgaW5zdGFuY2UgIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG52YXIgU3ludGhldGljRXZlbnQkMSA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblN0YXJ0JywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblN0YXJ0JzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbnZhciBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZSA9IHZvaWQgMDtcbiAgdmFyIGZhbGxiYWNrRGF0YSA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZykge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBnZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RvcExldmVsVHlwZXN9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnMgPSB2b2lkIDA7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGNvbXBvc2l0aW9uID0gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgdmFyIGJlZm9yZUlucHV0ID0gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgaWYgKGNvbXBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmVmb3JlSW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZUlucHV0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjb21wb3NpdGlvbiwgYmVmb3JlSW5wdXRdO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDIgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQyLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRuZWVkc1N0YXRlUmVzdG9yZTogbmVlZHNTdGF0ZVJlc3RvcmUsXG5cdHJlc3RvcmVTdGF0ZUlmTmVlZGVkOiByZXN0b3JlU3RhdGVJZk5lZWRlZFxufSk7XG5cbi8vIFVzZWQgYXMgYSB3YXkgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcyB3aGVuIHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG9cbi8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuXG4vLyBEZWZhdWx0c1xudmFyIF9iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG52YXIgX2ludGVyYWN0aXZlVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSwgYikge1xuICByZXR1cm4gZm4oYSwgYik7XG59O1xudmFyIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaXNCYXRjaGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKSB7XG4gIGlmIChpc0JhdGNoaW5nKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuICBpc0JhdGNoaW5nID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gX2JhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzQmF0Y2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuICAgIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgICAgLy8gSWYgYSBjb250cm9sbGVkIGV2ZW50IHdhcyBmaXJlZCwgd2UgbWF5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RhdGUgb2ZcbiAgICAgIC8vIHRoZSBET00gbm9kZSBiYWNrIHRvIHRoZSBjb250cm9sbGVkIHZhbHVlLiBUaGlzIGlzIG5lY2Vzc2FyeSB3aGVuIFJlYWN0XG4gICAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgICBfZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMoKTtcbiAgICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYikge1xuICByZXR1cm4gX2ludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYik7XG59XG5cblxuXG52YXIgaW5qZWN0aW9uJDMgPSB7XG4gIGluamVjdFJlbmRlcmVyOiBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICBfYmF0Y2hlZFVwZGF0ZXMgPSByZW5kZXJlci5iYXRjaGVkVXBkYXRlcztcbiAgICBfaW50ZXJhY3RpdmVVcGRhdGVzID0gcmVuZGVyZXIuaW50ZXJhY3RpdmVVcGRhdGVzO1xuICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlcyA9IHJlbmRlcmVyLmZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzO1xuICB9XG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tlcihub2RlKSB7XG4gIHJldHVybiBub2RlLl92YWx1ZVRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGRldGFjaFRyYWNrZXIobm9kZSkge1xuICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlID0gJyc7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICB2YXIgY3VycmVudFZhbHVlID0gJycgKyBub2RlW3ZhbHVlRmllbGRdO1xuXG4gIC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcbiAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCkgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdENhbGwnO1xuICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UmV0dXJuJztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEsXG4gIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW06IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMVxufTtcblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwO1xuXG4vLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbnZhciBTVFJJTkcgPSAxO1xuXG4vLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7XG5cbi8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxudmFyIEJPT0xFQU4gPSAzO1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgTlVNRVJJQyA9IDU7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4vLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59KTtcblxuLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJyxcbi8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJyxcbi8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59KTtcblxuLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5bJ2NoZWNrZWQnLFxuLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblsnY2FwdHVyZScsICdkb3dubG9hZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIHdoaXRlbGlzdC5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3htbG5zOnhsaW5rJywgJ3gtaGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCBudWxsKTtcbn0pO1xuXG4vLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbn0pO1xuXG4vLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyk7XG59KTtcblxuLy8gU3BlY2lhbCBjYXNlOiB0aGlzIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBJdHMgXCJ0YWJpbmRleFwiIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gaXRzIFJlYWN0IGB0YWJJbmRleGAgbmFtZSwgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cbnByb3BlcnRpZXMudGFiSW5kZXggPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd0YWJJbmRleCcsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3RhYmluZGV4JywgLy8gYXR0cmlidXRlTmFtZVxubnVsbCk7XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcblxuICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG4gICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gbnVsbCA/IGV4cGVjdGVkIDogc3RyaW5nVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHZhbHVlID0gbnVsbDtcbiAgfVxuICAvLyBJZiB0aGUgcHJvcCBpc24ndCBpbiB0aGUgc3BlY2lhbCBsaXN0LCB0cmVhdCBpdCBhcyBhIHNpbXBsZSBhdHRyaWJ1dGUuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbXVzdFVzZVByb3BlcnR5ID0gcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eTtcblxuICBpZiAobXVzdFVzZVByb3BlcnR5KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHR5cGUgPT09IEJPT0xFQU4gPyBmYWxzZSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxuICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lLFxuICAgICAgYXR0cmlidXRlTmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3R5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IHZvaWQgMDtcbiAgICBpZiAoX3R5cGUgPT09IEJPT0xFQU4gfHwgX3R5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTiAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJpYnV0ZU5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IG51bGxcbn07XG5cbntcbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9LFxuICAgIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAgICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAgICovXG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBnZXRTdGFjaykge1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgdGFnTmFtZSwgZ2V0U3RhY2spO1xuICB9O1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFNhZmVWYWx1ZShwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICB2YXIgX2NvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBfY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhX2NvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gZ2V0U2FmZVZhbHVlKHByb3BzLnZhbHVlKTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wcy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCBnZXRTYWZlVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gIH1cblxuICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG4gICAgaWYgKG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIH1cblxuICAgIC8vIHZhbHVlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGRlZmF1bHRWYWx1ZS4gVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSB0aGVcbiAgICAvLyB2aXN1YWxseSBkaXNwbGF5ZWQgdmFsdWUgb2YgZGF0ZSBpbnB1dHMgZGlzYXBwZWFycyBvbiBtb2JpbGUgU2FmYXJpIGFuZCBDaHJvbWU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH1cblxuICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKFxuICAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgdmFsdWUpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2FmZVZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbCBhcmUgYXNzaWduZWQgYXMgZW1wdHkgc3RyaW5nc1xuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbnZhciBldmVudFR5cGVzJDEgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25DaGFuZ2UnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNoYW5nZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDaGFuZ2UnLCAndG9wQ2xpY2snLCAndG9wRm9jdXMnLCAndG9wSW5wdXQnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDEuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBydW5FdmVudHNJbkJhdGNoKGV2ZW50LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gdm9pZCAwLFxuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSB2b2lkIDA7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5leHRlbmQoe1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn0pO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn0pO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luID0gdm9pZCAwO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSB2b2lkIDA7XG4gICAgdmFyIHRvID0gdm9pZCAwO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8wO1xudmFyIFBlcmZvcm1lZFdvcmsgPSAvKiAgICAgICAgICovMTtcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gLyogICAgICAgICAgICAgKi8yO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSAvKiAgICAqLzY7XG52YXIgRGVsZXRpb24gPSAvKiAgICAgICAgICAgICAgKi84O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovMTY7XG52YXIgQ2FsbGJhY2sgPSAvKiAgICAgICAgICAgICAgKi8zMjtcbnZhciBEaWRDYXB0dXJlID0gLyogICAgICAgICAgICAqLzY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovMTI4O1xudmFyIEVyckxvZyA9IC8qICAgICAgICAgICAgICAgICovMjU2O1xudmFyIFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovMjA0ODtcblxuLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xudmFyIEhvc3RFZmZlY3RNYXNrID0gLyogICAgICAgICovMjU1OTtcblxudmFyIEluY29tcGxldGUgPSAvKiAgICAgICAgICAgICovNTEyO1xudmFyIFNob3VsZENhcHR1cmUgPSAvKiAgICAgICAgICovMTAyNDtcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcihlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKGVsZW1lbnQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZXh0ZW5kKHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZXh0ZW5kKHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZSA9IHZvaWQgMDtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IFN5bnRoZXRpY1VJRXZlbnQuZXh0ZW5kKHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5leHRlbmQoe1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZXh0ZW5kKHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcblxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn0pO1xuXG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICogaW50b1xuICogZXZlbnRUeXBlcyA9IHtcbiAqICAgJ2Fib3J0Jzoge1xuICogICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gKiAgICAgICBidWJibGVkOiAnb25BYm9ydCcsXG4gKiAgICAgICBjYXB0dXJlZDogJ29uQWJvcnRDYXB0dXJlJyxcbiAqICAgICB9LFxuICogICAgIGRlcGVuZGVuY2llczogWyd0b3BBYm9ydCddLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gKiAgICd0b3BBYm9ydCc6IHsgc2FtZUNvbmZpZyB9XG4gKiB9O1xuICovXG52YXIgaW50ZXJhY3RpdmVFdmVudFR5cGVOYW1lcyA9IFsnYmx1cicsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbW91c2VEb3duJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3NlZWtlZCcsICdzdWJtaXQnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVDaGFuZ2UnXTtcbnZhciBub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnZHJhZycsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3Njcm9sbCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaE1vdmUnLCAndHJhbnNpdGlvbkVuZCcsICd3YWl0aW5nJywgJ3doZWVsJ107XG5cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKGV2ZW50LCBpc0ludGVyYWN0aXZlKSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdLFxuICAgIGlzSW50ZXJhY3RpdmU6IGlzSW50ZXJhY3RpdmVcbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufVxuXG5pbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZU5hbWUpIHtcbiAgYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKGV2ZW50VHlwZU5hbWUsIHRydWUpO1xufSk7XG5ub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZU5hbWUpIHtcbiAgYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKGV2ZW50VHlwZU5hbWUsIGZhbHNlKTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZTogZnVuY3Rpb24gKHRvcExldmVsVHlwZSkge1xuICAgIHZhciBjb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICByZXR1cm4gY29uZmlnICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmlzSW50ZXJhY3RpdmUgPT09IHRydWU7XG4gIH0sXG5cblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrbm93bkhUTUxUb3BMZXZlbFR5cGVzLmluZGV4T2YodG9wTGV2ZWxUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuIFRoaXMgd2FybmluZyAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIHRvcExldmVsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufTtcblxudmFyIGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZSA9IFNpbXBsZUV2ZW50UGx1Z2luLmlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZTtcblxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcudGFyZ2V0SW5zdDtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGlmICghYW5jZXN0b3IpIHtcbiAgICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGZpbmRSb290Q29udGFpbmVyTm9kZShhbmNlc3Rvcik7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocm9vdCk7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuLyoqXG4gKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZGlzcGF0Y2ggPSBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUodG9wTGV2ZWxUeXBlKSA/IGRpc3BhdGNoSW50ZXJhY3RpdmVFdmVudCA6IGRpc3BhdGNoRXZlbnQ7XG5cbiAgYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaW50ZXJhY3RpdmVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKlxuICogRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIG9yIGF1ZGlvL3ZpZGVvIGV2ZW50cyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHlcbiAqIGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZ1xuICogYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IHtcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJyksXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JyksXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJyksXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCBvZiB0aGVtLiBOb3RlIHRoZXNlIGFyZW4ndCB0ZWNobmljYWxseVxuLy8gXCJ0b3AtbGV2ZWxcIiBzaW5jZSB0aGV5IGRvbid0IGJ1YmJsZS4gV2Ugc2hvdWxkIGNvbWUgdXBcbi8vIHdpdGggYSBiZXR0ZXIgbmFtaW5nIGNvbnZlbnRpb24gaWYgd2UgY29tZSB0byByZWZhY3RvcmluZ1xuLy8gdGhlIGV2ZW50IHN5c3RlbS5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQmx1ciA9IHRydWU7XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENhbmNlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENhbmNlbCcsICdjYW5jZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2xvc2UnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENsb3NlJywgJ2Nsb3NlJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGVzLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wTGV2ZWxUeXBlc1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJpb3JGb2N1c2VkRWxlbS5mb2N1cygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQxLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG4vLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG52YXIgTUFYX1NJR05FRF8zMV9CSVRfSU5UID0gMTA3Mzc0MTgyMztcblxuLy8gVE9ETzogVXNlIGFuIG9wYXF1ZSB0eXBlIG9uY2UgRVNMaW50IGV0IGFsIHN1cHBvcnQgdGhlIHN5bnRheFxuXG5cbnZhciBOb1dvcmsgPSAwO1xudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNNb2RlID0gMTtcbnZhciBTdHJpY3RNb2RlID0gMjtcblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gdm9pZCAwO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIHZhciB0ZXN0TWFwID0gbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgdmFyIHRlc3RTZXQgPSBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIFJvbGx1cCB0byBub3QgY29uc2lkZXIgdGhlc2UgdW51c2VkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNzcxXG4gICAgLy8gVE9ETzogd2UgY2FuIHJlbW92ZSB0aGVzZSBpZiBSb2xsdXAgZml4ZXMgdGhlIGJ1Zy5cbiAgICB0ZXN0TWFwLnNldCgwLCAwKTtcbiAgICB0ZXN0U2V0LmFkZCgwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG52YXIgZGVidWdDb3VudGVyID0gdm9pZCAwO1xuXG57XG4gIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIoaXNBc3luYykge1xuICB2YXIgbW9kZSA9IGlzQXN5bmMgPyBBc3luY01vZGUgfCBTdHJpY3RNb2RlIDogTm9Db250ZXh0O1xuICByZXR1cm4gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIG51bGwsIG1vZGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcblxuICB2YXIgZmliZXJUYWcgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyVGFnID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gQ2xhc3NDb21wb25lbnQgOiBJbmRldGVybWluYXRlQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IEFzeW5jTW9kZSB8IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gUmV0dXJuQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb25zdW1lclxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgYXNzdW1lZCB0byBiZSBhIGNvbnRpbnVhdGlvbiBhbmQgdGhlcmVmb3JlIGlzIGFcbiAgICAgICAgICAgICAgICAgIC8vIGZpYmVyIGFscmVhZHkuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGUgeWllbGQgc3lzdGVtIGlzIGN1cnJlbnRseSBicm9rZW4gZm9yIHVwZGF0ZXMgaW5cbiAgICAgICAgICAgICAgICAgIC8vIHNvbWUgY2FzZXMuIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgIC8vIGtub3cgd2hpY2ggZmliZXIgdGhhdCBpczsgdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz9cbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmUgd2UgZG9uJ3Qga25vdyBpZiB3ZVxuICAgICAgICAgICAgICAgICAgLy8gY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC4gVGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGEgY2xldmVyIHdheSB0byByZXN0cnVjdHVyZSB0aGlzLlxuICAgICAgICAgICAgICAgICAgZmliZXIgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3dPbkludmFsaWRFbGVtZW50VHlwZSh0eXBlLCBvd25lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd09uSW52YWxpZEVsZW1lbnRUeXBlKHR5cGUsIG93bmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLnR5cGUgPSB0eXBlO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRFbGVtZW50VHlwZSh0eXBlLCBvd25lcikge1xuICB2YXIgaW5mbyA9ICcnO1xuICB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICB9XG4gICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgZmliZXIudHlwZSA9ICdERUxFVEVEJztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbi8vIFVzZWQgZm9yIHN0YXNoaW5nIFdJUCBwcm9wZXJ0aWVzIHRvIHJlcGxheSBmYWlsZWQgd29yayBpbiBERVYuXG5mdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBGaWJlcidzIGluaXRpYWwgcHJvcGVydGllcyB3aWxsIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5cbiAgICAvLyBXZSBvbmx5IHVzZSBhIEZpYmVyIHRvIGVuc3VyZSB0aGUgc2FtZSBoaWRkZW4gY2xhc3Mgc28gREVWIGlzbid0IHNsb3cuXG4gICAgdGFyZ2V0ID0gY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIGFzIGEgbGlzdCBvZiBhbGwgcHJvcGVydGllcy5cbiAgLy8gV2UgdHJpZWQgdG8gdXNlIE9iamVjdC5hc3NpZ24oKSBpbnN0ZWFkIGJ1dCB0aGlzIGlzIGNhbGxlZCBpblxuICAvLyB0aGUgaG90dGVzdCBwYXRoLCBhbmQgT2JqZWN0LmFzc2lnbigpIHdhcyB0b28gc2xvdzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwMlxuICAvLyBUaGlzIGNvZGUgaXMgREVWLW9ubHkgc28gc2l6ZSBpcyBub3QgYSBjb25jZXJuLlxuXG4gIHRhcmdldC50YWcgPSBzb3VyY2UudGFnO1xuICB0YXJnZXQua2V5ID0gc291cmNlLmtleTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldFsncmV0dXJuJ10gPSBzb3VyY2VbJ3JldHVybiddO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5tb2RlID0gc291cmNlLm1vZGU7XG4gIHRhcmdldC5lZmZlY3RUYWcgPSBzb3VyY2UuZWZmZWN0VGFnO1xuICB0YXJnZXQubmV4dEVmZmVjdCA9IHNvdXJjZS5uZXh0RWZmZWN0O1xuICB0YXJnZXQuZmlyc3RFZmZlY3QgPSBzb3VyY2UuZmlyc3RFZmZlY3Q7XG4gIHRhcmdldC5sYXN0RWZmZWN0ID0gc291cmNlLmxhc3RFZmZlY3Q7XG4gIHRhcmdldC5leHBpcmF0aW9uVGltZSA9IHNvdXJjZS5leHBpcmF0aW9uVGltZTtcbiAgdGFyZ2V0LmFsdGVybmF0ZSA9IHNvdXJjZS5hbHRlcm5hdGU7XG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gc291cmNlLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBsaWZ0ZWQgaW50byB0aGUgcmVuZGVyZXIuXG5cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKGlzQXN5bmMpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0QmF0Y2g6IG51bGwsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fVxufTtcblxue1xuICB2YXIgTElGRUNZQ0xFX1NVR0dFU1RJT05TID0ge1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJyxcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogJ2NvbXBvbmVudERpZFVwZGF0ZSdcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cbiAgdmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlV2FybmluZ3NNYXAsIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB2YXIgbGlmZWN5Y2xlV2FybmluZ3MgPSBsaWZlY3ljbGVXYXJuaW5nc01hcFtsaWZlY3ljbGVdO1xuICAgICAgICBpZiAobGlmZWN5Y2xlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBsaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IGxpZmVjeWNsZS5yZXBsYWNlKCdVTlNBRkVfJywgJycpO1xuICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gTElGRUNZQ0xFX1NVR0dFU1RJT05TW2xpZmVjeWNsZV07XG4gICAgICAgICAgdmFyIHNvcnRlZENvbXBvbmVudE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50TmFtZXMpO1xuXG4gICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLnB1c2goZm9ybWF0dGVkICsgJzogUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgdG8gdXNlICcgKyAoc3VnZ2VzdGlvbiArICcgaW5zdGVhZDogJyArIHNvcnRlZENvbXBvbmVudE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoc3RyaWN0Um9vdCk7XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vuc2FmZSBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGZvdW5kIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWU6JXMnICsgJ1xcblxcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmpvaW4oJ1xcblxcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZ2V0U3RyaWN0Um9vdCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBtYXliZVN0cmljdFJvb3QgPSBudWxsO1xuXG4gICAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgbWF5YmVTdHJpY3RSb290ID0gZmliZXI7XG4gICAgICB9XG5cbiAgICAgIGZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVN0cmljdFJvb3Q7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxNb3VudCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2UgY29tcG9uZW50RGlkTW91bnQgaW5zdGVhZC4gQXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCwgJyArICd5b3UgY2FuIHJlbmFtZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50LicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgc29ydGVkTmFtZXMpO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhfdW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgaW5zdGVhZC4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9zb3J0ZWROYW1lcyk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzMiA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzMi5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhfdW5pcXVlTmFtZXMyKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdjb21wb25lbnRXaWxsVXBkYXRlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiAnICsgJ1VzZSBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4gQXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCwgJyArICd5b3UgY2FuIHJlbmFtZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZS4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9zb3J0ZWROYW1lczIpO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZERlcHJlY2F0aW9uV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGdldFN0cmljdFJvb3QoZmliZXIpO1xuXG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIC8vIFRoaXMgaXMgZGlmZmljdWx0IHRvIHRyYWNrIGFueSBvdGhlciB3YXkgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gICAgLy8gYXJlIG9mdGVuIHZhZ3VlIGFuZCBhcmUgbGlrZWx5IHRvIGNvbGxpZGUgYmV0d2VlbiAzcmQgcGFydHkgbGlicmFyaWVzLlxuICAgIC8vIEFuIGV4cGFuZCBwcm9wZXJ0eSBpcyBwcm9iYWJseSBva2F5IHRvIHVzZSBoZXJlIHNpbmNlIGl0J3MgREVWLW9ubHksXG4gICAgLy8gYW5kIHdpbGwgb25seSBiZSBzZXQgaW4gdGhlIGV2ZW50IG9mIHNlcmlvdXMgd2FybmluZ3MuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgLy8gTm90ZSB0aGF0IGl0IGlzIHN1ZmZpY2llbnQgdG8gY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhXG4gICAgLy8gc2luZ2xlIGxpZmVjeWNsZSwgY29tcG9uZW50V2lsbE1vdW50LCB3aXRoIHRoZSBwb2x5ZmlsbCBmbGFnLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHZvaWQgMDtcbiAgICBpZiAoIXBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5oYXMoc3RyaWN0Um9vdCkpIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBbXSxcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6IFtdXG4gICAgICB9O1xuXG4gICAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Muc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5nZXQoc3RyaWN0Um9vdCk7XG4gICAgfVxuXG4gICAgdmFyIHVuc2FmZUxpZmVjeWNsZXMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaCgnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgIH1cblxuICAgIGlmICh1bnNhZmVMaWZlY3ljbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdFtsaWZlY3ljbGVdLnB1c2goZmliZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChGYWJyaWMpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgZXJyb3ItYm91bmRhcnkgQVBJIHRoYXQgY2FuIHJlY292ZXIgZnJvbSBlcnJvcnMgd2l0aGluIGEgc2luZ2xlXG4vLyByZW5kZXIgcGhhc2VcbnZhciBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSBmYWxzZTtcbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBJbiBzb21lIGNhc2VzLCBTdHJpY3RNb2RlIHNob3VsZCBhbHNvIGRvdWJsZS1yZW5kZXIgbGlmZWN5Y2xlcy5cbi8vIFRoaXMgY2FuIGJlIGNvbmZ1c2luZyBmb3IgdGVzdHMgdGhvdWdoLFxuLy8gQW5kIGl0IGNhbiBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGlzIGZlYXR1cmUgZmxhZyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBiZWhhdmlvcjpcbnZhciBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlID0gdHJ1ZTtcblxuLy8gVG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgZGVidWdnZXIsIHdlXG4vLyByZXBsYXkgdGhlIGJlZ2luIHBoYXNlIG9mIGEgZmFpbGVkIGNvbXBvbmVudCBpbnNpZGUgaW52b2tlR3VhcmRlZENhbGxiYWNrLlxudmFyIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrID0gdHJ1ZTtcblxuLy8gV2FybiBhYm91dCBkZXByZWNhdGVkLCBhc3luYy11bnNhZmUgbGlmZWN5Y2xlczsgcmVsYXRlcyB0byBSRkMgIzY6XG52YXIgd2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMgPSBmYWxzZTtcblxudmFyIGFsd2F5c1VzZVJlcXVlc3RJZGxlQ2FsbGJhY2tQb2x5ZmlsbCA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4gd2lsbCBmb3JjZSBmbHVzaCBpbiAnICsgZXhwaXJhdGlvblRpbWUgKyAnIG1zKScsICcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgd2FybmluZyQkMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyQkMSA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyQkMSk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgdmFyIGxhYmVsID0gZGlkQ29tcGxldGVSb290ID8gJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBDb21wbGV0ZWQgUm9vdCknIDogJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBZaWVsZGVkKSc7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyayhsYWJlbCwgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG59XG5cbi8vIENhbGxiYWNrcyBhcmUgbm90IHZhbGlkYXRlZCB1bnRpbCBpbnZvY2F0aW9uXG5cblxuLy8gU2luZ2x5IGxpbmtlZC1saXN0IG9mIHVwZGF0ZXMuIFdoZW4gYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCwgaXQgaXMgYWRkZWQgdG9cbi8vIHRoZSBxdWV1ZSBvZiB0aGUgY3VycmVudCBmaWJlciBhbmQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoZSB0d28gcXVldWVzXG4vLyBhcmUgc2VwYXJhdGUgYnV0IHRoZXkgc2hhcmUgYSBwZXJzaXN0ZW50IHN0cnVjdHVyZS5cbi8vXG4vLyBEdXJpbmcgcmVjb25jaWxpYXRpb24sIHVwZGF0ZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlcixcbi8vIGJ1dCB0aGV5IHJlbWFpbiBvbiB0aGUgY3VycmVudCBmaWJlci4gVGhhdCBlbnN1cmVzIHRoYXQgaWYgYSB3b3JrLWluLXByb2dyZXNzXG4vLyBpcyBhYm9ydGVkLCB0aGUgYWJvcnRlZCB1cGRhdGVzIGFyZSByZWNvdmVyZWQgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYWx3YXlzIGEgc3Vic2V0IG9mIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIFdoZW4gdGhlIHRyZWUgaXMgY29tbWl0dGVkLCB0aGUgd29yay1pbi1wcm9ncmVzcyBiZWNvbWVzIHRoZSBjdXJyZW50LlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlKGJhc2VTdGF0ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgY2FwdHVyZWRWYWx1ZXM6IG51bGxcbiAgfTtcbiAge1xuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgaWYgKHF1ZXVlLmxhc3QgPT09IG51bGwpIHtcbiAgICAvLyBRdWV1ZSBpcyBlbXB0eVxuICAgIHF1ZXVlLmZpcnN0ID0gcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZS5sYXN0Lm5leHQgPSB1cGRhdGU7XG4gICAgcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfVxuICBpZiAocXVldWUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBxdWV1ZS5leHBpcmF0aW9uVGltZSA+IHVwZGF0ZS5leHBpcmF0aW9uVGltZSkge1xuICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICB9XG59XG5cbnZhciBxMSA9IHZvaWQgMDtcbnZhciBxMiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVuc3VyZVVwZGF0ZVF1ZXVlcyhmaWJlcikge1xuICBxMSA9IHEyID0gbnVsbDtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFVzZSBtb2R1bGUgdmFyaWFibGVzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgdHVwbGVcbiAgcTEgPSBxdWV1ZTE7XG4gIHEyID0gcXVldWUyO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICBlbnN1cmVVcGRhdGVRdWV1ZXMoZmliZXIpO1xuICB2YXIgcXVldWUxID0gcTE7XG4gIHZhciBxdWV1ZTIgPSBxMjtcblxuICAvLyBXYXJuIGlmIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlciBmdW5jdGlvbi5cbiAge1xuICAgIGlmICgocXVldWUxLmlzUHJvY2Vzc2luZyB8fCBxdWV1ZTIgIT09IG51bGwgJiYgcXVldWUyLmlzUHJvY2Vzc2luZykgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHF1ZXVlLCBhZGQgdGhlIHVwZGF0ZSB0byB0aGF0IHF1ZXVlIGFuZCBleGl0LlxuICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBlaXRoZXIgcXVldWUgaXMgZW1wdHksIHdlIG5lZWQgdG8gYWRkIHRvIGJvdGggcXVldWVzLlxuICBpZiAocXVldWUxLmxhc3QgPT09IG51bGwgfHwgcXVldWUyLmxhc3QgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTIsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgYm90aCBsaXN0cyBhcmUgbm90IGVtcHR5LCB0aGUgbGFzdCB1cGRhdGUgaXMgdGhlIHNhbWUgZm9yIGJvdGggbGlzdHNcbiAgLy8gYmVjYXVzZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuIFNvLCB3ZSBzaG91bGQgb25seSBhcHBlbmQgdG8gb25lIG9mXG4gIC8vIHRoZSBsaXN0cy5cbiAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgLy8gQnV0IHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBgbGFzdGAgcG9pbnRlciBvZiBxdWV1ZTIuXG4gIHF1ZXVlMi5sYXN0ID0gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZShmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBOb1dvcms7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlUXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOb1dvcms7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhcnRpYWxTdGF0ZS5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICBjYXB0dXJlZFZhbHVlczogY3VycmVudFF1ZXVlLmNhcHR1cmVkVmFsdWVzLFxuICAgICAgLy8gVGhlc2UgZmllbGRzIGFyZSBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB0aGV5IHdlcmUgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgICAvLyBSZXNldCB0aGVtLlxuICAgICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICAvLyBTZXQgdGhpcyBmbGFnIHNvIHdlIGNhbiB3YXJuIGlmIHNldFN0YXRlIGlzIGNhbGxlZCBpbnNpZGUgdGhlIHVwZGF0ZVxuICAgIC8vIGZ1bmN0aW9uIG9mIGFub3RoZXIgc2V0U3RhdGUuXG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLiBJZiB3ZSBza2lwIG92ZXIgYW55IHVwZGF0ZXMsIHdlJ2xsXG4gIC8vIGluY3JlYXNlIHRoaXMgYWNjb3JkaW5nbHkuXG4gIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRPRE86IFdlIGRvbid0IGtub3cgd2hhdCB0aGUgYmFzZSBzdGF0ZSB3aWxsIGJlIHVudGlsIHdlIGJlZ2luIHdvcmsuXG4gIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgLy8gaGFwcHkgd2l0aCB0aGlzIGFwcHJvYWNoLlxuICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gIGlmIChxdWV1ZS5pc0luaXRpYWxpemVkKSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHF1ZXVlLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIHZhciBkb250TXV0YXRlUHJldlN0YXRlID0gdHJ1ZTtcbiAgdmFyIHVwZGF0ZSA9IHF1ZXVlLmZpcnN0O1xuICB2YXIgZGlkU2tpcCA9IGZhbHNlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBxdWV1ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICAgIGRpZFNraXAgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiBubyBwcmV2aW91cyB1cGRhdGVzIHdlcmUgc2tpcHBlZCwgZHJvcCB0aGlzIHVwZGF0ZSBmcm9tIHRoZSBxdWV1ZSBieVxuICAgIC8vIGFkdmFuY2luZyB0aGUgaGVhZCBvZiB0aGUgbGlzdC5cbiAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgIHF1ZXVlLmZpcnN0ID0gdXBkYXRlLm5leHQ7XG4gICAgICBpZiAocXVldWUuZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgcXVldWUubGFzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIC8vIElnbm9yZSB0aGUgcmV0dXJuIHZhbHVlIGluIHRoaXMgY2FzZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYXB0dXJlZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NhcHR1cmVkVmFsdWVzID0gcXVldWUuY2FwdHVyZWRWYWx1ZXM7XG4gICAgICBpZiAoX2NhcHR1cmVkVmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmNhcHR1cmVkVmFsdWVzID0gW3VwZGF0ZS5jYXB0dXJlZFZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9jYXB0dXJlZFZhbHVlcy5wdXNoKHVwZGF0ZS5jYXB0dXJlZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSAmJiBxdWV1ZS5jYXB0dXJlZFZhbHVlcyA9PT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuXG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2FsbEdldERlcml2ZWRTdGF0ZUZyb21DYXRjaChjdG9yLCBjYXB0dXJlZFZhbHVlcykge1xuICB2YXIgcmVzdWx0U3RhdGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXB0dXJlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjYXB0dXJlZFZhbHVlID0gY2FwdHVyZWRWYWx1ZXNbaV07XG4gICAgdmFyIGVycm9yID0gY2FwdHVyZWRWYWx1ZS52YWx1ZTtcbiAgICB2YXIgcGFydGlhbFN0YXRlID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2guY2FsbChudWxsLCBlcnJvcik7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCAmJiBwYXJ0aWFsU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgX2Fzc2lnbihyZXN1bHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFN0YXRlO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKGxlZ2FjeUNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgdmFyIGNhY2hlQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuY2FjaGVDb250ZXh0LFxuICAgICAgZ2V0TWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0TWFza2VkQ29udGV4dCxcbiAgICAgIGdldFVubWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0VW5tYXNrZWRDb250ZXh0LFxuICAgICAgaXNDb250ZXh0Q29uc3VtZXIgPSBsZWdhY3lDb250ZXh0LmlzQ29udGV4dENvbnN1bWVyLFxuICAgICAgaGFzQ29udGV4dENoYW5nZWQgPSBsZWdhY3lDb250ZXh0Lmhhc0NvbnRleHRDaGFuZ2VkO1xuXG4gIC8vIENsYXNzIGNvbXBvbmVudCBzdGF0ZSB1cGRhdGVyXG5cbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmVkVmFsdWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmVkVmFsdWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICB7XG4gICAgICAgICEoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQpID8gd2FybmluZyhmYWxzZSwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA9ICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3RhbmNlLnN0YXRlO1xuICAgICAgIW5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPyB3YXJuaW5nKGZhbHNlLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAgICFub0dldERlZmF1bHRQcm9wc09uRVM2ID8gd2FybmluZyhmYWxzZSwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICAgIW5vSW5zdGFuY2VQcm9wVHlwZXMgPyB3YXJuaW5nKGZhbHNlLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZXM7XG4gICAgICAhbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA/IHdhcm5pbmcoZmFsc2UsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgICAhbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbic7XG4gICAgICAhbm9Db21wb25lbnREaWRVbm1vdW50ID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA/IHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vVW5zYWZlQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgICFub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAhKGluc3RhbmNlLnByb3BzID09PSB1bmRlZmluZWQgfHwgIWhhc011dGF0ZWRQcm9wcykgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgIW5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyh0eXBlKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgICFub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID8gd2FybmluZyhmYWxzZSwgJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCgpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHR5cGVvZiB0eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICAgIHZhciBfc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIGlmIChfc3RhdGUgJiYgKHR5cGVvZiBfc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoX3N0YXRlKSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgISh0eXBlb2YgdHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gd2FybmluZyhmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHwgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclczogRGlkIG5vdCBwcm9wZXJseSBpbml0aWFsaXplIHN0YXRlIGR1cmluZyBjb25zdHJ1Y3Rpb24uICcgKyAnRXhwZWN0ZWQgc3RhdGUgdG8gYmUgYW4gb2JqZWN0LCBidXQgaXQgd2FzICVzLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuXG4gICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBwcm9wcywgc3RhdGUpO1xuXG4gICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCAmJiBwYXJ0aWFsU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVuZGVyLXBoYXNlIHVwZGF0ZXMgKGxpa2UgdGhpcykgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgdXBkYXRlIHF1ZXVlLFxuICAgICAgLy8gU28gdGhhdCBtdWx0aXBsZSByZW5kZXIgcGFzc2VzIGRvIG5vdCBlbnF1ZXVlIG11bHRpcGxlIHVwZGF0ZXMuXG4gICAgICAvLyBJbnN0ZWFkLCBqdXN0IHN5bmNocm9ub3VzbHkgbWVyZ2UgdGhlIHJldHVybmVkIHN0YXRlIGludG8gdGhlIGluc3RhbmNlLlxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9hc3NpZ24oe30sIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIH1cblxuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIC8vIEludm9rZSBtZXRob2QgYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLmNhbGwobnVsbCwgbmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydGlhbFN0YXRlID0gdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuY2FsbChudWxsLCBuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnRpYWxTdGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZERlcHJlY2F0aW9uV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gICAgdmFyIG5ld1VubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAgIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gICAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpIHtcbiAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgdmFyIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IHZvaWQgMDtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKG51bGwsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsICYmIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCAmJiB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVkVmFsdWVzID0gdXBkYXRlUXVldWUuY2FwdHVyZWRWYWx1ZXM7XG4gICAgICAgIC8vIERvbid0IHJlbW92ZSB0aGVzZSBmcm9tIHRoZSB1cGRhdGUgcXVldWUgeWV0LiBXZSBuZWVkIHRoZW0gaW5cbiAgICAgICAgLy8gZmluaXNoQ2xhc3NDb21wb25lbnQuIERvIHRoZSByZXNldCB0aGVyZS5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhd2t3YXJkLiBSZWZhY3RvciBjbGFzcyBjb21wb25lbnRzLlxuICAgICAgICAvLyB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IG51bGw7XG4gICAgICAgIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2goY3RvciwgY2FwdHVyZWRWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIHZhciBkZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB2b2lkIDA7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgLy8gVGhlIHByZXZTdGF0ZSBwYXJhbWV0ZXIgc2hvdWxkIGJlIHRoZSBwYXJ0aWFsbHkgdXBkYXRlZCBzdGF0ZS5cbiAgICAgIC8vIE90aGVyd2lzZSwgc3ByZWFkaW5nIHN0YXRlIGluIHJldHVybiB2YWx1ZXMgY291bGQgb3ZlcnJpZGUgdXBkYXRlcy5cbiAgICAgIGRlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChkZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09IG51bGwgJiYgZGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFJlbmRlci1waGFzZSB1cGRhdGVzIChsaWtlIHRoaXMpIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIHVwZGF0ZSBxdWV1ZSxcbiAgICAgIC8vIFNvIHRoYXQgbXVsdGlwbGUgcmVuZGVyIHBhc3NlcyBkbyBub3QgZW5xdWV1ZSBtdWx0aXBsZSB1cGRhdGVzLlxuICAgICAgLy8gSW5zdGVhZCwganVzdCBzeW5jaHJvbm91c2x5IG1lcmdlIHRoZSByZXR1cm5lZCBzdGF0ZSBpbnRvIHRoZSBpbnN0YW5jZS5cbiAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUgPT09IG51bGwgfHwgbmV3U3RhdGUgPT09IHVuZGVmaW5lZCA/IGRlcml2ZWRTdGF0ZUZyb21Qcm9wcyA6IF9hc3NpZ24oe30sIG5ld1N0YXRlLCBkZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGJhc2Ugc3RhdGUgb2YgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICAgIC8vIEZJWE1FOiBUaGlzIGlzIGdldHRpbmcgcmlkaWN1bG91cy4gUmVmYWN0b3IgcGx6IVxuICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBfdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gX2Fzc2lnbih7fSwgX3VwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbVByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlcml2ZWRTdGF0ZUZyb21DYXRjaCAhPT0gbnVsbCAmJiBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVuZGVyLXBoYXNlIHVwZGF0ZXMgKGxpa2UgdGhpcykgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgdXBkYXRlIHF1ZXVlLFxuICAgICAgLy8gU28gdGhhdCBtdWx0aXBsZSByZW5kZXIgcGFzc2VzIGRvIG5vdCBlbnF1ZXVlIG11bHRpcGxlIHVwZGF0ZXMuXG4gICAgICAvLyBJbnN0ZWFkLCBqdXN0IHN5bmNocm9ub3VzbHkgbWVyZ2UgdGhlIHJldHVybmVkIHN0YXRlIGludG8gdGhlIGluc3RhbmNlLlxuICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZSA9PT0gbnVsbCB8fCBuZXdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gZGVyaXZlZFN0YXRlRnJvbUNhdGNoIDogX2Fzc2lnbih7fSwgbmV3U3RhdGUsIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgYmFzZSBzdGF0ZSBvZiB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgICAgLy8gRklYTUU6IFRoaXMgaXMgZ2V0dGluZyByaWRpY3Vsb3VzLiBSZWZhY3RvciBwbHohXG4gICAgICB2YXIgX3VwZGF0ZVF1ZXVlMiA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKF91cGRhdGVRdWV1ZTIgIT09IG51bGwpIHtcbiAgICAgICAgX3VwZGF0ZVF1ZXVlMi5iYXNlU3RhdGUgPSBfYXNzaWduKHt9LCBfdXBkYXRlUXVldWUyLmJhc2VTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbUNhdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcyk7XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gICAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkge1xuICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXh0IHN0YXRlIHVzaW5nIHRoZSBtZW1vaXplZCBzdGF0ZSBhbmQgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIC8vIFRPRE86IFByZXZpb3VzIHN0YXRlIGNhbiBiZSBudWxsLlxuICAgIHZhciBuZXdTdGF0ZSA9IHZvaWQgMDtcbiAgICB2YXIgZGVyaXZlZFN0YXRlRnJvbUNhdGNoID0gdm9pZCAwO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyAhPT0gbnVsbCAmJiBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggJiYgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYXB0dXJlZFZhbHVlcyA9IHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzO1xuICAgICAgICAvLyBEb24ndCByZW1vdmUgdGhlc2UgZnJvbSB0aGUgdXBkYXRlIHF1ZXVlIHlldC4gV2UgbmVlZCB0aGVtIGluXG4gICAgICAgIC8vIGZpbmlzaENsYXNzQ29tcG9uZW50LiBEbyB0aGUgcmVzZXQgdGhlcmUuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYXdrd2FyZC4gUmVmYWN0b3IgY2xhc3MgY29tcG9uZW50cy5cbiAgICAgICAgLy8gdXBkYXRlUXVldWUuY2FwdHVyZWRWYWx1ZXMgPSBudWxsO1xuICAgICAgICBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSBjYWxsR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoKGN0b3IsIGNhcHR1cmVkVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdm9pZCAwO1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIFRoZSBwcmV2U3RhdGUgcGFyYW1ldGVyIHNob3VsZCBiZSB0aGUgcGFydGlhbGx5IHVwZGF0ZWQgc3RhdGUuXG4gICAgICAvLyBPdGhlcndpc2UsIHNwcmVhZGluZyBzdGF0ZSBpbiByZXR1cm4gdmFsdWVzIGNvdWxkIG92ZXJyaWRlIHVwZGF0ZXMuXG4gICAgICBkZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjYWxsR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoZGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSBudWxsICYmIGRlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW5kZXItcGhhc2UgdXBkYXRlcyAobGlrZSB0aGlzKSBzaG91bGQgbm90IGJlIGFkZGVkIHRvIHRoZSB1cGRhdGUgcXVldWUsXG4gICAgICAvLyBTbyB0aGF0IG11bHRpcGxlIHJlbmRlciBwYXNzZXMgZG8gbm90IGVucXVldWUgbXVsdGlwbGUgdXBkYXRlcy5cbiAgICAgIC8vIEluc3RlYWQsIGp1c3Qgc3luY2hyb25vdXNseSBtZXJnZSB0aGUgcmV0dXJuZWQgc3RhdGUgaW50byB0aGUgaW5zdGFuY2UuXG4gICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlID09PSBudWxsIHx8IG5ld1N0YXRlID09PSB1bmRlZmluZWQgPyBkZXJpdmVkU3RhdGVGcm9tUHJvcHMgOiBfYXNzaWduKHt9LCBuZXdTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbVByb3BzKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBiYXNlIHN0YXRlIG9mIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgICAvLyBGSVhNRTogVGhpcyBpcyBnZXR0aW5nIHJpZGljdWxvdXMuIFJlZmFjdG9yIHBseiFcbiAgICAgIHZhciBfdXBkYXRlUXVldWUzID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAoX3VwZGF0ZVF1ZXVlMyAhPT0gbnVsbCkge1xuICAgICAgICBfdXBkYXRlUXVldWUzLmJhc2VTdGF0ZSA9IF9hc3NpZ24oe30sIF91cGRhdGVRdWV1ZTMuYmFzZVN0YXRlLCBkZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSBudWxsICYmIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW5kZXItcGhhc2UgdXBkYXRlcyAobGlrZSB0aGlzKSBzaG91bGQgbm90IGJlIGFkZGVkIHRvIHRoZSB1cGRhdGUgcXVldWUsXG4gICAgICAvLyBTbyB0aGF0IG11bHRpcGxlIHJlbmRlciBwYXNzZXMgZG8gbm90IGVucXVldWUgbXVsdGlwbGUgdXBkYXRlcy5cbiAgICAgIC8vIEluc3RlYWQsIGp1c3Qgc3luY2hyb25vdXNseSBtZXJnZSB0aGUgcmV0dXJuZWQgc3RhdGUgaW50byB0aGUgaW5zdGFuY2UuXG4gICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlID09PSBudWxsIHx8IG5ld1N0YXRlID09PSB1bmRlZmluZWQgPyBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggOiBfYXNzaWduKHt9LCBuZXdTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbUNhdGNoKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBiYXNlIHN0YXRlIG9mIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgICAvLyBGSVhNRTogVGhpcyBpcyBnZXR0aW5nIHJpZGljdWxvdXMuIFJlZmFjdG9yIHBseiFcbiAgICAgIHZhciBfdXBkYXRlUXVldWU0ID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAoX3VwZGF0ZVF1ZXVlNCAhPT0gbnVsbCkge1xuICAgICAgICBfdXBkYXRlUXVldWU0LmJhc2VTdGF0ZSA9IF9hc3NpZ24oe30sIF91cGRhdGVRdWV1ZTQuYmFzZVN0YXRlLCBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcyk7XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gICAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlOiBhZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgY2FsbEdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogY2FsbEdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZTogcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHZvaWQgMDtcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0ge307XG5cbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBzdHJpbmcgcmVmLCBcIiVzXCIswqBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArICdcXG4lcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYsIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIocmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZy4nKSA6IHZvaWQgMDtcbiAgICAgICFlbGVtZW50Ll9vd25lciA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKCVzKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbjIuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgIHtcbiAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpIHx8ICcnKTtcbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBuZXdDaGlsZCwgYWRkZW5kdW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZSgpIHtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSB8fCAnJyk7XG5cbiAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIHdhcm5pbmcoZmFsc2UsICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpIHx8ICcnKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkMlsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQzWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiVzJywga2V5LCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aHMgZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cblxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cblxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKCFfbmV3RmliZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjIpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHtcbiAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBvc3NpYmxlTWFwID0gbmV3Q2hpbGRyZW5JdGVyYWJsZTtcbiAgICAgICAgaWYgKHBvc3NpYmxlTWFwLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICAhZGlkV2FybkFib3V0TWFwcyA/IHdhcm5pbmcoZmFsc2UsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG4gICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7XG59XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcih0cnVlKTtcbnZhciBtb3VudENoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKGZhbHNlKTtcblxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAhKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gICAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyA9IHt9O1xufVxuXG52YXIgUmVhY3RGaWJlckJlZ2luV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSA9IGNvbmZpZy5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlO1xuICB2YXIgcHVzaEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250ZXh0LFxuICAgICAgcHVzaEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRhaW5lcjtcbiAgdmFyIHB1c2hQcm92aWRlciA9IG5ld0NvbnRleHQucHVzaFByb3ZpZGVyO1xuICB2YXIgZ2V0TWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0TWFza2VkQ29udGV4dCxcbiAgICAgIGdldFVubWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0VW5tYXNrZWRDb250ZXh0LFxuICAgICAgaGFzTGVnYWN5Q29udGV4dENoYW5nZWQgPSBsZWdhY3lDb250ZXh0Lmhhc0NvbnRleHRDaGFuZ2VkLFxuICAgICAgcHVzaExlZ2FjeUNvbnRleHRQcm92aWRlciA9IGxlZ2FjeUNvbnRleHQucHVzaENvbnRleHRQcm92aWRlcixcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QgPSBsZWdhY3lDb250ZXh0LnB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QsXG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyID0gbGVnYWN5Q29udGV4dC5pbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyO1xuICB2YXIgZW50ZXJIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQuZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ2xhc3NDb21wbyA9IFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudChsZWdhY3lDb250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSxcbiAgICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5hZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgICBjYWxsR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgICBtb3VudENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8ubW91bnRDbGFzc0luc3RhbmNlLFxuICAgICAgcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgdXNlIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBkaXJlY3RseS5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVuZGVyID0gd29ya0luUHJvZ3Jlc3MudHlwZS5yZW5kZXI7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHJlbmRlcih3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHdvcmtJblByb2dyZXNzLnJlZik7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gV2UgcHJvY2Vzc2VkIHRoZSB1cGRhdGUgcXVldWUgaW5zaWRlIHVwZGF0ZUNsYXNzSW5zdGFuY2UuIEl0IG1heSBoYXZlXG4gICAgLy8gaW5jbHVkZWQgc29tZSBlcnJvcnMgdGhhdCB3ZXJlIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuXG4gICAgLy8gVE9ETzogUmVmYWN0b3IgY2xhc3MgY29tcG9uZW50cyBzbyB0aGlzIGlzIGxlc3MgYXdrd2FyZC5cbiAgICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgZGlkQ2FwdHVyZUVycm9yID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIGRpZENhcHR1cmVFcnJvciwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgZGlkQ2FwdHVyZUVycm9yLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAvLyBSZXJlbmRlclxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICAgIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgKCFlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tIGNhdGNoIGlzIG5vdCBkZWZpbmVkLFxuICAgICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gICAgaWYgKGRpZENhcHR1cmVFcnJvcikge1xuICAgICAgLy8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgdHdpY2U6IGZpcnN0IHRvIGRlbGV0ZVxuICAgICAgLy8gYWxsIHRoZSBleGlzdGluZyBjaGlsZHJlbi5cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgLy8gTm93IHdlIGNhbiBjb250aW51ZSByZWNvbmNpbGluZyBsaWtlIG5vcm1hbC4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gICAgICAvLyBpZGVudGl0eSBtYXRjaGVzLlxuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBzdGF0ZSk7XG4gICAgICB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSdzIGFuIHVuY2F1Z2h0IGVycm9yLiBVbm1vdW50IHRoZSB3aG9sZSByb290LlxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgdGhlIHNhbWUgYXMgYmVmb3JlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2Ugd2UgaGFkXG4gICAgICAgIC8vIG5vIHdvcmsgdGhhdCBleHBpcmVzIGF0IHRoaXMgdGltZS5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgaXNIaWRkZW4gPSB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQXN5bmNNb2RlICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKTtcbiAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAvLyBCZWZvcmUgYmFpbGluZyBvdXQsIG1ha2Ugc3VyZSB3ZSd2ZSBkZXByaW9yaXRpemVkIGEgaGlkZGVuIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNIaWRkZW4gfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3JlIHJlbmRlcmluZyBhIGhpZGRlbiBub2RlIGF0IGhpZGRlbiBwcmlvcml0eSwgZG9uJ3QgYmFpbG91dC4gVGhlXG4gICAgICAvLyBwYXJlbnQgaXMgY29tcGxldGUsIGJ1dCB0aGUgY2hpbGRyZW4gbWF5IG5vdCBiZS5cbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIEFzeW5jTW9kZSAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAgIC8vIERvd24tcHJpb3JpdGl6ZSB0aGUgY2hpbGRyZW4uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgICAgLy8gQmFpbG91dCBhbmQgY29tZSBiYWNrIHRvIHRoaXMgZmliZXIgbGF0ZXIuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIHZhbHVlLCBwcm9wcywgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSk7XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCAmJiBwYXJ0aWFsU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfYXNzaWduKHt9LCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hMZWdhY3lDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCwgZmFsc2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChfQ29tcG9uZW50KSB7XG4gICAgICAgICAgISFfQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgX0NvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBfQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICAgIHZhciBvd25lck5hbWUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG4gICAgICAgICAgaWYgKGRlYnVnU291cmNlKSB7XG4gICAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZuLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBTdGF0ZWxlc3MgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnRbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0xlZ2FjeUNvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNMZWdhY3lDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgZmliZXJbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5leHRGaWJlciA9IHZvaWQgMDtcbiAgICAgIC8vIFZpc2l0IHRoaXMgZmliZXIuXG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBmaWJlci5zdGF0ZU5vZGUgfCAwO1xuICAgICAgICAgIGlmIChmaWJlci50eXBlID09PSBjb250ZXh0ICYmIChvYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDApIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXhwaXJhdGlvbiB0aW1lIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmdcbiAgICAgICAgICAgIC8vIHRoZSBhbHRlcm5hdGVzLlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIChhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIGFsdGVybmF0ZSB3YXMgdXBkYXRlZCwgd2hpY2ggbWVhbnMgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIHRoYW4gYSBtYXRjaGluZyBjb25zdW1lci4gV2hlbiB3ZSByZW5kZXIgdGhlXG4gICAgICAgICAgICAvLyBjb25zdW1lciwgd2UnbGwgY29udGludWUgc2Nhbm5pbmcgZnJvbSB0aGF0IHBvaW50LiBUaGlzIHdheSB0aGVcbiAgICAgICAgICAgIC8vIHNjYW5uaW5nIHdvcmsgaXMgdGltZS1zbGljZWQuXG4gICAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICBuZXh0RmliZXJbJ3JldHVybiddID0gZmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXJbJ3JldHVybiddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIHByb3ZpZGVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChoYXNMZWdhY3lDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcblxuICAgIHZhciBjaGFuZ2VkQml0cyA9IHZvaWQgMDtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgIC8vIEluaXRpYWwgcmVuZGVyXG4gICAgICBjaGFuZ2VkQml0cyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9sZFByb3BzLnZhbHVlID09PSBuZXdQcm9wcy52YWx1ZSkge1xuICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gMDtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICAgICAgLy8gVXNlIE9iamVjdC5pcyB0byBjb21wYXJlIHRoZSBuZXcgY29udGV4dCB2YWx1ZSB0byB0aGUgb2xkIHZhbHVlLlxuICAgICAgICAvLyBJbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUgJiYgKG9sZFZhbHVlICE9PSAwIHx8IDEgLyBvbGRWYWx1ZSA9PT0gMSAvIG5ld1ZhbHVlKSB8fCBvbGRWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgIT09IG5ld1ZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gMDtcbiAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlZEJpdHMgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgICEoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMpID8gd2FybmluZyhmYWxzZSwgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYW5nZWRCaXRzIHw9IDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZEJpdHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjaGFuZ2VkQml0cztcbiAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNvbnRleHQuX2NoYW5nZWRCaXRzO1xuXG4gICAgaWYgKGhhc0xlZ2FjeUNvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKGNoYW5nZWRCaXRzID09PSAwICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gbmV3UHJvcHMudW5zdGFibGVfb2JzZXJ2ZWRCaXRzO1xuICAgIGlmIChvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwpIHtcbiAgICAgIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBieSBkZWZhdWx0XG4gICAgICBvYnNlcnZlZEJpdHMgPSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgfVxuICAgIC8vIFN0b3JlIHRoZSBvYnNlcnZlZEJpdHMgb24gdGhlIGZpYmVyJ3Mgc3RhdGVOb2RlIGZvciBxdWljayBhY2Nlc3MuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gb2JzZXJ2ZWRCaXRzO1xuXG4gICAgaWYgKChjaGFuZ2VkQml0cyAmIG9ic2VydmVkQml0cykgIT09IDApIHtcbiAgICAgIC8vIENvbnRleHQgY2hhbmdlIHByb3BhZ2F0aW9uIHN0b3BzIGF0IG1hdGNoaW5nIGNvbnN1bWVycywgZm9yIHRpbWUtXG4gICAgICAvLyBzbGljaW5nLiBDb250aW51ZSB0aGUgcHJvcGFnYXRpb24gaGVyZS5cbiAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIGNoYW5nZWRCaXRzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIFNraXAgb3ZlciBhIG1lbW9pemVkIHBhcmVudCB3aXRoIGEgYml0bWFzayBiYWlsb3V0IGV2ZW5cbiAgICAgIC8vIGlmIHdlIGJlZ2FuIHdvcmtpbmcgb24gaXQgYmVjYXVzZSBvZiBhIGRlZXBlciBtYXRjaGluZyBjaGlsZC5cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgLy8gVGhlcmUgaXMgbm8gYmFpbG91dCBvbiBgY2hpbGRyZW5gIGVxdWFsaXR5IGJlY2F1c2Ugd2UgZXhwZWN0IHBlb3BsZVxuICAgIC8vIHRvIG9mdGVuIHBhc3MgYSBib3VuZCBtZXRob2QgYXMgYSBjaGlsZCwgYnV0IGl0IG1heSByZWZlcmVuY2VcbiAgICAvLyBgdGhpcy5zdGF0ZWAgb3IgYHRoaXMucHJvcHNgIChhbmQgdGh1cyBuZWVkcyB0byByZS1yZW5kZXIgb24gYHNldFN0YXRlYCkuXG5cbiAgICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAgICB7XG4gICAgICAhKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIC8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuICBmdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBpZGVhbGx5IGJlIGFibGUgdG8gYmFpbCBvdXQgZWFybHkgaWYgdGhlIGNoaWxkcmVuIGhhdmUgbm9cbiAgICAvLyBtb3JlIHdvcmsgdG8gZG8uIEhvd2V2ZXIsIHNpbmNlIHdlIGRvbid0IGhhdmUgYSBzZXBhcmF0aW9uIG9mIHRoaXNcbiAgICAvLyBGaWJlcidzIHByaW9yaXR5IGFuZCBpdHMgY2hpbGRyZW4geWV0IC0gd2UgZG9uJ3Qga25vdyB3aXRob3V0IGRvaW5nIGxvdHNcbiAgICAvLyBvZiB0aGUgc2FtZSB3b3JrIHdlIGRvIGFueXdheS4gT25jZSB3ZSBoYXZlIHRoYXQgc2VwYXJhdGlvbiB3ZSBjYW4ganVzdFxuICAgIC8vIGJhaWwgb3V0IGhlcmUgaWYgdGhlIGNoaWxkcmVuIGhhcyBubyBtb3JlIHdvcmsgYXQgdGhpcyBwcmlvcml0eSBsZXZlbC5cbiAgICAvLyBpZiAod29ya0luUHJvZ3Jlc3MucHJpb3JpdHlPZkNoaWxkcmVuIDw9IHByaW9yaXR5TGV2ZWwpIHtcbiAgICAvLyAgIC8vIElmIHRoZXJlIGFyZSBzaWRlLWVmZmVjdHMgaW4gdGhlc2UgY2hpbGRyZW4gdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgIC8vICAgLy8gY29tbWl0dGVkIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhleSBnZXQgcHJvcGVybHkgdHJhbnNmZXJyZWQgdXAuXG4gICAgLy8gICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmNoaWxkICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgIC8vICAgICByZXVzZUNoaWxkcmVuRWZmZWN0cyh3b3JrSW5Qcm9ncmVzcywgY2hpbGQpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgLy8gfVxuXG4gICAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIEhvc3RDb21wb25lbnQgdGFncyBoZXJlIGFzIHdlbGwgYW5kIGNhbGwgcHVzaEhvc3RDb250ZXh0KCk/XG4gICAgLy8gU2VlIFBSIDg1OTAgZGlzY3Vzc2lvbiBmb3IgY29udGV4dFxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBUT0RPOiBXaGF0IGlmIHRoaXMgaXMgY3VycmVudGx5IGluIHByb2dyZXNzP1xuICAgIC8vIEhvdyBjYW4gdGhhdCBoYXBwZW4/IEhvdyBpcyB0aGlzIG5vdCBiZWluZyBjbG9uZWQ/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbiAgZnVuY3Rpb24gbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuICAgIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgICAvLyBpcyBoYW5kbGVkIGJ5IHByb2Nlc3NVcGRhdGVRdWV1ZS5cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFRoaXMgaXMgYSByZXN0YXJ0LiBSZXNldCB0aGUgdGFnIHRvIHRoZSBpbml0aWFsIHBoYXNlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggc2luY2UgdGhpcyBpcyBub3cgdGhlIHNhbWUuXG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gQSByZXR1cm4gY29tcG9uZW50IGlzIGp1c3QgYSBwbGFjZWhvbGRlciwgd2UgY2FuIGp1c3QgcnVuIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIG5leHQgb25lIGltbWVkaWF0ZWx5LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBNb2RlOlxuICAgICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gdW5pdCBvZiB3b3JrIHRhZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwb3BMZWdhY3lDb250ZXh0UHJvdmlkZXIgPSBsZWdhY3lDb250ZXh0LnBvcENvbnRleHRQcm92aWRlcixcbiAgICAgIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCA9IGxlZ2FjeUNvbnRleHQucG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0O1xuICB2YXIgcG9wUHJvdmlkZXIgPSBuZXdDb250ZXh0LnBvcFByb3ZpZGVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUucGVuZGluZ1Byb3BzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVDYWxsVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhcHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gcHJvcHMuaGFuZGxlcjtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IHByb3BzLnByb3BzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBmbihjaGlsZFByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIHRoZW4gbm9uZSBvZiBvdXIgY2hpbGRyZW4gaGFkIGFueSB1cGRhdGVzLlxuICAgICAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVjeWNsYWJsZUluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoY3VycmVudEluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHdvcmtJblByb2dyZXNzLCBjaGlsZHJlblVuY2hhbmdlZCwgcmVjeWNsYWJsZUluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGNhdWdodCBhbiBlcnJvciwgc2NoZWR1bGUgYW4gZXJyb3IgbG9nIGVmZmVjdC5cbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gfkRpZENhcHR1cmU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBFcnJMb2c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3JtYWxseSB3ZSBjbGVhciB0aGlzIGluIHRoZSBjb21taXQgcGhhc2UsIGJ1dCBzaW5jZSB3ZSBkaWQgbm90XG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlIGFuIGVmZmVjdCwgd2UgbmVlZCB0byByZXNldCBpdCBoZXJlLlxuICAgICAgICAgICAgICB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwgJiYgX3VwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyTG9nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3RcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4gICAgICAgICAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKF9pbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oX2luc3RhbmNlMiwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UyLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dDIsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdmVDYWxsVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRhZyB0byBub3cgYmUgYSBmaXJzdCBwaGFzZSBjYWxsLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBEb2VzIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBNb2RlOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzb3VyY2UpXG4gIH07XG59XG5cbnZhciBSZWFjdEZpYmVyVW53aW5kV29yayA9IGZ1bmN0aW9uIChob3N0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgbmV3Q29udGV4dCwgc2NoZWR1bGVXb3JrLCBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KSB7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQ7XG4gIHZhciBwb3BMZWdhY3lDb250ZXh0UHJvdmlkZXIgPSBsZWdhY3lDb250ZXh0LnBvcENvbnRleHRQcm92aWRlcixcbiAgICAgIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCA9IGxlZ2FjeUNvbnRleHQucG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0O1xuICB2YXIgcG9wUHJvdmlkZXIgPSBuZXdDb250ZXh0LnBvcFByb3ZpZGVyO1xuXG5cbiAgZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByYXdWYWx1ZSkge1xuICAgIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgICBzb3VyY2VGaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgICAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICB2YXIgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHJhd1ZhbHVlLCBzb3VyY2VGaWJlcik7XG5cbiAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFVuY2F1Z2h0IGVycm9yXG4gICAgICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgICBlbnN1cmVVcGRhdGVRdWV1ZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IFtlcnJvckluZm9dO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgX2luc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoX2luc3RhbmNlKSkpIHtcbiAgICAgICAgICAgIGVuc3VyZVVwZGF0ZVF1ZXVlcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZWRWYWx1ZXMgPSBfdXBkYXRlUXVldWUuY2FwdHVyZWRWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZWRWYWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3VwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgfSB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAgIGlmIChlZmZlY3RUYWcgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgX2VmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgICBpZiAoX2VmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IF9lZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gICAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGhyb3dFeGNlcHRpb246IHRocm93RXhjZXB0aW9uLFxuICAgIHVud2luZFdvcms6IHVud2luZFdvcmssXG4gICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrOiB1bndpbmRJbnRlcnJ1cHRlZFdvcmtcbiAgfTtcbn07XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcikge1xuICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGVycm9yICYmIGVycm9yLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gIGlmIChzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQzID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gIGlmIChzdGFjayA9PT0gbnVsbCkge1xuICAgIHN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UpIDogbnVsbCxcbiAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnLFxuICAgIGVycm9yOiBlcnJvckluZm8udmFsdWUsXG4gICAgZXJyb3JCb3VuZGFyeTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5TmFtZTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGZhbHNlLFxuICAgIHdpbGxSZXRyeTogZmFsc2VcbiAgfTtcblxuICBpZiAoYm91bmRhcnkgIT09IG51bGwgJiYgYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeSA9IGJvdW5kYXJ5LnN0YXRlTm9kZTtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeSk7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgIGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGUgJiYgZS5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSkge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQzKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgICBjYXB0dXJlRXJyb3IoY3VycmVudCwgcmVmRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY3VycmVudFRpbWUsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgICAgICAgX2luc3RhbmNlMi5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfaW5zdGFuY2UyLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIF9pbnN0YW5jZTIuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgICAgICAgX2luc3RhbmNlMi5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfaW5zdGFuY2UyLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIF9pbnN0YW5jZTIuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBfaW5zdGFuY2UyLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZTMgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UzID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlNCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2U0LCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9yTG9nZ2luZyhmaW5pc2hlZFdvcmssIG9uVW5jYXVnaHRFcnJvcikge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjdG9yID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAhKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGVycm9yIGxvZ2dpbmcgZWZmZWN0IHNob3VsZCBub3QgaGF2ZSBiZWVuIHNjaGVkdWxlZCBpZiBubyBlcnJvcnMgd2VyZSBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgY2FwdHVyZWRFcnJvcnMgPSB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcztcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIGlzXG4gICAgICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoX2luc3RhbmNlNSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2luc3RhbmNlNS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZTUuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhcHR1cmVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JJbmZvID0gY2FwdHVyZWRFcnJvcnNbaV07XG4gICAgICAgICAgICB2YXIgX2Vycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgICAgICAgbG9nRXJyb3IoZmluaXNoZWRXb3JrLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgX2luc3RhbmNlNS5jb21wb25lbnREaWRDYXRjaChfZXJyb3IsIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdXBkYXRlUXVldWUyID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICEoX3VwZGF0ZVF1ZXVlMiAhPT0gbnVsbCAmJiBfdXBkYXRlUXVldWUyLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGVycm9yIGxvZ2dpbmcgZWZmZWN0IHNob3VsZCBub3QgaGF2ZSBiZWVuIHNjaGVkdWxlZCBpZiBubyBlcnJvcnMgd2VyZSBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgX2NhcHR1cmVkRXJyb3JzID0gX3VwZGF0ZVF1ZXVlMi5jYXB0dXJlZFZhbHVlcztcbiAgICAgICAgICBfdXBkYXRlUXVldWUyLmNhcHR1cmVkVmFsdWVzID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2NhcHR1cmVkRXJyb3JzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9lcnJvckluZm8gPSBfY2FwdHVyZWRFcnJvcnNbX2ldO1xuICAgICAgICAgICAgbG9nRXJyb3IoZmluaXNoZWRXb3JrLCBfZXJyb3JJbmZvKTtcbiAgICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcihfZXJyb3JJbmZvLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBjYW5ub3QgY2FwdHVyZSBlcnJvcnMuICBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2luc3RhbmNlNiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICB2YXIgaW5zdGFuY2VUb1VzZSA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKF9pbnN0YW5jZTYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBfaW5zdGFuY2U2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLiVzJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmspLCBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbiAgLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbiAgLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbiAgZnVuY3Rpb24gY29tbWl0VW5tb3VudChjdXJyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHZhciBfaW5zdGFuY2U3ID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfaW5zdGFuY2U3LmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgX2luc3RhbmNlNyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudC5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyICYmIG11dGF0aW9uKSB7XG4gICAgICAgICAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciAmJiBwZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKHJvb3QpIHtcbiAgICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAgIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsICYmIChcbiAgICAgIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgICAgLy8gSWYgd2UgZG9uJ3QgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIGhlcmUgaW5zdGVhZC5cbiAgICAgICFtdXRhdGlvbiB8fCBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gcm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaEZpYmVyKGN1cnJlbnQpIHtcbiAgICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAgIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAgIC8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbiAgICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAgIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gICAgY3VycmVudFsncmV0dXJuJ10gPSBudWxsO1xuICAgIGN1cnJlbnQuY2hpbGQgPSBudWxsO1xuICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSkge1xuICAgICAgY3VycmVudC5hbHRlcm5hdGUuY2hpbGQgPSBudWxsO1xuICAgICAgY3VycmVudC5hbHRlcm5hdGVbJ3JldHVybiddID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSB2b2lkIDA7XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBlbXB0eUNoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVySW5mbyk7XG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbiAgICAgIH07XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIHx8IGVuYWJsZU5vb3BSZWNvbmNpbGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7fSxcbiAgICAgICAgY29tbWl0UGxhY2VtZW50OiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7fSxcbiAgICAgICAgY29tbWl0RGVsZXRpb246IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50KTtcbiAgICAgICAgICBkZXRhY2hGaWJlcihjdXJyZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWl0V29yazogZnVuY3Rpb24gKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIGNvbW1pdENvbnRhaW5lcihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlczogY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRFcnJvckxvZ2dpbmc6IGNvbW1pdEVycm9yTG9nZ2luZyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2U4ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoX2luc3RhbmNlOCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKF9pbnN0YW5jZTgsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlczogY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRFcnJvckxvZ2dpbmc6IGNvbW1pdEVycm9yTG9nZ2luZyxcbiAgICAgIGNvbW1pdEF0dGFjaFJlZjogY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gIH1cbn07XG5cbnZhciBOT19DT05URVhUID0ge307XG5cbnZhciBSZWFjdEZpYmVySG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY29uZmlnLCBzdGFjaykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcbiAgdmFyIGNyZWF0ZUN1cnNvciA9IHN0YWNrLmNyZWF0ZUN1cnNvcixcbiAgICAgIHB1c2ggPSBzdGFjay5wdXNoLFxuICAgICAgcG9wID0gc3RhY2sucG9wO1xuXG5cbiAgdmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgICAhKGMgIT09IE5PX0NPTlRFWFQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICByZXR1cm4gcm9vdEluc3RhbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG5cbiAgICAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gICAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAgIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHRocm93LCByZXBsYWNlIGl0LlxuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dFxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHZvaWQgMDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIFJlYWN0RmliZXJMZWdhY3lDb250ZXh0ID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBjcmVhdGVDdXJzb3IgPSBzdGFjay5jcmVhdGVDdXJzb3IsXG4gICAgICBwdXNoID0gc3RhY2sucHVzaCxcbiAgICAgIHBvcCA9IHN0YWNrLnBvcDtcblxuICAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuICAvLyBBIGN1cnNvciB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICB2YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4gIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbiAgLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4gIC8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG4gIHZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuICBmdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gICAgfVxuICAgIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICAgIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgICB9XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsXG4gICAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0pO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gICAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICAgIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAgIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAgICEoaXNGaWJlck1vdW50ZWQoZmliZXIpICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldFVubWFza2VkQ29udGV4dDogZ2V0VW5tYXNrZWRDb250ZXh0LFxuICAgIGNhY2hlQ29udGV4dDogY2FjaGVDb250ZXh0LFxuICAgIGdldE1hc2tlZENvbnRleHQ6IGdldE1hc2tlZENvbnRleHQsXG4gICAgaGFzQ29udGV4dENoYW5nZWQ6IGhhc0NvbnRleHRDaGFuZ2VkLFxuICAgIGlzQ29udGV4dENvbnN1bWVyOiBpc0NvbnRleHRDb25zdW1lcixcbiAgICBpc0NvbnRleHRQcm92aWRlcjogaXNDb250ZXh0UHJvdmlkZXIsXG4gICAgcG9wQ29udGV4dFByb3ZpZGVyOiBwb3BDb250ZXh0UHJvdmlkZXIsXG4gICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0OiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QsXG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdDogcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCxcbiAgICBwcm9jZXNzQ2hpbGRDb250ZXh0OiBwcm9jZXNzQ2hpbGRDb250ZXh0LFxuICAgIHB1c2hDb250ZXh0UHJvdmlkZXI6IHB1c2hDb250ZXh0UHJvdmlkZXIsXG4gICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcjogaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcixcbiAgICBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dDogZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHRcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyTmV3Q29udGV4dCA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgY3JlYXRlQ3Vyc29yID0gc3RhY2suY3JlYXRlQ3Vyc29yLFxuICAgICAgcHVzaCA9IHN0YWNrLnB1c2gsXG4gICAgICBwb3AgPSBzdGFjay5wb3A7XG5cblxuICB2YXIgcHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gIHZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgdmFyIGNoYW5nZWRCaXRzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApO1xuXG4gIHZhciByZW5kZXJlclNpZ2lsID0gdm9pZCAwO1xuICB7XG4gICAgLy8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG4gICAgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICAgIHB1c2goY2hhbmdlZEJpdHNDdXJzb3IsIGNvbnRleHQuX2NoYW5nZWRCaXRzLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIHB1c2gocHJvdmlkZXJDdXJzb3IsIHByb3ZpZGVyRmliZXIsIHByb3ZpZGVyRmliZXIpO1xuXG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJvdmlkZXJGaWJlci5wZW5kaW5nUHJvcHMudmFsdWU7XG4gICAgY29udGV4dC5fY2hhbmdlZEJpdHMgPSBwcm92aWRlckZpYmVyLnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgICEoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSBudWxsIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9PT0gcmVuZGVyZXJTaWdpbCkgPyB3YXJuaW5nKGZhbHNlLCAnRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNoYW5nZWRCaXRzQ3Vyc29yLmN1cnJlbnQ7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgICBwb3AocHJvdmlkZXJDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICAgIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG4gICAgcG9wKGNoYW5nZWRCaXRzQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcblxuICAgIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICBjb250ZXh0Ll9jaGFuZ2VkQml0cyA9IGNoYW5nZWRCaXRzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdXNoUHJvdmlkZXI6IHB1c2hQcm92aWRlcixcbiAgICBwb3BQcm92aWRlcjogcG9wUHJvdmlkZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZVN0YWNrID0gW107XG5cbiAgdmFyIGZpYmVyU3RhY2sgPSB2b2lkIDA7XG5cbiAge1xuICAgIGZpYmVyU3RhY2sgPSBbXTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IC0xO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICAgIGluZGV4Kys7XG5cbiAgICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgICB9XG5cbiAgICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCkge1xuICAgIHtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKSB7XG4gICAge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIHZhbHVlU3RhY2subGVuZ3RoID0gMDtcbiAgICAgIGZpYmVyU3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUN1cnNvcjogY3JlYXRlQ3Vyc29yLFxuICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgcG9wOiBwb3AsXG4gICAgcHVzaDogcHVzaCxcbiAgICBjaGVja1RoYXRTdGFja0lzRW1wdHk6IGNoZWNrVGhhdFN0YWNrSXNFbXB0eSxcbiAgICByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXY6IHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldlxuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxudmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHZvaWQgMDtcbnZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB2b2lkIDA7XG52YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSB2b2lkIDA7XG52YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbiAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCBzZXRTdGF0ZSAob3IgZm9yY2VVcGRhdGUpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiB0aGUgJyArICdjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QuJXMnLCBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpYmVyKSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RmliZXJTdGFjaygpO1xuICB2YXIgaG9zdENvbnRleHQgPSBSZWFjdEZpYmVySG9zdENvbnRleHQoY29uZmlnLCBzdGFjayk7XG4gIHZhciBsZWdhY3lDb250ZXh0ID0gUmVhY3RGaWJlckxlZ2FjeUNvbnRleHQoc3RhY2spO1xuICB2YXIgbmV3Q29udGV4dCA9IFJlYWN0RmliZXJOZXdDb250ZXh0KHN0YWNrKTtcbiAgdmFyIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcjtcbiAgdmFyIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCA9IGxlZ2FjeUNvbnRleHQucG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0LFxuICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyID0gbGVnYWN5Q29udGV4dC5wb3BDb250ZXh0UHJvdmlkZXI7XG4gIHZhciBwb3BQcm92aWRlciA9IG5ld0NvbnRleHQucG9wUHJvdmlkZXI7XG5cbiAgdmFyIGh5ZHJhdGlvbkNvbnRleHQgPSBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dChjb25maWcpO1xuXG4gIHZhciBfUmVhY3RGaWJlckJlZ2luV29yayA9IFJlYWN0RmliZXJCZWdpbldvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgbmV3Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSxcbiAgICAgIGJlZ2luV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21wbGV0ZVdvID0gUmVhY3RGaWJlckNvbXBsZXRlV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSxcbiAgICAgIGNvbXBsZXRlV29yayA9IF9SZWFjdEZpYmVyQ29tcGxldGVXby5jb21wbGV0ZVdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyVW53aW5kV29yayA9IFJlYWN0RmliZXJVbndpbmRXb3JrKGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBzY2hlZHVsZVdvcmssIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkpLFxuICAgICAgdGhyb3dFeGNlcHRpb24gPSBfUmVhY3RGaWJlclVud2luZFdvcmsudGhyb3dFeGNlcHRpb24sXG4gICAgICB1bndpbmRXb3JrID0gX1JlYWN0RmliZXJVbndpbmRXb3JrLnVud2luZFdvcmssXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsgPSBfUmVhY3RGaWJlclVud2luZFdvcmsudW53aW5kSW50ZXJydXB0ZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBSZWFjdEZpYmVyQ29tbWl0V29yayhjb25maWcsIG9uQ29tbWl0UGhhc2VFcnJvciwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkLCByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKSxcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMsXG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb24gPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRFcnJvckxvZ2dpbmcgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RXJyb3JMb2dnaW5nLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9IGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9IGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0O1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdGltZSBpbiBtcy5cblxuICB2YXIgb3JpZ2luYWxTdGFydFRpbWVNcyA9IG5vdygpO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKDApO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lTXMgPSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24gaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMuXG4gIHZhciBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uID0gMDtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG5cbiAgdmFyIGlzUm9vdFJlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgdmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIHZhciBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gdm9pZCAwO1xuICB2YXIgcmVwbGF5VW5pdE9mV29yayA9IHZvaWQgMDtcbiAgdmFyIGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yayA9IHZvaWQgMDtcbiAgdmFyIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSB2b2lkIDA7XG4gIHZhciByZXRocm93T3JpZ2luYWxFcnJvciA9IHZvaWQgMDtcbiAgaWYgKHRydWUgJiYgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2spIHtcbiAgICBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICByZXBsYXlVbml0T2ZXb3JrID0gZnVuY3Rpb24gKGZhaWxlZFVuaXRPZldvcmssIGVycm9yLCBpc0FzeW5jKSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgICAgYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZmFpbGVkVW5pdE9mV29yaywgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyk7XG4gICAgICBzd2l0Y2ggKGZhaWxlZFVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbExlZ2FjeUNvbnRleHRPYmplY3QoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BMZWdhY3lDb250ZXh0UHJvdmlkZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgICBwb3BQcm92aWRlcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIFJlcGxheSB0aGUgYmVnaW4gcGhhc2UuXG4gICAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB0cnVlO1xuICAgICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IGVycm9yO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgd29ya0xvb3AsIG51bGwsIGlzQXN5bmMpO1xuICAgICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gICAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBiZWdpbiBwaGFzZSBkaWQgbm90IGZhaWwgdGhlIHNlY29uZCB0aW1lLCBzZXQgdGhpcyBwb2ludGVyXG4gICAgICAgIC8vIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgICBuZXh0VW5pdE9mV29yayA9IGZhaWxlZFVuaXRPZldvcms7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXRocm93T3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG9yaWdpbmFsUmVwbGF5RXJyb3I7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3RhY2soKSB7XG4gICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gbmV4dFVuaXRPZldvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKGludGVycnVwdGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgICBzdGFjay5jaGVja1RoYXRTdGFja0lzRW1wdHkoKTtcbiAgICB9XG5cbiAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcblxuICAgIGlzUm9vdFJlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgICAgLy8gdXBkYXRlcywgYW5kIGRlbGV0aW9ucy4gVG8gYXZvaWQgbmVlZGluZyB0byBhZGQgYSBjYXNlIGZvciBldmVyeVxuICAgICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgICAvLyBlZmZlY3QgdGFnIGFuZCBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cbiAgICAgIHZhciBwcmltYXJ5RWZmZWN0VGFnID0gZWZmZWN0VGFnICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IERlbGV0aW9uKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdERlbGV0aW9uKG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBjbGVhbnVwIGVmZmVjdHMgeWV0O1xuICAgICAgLy8gVGhpcyB3aWxsIGJlIGRvbmUgYnkgY29tbWl0QWxsTGlmZUN5Y2xlcygpXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50VGltZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpIHtcbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuXG4gICAgICBpZiAod2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMpIHtcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncygpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5leHRFZmZlY3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBFcnJMb2cpIHtcbiAgICAgICAgY29tbWl0RXJyb3JMb2dnaW5nKG5leHRFZmZlY3QsIG9uVW5jYXVnaHRFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gICAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspIHtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICAgIShjb21taXR0ZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuXG4gICAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfVxuXG4gICAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gICAgLy8gSW52b2tlIGluc3RhbmNlcyBvZiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBiZWZvcmUgbXV0YXRpb24uXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBvbkNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgZXJyb3IpO1xuICAgICAgICAvLyBDbGVhbi11cFxuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9kaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY29tbWl0QWxsSG9zdEVmZmVjdHMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIF9kaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgb25Db21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvcjIgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwsIHJvb3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kaWRFcnJvcjIpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBvbkNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVtYWluaW5nVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlXG4gICAgLy8gbmV4dCBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZVxuICAgIC8vIHBhcmVudCBmaWJlci5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgLy8gVGhpcyBmaWJlciBjb21wbGV0ZWQuXG4gICAgICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAge1xuICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCAmJlxuICAgICAgICAvLyBEbyBub3QgYXBwZW5kIGVmZmVjdHMgdG8gcGFyZW50cyBpZiBhIHNpYmxpbmcgZmFpbGVkIHRvIGNvbXBsZXRlXG4gICAgICAgIChyZXR1cm5GaWJlci5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgICAgaXNSb290UmVhZHlGb3JDb21taXQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IGVudGVyaW5nIHRoZSBjb21wbGV0ZSBwaGFzZS4gSWYgdGhpcyBpcyBhIGJvdW5kYXJ5LFxuICAgICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkge1xuICAgICAgICAgIC8vIFJlc3RhcnRpbmcgYW4gZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBzdG9wRmFpbGVkV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgICBfbmV4dC5lZmZlY3RUYWcgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgICAgcmV0dXJuIF9uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBlZmZlY3QgbGlzdC5cbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIHJldHVybkZpYmVyLmVmZmVjdFRhZyB8PSBJbmNvbXBsZXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9IGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgaWYgKGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yaykge1xuICAgICAgICAvLyBDdXJyZW50bHkgcmVwbGF5aW5nIGEgZmFpbGVkIHVuaXQgb2Ygd29yay4gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHJlbmRlciBwaGFzZSBpcyBtZWFudCB0byBiZSBpZGVtcG90ZW50LCBhbmQgaXQgc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgdGhyb3duIGFnYWluLiBTaW5jZSBpdCBkaWRuJ3QsIHJldGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yLCBzb1xuICAgICAgICAvLyBSZWFjdCdzIGludGVybmFsIHN0YWNrIGlzIG5vdCBtaXNhbGlnbmVkLlxuICAgICAgICByZXRocm93T3JpZ2luYWxFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGlzQXN5bmMpIHtcbiAgICBpZiAoIWlzQXN5bmMpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzQXN5bmMpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gICAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lICE9PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgfHwgcm9vdCAhPT0gbmV4dFJvb3QgfHwgbmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgICAgcmVzZXRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICB9XG5cbiAgICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICBkbyB7XG4gICAgICB0cnkge1xuICAgICAgICB3b3JrTG9vcChpc0FzeW5jKTtcbiAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgIGlmIChuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGZhaWxlZFVuaXRPZldvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgICAgICByZXBsYXlVbml0T2ZXb3JrKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc0FzeW5jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2VGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlclsncmV0dXJuJ107XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3QuIFRoZSByb290IGNvdWxkIGNhcHR1cmUgaXRzIG93biBlcnJvcnMuIEhvd2V2ZXIsXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCBlcnJvcnMgYmVmb3JlIG9yIGFmdGVyIHdlIHB1c2hlZCB0aGUgaG9zdFxuICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaW5mb3JtYXRpb24gaXMgbmVlZGVkIHRvIGF2b2lkIGEgc3RhY2sgbWlzbWF0Y2guXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBub3Qgc3VyZSwgdHJlYXQgdGhpcyBhcyBhIGZhdGFsIGVycm9yLiBXZSBjb3VsZCB0cmFja1xuICAgICAgICAgIC8vIHdoaWNoIHBoYXNlIGl0IGZhaWxzIGluLCBidXQgZG9lc24ndCBzZWVtIHdvcnRoIGl0LiBBdCBsZWFzdFxuICAgICAgICAgIC8vIGZvciBub3cuXG4gICAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFeGNlcHRpb24ocmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVVbml0T2ZXb3JrKHNvdXJjZUZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgLy8gV2UncmUgZG9uZSBwZXJmb3JtaW5nIHdvcmsuIFRpbWUgdG8gY2xlYW4gdXAuXG4gICAgdmFyIGRpZENvbXBsZXRlUm9vdCA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gICAgLy8gWWllbGQgYmFjayB0byBtYWluIHRocmVhZC5cbiAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICAgIC8vIFRoZXJlIHdhcyBhIGZhdGFsIGVycm9yLlxuICAgICAge1xuICAgICAgICBzdGFjay5yZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICBpZiAoaXNSb290UmVhZHlGb3JDb21taXQpIHtcbiAgICAgICAgZGlkQ29tcGxldGVSb290ID0gdHJ1ZTtcbiAgICAgICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgICAgIC8vIFRoZSByb290IHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuIEl0J3MgcmVhZHkgZm9yIGNvbW1pdC5cbiAgICAgICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICAgIHJldHVybiBmaW5pc2hlZFdvcms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcm9vdCBkaWQgbm90IGNvbXBsZXRlLlxuICAgICAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpO1xuICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwaXJlZCB3b3JrIHNob3VsZCBoYXZlIGNvbXBsZXRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgICAgLy8gVGhlcmUncyBtb3JlIHdvcmsgdG8gZG8sIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWUuIFlpZWxkIGJhY2sgdG9cbiAgICAgIC8vIHRoZSByZW5kZXJlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FwdHVyZShzb3VyY2VGaWJlciwgYm91bmRhcnlGaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogV2Ugb25seSBzdXBwb3J0IGRpc3BhdGNoaW5nIGVycm9ycy5cbiAgICB2YXIgY2FwdHVyZWRWYWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiBudWxsLFxuICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZWRWYWx1ZTogY2FwdHVyZWRWYWx1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihib3VuZGFyeUZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhib3VuZGFyeUZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaChzb3VyY2VGaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISghaXNXb3JraW5nIHx8IGlzQ29tbWl0dGluZykgPyBpbnZhcmlhbnQoZmFsc2UsICdkaXNwYXRjaDogQ2Fubm90IGRpc3BhdGNoIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIGFycmF5c1xuXG4gICAgdmFyIGZpYmVyID0gc291cmNlRmliZXJbJ3JldHVybiddO1xuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVDYXB0dXJlKHNvdXJjZUZpYmVyLCBmaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBhc3luYyBib3VuZGFyaWVzXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgc2NoZWR1bGVDYXB0dXJlKHNvdXJjZUZpYmVyLCBmaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgICAgc2NoZWR1bGVDYXB0dXJlKHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGVycm9yKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGZpYmVyLCBlcnJvciwgU3luYyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IDUwMDA7XG4gICAgdmFyIGJ1Y2tldFNpemVNcyA9IDI1MDtcbiAgICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25NcywgYnVja2V0U2l6ZU1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnRlcmFjdGl2ZUV4cGlyYXRpb24oY3VycmVudFRpbWUpIHtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gdm9pZCAwO1xuICAgIC8vIFdlIGludGVudGlvbmFsbHkgc2V0IGEgaGlnaGVyIGV4cGlyYXRpb24gdGltZSBmb3IgaW50ZXJhY3RpdmUgdXBkYXRlcyBpblxuICAgIC8vIGRldiB0aGFuIGluIHByb2R1Y3Rpb24uXG4gICAgLy8gSWYgdGhlIG1haW4gdGhyZWFkIGlzIGJlaW5nIGJsb2NrZWQgc28gbG9uZyB0aGF0IHlvdSBoaXQgdGhlIGV4cGlyYXRpb24sXG4gICAgLy8gaXQncyBhIHByb2JsZW0gdGhhdCBjb3VsZCBiZSBzb2x2ZWQgd2l0aCBiZXR0ZXIgc2NoZWR1bGluZy5cbiAgICAvLyBQZW9wbGUgd2lsbCBiZSBtb3JlIGxpa2VseSB0byBub3RpY2UgdGhpcyBhbmQgZml4IGl0IHdpdGggdGhlIGxvbmdcbiAgICAvLyBleHBpcmF0aW9uIHRpbWUgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBvcHQgZm9yIGJldHRlciBVWCBhdCB0aGUgcmlzayBvZiBtYXNraW5nIHNjaGVkdWxpbmdcbiAgICAvLyBwcm9ibGVtcywgYnkgZXhwaXJpbmcgZmFzdC5cbiAgICB7XG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH41MDBtcy4gNjAwbXMgbWF4LlxuICAgICAgZXhwaXJhdGlvbk1zID0gNTAwO1xuICAgIH1cbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMTAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIHVuaXF1ZSBhc3luYyBleHBpcmF0aW9uIHRpbWUuXG4gIGZ1bmN0aW9uIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciByZXN1bHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocmVzdWx0IDw9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24pIHtcbiAgICAgIC8vIFNpbmNlIHdlIGFzc3VtZSB0aGUgY3VycmVudCB0aW1lIG1vbm90b25pY2FsbHkgaW5jcmVhc2VzLCB3ZSBvbmx5IGhpdFxuICAgICAgLy8gdGhpcyBicmFuY2ggd2hlbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIGlzIGZpcmVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAvLyB3aXRoaW4gYSAyMDBtcyB3aW5kb3cgKG9yIHdoYXRldmVyIHRoZSBhc3luYyBidWNrZXQgc2l6ZSBpcykuXG4gICAgICByZXN1bHQgPSBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uICsgMTtcbiAgICB9XG4gICAgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IHJlc3VsdDtcbiAgICByZXR1cm4gbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gICAgaWYgKGV4cGlyYXRpb25Db250ZXh0ICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEFuIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0O1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICB9IGVsc2UgaWYgKGlzV29ya2luZykge1xuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICAvLyBVcGRhdGVzIHRoYXQgb2NjdXIgZHVyaW5nIHRoZSBjb21taXQgcGhhc2Ugc2hvdWxkIGhhdmUgc3luYyBwcmlvcml0eVxuICAgICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgICAvLyB0aGUgd29yayB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQsIGFuZCB3ZSdyZSBub3QgY3VycmVudGx5XG4gICAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAoZmliZXIubW9kZSAmIEFzeW5jTW9kZSkge1xuICAgICAgICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJhY3RpdmUgdXBkYXRlXG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgICB2YXIgX2N1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihfY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB1cGRhdGUuIEtlZXAgdHJhY2sgb2YgdGhlIGxvd2VzdCBwZW5kaW5nXG4gICAgICAvLyBpbnRlcmFjdGl2ZSBleHBpcmF0aW9uIHRpbWUuIFRoaXMgYWxsb3dzIHVzIHRvIHN5bmNocm9ub3VzbHkgZmx1c2hcbiAgICAgIC8vIGFsbCBpbnRlcmFjdGl2ZSB1cGRhdGVzIHdoZW4gbmVlZGVkLlxuICAgICAgaWYgKGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPiBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBleHBpcmF0aW9uVGltZSwgaXNFcnJvclJlY292ZXJ5KSB7XG4gICAgcmVjb3JkU2NoZWR1bGVVcGRhdGUoKTtcblxuICAgIHtcbiAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyhpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSBlYWNoIG5vZGUnc1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5vZGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbm9kZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKCFpc1dvcmtpbmcgJiYgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgICAgICAgcmVzZXRTdGFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZSwgd2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHJvb3RcbiAgICAgICAgICAvLyBmb3IgYW4gdXBkYXRlLCBiZWNhdXNlIHdlJ2xsIGRvIGl0IGJlZm9yZSB3ZSBleGl0Li4uXG4gICAgICAgICAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmcgfHxcbiAgICAgICAgICAvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGRpZmZlcmVudCByb290IHRoYW4gdGhlIG9uZSB3ZSdyZSByZW5kZXJpbmcuXG4gICAgICAgICAgbmV4dFJvb3QgIT09IHJvb3QpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGlzIHJvb3QgdG8gdGhlIHJvb3Qgc2NoZWR1bGUuXG4gICAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZU1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtb3N0UmVjZW50Q3VycmVudFRpbWVNcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN5bmNVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IFN5bmM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBpcyB3cml0dGVuIGFzIGlmIGl0IGhhcyBiZWVuIGxpZnRlZCB0byB0aGVcbiAgLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgdmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gIHZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbiAgdmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBjYWxsYmFja0lEID0gLTE7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgdmFyIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gIHZhciBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICB2YXIgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICB2YXIgZGVhZGxpbmUgPSBudWxsO1xuXG4gIHZhciBpc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB2YXIgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB2YXIgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IGZhbHNlO1xuXG4gIHZhciBjb21wbGV0ZWRCYXRjaGVzID0gbnVsbDtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lID4gY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlcXVlc3QgY2FsbGJhY2sgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLiBEb24ndCBzdGFydCBhIG5ldyBvbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY3VycmVudE1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBhZGRSb290VG9TY2hlZHVsZShyb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogR2V0IHJpZCBvZiBTeW5jIGFuZCB1c2UgY3VycmVudCB0aW1lP1xuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gU3luYykge1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgICAgLy8gVGhpcyByb290IG5vIGxvbmdlciBoYXMgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlci5cblxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgaXMgcmVkdWRhbnQsIGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBicmFuY2hcbiAgICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgICAvLyBmcm9tIHRoZSBsb29wIHJpZ2h0IGFmdGVyLlxuICAgICAgICAgICEocHJldmlvdXNTY2hlZHVsZWRSb290ICE9PSBudWxsICYmIGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGEgcHJldmlvdXMgYW5kIGxhc3Qgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGZpcnN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChoaWdoZXN0UHJpb3JpdHlXb3JrID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBoaWdoZXN0UHJpb3JpdHlXb3JrKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5V29yayA9IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgICAgcm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gICAgLy8gdXBkYXRlLiBUbyBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AsIGluY3JlbWVudCB0aGUgbmVzdGVkIHVwZGF0ZSBjb3VudC5cbiAgICB2YXIgcHJldmlvdXNGbHVzaGVkUm9vdCA9IG5leHRGbHVzaGVkUm9vdDtcbiAgICBpZiAocHJldmlvdXNGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBwcmV2aW91c0ZsdXNoZWRSb290ID09PSBoaWdoZXN0UHJpb3JpdHlSb290ICYmIGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIHRydWUsIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1TeW5jV29yaygpIHtcbiAgICBwZXJmb3JtV29yayhTeW5jLCBmYWxzZSwgbnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtV29yayhtaW5FeHBpcmF0aW9uVGltZSwgaXNBc3luYywgZGwpIHtcbiAgICBkZWFkbGluZSA9IGRsO1xuXG4gICAgLy8gS2VlcCB3b3JraW5nIG9uIHJvb3RzIHVudGlsIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrLCBvciB1bnRpbCB0aGUgd2UgcmVhY2hcbiAgICAvLyB0aGUgZGVhZGxpbmUuXG4gICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcblxuICAgIGlmIChlbmFibGVVc2VyVGltaW5nQVBJICYmIGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXhwaXJlID0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVUb01zKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHdoaWxlIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG1pbkV4cGlyYXRpb25UaW1lID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpICYmICghZGVhZGxpbmVEaWRFeHBpcmUgfHwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSwgIWRlYWRsaW5lRGlkRXhwaXJlKTtcbiAgICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbWluRXhwaXJhdGlvblRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgY2FsbGJhY2tJRCA9IC0xO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24obmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG5cbiAgICBmaW5pc2hSZW5kZXJpbmcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJykgOiB2b2lkIDA7XG4gICAgLy8gUGVyZm9ybSB3b3JrIG9uIHJvb3QgYXMgaWYgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZSBpcyB0aGUgY3VycmVudCB0aW1lLlxuICAgIC8vIFRoaXMgaGFzIHRoZSBlZmZlY3Qgb2Ygc3luY2hyb25vdXNseSBmbHVzaGluZyBhbGwgd29yayB1cCB0byBhbmRcbiAgICAvLyBpbmNsdWRpbmcgdGhlIGdpdmVuIHRpbWUuXG4gICAgbmV4dEZsdXNoZWRSb290ID0gcm9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgICAvLyBGbHVzaCBhbnkgc3luYyB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZCBieSBsaWZlY3ljbGVzXG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgZmluaXNoUmVuZGVyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmcoKSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGNvbXBsZXRlZEJhdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIHZhciBiYXRjaGVzID0gY29tcGxldGVkQmF0Y2hlcztcbiAgICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmF0Y2guX29uQ29tcGxldGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gdW5oYW5kbGVkRXJyb3I7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzQXN5bmMpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICBpZiAoIWlzQXN5bmMpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgICAgY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBiYXRjaCB0aGF0IG1hdGNoZXMgdGhpcyBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGZpcnN0QmF0Y2ggPSByb290LmZpcnN0QmF0Y2g7XG4gICAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGlmIChjb21wbGV0ZWRCYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBbZmlyc3RCYXRjaF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZWRCYXRjaGVzLnB1c2goZmlyc3RCYXRjaCk7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RCYXRjaC5fZGVmZXIpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGJsb2NrZWQgZnJvbSBjb21taXR0aW5nIGJ5IGEgYmF0Y2guIFVuc2NoZWR1bGUgaXQgdW50aWxcbiAgICAgICAgLy8gd2UgcmVjZWl2ZSBhbm90aGVyIHVwZGF0ZS5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21taXQgdGhlIHJvb3QuXG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAgIC8vIGR1cmluZyBhIHRpbWVvdXQuIFRoaXMgcGF0aCBpcyBvbmx5IGhpdCBmb3Igbm9uLWV4cGlyZWQgd29yay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oYSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbihhKTtcbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCB3aXRoaW5cbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IGNhbm5vdCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4nKSA6IHZvaWQgMDtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuLCBhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKSB7XG4gICAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMsIHN5bmNocm9ub3VzbHkgZmx1c2ggdGhlbS5cbiAgICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAgIC8vIHRoZSBwcmV2aW91cyBldmVudCBtYXkgaW5mbHVlbmNlIHdoaWNoIGhhbmRsZXJzIGFyZSBjYWxsZWQgZHVyaW5nXG4gICAgLy8gdGhpcyBldmVudC5cbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZyAmJiBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICAgIHBlcmZvcm1Xb3JrKGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lLCBmYWxzZSwgbnVsbCk7XG4gICAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gdHJ1ZTtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzKCkge1xuICAgIGlmICghaXNSZW5kZXJpbmcgJiYgbG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgICBwZXJmb3JtV29yayhsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgZmFsc2UsIG51bGwpO1xuICAgICAgbG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hDb250cm9sbGVkKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgZmFsc2UsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVjYWxjdWxhdGVDdXJyZW50VGltZTogcmVjYWxjdWxhdGVDdXJyZW50VGltZSxcbiAgICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgIHNjaGVkdWxlV29yazogc2NoZWR1bGVXb3JrLFxuICAgIHJlcXVlc3RXb3JrOiByZXF1ZXN0V29yayxcbiAgICBmbHVzaFJvb3Q6IGZsdXNoUm9vdCxcbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICBmbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlcyxcbiAgICBzeW5jVXBkYXRlczogc3luY1VwZGF0ZXMsXG4gICAgaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gICAgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM6IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuICAgIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb246IGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24sXG4gICAgbGVnYWN5Q29udGV4dDogbGVnYWN5Q29udGV4dFxuICB9O1xufTtcblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5yZWNhbGN1bGF0ZUN1cnJlbnRUaW1lLFxuICAgICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgICBzY2hlZHVsZVdvcmsgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zY2hlZHVsZVdvcmssXG4gICAgICByZXF1ZXN0V29yayA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnJlcXVlc3RXb3JrLFxuICAgICAgZmx1c2hSb290ID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hSb290LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZmx1c2hDb250cm9sbGVkID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hDb250cm9sbGVkLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzLFxuICAgICAgc3luY1VwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zeW5jVXBkYXRlcyxcbiAgICAgIGludGVyYWN0aXZlVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmludGVyYWN0aXZlVXBkYXRlcyxcbiAgICAgIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gICAgICBsZWdhY3lDb250ZXh0ID0gX1JlYWN0RmliZXJTY2hlZHVsZXIubGVnYWN5Q29udGV4dDtcblxuICB2YXIgZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQgPSBsZWdhY3lDb250ZXh0LmZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0LFxuICAgICAgaXNDb250ZXh0UHJvdmlkZXIgPSBsZWdhY3lDb250ZXh0LmlzQ29udGV4dFByb3ZpZGVyLFxuICAgICAgcHJvY2Vzc0NoaWxkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQucHJvY2Vzc0NoaWxkQ29udGV4dDtcblxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICAgIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gICAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjdXJyZW50VGltZSwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gICAge1xuICAgICAgaWYgKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPT09ICdyZW5kZXInICYmIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuICAgICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAge1xuICAgICAgIShjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBwYXJ0aWFsU3RhdGU6IHsgZWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVkVmFsdWU6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuXG4gICAgcmV0dXJuIGV4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY3VycmVudFRpbWUsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICB7XG4gICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjdXJyZW50VGltZSwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVySW5mbywgaXNBc3luYywgaHlkcmF0ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY3VycmVudFRpbWUsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cblxuICAgIGZsdXNoUm9vdDogZmx1c2hSb290LFxuXG4gICAgcmVxdWVzdFdvcms6IHJlcXVlc3RXb3JrLFxuXG4gICAgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbjogY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbixcblxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlcyxcblxuICAgIHN5bmNVcGRhdGVzOiBzeW5jVXBkYXRlcyxcblxuICAgIGludGVyYWN0aXZlVXBkYXRlczogaW50ZXJhY3RpdmVVcGRhdGVzLFxuXG4gICAgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM6IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuXG4gICAgZmx1c2hDb250cm9sbGVkOiBmbHVzaENvbnRyb2xsZWQsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgZmluZEhvc3RJbnN0YW5jZTogZmluZEhvc3RJbnN0YW5jZSxcblxuICAgIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgaW5qZWN0SW50b0RldlRvb2xzOiBmdW5jdGlvbiAoZGV2VG9vbHNDb25maWcpIHtcbiAgICAgIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKF9hc3NpZ24oe30sIGRldlRvb2xzQ29uZmlnLCB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGlmICghZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIE1pZ2h0IG5vdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDFcbn0pO1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMyA9ICggUmVhY3RGaWJlclJlY29uY2lsZXIkMiAmJiBSZWFjdEZpYmVyUmVjb25jaWxlciQxICkgfHwgUmVhY3RGaWJlclJlY29uY2lsZXIkMjtcblxuLy8gVE9ETzogYnVuZGxlIEZsb3cgdHlwZXMgd2l0aCB0aGUgcGFja2FnZS5cblxuXG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0UmVjb25jaWxlciA9IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA/IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDM7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLFxuLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjMuMic7XG5cbi8vIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBzdG9yaW5nIHRoZSB0aW1lIGZvciB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lLCB0aGVuXG4vLyBzY2hlZHVsaW5nIGEgcG9zdE1lc3NhZ2Ugd2hpY2ggZ2V0cyBzY2hlZHVsZWQgYWZ0ZXIgcGFpbnQuIFdpdGhpbiB0aGVcbi8vIHBvc3RNZXNzYWdlIGhhbmRsZXIgZG8gYXMgbXVjaCB3b3JrIGFzIHBvc3NpYmxlIHVudGlsIHRpbWUgKyBmcmFtZSByYXRlLlxuLy8gQnkgc2VwYXJhdGluZyB0aGUgaWRsZSBjYWxsIGludG8gYSBzZXBhcmF0ZSBldmVudCB0aWNrIHdlIGVuc3VyZSB0aGF0XG4vLyBsYXlvdXQsIHBhaW50IGFuZCBvdGhlciBicm93c2VyIHdvcmsgaXMgY291bnRlZCBhZ2FpbnN0IHRoZSBhdmFpbGFibGUgdGltZS5cbi8vIFRoZSBmcmFtZSByYXRlIGlzIGR5bmFtaWNhbGx5IGFkanVzdGVkLlxuXG57XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIG5vdyA9IHZvaWQgMDtcbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG4vLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byBjYW5jZWwsIGJlY2F1c2UgRmliZXIgZG9lc24ndCBhdG0uXG52YXIgcklDID0gdm9pZCAwO1xudmFyIGNJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGNJQyA9IGZ1bmN0aW9uICh0aW1lb3V0SUQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfTtcbn0gZWxzZSBpZiAoYWx3YXlzVXNlUmVxdWVzdElkbGVDYWxsYmFja1BvbHlmaWxsIHx8IHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdCA9IHZvaWQgMDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAvLyBXZSBjYW4gc2lsZW50bHkgc2tpcCB0aGVtIGJlY2F1c2UgaW52YWxpZCBET00gbmVzdGluZyB3YXJuaW5nXG4gIC8vIGNhdGNoZXMgdGhlc2UgY2FzZXMgaW4gRmliZXIuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICB7XG4gICAgaWYgKHByb3BzLnNlbGVjdGVkICE9IG51bGwgJiYgIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMoKTtcbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpIHtcbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdGlvbnMgPSBub2RlLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWVzID0gcHJvcFZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJCcgKyBzZWxlY3RlZFZhbHVlc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbX2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgdmFyIF9zZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgdmFyIGRlZmF1bHRTZWxlY3RlZCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgd2FzTXVsdGlwbGU6ICEhcHJvcHMubXVsdGlwbGVcbiAgfTtcblxuICB7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG5cbiAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZVxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSk7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiB2b2lkIDA7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gIHZhciB0ZXh0Q29udGVudCA9IG5vZGUudGV4dENvbnRlbnQ7XG5cbiAgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG4gIGlmICh0ZXh0Q29udGVudCA9PT0gbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgIG5vZGUudmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG52YXIgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG52YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSQxLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07XG5cbi8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxuICAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcblxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLiBGb3IgdGV4dCB1cGRhdGVzLCBpdCdzIGZhc3RlclxuICogdG8gc2V0IHRoZSBgbm9kZVZhbHVlYCBvZiB0aGUgVGV4dCBub2RlIGRpcmVjdGx5IGluc3RlYWQgb2YgdXNpbmdcbiAqIGAudGV4dENvbnRlbnRgIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBleGlzdGluZyBub2RlIGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgIShwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJXMnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcblxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICAnaW4nOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICAndHlwZW9mJzogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIGNvcnJlY3ROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG52YXIgd2FybmVkVW5rbm93blRhZ3MgPSB2b2lkIDA7XG52YXIgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nID0gdm9pZCAwO1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IHZvaWQgMDtcbnZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSB2b2lkIDA7XG52YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMgPSB2b2lkIDA7XG52YXIgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gdm9pZCAwO1xuXG52YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gdm9pZCAwO1xudmFyIG5vcm1hbGl6ZUhUTUwgPSB2b2lkIDA7XG5cbntcbiAgZ2V0U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDM7XG5cbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZVxuICB9O1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0KSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1RleHQgY29udGVudCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6IFwiJXNcIiBDbGllbnQ6IFwiJXNcIicsIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LCBub3JtYWxpemVkQ2xpZW50VGV4dCk7XG4gIH07XG5cbiAgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09PSBmYWxzZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lciwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3AsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gdm9pZCAwO1xuXG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpO1xuICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgIShpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCB0eXBlID09PSB0eXBlLnRvTG93ZXJDYXNlKCkpID8gd2FybmluZyhmYWxzZSwgJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCB0eXBlKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRUeXBlcykge1xuICAgICAgICBpZiAobWVkaWFFdmVudFR5cGVzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRUeXBlc1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzID0gdm9pZCAwO1xuICB2YXIgbmV4dFByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5ID0gdm9pZCAwO1xuICB2YXIgc3R5bGVOYW1lID0gdm9pZCAwO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG4gIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuXG4gIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRUeXBlcykge1xuICAgICAgICBpZiAobWVkaWFFdmVudFR5cGVzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRUeXBlc1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIGV4dHJhQXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgd2hpdGVsaXN0ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IHVzZSB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMDY3Ni5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRydWUgJiZcbiAgICAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhwcm9wS2V5KTtcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSAmJiAhc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgICAgICB2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG51bGwgJiYgc3RhbmRhcmROYW1lICE9PSBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIC8vIElmIGFuIFNWRyBwcm9wIGlzIHN1cHBsaWVkIHdpdGggYmFkIGNhc2luZywgaXQgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4gICAgICAgICAgICAgIC8vIChhbmQgd291bGQgYmUgaW5jb3JyZWN0bHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCkuXG4gICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIGFscmVhZHkgd2FybiBhYm91dCBiYWQgY2FzaW5nIGVsc2V3aGVyZS5cbiAgICAgICAgICAgICAgLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMVxufSk7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyQxID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICAhKGNoaWxkVGFnID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpIDogdm9pZCAwO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyQxID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG4vLyBUT0RPOiBUaGlzIHR5cGUgaXMgc2hhcmVkIGJldHdlZW4gdGhlIHJlY29uY2lsZXIgYW5kIFJlYWN0RE9NLCBidXQgd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgb3V0IHRvIHRoZSByZW5kZXJlci5cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSB2b2lkIDA7XG52YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IHZvaWQgMDtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSBmYWxzZTtcblxue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxuXG4gIHRvcExldmVsVXBkYXRlV2FybmluZ3MgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyICYmIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaG9zdEluc3RhbmNlID0gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuX2ludGVybmFsUm9vdC5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgIShob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgISghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJykgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcbiAgfTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAhKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuaW5qZWN0aW9uJDIuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50KTtcblxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gUmVhY3RCYXRjaChyb290KSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IERPTVJlbmRlcmVyLmNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKTtcbiAgdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICB0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX2RlZmVyID0gdHJ1ZTtcbn1cblJlYWN0QmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAhdGhpcy5fZGVmZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5yZW5kZXI6IENhbm5vdCByZW5kZXIgYSBiYXRjaCB0aGF0IGFscmVhZHkgY29tbWl0dGVkLicpIDogdm9pZCAwO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZhciBpbnRlcm5hbFJvb3QgPSB0aGlzLl9yb290Ll9pbnRlcm5hbFJvb3Q7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShjaGlsZHJlbiwgaW50ZXJuYWxSb290LCBudWxsLCBleHBpcmF0aW9uVGltZSwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgaWYgKHRoaXMuX2RpZENvbXBsZXRlKSB7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21wbGV0ZSk7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5fcm9vdC5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICAhKHRoaXMuX2RlZmVyICYmIGZpcnN0QmF0Y2ggIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2guY29tbWl0OiBDYW5ub3QgY29tbWl0IGEgYmF0Y2ggbXVsdGlwbGUgdGltZXMuJykgOiB2b2lkIDA7XG5cbiAgaWYgKCF0aGlzLl9oYXNDaGlsZHJlbikge1xuICAgIC8vIFRoaXMgYmF0Y2ggaXMgZW1wdHkuIFJldHVybi5cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuXG4gIC8vIEVuc3VyZSB0aGlzIGlzIHRoZSBmaXJzdCBiYXRjaCBpbiB0aGUgbGlzdC5cbiAgaWYgKGZpcnN0QmF0Y2ggIT09IHRoaXMpIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIG5vdCB0aGUgZWFybGllc3QgYmF0Y2guIFdlIG5lZWQgdG8gbW92ZSBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gVXBkYXRlIGl0cyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgZWFybGllc3RcbiAgICAvLyBiYXRjaCwgc28gdGhhdCB3ZSBjYW4gZmx1c2ggaXQgd2l0aG91dCBmbHVzaGluZyB0aGUgb3RoZXIgYmF0Y2hlcy5cbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZTtcbiAgICAgIC8vIFJlbmRlcmluZyB0aGlzIGJhdGNoIGFnYWluIGVuc3VyZXMgaXRzIGNoaWxkcmVuIHdpbGwgYmUgdGhlIGZpbmFsIHN0YXRlXG4gICAgICAvLyB3aGVuIHdlIGZsdXNoICh1cGRhdGVzIGFyZSBwcm9jZXNzZWQgaW4gaW5zZXJ0aW9uIG9yZGVyOiBsYXN0XG4gICAgICAvLyB1cGRhdGUgd2lucykuXG4gICAgICAvLyBUT0RPOiBUaGlzIGZvcmNlcyBhIHJlc3RhcnQuIFNob3VsZCB3ZSBwcmludCBhIHdhcm5pbmc/XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLl9jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICAgIHZhciBwcmV2aW91cyA9IG51bGw7XG4gICAgdmFyIGJhdGNoID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoYmF0Y2ggIT09IHRoaXMpIHtcbiAgICAgIHByZXZpb3VzID0gYmF0Y2g7XG4gICAgICBiYXRjaCA9IGJhdGNoLl9uZXh0O1xuICAgIH1cbiAgICAhKHByZXZpb3VzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLmNvbW1pdDogQ2Fubm90IGNvbW1pdCBhIGJhdGNoIG11bHRpcGxlIHRpbWVzLicpIDogdm9pZCAwO1xuICAgIHByZXZpb3VzLl9uZXh0ID0gYmF0Y2guX25leHQ7XG5cbiAgICAvLyBBZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIHRoaXMuX25leHQgPSBmaXJzdEJhdGNoO1xuICAgIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IHRoaXM7XG4gIH1cblxuICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCB0aGUgd29yayB1cCB0byB0aGlzIGJhdGNoJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICBET01SZW5kZXJlci5mbHVzaFJvb3QoaW50ZXJuYWxSb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgLy8gUG9wIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICB2YXIgbmV4dCA9IHRoaXMuX25leHQ7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2ggPSBuZXh0O1xuXG4gIC8vIEFwcGVuZCB0aGUgbmV4dCBlYXJsaWVzdCBiYXRjaCdzIGNoaWxkcmVuIHRvIHRoZSB1cGRhdGUgcXVldWUuXG4gIGlmIChmaXJzdEJhdGNoICE9PSBudWxsICYmIGZpcnN0QmF0Y2guX2hhc0NoaWxkcmVuKSB7XG4gICAgZmlyc3RCYXRjaC5yZW5kZXIoZmlyc3RCYXRjaC5fY2hpbGRyZW4pO1xuICB9XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuX29uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9kaWRDb21wbGV0ZSA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICBfY2FsbGJhY2soKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RXb3JrKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21taXQgPSBmYWxzZTtcbiAgLy8gVE9ETzogQXZvaWQgbmVlZCB0byBiaW5kIGJ5IHJlcGxhY2luZyBjYWxsYmFja3MgaW4gdGhlIHVwZGF0ZSBxdWV1ZSB3aXRoXG4gIC8vIGxpc3Qgb2YgV29yayBvYmplY3RzLlxuICB0aGlzLl9vbkNvbW1pdCA9IHRoaXMuX29uQ29tbWl0LmJpbmQodGhpcyk7XG59XG5SZWFjdFdvcmsucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25Db21taXQpIHtcbiAgaWYgKHRoaXMuX2RpZENvbW1pdCkge1xuICAgIG9uQ29tbWl0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBjYWxsYmFja3MucHVzaChvbkNvbW1pdCk7XG59O1xuUmVhY3RXb3JrLnByb3RvdHlwZS5fb25Db21taXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tbWl0ID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUT0RPOiBFcnJvciBoYW5kbGluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NhbGxiYWNrMiA9IGNhbGxiYWNrc1tpXTtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2syID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjazIpIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjazIoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaXNBc3luYywgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGlzQXN5bmMsIGh5ZHJhdGUpO1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhdGNoID0gbmV3IFJlYWN0QmF0Y2godGhpcyk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGJhdGNoLl9leHBpcmF0aW9uVGltZTtcblxuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCA9PT0gbnVsbCkge1xuICAgIGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gYmF0Y2g7XG4gICAgYmF0Y2guX25leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIEluc2VydCBzb3J0ZWQgYnkgZXhwaXJhdGlvbiB0aW1lIHRoZW4gaW5zZXJ0aW9uIG9yZGVyXG4gICAgdmFyIGluc2VydEFmdGVyID0gbnVsbDtcbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlICE9PSBudWxsICYmIGluc2VydEJlZm9yZS5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGluc2VydEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLl9uZXh0O1xuICAgIH1cbiAgICBiYXRjaC5fbmV4dCA9IGluc2VydEJlZm9yZTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgIGluc2VydEFmdGVyLl9uZXh0ID0gYmF0Y2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIERPTVJlbmRlcmVyID0gcmVhY3RSZWNvbmNpbGVyKHtcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB2YXIgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICB7XG4gICAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICAgIHR5cGUgPSBjb250YWluZXIudGFnTmFtZTtcbiAgICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgfSxcbiAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogZnVuY3Rpb24gKHBhcmVudEhvc3RDb250ZXh0LCB0eXBlKSB7XG4gICAge1xuICAgICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgICB2YXIgX25hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbzIgPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IF9uYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbzIgfTtcbiAgICB9XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHJldHVybiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpO1xuICB9LFxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuICBwcmVwYXJlRm9yQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgICBzZXRFbmFibGVkKGZhbHNlKTtcbiAgfSxcbiAgcmVzZXRBZnRlckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB7XG4gICAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMSh0eXBlLCBudWxsLCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgIH1cbiAgICB2YXIgZG9tRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICByZXR1cm4gZG9tRWxlbWVudDtcbiAgfSxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICByZXR1cm4gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gIH0sXG4gIHByZXBhcmVVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICB9LFxuICBzaG91bGRTZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiYgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiAhIXByb3BzLmhpZGRlbjtcbiAgfSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gICAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9LFxuXG5cbiAgbm93OiBub3csXG5cbiAgbXV0YXRpb246IHtcbiAgICBjb21taXRNb3VudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbiAgICAgIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4gICAgICAvLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbiAgICAgIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgICAgIC8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbiAgICAgIGlmIChzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIG5ld1Byb3BzKSkge1xuICAgICAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21taXRVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvcHMgaGFuZGxlIHNvIHRoYXQgd2Uga25vdyB3aGljaCBwcm9wcyBhcmUgdGhlIG9uZXMgd2l0aFxuICAgICAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gICAgICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgRE9NIG5vZGUuXG4gICAgICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSxcbiAgICByZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xuICAgIH0sXG4gICAgY29tbWl0VGV4dFVwZGF0ZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGh5ZHJhdGlvbjoge1xuICAgIGNhbkh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSAnJyB8fCBpbnN0YW5jZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBub2RlID0gaW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSkge1xuICAgICAgdmFyIG5leHQgPSBwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuICAgIGh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpO1xuICAgICAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gICAgICAvLyBnZXQgYXR0YWNoZWQuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgfSxcbiAgICBoeWRyYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpO1xuICAgICAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6IHJJQyxcbiAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjazogY0lDXG59KTtcblxuaW5qZWN0aW9uJDMuaW5qZWN0UmVuZGVyZXIoRE9NUmVuZGVyZXIpO1xuXG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKSB7XG4gIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cbiAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHZhciByb290U2libGluZyA9IHZvaWQgMDtcbiAgICB3aGlsZSAocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghd2FybmVkICYmIHJvb3RTaWJsaW5nLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdFNpYmxpbmcuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKSB7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKHNob3VsZEh5ZHJhdGUgJiYgIWZvcmNlSHlkcmF0ZSAmJiAhd2FybmVkQWJvdXRIeWRyYXRlQVBJKSB7XG4gICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgIH1cbiAgfVxuICAvLyBMZWdhY3kgcm9vdHMgYXJlIG5vdCBhc3luYyBieSBkZWZhdWx0LlxuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIGlzQXN5bmMsIHNob3VsZEh5ZHJhdGUpO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgLy8gVE9ETzogRW5zdXJlIGFsbCBlbnRyeSBwb2ludHMgY29udGFpbiB0aGlzIGNoZWNrXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBUT0RPOiBXaXRob3V0IGBhbnlgIHR5cGUsIEZsb3cgc2F5cyBcIlByb3BlcnR5IGNhbm5vdCBiZSBhY2Nlc3NlZCBvbiBhbnlcbiAgLy8gbWVtYmVyIG9mIGludGVyc2VjdGlvbiB0eXBlLlwiIFdoeXl5eXl5LlxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICBpZiAoIXJvb3QpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICByb290LmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xuICAgICAgICBfb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIFVwZGF0ZVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgcm9vdC5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gIC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgIXdhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgICEhcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID8gd2FybmluZyhmYWxzZSwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICAhIWhhc05vblJvb3RSZWFjdENoaWxkID8gd2FybmluZyhmYWxzZSwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ1RoZSBSZWFjdERPTS51bnN0YWJsZV9jcmVhdGVQb3J0YWwoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0RE9NLmNyZWF0ZVBvcnRhbCgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEksICcgKyAnYnV0IHdpdGhvdXQgdGhlIFwidW5zdGFibGVfXCIgcHJlZml4LicpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfSxcblxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyxcblxuICB1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6IERPTVJlbmRlcmVyLmRlZmVycmVkVXBkYXRlcyxcblxuICBmbHVzaFN5bmM6IERPTVJlbmRlcmVyLmZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IERPTVJlbmRlcmVyLmZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5SZWFjdERPTS51bnN0YWJsZV9jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIHRydWUsIGh5ZHJhdGUpO1xufTtcblxudmFyIGZvdW5kRGV2VG9vbHMgPSBET01SZW5kZXJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzWydkZWZhdWx0J10gPyBSZWFjdERPTSQzWydkZWZhdWx0J10gOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz84YmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFLQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/BrowserRouter.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-router-dom/es/BrowserRouter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createBrowserHistory */ \"./node_modules/history/createBrowserHistory.js\");\n/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router-dom/es/Router.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\n\nvar BrowserRouter = function (_React$Component) {\n  _inherits(BrowserRouter, _React$Component);\n\n  function BrowserRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, BrowserRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  BrowserRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');\n  };\n\n  BrowserRouter.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { history: this.history, children: this.props.children });\n  };\n\n  return BrowserRouter;\n}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);\n\nBrowserRouter.propTypes = {\n  basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  forceRefresh: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,\n  getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BrowserRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcz9hMDUxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cblxudmFyIEJyb3dzZXJSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQnJvd3NlclJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnJvd3NlclJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyb3dzZXJSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPEJyb3dzZXJSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VyUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Ccm93c2VyUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZvcmNlUmVmcmVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/BrowserRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/HashRouter.js":
/*!********************************************************!*\
  !*** ./node_modules/react-router-dom/es/HashRouter.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var history_createHashHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createHashHistory */ \"./node_modules/history/createHashHistory.js\");\n/* harmony import */ var history_createHashHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createHashHistory__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router-dom/es/Router.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\n\nvar HashRouter = function (_React$Component) {\n  _inherits(HashRouter, _React$Component);\n\n  function HashRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, HashRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = history_createHashHistory__WEBPACK_IMPORTED_MODULE_3___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  HashRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');\n  };\n\n  HashRouter.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { history: this.history, children: this.props.children });\n  };\n\n  return HashRouter;\n}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);\n\nHashRouter.propTypes = {\n  basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  hashType: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOf(['hashbang', 'noslash', 'slash']),\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (HashRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcz8yMGRmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIYXNoUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxIYXNoUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEhhc2hSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gSGFzaFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuSGFzaFJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgaGFzaFR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2hhc2hiYW5nJywgJ25vc2xhc2gnLCAnc2xhc2gnXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBIYXNoUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/HashRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Link.js":
/*!**************************************************!*\
  !*** ./node_modules/react-router-dom/es/Link.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_2__);\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar isModifiedEvent = function isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n};\n\n/**\n * The public API for rendering a history-aware <a>.\n */\n\nvar Link = function (_React$Component) {\n  _inherits(Link, _React$Component);\n\n  function Link() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Link);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {\n      if (_this.props.onClick) _this.props.onClick(event);\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && // ignore right clicks\n      !_this.props.target && // let browser handle \"target=_blank\" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n\n          var history = _this.context.router.history;\n          var _this$props = _this.props,\n              replace = _this$props.replace,\n              to = _this$props.to;\n\n\n          if (replace) {\n            history.replace(to);\n          } else {\n            history.push(to);\n          }\n        }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Link.prototype.render = function render() {\n    var _props = this.props,\n        replace = _props.replace,\n        to = _props.to,\n        innerRef = _props.innerRef,\n        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars\n\n    invariant__WEBPACK_IMPORTED_MODULE_2___default()(this.context.router, 'You should not use <Link> outside a <Router>');\n\n    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);\n\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));\n  };\n\n  return Link;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nLink.propTypes = {\n  onClick: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  replace: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object]).isRequired,\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func])\n};\nLink.defaultProps = {\n  replace: false\n};\nLink.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n      push: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n      replace: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n      createHref: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired\n    }).isRequired\n  }).isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Link);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qcz9kYTIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcblxudmFyIGlzTW9kaWZpZWRFdmVudCA9IGZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaW5rKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNsaWNrKSBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBpZ25vcmUgcmlnaHQgY2xpY2tzXG4gICAgICAhX3RoaXMucHJvcHMudGFyZ2V0ICYmIC8vIGxldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBpZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICAgICAgKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHZhciBoaXN0b3J5ID0gX3RoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgcmVwbGFjZSA9IF90aGlzJHByb3BzLnJlcGxhY2UsXG4gICAgICAgICAgICAgIHRvID0gX3RoaXMkcHJvcHMudG87XG5cblxuICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByZXBsYWNlID0gX3Byb3BzLnJlcGxhY2UsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvLFxuICAgICAgICBpbm5lclJlZiA9IF9wcm9wcy5pbm5lclJlZixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ3JlcGxhY2UnLCAndG8nLCAnaW5uZXJSZWYnXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciBocmVmID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5LmNyZWF0ZUhyZWYodHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHsgcGF0aG5hbWU6IHRvIH0gOiB0byk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBocmVmOiBocmVmLCByZWY6IGlubmVyUmVmIH0pKTtcbiAgfTtcblxuICByZXR1cm4gTGluaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTGluay5wcm9wVHlwZXMgPSB7XG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHJlcGxhY2U6IFByb3BUeXBlcy5ib29sLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWQsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pXG59O1xuTGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIHJlcGxhY2U6IGZhbHNlXG59O1xuTGluay5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBjcmVhdGVIcmVmOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IExpbms7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Link.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/MemoryRouter.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-router-dom/es/MemoryRouter.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_MemoryRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/MemoryRouter */ \"./node_modules/react-router/es/MemoryRouter.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_MemoryRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanM/ZjYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IE1lbW9yeVJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/MemoryRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/NavLink.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/es/NavLink.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route */ \"./node_modules/react-router-dom/es/Route.js\");\n/* harmony import */ var _Link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Link */ \"./node_modules/react-router-dom/es/Link.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n\n\n\n\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nvar NavLink = function NavLink(_ref) {\n  var to = _ref.to,\n      exact = _ref.exact,\n      strict = _ref.strict,\n      location = _ref.location,\n      activeClassName = _ref.activeClassName,\n      className = _ref.className,\n      activeStyle = _ref.activeStyle,\n      style = _ref.style,\n      getIsActive = _ref.isActive,\n      ariaCurrent = _ref.ariaCurrent,\n      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Route__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,\n    exact: exact,\n    strict: strict,\n    location: location,\n    children: function children(_ref2) {\n      var location = _ref2.location,\n          match = _ref2.match;\n\n      var isActive = !!(getIsActive ? getIsActive(match, location) : match);\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _extends({\n        to: to,\n        className: isActive ? [className, activeClassName].filter(function (i) {\n          return i;\n        }).join(' ') : className,\n        style: isActive ? _extends({}, style, activeStyle) : style,\n        'aria-current': isActive && ariaCurrent\n      }, rest));\n    }\n  });\n};\n\nNavLink.propTypes = {\n  to: _Link__WEBPACK_IMPORTED_MODULE_3__[\"default\"].propTypes.to,\n  exact: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  strict: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  location: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  activeClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  activeStyle: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  style: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  isActive: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  ariaCurrent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOf(['page', 'step', 'location', 'true'])\n};\n\nNavLink.defaultProps = {\n  activeClassName: 'active',\n  ariaCurrent: 'true'\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (NavLink);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcz9iOGQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYuYXJpYUN1cnJlbnQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnLCAnYXJpYUN1cnJlbnQnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbY2xhc3NOYW1lLCBhY3RpdmVDbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgICdhcmlhLWN1cnJlbnQnOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudFxuICAgICAgfSwgcmVzdCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5OYXZMaW5rLnByb3BUeXBlcyA9IHtcbiAgdG86IExpbmsucHJvcFR5cGVzLnRvLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGFyaWFDdXJyZW50OiBQcm9wVHlwZXMub25lT2YoWydwYWdlJywgJ3N0ZXAnLCAnbG9jYXRpb24nLCAndHJ1ZSddKVxufTtcblxuTmF2TGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIGFyaWFDdXJyZW50OiAndHJ1ZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5hdkxpbms7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/NavLink.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Prompt.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router-dom/es/Prompt.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Prompt */ \"./node_modules/react-router/es/Prompt.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Prompt__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanM/MjcxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFByb21wdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUHJvbXB0JztcblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Prompt.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Redirect.js":
/*!******************************************************!*\
  !*** ./node_modules/react-router-dom/es/Redirect.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Redirect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Redirect */ \"./node_modules/react-router/es/Redirect.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Redirect__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzPzk5ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSZWRpcmVjdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Redirect.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Route.js":
/*!***************************************************!*\
  !*** ./node_modules/react-router-dom/es/Route.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Route */ \"./node_modules/react-router/es/Route.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Route__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzP2Q4ODMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSb3V0ZSBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGUnO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Route.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Router.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router-dom/es/Router.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Router */ \"./node_modules/react-router/es/Router.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Router__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanM/Njg5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Router.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/StaticRouter.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-router-dom/es/StaticRouter.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_StaticRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/StaticRouter */ \"./node_modules/react-router/es/StaticRouter.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_StaticRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanM/YmFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/StaticRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Switch.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router-dom/es/Switch.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Switch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Switch */ \"./node_modules/react-router/es/Switch.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Switch__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanM/OGNhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Switch.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/index.js":
/*!***************************************************!*\
  !*** ./node_modules/react-router-dom/es/index.js ***!
  \***************************************************/
/*! exports provided: BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Redirect, Route, Router, StaticRouter, Switch, matchPath, withRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _BrowserRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrowserRouter */ \"./node_modules/react-router-dom/es/BrowserRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BrowserRouter\", function() { return _BrowserRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _HashRouter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HashRouter */ \"./node_modules/react-router-dom/es/HashRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HashRouter\", function() { return _HashRouter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _Link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Link */ \"./node_modules/react-router-dom/es/Link.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Link\", function() { return _Link__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _MemoryRouter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MemoryRouter */ \"./node_modules/react-router-dom/es/MemoryRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MemoryRouter\", function() { return _MemoryRouter__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _NavLink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NavLink */ \"./node_modules/react-router-dom/es/NavLink.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NavLink\", function() { return _NavLink__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _Prompt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Prompt */ \"./node_modules/react-router-dom/es/Prompt.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Prompt\", function() { return _Prompt__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _Redirect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Redirect */ \"./node_modules/react-router-dom/es/Redirect.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Redirect\", function() { return _Redirect__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _Route__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Route */ \"./node_modules/react-router-dom/es/Route.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Route\", function() { return _Route__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router-dom/es/Router.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return _Router__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _StaticRouter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./StaticRouter */ \"./node_modules/react-router-dom/es/StaticRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StaticRouter\", function() { return _StaticRouter__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _Switch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Switch */ \"./node_modules/react-router-dom/es/Switch.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Switch\", function() { return _Switch__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./matchPath */ \"./node_modules/react-router-dom/es/matchPath.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"matchPath\", function() { return _matchPath__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _withRouter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./withRouter */ \"./node_modules/react-router-dom/es/withRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"withRouter\", function() { return _withRouter__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzPzc4ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/index.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/matchPath.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-router-dom/es/matchPath.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_matchPath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/matchPath */ \"./node_modules/react-router/es/matchPath.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_matchPath__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanM/NTQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoJztcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/matchPath.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/withRouter.js":
/*!********************************************************!*\
  !*** ./node_modules/react-router-dom/es/withRouter.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_withRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/withRouter */ \"./node_modules/react-router/es/withRouter.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_withRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qcz9jMDhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgd2l0aFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhSb3V0ZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/withRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/MemoryRouter.js":
/*!******************************************************!*\
  !*** ./node_modules/react-router/es/MemoryRouter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createMemoryHistory */ \"./node_modules/history/createMemoryHistory.js\");\n/* harmony import */ var history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router/es/Router.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\n\nvar MemoryRouter = function (_React$Component) {\n  _inherits(MemoryRouter, _React$Component);\n\n  function MemoryRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, MemoryRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  MemoryRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');\n  };\n\n  MemoryRouter.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { history: this.history, children: this.props.children });\n  };\n\n  return MemoryRouter;\n}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);\n\nMemoryRouter.propTypes = {\n  initialEntries: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  initialIndex: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MemoryRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyLmpzP2YxNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5Um91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/MemoryRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Prompt.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/es/Prompt.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_2__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n/**\n * The public API for prompting the user before navigating away\n * from a screen with a component.\n */\n\nvar Prompt = function (_React$Component) {\n  _inherits(Prompt, _React$Component);\n\n  function Prompt() {\n    _classCallCheck(this, Prompt);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Prompt.prototype.enable = function enable(message) {\n    if (this.unblock) this.unblock();\n\n    this.unblock = this.context.router.history.block(message);\n  };\n\n  Prompt.prototype.disable = function disable() {\n    if (this.unblock) {\n      this.unblock();\n      this.unblock = null;\n    }\n  };\n\n  Prompt.prototype.componentWillMount = function componentWillMount() {\n    invariant__WEBPACK_IMPORTED_MODULE_2___default()(this.context.router, 'You should not use <Prompt> outside a <Router>');\n\n    if (this.props.when) this.enable(this.props.message);\n  };\n\n  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (nextProps.when) {\n      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);\n    } else {\n      this.disable();\n    }\n  };\n\n  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.disable();\n  };\n\n  Prompt.prototype.render = function render() {\n    return null;\n  };\n\n  return Prompt;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nPrompt.propTypes = {\n  when: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  message: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string]).isRequired\n};\nPrompt.defaultProps = {\n  when: true\n};\nPrompt.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n      block: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired\n    }).isRequired\n  }).isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Prompt);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzPzJkNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXlcbiAqIGZyb20gYSBzY3JlZW4gd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUHJvbXB0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb21wdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUHJvbXB0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9tcHQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQcm9tcHQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykgdGhpcy51bmJsb2NrKCk7XG5cbiAgICB0aGlzLnVuYmxvY2sgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuYmxvY2sobWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB7XG4gICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgIHRoaXMudW5ibG9jayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxQcm9tcHQ+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMud2hlbikgdGhpcy5lbmFibGUodGhpcy5wcm9wcy5tZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMud2hlbikge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLndoZW4gfHwgdGhpcy5wcm9wcy5tZXNzYWdlICE9PSBuZXh0UHJvcHMubWVzc2FnZSkgdGhpcy5lbmFibGUobmV4dFByb3BzLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQcm9tcHQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblByb21wdC5wcm9wVHlwZXMgPSB7XG4gIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICBtZXNzYWdlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWRcbn07XG5Qcm9tcHQuZGVmYXVsdFByb3BzID0ge1xuICB3aGVuOiB0cnVlXG59O1xuUHJvbXB0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBibG9jazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Prompt.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Redirect.js":
/*!**************************************************!*\
  !*** ./node_modules/react-router/es/Redirect.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! history */ \"./node_modules/history/es/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for updating the location programmatically\n * with a component.\n */\n\nvar Redirect = function (_React$Component) {\n  _inherits(Redirect, _React$Component);\n\n  function Redirect() {\n    _classCallCheck(this, Redirect);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Redirect.prototype.isStatic = function isStatic() {\n    return this.context.router && this.context.router.staticContext;\n  };\n\n  Redirect.prototype.componentWillMount = function componentWillMount() {\n    invariant__WEBPACK_IMPORTED_MODULE_3___default()(this.context.router, 'You should not use <Redirect> outside a <Router>');\n\n    if (this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var prevTo = Object(history__WEBPACK_IMPORTED_MODULE_4__[\"createLocation\"])(prevProps.to);\n    var nextTo = Object(history__WEBPACK_IMPORTED_MODULE_4__[\"createLocation\"])(this.props.to);\n\n    if (Object(history__WEBPACK_IMPORTED_MODULE_4__[\"locationsAreEqual\"])(prevTo, nextTo)) {\n      warning__WEBPACK_IMPORTED_MODULE_2___default()(false, 'You tried to redirect to the same route you\\'re currently on: ' + ('\"' + nextTo.pathname + nextTo.search + '\"'));\n      return;\n    }\n\n    this.perform();\n  };\n\n  Redirect.prototype.perform = function perform() {\n    var history = this.context.router.history;\n    var _props = this.props,\n        push = _props.push,\n        to = _props.to;\n\n\n    if (push) {\n      history.push(to);\n    } else {\n      history.replace(to);\n    }\n  };\n\n  Redirect.prototype.render = function render() {\n    return null;\n  };\n\n  return Redirect;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nRedirect.propTypes = {\n  push: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  from: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object]).isRequired\n};\nRedirect.defaultProps = {\n  push: false\n};\nRedirect.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n      push: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n      replace: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired\n    }).isRequired,\n    staticContext: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object\n  }).isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Redirect);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcz85OGJjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJ2hpc3RvcnknO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciB1cGRhdGluZyB0aGUgbG9jYXRpb24gcHJvZ3JhbW1hdGljYWxseVxuICogd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVkaXJlY3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWRpcmVjdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5pc1N0YXRpYyA9IGZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm91dGVyICYmIHRoaXMuY29udGV4dC5yb3V0ZXIuc3RhdGljQ29udGV4dDtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSZWRpcmVjdD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICBpZiAodGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcHJldlRvID0gY3JlYXRlTG9jYXRpb24ocHJldlByb3BzLnRvKTtcbiAgICB2YXIgbmV4dFRvID0gY3JlYXRlTG9jYXRpb24odGhpcy5wcm9wcy50byk7XG5cbiAgICBpZiAobG9jYXRpb25zQXJlRXF1YWwocHJldlRvLCBuZXh0VG8pKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnWW91IHRyaWVkIHRvIHJlZGlyZWN0IHRvIHRoZSBzYW1lIHJvdXRlIHlvdVxcJ3JlIGN1cnJlbnRseSBvbjogJyArICgnXCInICsgbmV4dFRvLnBhdGhuYW1lICsgbmV4dFRvLnNlYXJjaCArICdcIicpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIHBlcmZvcm0oKSB7XG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHB1c2ggPSBfcHJvcHMucHVzaCxcbiAgICAgICAgdG8gPSBfcHJvcHMudG87XG5cblxuICAgIGlmIChwdXNoKSB7XG4gICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgIH1cbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZWRpcmVjdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVkaXJlY3QucHJvcFR5cGVzID0ge1xuICBwdXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkXG59O1xuUmVkaXJlY3QuZGVmYXVsdFByb3BzID0ge1xuICBwdXNoOiBmYWxzZVxufTtcblJlZGlyZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJlZGlyZWN0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Redirect.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Route.js":
/*!***********************************************!*\
  !*** ./node_modules/react-router/es/Route.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matchPath */ \"./node_modules/react-router/es/matchPath.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.count(children) === 0;\n};\n\n/**\n * The public API for matching a single path and rendering.\n */\n\nvar Route = function (_React$Component) {\n  _inherits(Route, _React$Component);\n\n  function Route() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Route);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props, _this.context.router)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Route.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        route: {\n          location: this.props.location || this.context.router.route.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Route.prototype.computeMatch = function computeMatch(_ref, router) {\n    var computedMatch = _ref.computedMatch,\n        location = _ref.location,\n        path = _ref.path,\n        strict = _ref.strict,\n        exact = _ref.exact,\n        sensitive = _ref.sensitive;\n\n    if (computedMatch) return computedMatch; // <Switch> already computed the match for us\n\n    invariant__WEBPACK_IMPORTED_MODULE_1___default()(router, 'You should not use <Route> or withRouter() outside a <Router>');\n\n    var route = router.route;\n\n    var pathname = (location || route.location).pathname;\n\n    return path ? Object(_matchPath__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;\n  };\n\n  Route.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');\n  };\n\n  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n\n    this.setState({\n      match: this.computeMatch(nextProps, nextContext.router)\n    });\n  };\n\n  Route.prototype.render = function render() {\n    var match = this.state.match;\n    var _props = this.props,\n        children = _props.children,\n        component = _props.component,\n        render = _props.render;\n    var _context$router = this.context.router,\n        history = _context$router.history,\n        route = _context$router.route,\n        staticContext = _context$router.staticContext;\n\n    var location = this.props.location || route.location;\n    var props = { match: match, location: location, history: history, staticContext: staticContext };\n\n    return component ? // component prop gets first priority, only called if there's a match\n    match ? react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(component, props) : null : render ? // render prop is next, only called if there's a match\n    match ? render(props) : null : children ? // children come last, always called\n    typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.only(children) : null : null;\n  };\n\n  return Route;\n}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\nRoute.propTypes = {\n  computedMatch: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object, // private, from <Switch>\n  path: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,\n  exact: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,\n  strict: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,\n  sensitive: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,\n  component: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,\n  render: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node]),\n  location: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object\n};\nRoute.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n    route: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n    staticContext: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object\n  })\n};\nRoute.childContextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Route);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcz9lMjllIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG52YXIgaXNFbXB0eUNoaWxkcmVuID0gZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIHNpbmdsZSBwYXRoIGFuZCByZW5kZXJpbmcuXG4gKi9cblxudmFyIFJvdXRlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMsIF90aGlzLmNvbnRleHQucm91dGVyKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGUucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHRoaXMuY29udGV4dC5yb3V0ZXIucm91dGUubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2goX3JlZiwgcm91dGVyKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgICAgc2Vuc2l0aXZlID0gX3JlZi5zZW5zaXRpdmU7XG5cbiAgICBpZiAoY29tcHV0ZWRNYXRjaCkgcmV0dXJuIGNvbXB1dGVkTWF0Y2g7IC8vIDxTd2l0Y2g+IGFscmVhZHkgY29tcHV0ZWQgdGhlIG1hdGNoIGZvciB1c1xuXG4gICAgaW52YXJpYW50KHJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG9yIHdpdGhSb3V0ZXIoKSBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciByb3V0ZSA9IHJvdXRlci5yb3V0ZTtcblxuICAgIHZhciBwYXRobmFtZSA9IChsb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbikucGF0aG5hbWU7XG5cbiAgICByZXR1cm4gcGF0aCA/IG1hdGNoUGF0aChwYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBzdHJpY3Q6IHN0cmljdCwgZXhhY3Q6IGV4YWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSA6IHJvdXRlLm1hdGNoO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMucmVuZGVyKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5yZW5kZXIgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgcmVuZGVyPiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgIHdhcm5pbmcoIShuZXh0UHJvcHMubG9jYXRpb24gJiYgIXRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbWF0Y2g6IHRoaXMuY29tcHV0ZU1hdGNoKG5leHRQcm9wcywgbmV4dENvbnRleHQucm91dGVyKVxuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5zdGF0ZS5tYXRjaDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wcy5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wcy5yZW5kZXI7XG4gICAgdmFyIF9jb250ZXh0JHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXIsXG4gICAgICAgIGhpc3RvcnkgPSBfY29udGV4dCRyb3V0ZXIuaGlzdG9yeSxcbiAgICAgICAgcm91dGUgPSBfY29udGV4dCRyb3V0ZXIucm91dGUsXG4gICAgICAgIHN0YXRpY0NvbnRleHQgPSBfY29udGV4dCRyb3V0ZXIuc3RhdGljQ29udGV4dDtcblxuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMucHJvcHMubG9jYXRpb24gfHwgcm91dGUubG9jYXRpb247XG4gICAgdmFyIHByb3BzID0geyBtYXRjaDogbWF0Y2gsIGxvY2F0aW9uOiBsb2NhdGlvbiwgaGlzdG9yeTogaGlzdG9yeSwgc3RhdGljQ29udGV4dDogc3RhdGljQ29udGV4dCB9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudCA/IC8vIGNvbXBvbmVudCBwcm9wIGdldHMgZmlyc3QgcHJpb3JpdHksIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IG51bGwgOiByZW5kZXIgPyAvLyByZW5kZXIgcHJvcCBpcyBuZXh0LCBvbmx5IGNhbGxlZCBpZiB0aGVyZSdzIGEgbWF0Y2hcbiAgICBtYXRjaCA/IHJlbmRlcihwcm9wcykgOiBudWxsIDogY2hpbGRyZW4gPyAvLyBjaGlsZHJlbiBjb21lIGxhc3QsIGFsd2F5cyBjYWxsZWRcbiAgICB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihwcm9wcykgOiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbCA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZS5wcm9wVHlwZXMgPSB7XG4gIGNvbXB1dGVkTWF0Y2g6IFByb3BUeXBlcy5vYmplY3QsIC8vIHByaXZhdGUsIGZyb20gPFN3aXRjaD5cbiAgcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICBjb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ub2RlXSksXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGUuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KVxufTtcblJvdXRlLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Route.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Router.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/es/Router.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n/**\n * The public API for putting history on context.\n */\n\nvar Router = function (_React$Component) {\n  _inherits(Router, _React$Component);\n\n  function Router() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Router);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props.history.location.pathname)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Router.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        history: this.props.history,\n        route: {\n          location: this.props.history.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Router.prototype.computeMatch = function computeMatch(pathname) {\n    return {\n      path: '/',\n      url: '/',\n      params: {},\n      isExact: pathname === '/'\n    };\n  };\n\n  Router.prototype.componentWillMount = function componentWillMount() {\n    var _this2 = this;\n\n    var _props = this.props,\n        children = _props.children,\n        history = _props.history;\n\n\n    invariant__WEBPACK_IMPORTED_MODULE_1___default()(children == null || react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.count(children) === 1, 'A <Router> may have only one child element');\n\n    // Do this here so we can setState when a <Redirect> changes the\n    // location in componentWillMount. This happens e.g. when doing\n    // server rendering using a <StaticRouter>.\n    this.unlisten = history.listen(function () {\n      _this2.setState({\n        match: _this2.computeMatch(history.location.pathname)\n      });\n    });\n  };\n\n  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(this.props.history === nextProps.history, 'You cannot change <Router history>');\n  };\n\n  Router.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.unlisten();\n  };\n\n  Router.prototype.render = function render() {\n    var children = this.props.children;\n\n    return children ? react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.only(children) : null;\n  };\n\n  return Router;\n}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\nRouter.propTypes = {\n  history: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node\n};\nRouter.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object\n};\nRouter.childContextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Router);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGVyLmpzPzllYmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChwYXRobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiAnLycsXG4gICAgICB1cmw6ICcvJyxcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0V4YWN0OiBwYXRobmFtZSA9PT0gJy8nXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuXG5cbiAgICBpbnZhcmlhbnQoY2hpbGRyZW4gPT0gbnVsbCB8fCBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDEsICdBIDxSb3V0ZXI+IG1heSBoYXZlIG9ubHkgb25lIGNoaWxkIGVsZW1lbnQnKTtcblxuICAgIC8vIERvIHRoaXMgaGVyZSBzbyB3ZSBjYW4gc2V0U3RhdGUgd2hlbiBhIDxSZWRpcmVjdD4gY2hhbmdlcyB0aGVcbiAgICAvLyBsb2NhdGlvbiBpbiBjb21wb25lbnRXaWxsTW91bnQuIFRoaXMgaGFwcGVucyBlLmcuIHdoZW4gZG9pbmdcbiAgICAvLyBzZXJ2ZXIgcmVuZGVyaW5nIHVzaW5nIGEgPFN0YXRpY1JvdXRlcj4uXG4gICAgdGhpcy51bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgIG1hdGNoOiBfdGhpczIuY29tcHV0ZU1hdGNoKGhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHdhcm5pbmcodGhpcy5wcm9wcy5oaXN0b3J5ID09PSBuZXh0UHJvcHMuaGlzdG9yeSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT4nKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmxpc3RlbigpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICByZXR1cm4gY2hpbGRyZW4gPyBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5Sb3V0ZXIuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Router.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/StaticRouter.js":
/*!******************************************************!*\
  !*** ./node_modules/react-router/es/StaticRouter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var history_PathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! history/PathUtils */ \"./node_modules/history/PathUtils.js\");\n/* harmony import */ var history_PathUtils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router/es/Router.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n\nvar normalizeLocation = function normalizeLocation(object) {\n  var _object$pathname = object.pathname,\n      pathname = _object$pathname === undefined ? '/' : _object$pathname,\n      _object$search = object.search,\n      search = _object$search === undefined ? '' : _object$search,\n      _object$hash = object.hash,\n      hash = _object$hash === undefined ? '' : _object$hash;\n\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar addBasename = function addBasename(basename, location) {\n  if (!basename) return location;\n\n  return _extends({}, location, {\n    pathname: Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"addLeadingSlash\"])(basename) + location.pathname\n  });\n};\n\nvar stripBasename = function stripBasename(basename, location) {\n  if (!basename) return location;\n\n  var base = Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"addLeadingSlash\"])(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return _extends({}, location, {\n    pathname: location.pathname.substr(base.length)\n  });\n};\n\nvar createLocation = function createLocation(location) {\n  return typeof location === 'string' ? Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"parsePath\"])(location) : normalizeLocation(location);\n};\n\nvar createURL = function createURL(location) {\n  return typeof location === 'string' ? location : Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"createPath\"])(location);\n};\n\nvar staticHandler = function staticHandler(methodName) {\n  return function () {\n    invariant__WEBPACK_IMPORTED_MODULE_1___default()(false, 'You cannot %s with <StaticRouter>', methodName);\n  };\n};\n\nvar noop = function noop() {};\n\n/**\n * The public top-level API for a \"static\" <Router>, so-called because it\n * can't actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\n\nvar StaticRouter = function (_React$Component) {\n  _inherits(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, StaticRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {\n      return Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"addLeadingSlash\"])(_this.props.basename + createURL(path));\n    }, _this.handlePush = function (location) {\n      var _this$props = _this.props,\n          basename = _this$props.basename,\n          context = _this$props.context;\n\n      context.action = 'PUSH';\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, _this.handleReplace = function (location) {\n      var _this$props2 = _this.props,\n          basename = _this$props2.basename,\n          context = _this$props2.context;\n\n      context.action = 'REPLACE';\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, _this.handleListen = function () {\n      return noop;\n    }, _this.handleBlock = function () {\n      return noop;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  StaticRouter.prototype.getChildContext = function getChildContext() {\n    return {\n      router: {\n        staticContext: this.props.context\n      }\n    };\n  };\n\n  StaticRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');\n  };\n\n  StaticRouter.prototype.render = function render() {\n    var _props = this.props,\n        basename = _props.basename,\n        context = _props.context,\n        location = _props.location,\n        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);\n\n    var history = {\n      createHref: this.createHref,\n      action: 'POP',\n      location: stripBasename(basename, createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler('go'),\n      goBack: staticHandler('goBack'),\n      goForward: staticHandler('goForward'),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _extends({}, props, { history: history }));\n  };\n\n  return StaticRouter;\n}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\nStaticRouter.propTypes = {\n  basename: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,\n  context: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n  location: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object])\n};\nStaticRouter.defaultProps = {\n  basename: '',\n  location: '/'\n};\nStaticRouter.childContextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StaticRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzP2M5Y2MiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIGNyZWF0ZVBhdGgsIHBhcnNlUGF0aCB9IGZyb20gJ2hpc3RvcnkvUGF0aFV0aWxzJztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG52YXIgbm9ybWFsaXplTG9jYXRpb24gPSBmdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbihvYmplY3QpIHtcbiAgdmFyIF9vYmplY3QkcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUsXG4gICAgICBwYXRobmFtZSA9IF9vYmplY3QkcGF0aG5hbWUgPT09IHVuZGVmaW5lZCA/ICcvJyA6IF9vYmplY3QkcGF0aG5hbWUsXG4gICAgICBfb2JqZWN0JHNlYXJjaCA9IG9iamVjdC5zZWFyY2gsXG4gICAgICBzZWFyY2ggPSBfb2JqZWN0JHNlYXJjaCA9PT0gdW5kZWZpbmVkID8gJycgOiBfb2JqZWN0JHNlYXJjaCxcbiAgICAgIF9vYmplY3QkaGFzaCA9IG9iamVjdC5oYXNoLFxuICAgICAgaGFzaCA9IF9vYmplY3QkaGFzaCA9PT0gdW5kZWZpbmVkID8gJycgOiBfb2JqZWN0JGhhc2g7XG5cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgYWRkQmFzZW5hbWUgPSBmdW5jdGlvbiBhZGRCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKSArIGxvY2F0aW9uLnBhdGhuYW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgdmFyIGJhc2UgPSBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpO1xuXG4gIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2UpICE9PSAwKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHIoYmFzZS5sZW5ndGgpXG4gIH0pO1xufTtcblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgobG9jYXRpb24pIDogbm9ybWFsaXplTG9jYXRpb24obG9jYXRpb24pO1xufTtcblxudmFyIGNyZWF0ZVVSTCA9IGZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/IGxvY2F0aW9uIDogY3JlYXRlUGF0aChsb2NhdGlvbik7XG59O1xuXG52YXIgc3RhdGljSGFuZGxlciA9IGZ1bmN0aW9uIHN0YXRpY0hhbmRsZXIobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChmYWxzZSwgJ1lvdSBjYW5ub3QgJXMgd2l0aCA8U3RhdGljUm91dGVyPicsIG1ldGhvZE5hbWUpO1xuICB9O1xufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG52YXIgU3RhdGljUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGljUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nU2xhc2goX3RoaXMucHJvcHMuYmFzZW5hbWUgKyBjcmVhdGVVUkwocGF0aCkpO1xuICAgIH0sIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1BVU0gnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wczIuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVMaXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGhpcy5oYW5kbGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjoge1xuICAgICAgICBzdGF0aWNDb250ZXh0OiB0aGlzLnByb3BzLmNvbnRleHRcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxTdGF0aWNSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgU3RhdGljUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZW5hbWUgPSBfcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgIGNvbnRleHQgPSBfcHJvcHMuY29udGV4dCxcbiAgICAgICAgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydiYXNlbmFtZScsICdjb250ZXh0JywgJ2xvY2F0aW9uJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiB0aGlzLmNyZWF0ZUhyZWYsXG4gICAgICBhY3Rpb246ICdQT1AnLFxuICAgICAgbG9jYXRpb246IHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSksXG4gICAgICBwdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICByZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXG4gICAgICBnbzogc3RhdGljSGFuZGxlcignZ28nKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcignZ29CYWNrJyksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoJ2dvRm9yd2FyZCcpLFxuICAgICAgbGlzdGVuOiB0aGlzLmhhbmRsZUxpc3RlbixcbiAgICAgIGJsb2NrOiB0aGlzLmhhbmRsZUJsb2NrXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7IGhpc3Rvcnk6IGhpc3RvcnkgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGF0aWNSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN0YXRpY1JvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSlcbn07XG5TdGF0aWNSb3V0ZXIuZGVmYXVsdFByb3BzID0ge1xuICBiYXNlbmFtZTogJycsXG4gIGxvY2F0aW9uOiAnLydcbn07XG5TdGF0aWNSb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY1JvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/StaticRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Switch.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/es/Switch.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matchPath */ \"./node_modules/react-router/es/matchPath.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\n\nvar Switch = function (_React$Component) {\n  _inherits(Switch, _React$Component);\n\n  function Switch() {\n    _classCallCheck(this, Switch);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Switch.prototype.componentWillMount = function componentWillMount() {\n    invariant__WEBPACK_IMPORTED_MODULE_3___default()(this.context.router, 'You should not use <Switch> outside a <Router>');\n  };\n\n  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    warning__WEBPACK_IMPORTED_MODULE_2___default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n\n    warning__WEBPACK_IMPORTED_MODULE_2___default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n  };\n\n  Switch.prototype.render = function render() {\n    var route = this.context.router.route;\n    var children = this.props.children;\n\n    var location = this.props.location || route.location;\n\n    var match = void 0,\n        child = void 0;\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.forEach(children, function (element) {\n      if (!react__WEBPACK_IMPORTED_MODULE_0___default.a.isValidElement(element)) return;\n\n      var _element$props = element.props,\n          pathProp = _element$props.path,\n          exact = _element$props.exact,\n          strict = _element$props.strict,\n          sensitive = _element$props.sensitive,\n          from = _element$props.from;\n\n      var path = pathProp || from;\n\n      if (match == null) {\n        child = element;\n        match = path ? Object(_matchPath__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;\n      }\n    });\n\n    return match ? react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, { location: location, computedMatch: match }) : null;\n  };\n\n  return Switch;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nSwitch.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    route: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired\n  }).isRequired\n};\nSwitch.propTypes = {\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node,\n  location: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Switch);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N3aXRjaC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzP2NhODIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyB0aGUgZmlyc3QgPFJvdXRlPiB0aGF0IG1hdGNoZXMuXG4gKi9cblxudmFyIFN3aXRjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTd2l0Y2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3dpdGNoKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFN3aXRjaD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBjaGlsZCA9IHZvaWQgMDtcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2VsZW1lbnQkcHJvcHMgPSBlbGVtZW50LnByb3BzLFxuICAgICAgICAgIHBhdGhQcm9wID0gX2VsZW1lbnQkcHJvcHMucGF0aCxcbiAgICAgICAgICBleGFjdCA9IF9lbGVtZW50JHByb3BzLmV4YWN0LFxuICAgICAgICAgIHN0cmljdCA9IF9lbGVtZW50JHByb3BzLnN0cmljdCxcbiAgICAgICAgICBzZW5zaXRpdmUgPSBfZWxlbWVudCRwcm9wcy5zZW5zaXRpdmUsXG4gICAgICAgICAgZnJvbSA9IF9lbGVtZW50JHByb3BzLmZyb207XG5cbiAgICAgIHZhciBwYXRoID0gcGF0aFByb3AgfHwgZnJvbTtcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgZXhhY3Q6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSkgOiByb3V0ZS5tYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaCA/IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyBsb2NhdGlvbjogbG9jYXRpb24sIGNvbXB1dGVkTWF0Y2g6IG1hdGNoIH0pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Td2l0Y2guY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuU3dpdGNoLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Switch.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/matchPath.js":
/*!***************************************************!*\
  !*** ./node_modules/react-router/es/matchPath.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-to-regexp */ \"./node_modules/react-router/node_modules/path-to-regexp/index.js\");\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_to_regexp__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = '' + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  var keys = [];\n  var re = path_to_regexp__WEBPACK_IMPORTED_MODULE_0___default()(pattern, keys, options);\n  var compiledPattern = { re: re, keys: keys };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options === 'string') options = { path: options };\n\n  var _options = options,\n      _options$path = _options.path,\n      path = _options$path === undefined ? '/' : _options$path,\n      _options$exact = _options.exact,\n      exact = _options$exact === undefined ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === undefined ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === undefined ? false : _options$sensitive;\n\n  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),\n      re = _compilePath.re,\n      keys = _compilePath.keys;\n\n  var match = re.exec(pathname);\n\n  if (!match) return null;\n\n  var url = match[0],\n      values = match.slice(1);\n\n  var isExact = pathname === url;\n\n  if (exact && !isExact) return null;\n\n  return {\n    path: path, // the path pattern used to match\n    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n    isExact: isExact, // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (matchPath);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoLmpzPzRhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG5cbnZhciBwYXR0ZXJuQ2FjaGUgPSB7fTtcbnZhciBjYWNoZUxpbWl0ID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCA9IDA7XG5cbnZhciBjb21waWxlUGF0aCA9IGZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gJycgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0ICsgb3B0aW9ucy5zZW5zaXRpdmU7XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHBhdHRlcm4sIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0geyByZTogcmUsIGtleXM6IGtleXMgfTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkUGF0dGVybjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGggcGF0dGVybi5cbiAqL1xudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykgb3B0aW9ucyA9IHsgcGF0aDogb3B0aW9ucyB9O1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIHBhdGggPSBfb3B0aW9ucyRwYXRoID09PSB1bmRlZmluZWQgPyAnLycgOiBfb3B0aW9ucyRwYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0LFxuICAgICAgX29wdGlvbnMkc2Vuc2l0aXZlID0gX29wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgc2Vuc2l0aXZlID0gX29wdGlvbnMkc2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHNlbnNpdGl2ZTtcblxuICB2YXIgX2NvbXBpbGVQYXRoID0gY29tcGlsZVBhdGgocGF0aCwgeyBlbmQ6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSksXG4gICAgICByZSA9IF9jb21waWxlUGF0aC5yZSxcbiAgICAgIGtleXMgPSBfY29tcGlsZVBhdGgua2V5cztcblxuICB2YXIgbWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcblxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgdXJsID0gbWF0Y2hbMF0sXG4gICAgICB2YWx1ZXMgPSBtYXRjaC5zbGljZSgxKTtcblxuICB2YXIgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG5cbiAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsIC8vIHRoZSBwYXRoIHBhdHRlcm4gdXNlZCB0byBtYXRjaFxuICAgIHVybDogcGF0aCA9PT0gJy8nICYmIHVybCA9PT0gJycgPyAnLycgOiB1cmwsIC8vIHRoZSBtYXRjaGVkIHBvcnRpb24gb2YgdGhlIFVSTFxuICAgIGlzRXhhY3Q6IGlzRXhhY3QsIC8vIHdoZXRoZXIgb3Igbm90IHdlIG1hdGNoZWQgZXhhY3RseVxuICAgIHBhcmFtczoga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSwgaW5kZXgpIHtcbiAgICAgIG1lbW9ba2V5Lm5hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/matchPath.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/withRouter.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router/es/withRouter.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/index.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Route__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Route */ \"./node_modules/react-router/es/Route.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n\n\n\n\n\n/**\n * A public higher-order component to access the imperative API\n */\nvar withRouter = function withRouter(Component) {\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);\n\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Route__WEBPACK_IMPORTED_MODULE_3__[\"default\"], { render: function render(routeComponentProps) {\n        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));\n      } });\n  };\n\n  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';\n  C.WrappedComponent = Component;\n  C.propTypes = {\n    wrappedComponentRef: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n  };\n\n  return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(C, Component);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (withRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanM/ZjQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgWyd3cmFwcGVkQ29tcG9uZW50UmVmJ10pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHsgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywgeyByZWY6IHdyYXBwZWRDb21wb25lbnRSZWYgfSkpO1xuICAgICAgfSB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgJyknO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/withRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/node_modules/isarray/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-router/node_modules/isarray/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lZDA3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/react-router/node_modules/path-to-regexp/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-router/node_modules/path-to-regexp/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isarray = __webpack_require__(/*! isarray */ \"./node_modules/react-router/node_modules/isarray/index.js\")\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzP2YyZDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzYXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW11cbiAgdmFyIGtleSA9IDBcbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgcGF0aCA9ICcnXG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLydcbiAgdmFyIHJlc1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIHByZWZpeCA9IHJlc1syXVxuICAgIHZhciBuYW1lID0gcmVzWzNdXG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cbiAgICB2YXIgZ3JvdXAgPSByZXNbNV1cbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl1cbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pXG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKVxuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2VcbiAgdmFyIHJvdXRlID0gJydcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJ1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonXG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSdcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKVxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlclxuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nXG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJ1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/node_modules/path-to-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.3.2\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.3.2';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol['for']('react.strict_mode') : 0xeacc;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol['for']('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol['for']('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol['for']('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol['for']('react.forward_ref') : 0xead0;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warning(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n  {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown = void 0;\nvar specialPropRefWarningShown = void 0;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName = void 0;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\n\n  var propName = void 0;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps = void 0;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar ReactDebugCurrentFrame = {};\n\n{\n  // Component that is being worked on\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      return impl();\n    }\n    return null;\n  };\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child = void 0;\n  var nextName = void 0;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step = void 0;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.toarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    _defaultValue: defaultValue,\n    _currentValue: defaultValue,\n    _changedBits: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  context.Consumer = context;\n\n  {\n    context._currentRenderer = null;\n  }\n\n  return context;\n}\n\nfunction forwardRef(render) {\n  {\n    !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render) : void 0;\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'ReactFragment';\n    case REACT_PORTAL_TYPE:\n      return 'ReactPortal';\n    case REACT_CALL_TYPE:\n      return 'ReactCall';\n    case REACT_RETURN_TYPE:\n      return 'ReactReturn';\n  }\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || '';\n        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    }\n  }\n  return null;\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nvar currentlyValidatingElement = void 0;\nvar propTypesMisspellWarningShown = void 0;\n\nvar getDisplayName = function () {};\nvar getStackAddendum = function () {};\n\n{\n  currentlyValidatingElement = null;\n\n  propTypesMisspellWarningShown = false;\n\n  getDisplayName = function (element) {\n    if (element == null) {\n      return '#empty';\n    } else if (typeof element === 'string' || typeof element === 'number') {\n      return '#text';\n    } else if (typeof element.type === 'string') {\n      return element.type;\n    } else if (element.type === REACT_FRAGMENT_TYPE) {\n      return 'React.Fragment';\n    } else {\n      return element.type.displayName || element.type.name || 'Unknown';\n    }\n  };\n\n  getStackAddendum = function () {\n    var stack = '';\n    if (currentlyValidatingElement) {\n      var name = getDisplayName(currentlyValidatingElement);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n    }\n    stack += ReactDebugCurrentFrame.getStackAddendum() || '';\n    return stack;\n  };\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n  }\n\n  currentlyValidatingElement = element;\n  {\n    warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\n  }\n  currentlyValidatingElement = null;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step = void 0;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var componentClass = element.type;\n  if (typeof componentClass !== 'function') {\n    return;\n  }\n  var name = componentClass.displayName || componentClass.name;\n  var propTypes = componentClass.propTypes;\n  if (propTypes) {\n    currentlyValidatingElement = element;\n    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\n    currentlyValidatingElement = null;\n  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    !componentClass.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  currentlyValidatingElement = fragment;\n\n  var keys = Object.keys(fragment.props);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\n  }\n\n  currentlyValidatingElement = null;\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    info += getStackAddendum() || '';\n\n    var typeString = void 0;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  createRef: createRef,\n  Component: Component,\n  PureComponent: PureComponent,\n\n  createContext: createContext,\n  forwardRef: forwardRef,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: ReactCurrentOwner,\n    // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n    assign: _assign\n  }\n};\n\n{\n  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3['default'] ? React$3['default'] : React$3;\n\nmodule.exports = react;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcz83MmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMy4yXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4zLjInO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gaGF2ZSBwcmVzZXJ2ZSB0aGUgZm9ybWF0IGFuZCBwYXJhbXMgaW4gdGhlIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICVzLicsIGVsZW1lbnQpIDogdm9pZCAwO1xuXG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgdmFyIG5leHROYW1lID0gdm9pZCAwO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgICEoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IG51bGwgfHwgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2NoYW5nZWRCaXRzOiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG5cbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICBjb250ZXh0LkNvbnN1bWVyID0gY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgISh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdENhbGwnO1xuICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UmV0dXJuJztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IHZvaWQgMDtcbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHZvaWQgMDtcblxudmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge307XG52YXIgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXG4gIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyKSArICcuJztcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgdmFyIHByb3BUeXBlcyA9IGNvbXBvbmVudENsYXNzLnByb3BUeXBlcztcbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudENsYXNzLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA/IHdhcm5pbmcoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLiVzJywga2V5LCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiVzJywgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpO1xuXG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIGluZm8gKz0gZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuXG4gICAgdmFyIHR5cGVTdHJpbmcgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcbiAgLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgY3JlYXRlUmVmOiBjcmVhdGVSZWYsXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWY6IGZvcndhcmRSZWYsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gIFN0cmljdE1vZGU6IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX0FzeW5jTW9kZTogUkVBQ1RfQVNZTkNfTU9ERV9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBRUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/resolve-pathname/index.js":
/*!************************************************!*\
  !*** ./node_modules/resolve-pathname/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction isAbsolute(pathname) {\n  return pathname.charAt(0) === '/';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var toParts = to && to.split('/') || [];\n  var fromParts = from && from.split('/') || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return '/';\n\n  var hasTrailingSlash = void 0;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === '.' || last === '..' || last === '';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === '.') {\n      spliceOne(fromParts, i);\n    } else if (part === '..') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) {\n    fromParts.unshift('..');\n  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');\n\n  var result = fromParts.join('/');\n\n  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';\n\n  return result;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (resolvePathname);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzPzQ2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRobmFtZSkge1xuICByZXR1cm4gcGF0aG5hbWUuY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkge1xuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICB9XG5cbiAgbGlzdC5wb3AoKTtcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBoZWF2aWx5IG9uIG5vZGUncyB1cmwucGFyc2VcbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZSh0bykge1xuICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgdmFyIHRvUGFydHMgPSB0byAmJiB0by5zcGxpdCgnLycpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcvJykgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gIH1pZiAobXVzdEVuZEFicyAmJiBmcm9tUGFydHNbMF0gIT09ICcnICYmICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpKSBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlUGF0aG5hbWU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/resolve-pathname/index.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz9mNmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/value-equal/index.js":
/*!*******************************************!*\
  !*** ./node_modules/value-equal/index.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction valueEqual(a, b) {\n  if (a === b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return valueEqual(item, b[index]);\n    });\n  }\n\n  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);\n  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);\n\n  if (aType !== bType) return false;\n\n  if (aType === 'object') {\n    var aValue = a.valueOf();\n    var bValue = b.valueOf();\n\n    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);\n\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) return false;\n\n    return aKeys.every(function (key) {\n      return valueEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (valueEqual);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanM/YzNhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZUVxdWFsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/value-equal/index.js\n");

/***/ }),

/***/ "./node_modules/warning/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (true) {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcz9lODM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/warning/browser.js\n");

/***/ }),

/***/ "./src/app/about.js":
/*!**************************!*\
  !*** ./src/app/about.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\nvar About = function (_React$Component) {\n    _inherits(About, _React$Component);\n\n    function About() {\n        _classCallCheck(this, About);\n\n        return _possibleConstructorReturn(this, (About.__proto__ || Object.getPrototypeOf(About)).apply(this, arguments));\n    }\n\n    _createClass(About, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                { 'class': 'about-me' },\n                React.createElement('img', { 'class': 'img', src: 'http://mpggw.com/data/wallpapers/57/WDF_1035619.jpg' }),\n                React.createElement(\n                    'h2',\n                    null,\n                    'Hello, I\\'m Misha'\n                ),\n                React.createElement(\n                    'p',\n                    null,\n                    'Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.Why do we use it? It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using \\'Content here, content here\\', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for \\'lorem ipsum\\' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).'\n                )\n            );\n        }\n    }]);\n\n    return About;\n}(React.Component);\n\nmodule.exports = About;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Fib3V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvYWJvdXQuanM/ODMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xubGV0IFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvaW5kZXguY3NzJyk7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmNsYXNzIEFib3V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybihcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Fib3V0LW1lJz5cbiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPSdpbWcnIHNyYz0naHR0cDovL21wZ2d3LmNvbS9kYXRhL3dhbGxwYXBlcnMvNTcvV0RGXzEwMzU2MTkuanBnJy8+XG4gICAgICAgICAgICAgICAgPGgyPkhlbGxvLCBJJ20gTWlzaGE8L2gyPlxuICAgICAgICAgICAgICAgIDxwPkxvcmVtIElwc3VtIGlzIHNpbXBseSBkdW1teSB0ZXh0IG9mIHRoZSBwcmludGluZyBhbmQgdHlwZXNldHRpbmcgaW5kdXN0cnkuIExvcmVtIElwc3VtIGhhcyBiZWVuIHRoZSBpbmR1c3RyeSdzIHN0YW5kYXJkIGR1bW15IHRleHQgZXZlciBzaW5jZSB0aGUgMTUwMHMsIHdoZW4gYW4gdW5rbm93biBwcmludGVyIHRvb2sgYSBnYWxsZXkgb2YgdHlwZSBhbmQgc2NyYW1ibGVkIGl0IHRvIG1ha2UgYSB0eXBlIHNwZWNpbWVuIGJvb2suIEl0IGhhcyBzdXJ2aXZlZCBub3Qgb25seSBmaXZlIGNlbnR1cmllcywgYnV0IGFsc28gdGhlIGxlYXAgaW50byBlbGVjdHJvbmljIHR5cGVzZXR0aW5nLCByZW1haW5pbmcgZXNzZW50aWFsbHkgdW5jaGFuZ2VkLiBJdCB3YXMgcG9wdWxhcmlzZWQgaW4gdGhlIDE5NjBzIHdpdGggdGhlIHJlbGVhc2Ugb2YgTGV0cmFzZXQgc2hlZXRzIGNvbnRhaW5pbmcgTG9yZW0gSXBzdW0gcGFzc2FnZXMsIGFuZCBtb3JlIHJlY2VudGx5IHdpdGggZGVza3RvcCBwdWJsaXNoaW5nIHNvZnR3YXJlIGxpa2UgQWxkdXMgUGFnZU1ha2VyIGluY2x1ZGluZyB2ZXJzaW9ucyBvZiBMb3JlbSBJcHN1bS5XaHkgZG8gd2UgdXNlIGl0P1xuICAgICAgICAgICAgICAgICAgICBJdCBpcyBhIGxvbmcgZXN0YWJsaXNoZWQgZmFjdCB0aGF0IGEgcmVhZGVyIHdpbGwgYmUgZGlzdHJhY3RlZCBieSB0aGUgcmVhZGFibGUgY29udGVudCBvZiBhIHBhZ2Ugd2hlbiBsb29raW5nIGF0IGl0cyBsYXlvdXQuIFRoZSBwb2ludCBvZiB1c2luZyBMb3JlbSBJcHN1bSBpcyB0aGF0IGl0IGhhcyBhIG1vcmUtb3ItbGVzcyBub3JtYWwgZGlzdHJpYnV0aW9uIG9mIGxldHRlcnMsIGFzIG9wcG9zZWQgdG8gdXNpbmcgJ0NvbnRlbnQgaGVyZSwgY29udGVudCBoZXJlJywgbWFraW5nIGl0IGxvb2sgbGlrZSByZWFkYWJsZSBFbmdsaXNoLiBNYW55IGRlc2t0b3AgcHVibGlzaGluZyBwYWNrYWdlcyBhbmQgd2ViIHBhZ2UgZWRpdG9ycyBub3cgdXNlIExvcmVtIElwc3VtIGFzIHRoZWlyIGRlZmF1bHQgbW9kZWwgdGV4dCwgYW5kIGEgc2VhcmNoIGZvciAnbG9yZW0gaXBzdW0nIHdpbGwgdW5jb3ZlciBtYW55IHdlYiBzaXRlcyBzdGlsbCBpbiB0aGVpciBpbmZhbmN5LiBWYXJpb3VzIHZlcnNpb25zIGhhdmUgZXZvbHZlZCBvdmVyIHRoZSB5ZWFycywgc29tZXRpbWVzIGJ5IGFjY2lkZW50LCBzb21ldGltZXMgb24gcHVycG9zZSAoaW5qZWN0ZWQgaHVtb3VyIGFuZCB0aGUgbGlrZSkuXG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBBYm91dFxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFHQTtBQUNBOzs7Ozs7O0FBSkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQVFBOzs7O0FBWEE7QUFDQTtBQWVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/about.js\n");

/***/ }),

/***/ "./src/app/admin.js":
/*!**************************!*\
  !*** ./src/app/admin.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\nvar Admin = function (_React$Component) {\n    _inherits(Admin, _React$Component);\n\n    function Admin() {\n        _classCallCheck(this, Admin);\n\n        return _possibleConstructorReturn(this, (Admin.__proto__ || Object.getPrototypeOf(Admin)).apply(this, arguments));\n    }\n\n    _createClass(Admin, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'form',\n                    null,\n                    React.createElement(\n                        'label',\n                        null,\n                        'Username:',\n                        React.createElement('input', { type: 'text' })\n                    ),\n                    React.createElement(\n                        'label',\n                        null,\n                        'Password:',\n                        React.createElement('input', { type: 'text' })\n                    ),\n                    React.createElement('input', { type: 'submit', value: 'Login' })\n                )\n            );\n        }\n    }]);\n\n    return Admin;\n}(React.Component);\n\nmodule.exports = Admin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2FkbWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvYWRtaW4uanM/NDRiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xubGV0IFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvaW5kZXguY3NzJyk7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmNsYXNzIEFkbWluIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybihcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGZvcm0+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIFVzZXJuYW1lOlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIvPlxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICBQYXNzd29yZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIkxvZ2luXCIgLz4gXG4gICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICB9XG59XG5cblxuXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFkbWluIl0sIm1hcHBpbmdzIjoiOzs7O0FBR0E7QUFDQTs7Ozs7OztBQUpBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRkE7QUFJQTtBQVRBO0FBREE7QUFjQTs7OztBQWpCQTtBQUNBO0FBd0JBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/admin.js\n");

/***/ }),

/***/ "./src/app/css/images/bb8.jpeg":
/*!*************************************!*\
  !*** ./src/app/css/images/bb8.jpeg ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9pbWFnZXMvYmI4LmpwZWcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Nzcy9pbWFnZXMvYmI4LmpwZWc/YjlhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvNGd4WVNVTkRYMUJTVDBaSlRFVUFBUUVBQUF4SVRHbHVid0lRQUFCdGJuUnlVa2RDSUZoWldpQUh6Z0FDQUFrQUJnQXhBQUJoWTNOd1RWTkdWQUFBQUFCSlJVTWdjMUpIUWdBQUFBQUFBQUFBQUFBQUFBQUE5dFlBQVFBQUFBRFRMVWhRSUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCRmpjSEowQUFBQlVBQUFBRE5rWlhOakFBQUJoQUFBQUd4M2RIQjBBQUFCOEFBQUFCUmlhM0IwQUFBQ0JBQUFBQlJ5V0ZsYUFBQUNHQUFBQUJSbldGbGFBQUFDTEFBQUFCUmlXRmxhQUFBQ1FBQUFBQlJrYlc1a0FBQUNWQUFBQUhCa2JXUmtBQUFDeEFBQUFJaDJkV1ZrQUFBRFRBQUFBSVoyYVdWM0FBQUQxQUFBQUNSc2RXMXBBQUFEK0FBQUFCUnRaV0Z6QUFBRURBQUFBQ1IwWldOb0FBQUVNQUFBQUF4eVZGSkRBQUFFUEFBQUNBeG5WRkpEQUFBRVBBQUFDQXhpVkZKREFBQUVQQUFBQ0F4MFpYaDBBQUFBQUVOdmNIbHlhV2RvZENBb1l5a2dNVGs1T0NCSVpYZHNaWFIwTFZCaFkydGhjbVFnUTI5dGNHRnVlUUFBWkdWell3QUFBQUFBQUFBU2MxSkhRaUJKUlVNMk1UazJOaTB5TGpFQUFBQUFBQUFBQUFBQUFCSnpVa2RDSUVsRlF6WXhPVFkyTFRJdU1RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBV0ZsYUlBQUFBQUFBQVBOUkFBRUFBQUFCRnN4WVdWb2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFGaFpXaUFBQUFBQUFBQnZvZ0FBT1BVQUFBT1FXRmxhSUFBQUFBQUFBR0taQUFDM2hRQUFHTnBZV1ZvZ0FBQUFBQUFBSktBQUFBK0VBQUMyejJSbGMyTUFBQUFBQUFBQUZrbEZReUJvZEhSd09pOHZkM2QzTG1sbFl5NWphQUFBQUFBQUFBQUFBQUFBRmtsRlF5Qm9kSFJ3T2k4dmQzZDNMbWxsWXk1amFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmtaWE5qQUFBQUFBQUFBQzVKUlVNZ05qRTVOall0TWk0eElFUmxabUYxYkhRZ1VrZENJR052Ykc5MWNpQnpjR0ZqWlNBdElITlNSMElBQUFBQUFBQUFBQUFBQUM1SlJVTWdOakU1TmpZdE1pNHhJRVJsWm1GMWJIUWdVa2RDSUdOdmJHOTFjaUJ6Y0dGalpTQXRJSE5TUjBJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaR1Z6WXdBQUFBQUFBQUFzVW1WbVpYSmxibU5sSUZacFpYZHBibWNnUTI5dVpHbDBhVzl1SUdsdUlFbEZRell4T1RZMkxUSXVNUUFBQUFBQUFBQUFBQUFBTEZKbFptVnlaVzVqWlNCV2FXVjNhVzVuSUVOdmJtUnBkR2x2YmlCcGJpQkpSVU0yTVRrMk5pMHlMakVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSFpwWlhjQUFBQUFBQk9rL2dBVVh5NEFFTThVQUFQdHpBQUVFd3NBQTF5ZUFBQUFBVmhaV2lBQUFBQUFBRXdKVmdCUUFBQUFWeC9uYldWaGN3QUFBQUFBQUFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFvOEFBQUFDYzJsbklBQUFBQUJEVWxRZ1kzVnlkZ0FBQUFBQUFBUUFBQUFBQlFBS0FBOEFGQUFaQUI0QUl3QW9BQzBBTWdBM0FEc0FRQUJGQUVvQVR3QlVBRmtBWGdCakFHZ0FiUUJ5QUhjQWZBQ0JBSVlBaXdDUUFKVUFtZ0NmQUtRQXFRQ3VBTElBdHdDOEFNRUF4Z0RMQU5BQTFRRGJBT0FBNVFEckFQQUE5Z0Q3QVFFQkJ3RU5BUk1CR1FFZkFTVUJLd0V5QVRnQlBnRkZBVXdCVWdGWkFXQUJad0Z1QVhVQmZBR0RBWXNCa2dHYUFhRUJxUUd4QWJrQndRSEpBZEVCMlFIaEFla0I4Z0g2QWdNQ0RBSVVBaDBDSmdJdkFqZ0NRUUpMQWxRQ1hRSm5BbkVDZWdLRUFvNENtQUtpQXF3Q3RnTEJBc3NDMVFMZ0F1c0M5UU1BQXdzREZnTWhBeTBET0FOREEwOERXZ05tQTNJRGZnT0tBNVlEb2dPdUE3b0R4d1BUQStBRDdBUDVCQVlFRXdRZ0JDMEVPd1JJQkZVRVl3UnhCSDRFakFTYUJLZ0V0Z1RFQk5NRTRRVHdCUDRGRFFVY0JTc0ZPZ1ZKQlZnRlp3VjNCWVlGbGdXbUJiVUZ4UVhWQmVVRjlnWUdCaFlHSndZM0JrZ0dXUVpxQm5zR2pBYWRCcThHd0FiUkJ1TUc5UWNIQnhrSEt3YzlCMDhIWVFkMEI0WUhtUWVzQjc4SDBnZmxCL2dJQ3dnZkNESUlSZ2hhQ0c0SWdnaVdDS29JdmdqU0NPY0krd2tRQ1NVSk9nbFBDV1FKZVFtUENhUUp1Z25QQ2VVSit3b1JDaWNLUFFwVUNtb0tnUXFZQ3E0S3hRcmNDdk1MQ3dzaUN6a0xVUXRwQzRBTG1BdXdDOGdMNFF2NURCSU1LZ3hEREZ3TWRReU9ES2NNd0F6WkRQTU5EUTBtRFVBTldnMTBEWTROcVEzRERkNE4rQTRURGk0T1NRNWtEbjhPbXc2MkR0SU83ZzhKRHlVUFFROWVEM29QbGcrekQ4OFA3QkFKRUNZUVF4QmhFSDRRbXhDNUVOY1E5UkVURVRFUlR4RnRFWXdScWhISkVlZ1NCeEltRWtVU1pCS0VFcU1Td3hMakV3TVRJeE5ERTJNVGd4T2tFOFVUNVJRR0ZDY1VTUlJxRklzVXJSVE9GUEFWRWhVMEZWWVZlQldiRmIwVjRCWURGaVlXU1Jac0ZvOFdzaGJXRnZvWEhSZEJGMlVYaVJldUY5SVg5eGdiR0VBWVpSaUtHSzhZMVJqNkdTQVpSUmxyR1pFWnR4bmRHZ1FhS2hwUkduY2FuaHJGR3V3YkZCczdHMk1iaWh1eUc5b2NBaHdxSEZJY2V4eWpITXdjOVIwZUhVY2RjQjJaSGNNZDdCNFdIa0FlYWg2VUhyNGU2UjhUSHo0ZmFSK1VINzhmNmlBVklFRWdiQ0NZSU1RZzhDRWNJVWdoZFNHaEljNGgreUluSWxVaWdpS3ZJdDBqQ2lNNEkyWWpsQ1BDSS9Ba0h5Uk5KSHdrcXlUYUpRa2xPQ1ZvSlpjbHh5WDNKaWNtVnlhSEpyY202Q2NZSjBrbmVpZXJKOXdvRFNnL0tIRW9vaWpVS1FZcE9DbHJLWjBwMENvQ0tqVXFhQ3FiS3M4ckFpczJLMmtyblN2UkxBVXNPU3h1TEtJczF5ME1MVUV0ZGkyckxlRXVGaTVNTG9JdXR5N3VMeVF2V2krUkw4Y3YvakExTUd3d3BERGJNUkl4U2pHQ01ib3g4aklxTW1NeW16TFVNdzB6UmpOL003Z3o4VFFyTkdVMG5qVFlOUk0xVFRXSE5jSTEvVFkzTm5JMnJqYnBOeVEzWURlY045YzRGRGhRT0l3NHlEa0ZPVUk1ZnptOE9mazZOanAwT3JJNjd6c3RPMnM3cWp2b1BDYzhaVHlrUE9NOUlqMWhQYUU5NEQ0Z1BtQStvRDdnUHlFL1lUK2lQK0pBSTBCa1FLWkE1MEVwUVdwQnJFSHVRakJDY2tLMVF2ZERPa045UThCRUEwUkhSSXBFemtVU1JWVkZta1hlUmlKR1owYXJSdkJITlVkN1I4QklCVWhMU0pGSTEwa2RTV05KcVVud1NqZEtmVXJFU3d4TFUwdWFTK0pNS2t4eVRMcE5BazFLVFpOTjNFNGxUbTVPdDA4QVQwbFBrMC9kVUNkUWNWQzdVUVpSVUZHYlVlWlNNVko4VXNkVEUxTmZVNnBUOWxSQ1ZJOVUyMVVvVlhWVndsWVBWbHhXcVZiM1YwUlhrbGZnV0M5WWZWakxXUnBaYVZtNFdnZGFWbHFtV3ZWYlJWdVZXK1ZjTlZ5R1hOWmRKMTE0WGNsZUdsNXNYcjFmRDE5aFg3TmdCV0JYWUtwZy9HRlBZYUpoOVdKSllweGk4R05EWTVkajYyUkFaSlJrNldVOVpaSmw1Mlk5WnBKbTZHYzlaNU5uNldnL2FKWm83R2xEYVpwcDhXcElhcDlxOTJ0UGE2ZHIvMnhYYks5dENHMWdiYmx1RW01cmJzUnZIbTk0YjlGd0szQ0djT0J4T25HVmNmQnlTM0ttY3dGelhYTzRkQlIwY0hUTWRTaDFoWFhoZGo1Mm0zYjRkMVozczNnUmVHNTR6SGtxZVlsNTUzcEdlcVY3Qkh0amU4SjhJWHlCZk9GOVFYMmhmZ0YrWW43Q2Z5Ti9oSC9sZ0VlQXFJRUtnV3VCellJd2dwS0M5SU5YZzdxRUhZU0FoT09GUjRXcmhnNkdjb2JYaHp1SG40Z0VpR21Jem9remlabUovb3BraXNxTE1JdVdpL3lNWTR6S2pUR05tSTMvam1hT3pvODJqNTZRQnBCdWtOYVJQNUdva2hHU2VwTGprMDJUdHBRZ2xJcVU5SlZmbGNtV05KYWZsd3FYZFpmZ21FeVl1SmtrbVpDWi9KcG9tdFdiUXB1dm5CeWNpWnozbldTZDBwNUFucTZmSForTG4vcWdhYURZb1VlaHRxSW1vcGFqQnFOMm8rYWtWcVRIcFRpbHFhWWFwb3VtL2FkdXArQ29VcWpFcVRlcHFhb2NxbytyQXF0MXErbXNYS3pRclVTdHVLNHRycUd2RnErTHNBQ3dkYkRxc1dDeDFySkxzc0t6T0xPdXRDVzBuTFVUdFlxMkFiWjV0dkMzYUxmZ3VGbTQwYmxLdWNLNk83cTF1eTY3cDd3aHZKdTlGYjJQdmdxK2hMNy92M3EvOWNCd3dPekJaOEhqd2wvQzI4Tll3OVRFVWNUT3hVdkZ5TVpHeHNQSFFjZS95RDNJdk1rNnlibktPTXEzeXpiTHRzdzF6TFhOTmMyMXpqYk90czgzejdqUU9kQzYwVHpSdnRJLzBzSFRSTlBHMUVuVXk5Vk8xZEhXVmRiWTExelg0TmhrMk9qWmJObngybmJhKzl1QTNBWGNpdDBRM1piZUhONmkzeW5mcitBMjRMM2hST0hNNGxQaTIrTmo0K3ZrYytUODVZVG1EZWFXNXgvbnFlZ3k2THpwUnVuUTZsdnE1ZXR3Ni92c2h1MFI3Wnp1S082MDcwRHZ6UEJZOE9YeGN2SC84b3p6R2ZPbjlEVDB3dlZROWQ3MmJmYjc5NHI0R2ZpbytUajV4L3BYK3VmN2Qvd0gvSmo5S2YyNi9rdiszUDl0Ly8vLzJ3Q0VBQUlEQXdNRUF3UUZCUVFHQmdZR0JnZ0lCd2NJQ0EwSkNna0tDUTBUREE0TURBNE1FeEVVRVE4UkZCRWVHQlVWR0I0akhSd2RJeW9sSlNvMU1qVkZSVndCQWdNREF3UURCQVVGQkFZR0JnWUdDQWdIQndnSURRa0tDUW9KRFJNTURnd01EZ3dURVJRUkR4RVVFUjRZRlJVWUhpTWRIQjBqS2lVbEtqVXlOVVZGWFAvQUFCRUlBNFFGUmdNQklnQUNFUUVERVFIL3hBR2lBQUFCQlFFQkFRRUJBUUFBQUFBQUFBQUFBUUlEQkFVR0J3Z0pDZ3NRQUFJQkF3TUNCQU1GQlFRRUFBQUJmUUVDQXdBRUVRVVNJVEZCQmhOUllRY2ljUlF5Z1pHaENDTkNzY0VWVXRId0pETmljb0lKQ2hZWEdCa2FKU1luS0NrcU5EVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnNFNGaG9lSWlZcVNrNVNWbHBlWW1acWlvNlNscHFlb3FhcXlzN1MxdHJlNHVickN3OFRGeHNmSXljclMwOVRWMXRmWTJkcmg0dVBrNWVibjZPbnE4Zkx6OVBYMjkvajUrZ0VBQXdFQkFRRUJBUUVCQVFBQUFBQUFBQUVDQXdRRkJnY0lDUW9MRVFBQ0FRSUVCQU1FQndVRUJBQUJBbmNBQVFJREVRUUZJVEVHRWtGUkIyRnhFeUl5Z1FnVVFwR2hzY0VKSXpOUzhCVmljdEVLRmlRMDRTWHhGeGdaR2lZbktDa3FOVFkzT0RrNlEwUkZSa2RJU1VwVFZGVldWMWhaV21Oa1pXWm5hR2xxYzNSMWRuZDRlWHFDZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJpNCtUbDV1Zm82ZXJ5OC9UMTl2ZjQrZnIvMmdBTUF3RUFBaEVERVFBL0FQS2pBNUtsbDR5UjdZUHJVOFVia1pQOHYwcWhMY09HSTdnODU3ZzFvV3haOHN3NkRHUDZpdm51aC9LcTVlYTFuYzNvbEdCdXlQWWNmbGl0T05FVVo2Y0FFL1N1WW11MFVyMUhXcnFYRGxjZ0RKSGYxcWVoMSsxZ25aZERXbkxER0QrSXBGa0FHQnoyNDlEV0daNVZJNDUvb2FxTmVNWkRuc2VlM2FpN0c1cGE5enJsZkh0L24rZFVtbUI1eHhucURXTkhMSmtFbmpHZnlwV1pUME9PdmJpaTVrNXQ3R3lyd0FENWlNanBuTlRFS09SMzk2NWRaWmU0eGpvY1lyYlFrTXBJUFhPUGM4VWhSbmRxNk9namtHNDQ5dTFXUE1JVS93QS9UMnJPaFErZ3o3MVpNK080ejJ4M29PNVNkaTU1cWhNTWV2dFZBYlBNeUNldWFxN3lEa0RQNDg1RlVuZVFFWTR6aWdpVXpvbGM4Z0pWNUNXVEh2WE9ST1g1YkpQWTEwS3NOcWs5ZTlPK2hyQ2Q5RE51b01Ba0E1SGYzOXF3NHJkdHh5MmM4OUs2bVZrWTUzWlhyakZZVHlLbVNCZ2pyLzhBWHBHRmFNYnBtNDhHSXdPTSsvclhPRzJKazNidVBYUFR0VVAyK1RIVTRCNzgwUXlzVllrZFQrUFdoR2NwUWxiUTNvN1pjZk5qT1Qwb2EyQWM0eG5xS2pobElZRGFjOG5IUFN0SWxTNE9QWFBGRmplS2k0N0dMSmJPUUNSa2R2OEFQclZpRzJBVDd1T091UDhBR3RvcUNvSTZjOUtyb1d6bkhINVVnVUlxU01hNXRGWmNDblFXS0kvcU9QNWUxYWpNb2JQSkh2V2Q5cTNNY0x6NlV5WlJncHB2ZDdDWEVTb005UGF1ZkVZZDg4azUvd0RyWXJla0xIMzU0QVBTb29ES0NHQzVJR2NrVWtaVFNjbG9VNWJOZG8rYmtWSERhQldKd0RuOU1WMFQ3eUFOdlhwNjB5R05Cbktra2RzVUdqcHg1dGlxWUgyZjU1cWhKRTRIekE1eGpIdFc4U0VLazgvNTZVdVkzSnlwWEl4OU9hQnVuRnJmVXlJRVluN24zY1orbEpOS2RyS3E5Q2Y4KzFhdmtmS3V4czg4bnJ3YTUrNmhrRHNjZTMwOTZraVNsR0tJV2R3Q2NrLzdJSDZtdENCWTVHNjVxakRBU3VEeml0dElrakhjY0hQMHBhanByVzcyTGl3cnZBem5kVW4yZFNvd280NkVlaDdWbkNiTERIUFFkZXc5cTMxZFhBT08yYXB0bTBYRnQyS1JBQnh4Z2ZobXBDUWR4WURISEFGVGhFTEhBNCt0WnR6S3F4a1lCUFlWSmIwVnpRekZnL04zeDZjbXBGVGNtZG85ZlVjVnowRXpOeXg3OUFjNXhXb2JsVlpWQjVxZ2pPTDFIbUxuc285K25XbXlSSGFlUjB4K0hwVm95aGprOEhGVTNsK1VZNXlNZ2RLUXBXdTdtVWtBM2RTTUhwMy9BRnJYTnR2VG44UlVhUmt1TURHUngzcFRJVlBPQWZVVUV3akZMWW9MYUVPbzZENjgxYU1lRjVCNjhlOVRJMlJ6L2tVNHFTQU1mS0IrWDBwQXJkRWM0TXEzQnlPM0lyYlYzY0hJK25iM3FOYmVQY0dBNkhQdFRqdEI1UEkvS2d6aW12bU9ZeHFRQmp2K0dhb0pKSzc0ejZZT0sxbzBWempwL3dEV3FSYmRCSndwNFBPZVB5cDNOT1NUdDZtbkNuR2ZYMnBwVGdBTmptcG1sSVRBenovU3M0VFpPQ2UzMW9SMXl0R3haOHBjZ055RCtXYW1TRUlwL21lK2FnVm4zYzdlUDg0cUptUHpLU2U1NjFmUXp1dDdFanJHU01INmVuNFZBa0kyOXVveFZhUXRrWXgxcVhheEdSazl6emlnenZmb1RQRWVvT09lZi8xVkdIWUVrbkgrZmFwNG5EczI0L3B6VmhrUWpHT081NjlhUlNXbHlEWUNTV0lPT25yUnRKTEhnZjU2MVlRS2V1RHp4K05XUXFFakp3TTg1cG1pVjBDSU5uYlBURlpqd052NXdQcC9ucldudXordWVNR3J1NWVBVnlQWFBhZ3JsVE11TlF1TWMvV29wUXJEcG5ybXJyNEJ6ajh4VkZwUnlOd0ZBdExXS0txU0Q4dnIyL2xWYVcwZFhMQUhCNjVOYXFrS3k3Um5wanZWNVpWZmdyK2VEUVk4a1hvMllTTktCdFBOQVJ0K1N2UFA1VnVpTk04ZnFhYTZMNWZyUll2a2R0eU9KUjF4am5yaXFWMmhMWUhIUFFDdEZYQ25ya0VaNTcwcEFZTmcvcnhRVzBuR3h6QlJpUmtqSjdWSDBBMnQ2ajZpdGRvL215QjA2R25MQXhCejFQYnFhRG01TmRES1hKSTVBeDZkNnNOSHVVa2RQZmlyaXdBTHdDMkNmclVUc1VRazhZNXdPZnlwbWlpa3RUT2FGQWNIbW50QkVSeWNuSEFOSXMyOGNBY0RBeWVsU1B1WEhIVC9BQTRwR2Z1OUVRTGF4cTJPZWc3ZDYxRkl6dHh4K2xjLzlwS3lFY2M0Nzk2M29jWURNdWNuL3dDdFFFSEJ2UkZhWlRnN3VoUFNzOHlrSWZrNlpHYTZCbFFBakFPVFZKSUZMODRBNHgvaGlwc0tVSHphSE91b0xmZEhQYzlLMG9BUXYzU1JuSXJvV3RVOU53Nit0VThJcmJkbTNyak5GZzltNHZWamNxMmZseHpqTlZKSVdLQVk1UGJINjFyZktBR0RaeWVmcFMrWU1jcnh5VFZGdEo3bVF0dW9JNUdNMWJTS0lrYzV4My9DbzVHT0RrWTU2WXozNjAxT0NjdFFTcmRqUmFIZU9BTW5wUWxxQURrSDFQb0tmRkxDcDU0eDc1clNSNDVGRzBaNTcwckdxakYrcGpxdnpaM1pINVZ1eEJBbzVCeWMxbXpJcEdRTWtkUm5nVTZBcjBKR2MweW9YVE5PVlZPTnB6bnJVQ1FqQjZIcGsrMzRVa3o3Y2dZNiszK2MwUnpqSjdIK2YvMXFMbWwxY25pdFkxN2NaL0NyVHFoeGp2bkZWdk5VOU8zOHU5VFF5S2NGaHg2KzlPK3BzdVcxaXBMRElDVCtQcFRRakZRUjM2KzlhMHJxVDFPTVpxbXJrWkE3KzFJbmxTZGlNRHkyNXh4Mjc1cGpUcXdBQi84QXJacHM3azg1NS9uUkN1ZW9vRTI3MlJNRjVJSkJ5S2JJVHMvd05TeVBHbU1nRFBCNTRxbDV4SUl5QWZUMG9FMk04M0JQWEdlS3NyR0dHN0dlYzlLeDJJM1p3ZVRXdEN3SzlzWjU5cURLTHV3a2RWSGYyRlUwbkJZOXlPUGJGTGNydndRZWg2ZldxTWZ5dGdnWUg1MHh1YjVpMUlWeGc0K3BwaDNsZHVPUGNlbFRTa01SOHZUMHEwbzNJVGdjNHlNZmpTS3RmcVo2S2M0eGtaNmM0clNWSTJYSkF6K1dEVUxRNFlZT09QWFA0MDB1VUp5dkI2VWhwV0tFOXJHemNFWXovd0RYcVZZZjNhdG5PUFRtbnlGU1RrY0hwbXBJWHgxNitnL1NtWnFNYjdGeU5DTWNFRDZjWnFHNHh1OXV2MDlxWVpSanIyNXgrdFZkeGNEamo2OVAvd0JkTTBiVnJHdEJFbTNBK2dxY3d4blBwNjFERWNJdU1qakl3T2xNM3VNOEh2eDI1b0tUVml5a0Vhazhqdm4zL09xVWdVREFPUU90VUh1WmY0dTlUSy9jSElaZnJRSFBHMmlBQkJ5dm9hUVJrTVBuSFU0R085VGVmaFNCZ2c5UGNlOVJISkJZZW5QcWFHVG9YY1JsTTV4Z2pJcW81VEJBR1I3L0FLMVRhVXFSamdrOWFzSVN3T1FBTTlQU2tGK2cxWTF4anZ6MnFoTENBT2NqQS84QXIxdXNqUmdjZ2YxcWlWWGRnZ24wK2xBcFIwc3pNaFVoZlRtdExhekZSalBINWtWT01CZWdCN1ZiaFpTZm1JQndPOUFSaWtrcm5PM0NsVmJPUXYxeDFxZ3JaSnlUeTNwVy9lWStZZE8rYy80MWhoZ09WNysyS0RDYVNrWHRvQndvNEFvWkFPdjVkZWF1UmtkKzNINFZLeklTT09LcXh0WmR6TUNNb0hvS295TWQ0ejB4K2xiNWl5TXRqLzYzNDFTWlZaZnU3czl1bkZTWnVPaERGTVJ1QklPZTFVSFlNU1JuNjk2dUNKUWR3eWFSb2lEd3VPZjUwV01YeldTSmJiY000UGJwbmo4NjZLR1FiT2VnNlZ6Nm9RZ0J6MDYwNUpKRXp6MFBOQnRHZktrWDVaQURrZHo5T0RVMERvQWNNUHhOYzNMTy9ZZzl6azA2S1NSbU9VNHp4elRRdmFMbXNkRzdZVmV2b1BYbW9tWnR1ZVJrZE05NmdVTzNYSUpKeDNxVWhnRDdqK2xWYzBUS2U5d1FjZGUxWElwWEFIYnZUSTQxejA1SkhVMXNCQnQ2Zmgwb0xpbStwUk1wSU9XWUNuWk80ODVQY2RjVkZJeTVJeGdkTW1wVkNybjI3SCtsTXBYdnVJcHdlV09PeHF3MGpmUUVkUmdmenFCcE1uQUFGTzJzUjJ6azBpMHRYWVpKc1BHUWVlUVBXb0Fxdm5KUFRxZXBweUVldVRqbk5PZFdBeVY3WjRwa3RYMUpGaEF4d09oSHBWZ3NvQUI2ZjU3MVFlVEFYOUt5bnVzYnNIbjBxYmljMGpvRE5qT01kY1ZsdElNNWJuSS9LczBTcmsvTjNweGNFbklQSGVsY24ybHpaM3B0Nlo0eGp0N1ZDODQzWTlBYTUrVzVJYmJqcjBKNHFLU1NSMUhzUFgvUEZGeUpWTDN0ME93Z2xQWTU3NTYwa3N5OU1lbkpGWTlvV0k1eWUvTmFMb0hJd01Edno2VVhOWXliaWlzc3dkbEFQSkhmR2EySTErVWduNlo5cXgvS1V1U2V2US8vQUs2MEk1MUNkZWNZOTZXbzROMzFKbkNzQ29HRCtmSXJMbGo2L0tHL1htdFVsRGdnZzU5OC9qVEFFT1BiMXpWTkZTVnpuREdWSXd2ditOQlVzaFhZTW5wejJyb1RFR09BTWdaSFBhcUJ0bVhuZy84QTFxaTJwa290R09rVDd6eHowRlhXVWdkT3ZGV0JHdzZnNTdkeFQza0d6cGtkUGNmaFJZYVNzVkVHTytTQitOU0t4eUFSOVQ2MU9NRTVJQTR6d2V0VjJaYzQ0NjkvNjBJZHRFYTBjOGV3RDI0eWM5S2dhYk9lbjVjVm00NFlkQjMvQU1LbTJNY25PZjhBNjlNMDVtMVl2YnZVZ0R0aWlxakt5cU01UDBHZXRGT3d1WnJvZWV6V2l5TW9VWklKd1QxcWRZRlJSa2ZNVDBwWTdrYlA4YXNDWGNTUVFwSDhSNlUraDVVM0djM0xxekhsdGl6RThnbmduclduRGJySDk3T052NUQ2VlpBQmRzbnZ4bnYzcFdrYnNCeitkSXlqVFhNMlpsekdtR0FiTEg4dWF3VlV4Z2hSMzVKOTY2U2EzWmlwQStuMW9OcWRvK1laL2k5YVJNb3R0NkdlSW8yUThFKy85YXJDRjJsMjdNRGs1OTYxaUpGalhIUHIvazFRakRtUUU0eG5HQlRNM2JRdlBaZzdjQTlqbjA5cTBrdDNpVlczRVk3MU1oR3hTZlVjR3JUM0NxQ0F1Vnhqbm5yL0FGcEhVcWNOWHNVa1p0M2JnNXBySnlHempPY0UxZFRxb0J5RDIvV3BtaEpaaXk1eGp0bmltTlJaaVlkUVd6MjZVb2tERWZNQ2NqUHVQYXRPZEVDNDllZ0JQMXhXZWxzdS9uanJnLzU2VWpLU2xkSmFtOURIR0IwQTZkS3o1WkFTUnY2SFB1S015cWNkaDB6eFdiTTRPT1B4OUQ2OFVHbFNjVkZhV0xSSklQT2ZUdFZjdzd3RkhwK3RTUkJ3UWNjRVk1cTBnSVBKSFBwMkZUMU1WWnJVb1BFWTFUZ0UrcHFXMFk3bXlvOWg3Vk81UWtCczlQeHpURldPTWNjL1gxTlVpa3ZldmZSRnh5RlVISEhUNi9Tc2w3aVhkdEdRZmM5YTFZcFluL2p6MDVQUGVyRWtkdUNEZ2NZT1FLTG91WHZKV2RpSzJtRElReEdldFhUY0xzenZVWTZWUmtjS2hDajh4K05ja3p5aVFkam44NmFaRHF1Q1dsenIya1VuSXh3UHpGUmhWNFBmK25XdWZNckdNTVNlUjNHTUgwcUNLVjk0QmJPVDI1d2FRL2FwdGFIUnlUeGhsQUFJUFgyTmEwWWlBNmduSGJ0WEpMQXp0bGlRY2dpdHJJV1BnbmdrWjc4MG1YQ1R1MjBqYUU4WEErdjBxVG9NNHpnOGV0Y0ROTGNpVXNEL0FQcXJhaW4vQUhJM0hxT2FMRlJyWGRyYkdsTEtNcUFwSkhHS1dPSWdoam5qcngrZFJSeEJqdUREbnJpclpVZ3FlUmtIaWhHblc1SXJuY08vYW5TN0NuM2NZNzk2aFBYM1BGWjEwR1pjS3pFRWM4LzRVRGxLeWVseWRHaUJJVS9sVUVtOG5ISEhQSnFyYVcwcGJHY0FjbkovU3RTYTNDQVpQNFkvV2d5dEp4dmF4bEtwS2tqZ1kvS3IwVEFIUFhBNzFCNWJqSG9TUFljMXB4S2h5UGJtcEpweGR5akpNNmg4TmdudFZJaVI5dnpjazVQZml0T1dGUWNubkZWRWpBNkRrK25BeC9Ta1hKRldLRWdZOThtbG5TUitmYnFPZnlyU0VhZ0RwMHllTTB3TVFoSlU0em5IY2MwRWNtbGpIalprTzNKSnpnZTFkSkhEdWlKejF4MTc0ckZrbFVuT09udDFxOURjRkR6Zyt4OVRRRUxLVm05RFc0QXlEMDllb3FxcVN1ZHdQWFBUOHFvTmRGbU9BUWVtZXYxclVnWUtvUG92NVVHNmFrL0pFenc3UXVSeDM5cWpKSUFYT1B3ckt1NzhGaDZFL2h4VU1Wd3hMRXAzN0dxZXhQTkRtYVJxL05rNUlPT29xcTZIREVIb2VncW5MZktvVW9tTVo2bXA3YTVXWG9oSHFlbExvUnpRY3JYMUprZlpqZVRuanIrVlhrUUVzd0lQQkk1cWhjcVVjRlFja2pBN21yRU53Z0h6TGh2VFBlcXNXbXVhejZGZzhBZ2dudGlxZ2xLazVHQi9LdEZwa1lnNEJIMHhuNlZUbFJUemdEbnAxcGRUU1MwMGR3UzVMS2ZVMUhORkpsVGdZL3FhdjI4SzdNNHlQNVlvZVFoY2VwK25TbUxrOTNWbk9qY0d3ZXg3K3RhRFQ3NHV2ekVIMjl1S21jUnNQY2M4OXpVeUlOd08zamdldERKaEJwTlgzTWlOSEJIWDgvVDYxcUNTWEJQVVo1cTZWNUdUa0U4LzRWR3dBNmo2WjdVaHFIS3JYSUZsY2p2ajM5cVJKWkgzWkJIWUgxcE14bGdjSGpvVFRFK1lrZ25HZWUvRkxVTzJwWTg4bGhrZS9yVjJLVXMyRGpGVTFSVElRUWMrdld0MkcwaVVnWjloaW1tWEdNbXhwS2JRR3lPT25XcytTRWNrRFBIVDBxZWFQNjU1NCtsQ3FTTjJNY0R2L1NxTDFiMktNY1FKeGtkZlg5YXVyRXE0NVB2V2RLcFJzN2pqc0J3YWFKU01FKy92UVpXUzZhbXVTUWM1R1RpcThrcFhnSG5rL3JXZkxjRWprYzhWV0pabUEybmpKb0w1OUxJdW94TEQ1dWNjYytwcTA3TU0rblBmMHJNajRBeU1uT09sTytZbkJJSlA2VUdhbGJRb2k4d1NNRTgxdC9iQnM0eG5qQXh6V2FiVXN4OUFTQ2FTTzE2ZTM2VUV4ZFZFalhpNTZZOWVmNTRwN3lCeG5wenlSVktXQkVKWW44VDJwOFcxbVBjanJTR25LOW1YbHQ5M2IvSnJUTU82UEhyMjQvbldROHNhN2NQZ1p4MTZucldqYjNpc0JsZ01kVDNwbWtKUnUwVW0wMVhCejlSeDZkcXNyYVNMOUNmeXJWanVJYzQ1UFBUUFAxcUtTNGlHUHdQSXBHbkxUU3ZvVkRDd3dRU004anZ4VlNRRkZQSFFWc1JYTWJCZ01lblBHYXNQRkd5Y2dFRDhEVEU0SnJSbkxSWERGc2NqMjlLbmNNeWs1enlPcHE4TFZWZmQvbkJxVXdsVU9UeG1nU2pLMW1ZR0NTcWdqa0g4TWV0WDFpSVVBOWVnSUZXdkxYQXdELzhBVzk2ZEd2OEFzL2hRQ2drVWR5cjF6OHZjZE1tczU4RWtxUHc2WXJhbGd5RGdIK1hYdFdNMXZNSDVPQ001NG9zWTFPWmFjcFVsTXFkT21QVEpxUzJ1bkRIaytuK2MxZmVKeUN3QkdSMnJQV0tWSDQ5ZWg0elNSbnl5VFRWemFlVGN1UjE1OXFxSktWMnFEMHpWOEU0eVIwQXFuSUV6eDI2VXpwMklybTZKd04yT3Y2ZjFxbERjbnB1eVFPaDlLbThndVQ4bWU1L3dyTWVIeS9ZWTZqdm50Ulk1NU9kNzlEYmU1T0ZPZS9IcFRvN3hkd3llMWMvR3hMS3BHUmo4c2NWcEloMnQ4b3gyeHgrZFE3aVU1ZERlVzdCNEhJejJQYXRCWjFBR0NPUDFyeTY0bkNNTXFRUVNTUjB4VnVLNGtmWWQyT1BTcVZ4eHI2dEhlUEpsaVI5MzJxdVoyQTRIZnI2MWp4VE9BVlByMkhwVzdHcU5qcG5QUDFwbTZia1VKcmlSandQNHV2cFZOSFlBRWdqcjA3NXJvakhiNEo2WVBwMXBqeElBQU9jVURjSmI4eGpSemtzT000cTFMTmdBQUhCNmdkc1V3d0l6ajBCQndPdFdEYVJNbytZRVpQZkdmclFURlNzek4rMU5uR0NlZnIrRlBOeVR5QnhuL3dDdFNHMlV1eEJ4Ni9XcFV0aEdvOWVsTHFRbE94RXM3NEkzWXgxeDJ4V3REUHVqNjhZNmQ2em1qUnNuUElIYitWVG1JcXVjRURxRFRORTVJbG11Zm1PWE9PTTAxTGxDQWNuQjkvWDYxU2VFT0RsY2pyN1VpMlkyNDlLQjgwNzdHa2txL3dBZmJOTDUwZjB6MEdPMVpFMExweG5JeG4xck9BbEJZNU9PUmpwVTZtYnFTV2xqcHdTNFUvTmpIT2UxU1NTaFV6eVJqcjZWbFJNZGdIUGJQdjhBNDFETVhZYlRubk5VVTV2a3Y1Riszdk15Z0J1TS93QTYyQzZuREVrSG5CNmZwWEoyYUtrd0g5MDRKNjExcnRFVUo0NUZCZEZ5bEJ0c2FJNDJYcUJtb0dMYnZsSXhuamovQUQwcUFrOXNqZ1o1OWFrVmdXNU9CMk9LQzdwbG55eVJ6engrZjRtZ0lwWWZMbnQ3L1duYnc2Z0QzL3lhY3pPRzVHUG9hTG1taEJMQ053UFRBeHlhWkY4cDQ1NDcwOHVTNTUvQ3IwS3A1ZVNQeXBGUVNjak5lUTdldlh0VkhNemRjRSt0YkVxeHJrazl2ci9rMVNqVk41eWUvUE5NbWNiZFNGZ2NOa2M1NEZVa2RzNFlqOC9ldDJTRU5Ia0RCOVRYUEdLVHpNWk9Cem5INjBqQ1Rhc1dwV0JIekRQYnIwL09xc2NZR01kRDNIYXBDa2g2Z3RqMnFlRjI1M0x4MlBUNlV5SHE5U01iNDhrWnhqOGdhdFJ5OEFZemdZL0Nub055RUhqQjlLck91MXVoejN4L1dndld5WmNsa1hia2Rxemh2REhieWFseUNwd0NPbmVyVWNCR01BZXY1MER0ZlVkR2g1SFRyK0o5U2FsVlFUMC9EclUwbTRMamtkYzFIQUNHd2VTUHdwMk5FdGl3WUR3M1RqcDF6V1hMYklTU280eno2NHJyOEFvY1ZueU9GUFlZejFwMk5aVTRuSS9ZdzNKQk9CZzhWcHhRd29TVklHQ005ODU3OFZMSk1vQk9lRDFIdFZJc2VoR1A4L3lvYU9lMFl2WTNOaWdFTHlTUHdwMjFkdVQwenpXSkY1Z1lBODFiZDV0dVZ4bkhOQ0xVdXRoN0lBNXd3R0IwN1ZDWm0yWXpUZk85Ums5eCtOU3FBY2JlT3VUL0FKNzB4ZGRDZ1ErVHo4cHEwaFlnREpPTSs5V3BJQXB6ajhUVlpTVkJKUWNrNHBnb3lUQnZsY2pnWUhHS3VvNGNLQ1Q3L1dzeG5WbTZZOXF1b0NNa0hnOTZuWXVMMUlIYmJrcU1lMUt0MEFPUUJ4bjFwWkNXem5CejE5c1ZINWFnN2xQSE9mZlA5S0xqdStoSE9xa0FnL3Jpc1lwa2hoazg0K3RhMG1kNTR5UjByTGxMWk9BZTJLT2h5eVN2Y2NiZGpnNy9BSHExSEZJQnh4Nlo1NTlxalE3aG5CQjlCM3F3dHhuMjU5S1doUzVia1J0UTJHeUFSN2RhdUphYmlEblBjWTQvS3E3U3VqS1FlU1JuOGZUM3EvRmMrdmIxcDZHMFZUdU9XRFlEZ0RKR2FrY0ZjZkw3Vkw1NFlrbmtaL3lhc2pESU1uQjlhZWgwV2piUXoyeHNiS2o4S280ZmVwQVB0K05YV1lZemdaQjdWTWd6Z1lYcngvbjBvTTdYWlN5eEk3Y0RwL0twQjkwZ0EvOEE2NnNURGJudWVvNHFxalpHVGpQZW1PMnRpVVNCV0E3SHAzR0tzU09CMDlNREZRbGVUakdBU1ByVE1LUUZIQjlRTTlhVEZxU0Jrd2V2UHRWYTRISkpPZWVoTklVS3J5ZlRPYWdlVXNvempHZWFsZzM3cFloVUZlZW1lbmZGTmxnWU55TWpwbnAvazFZaGRCamdETlhtUlNlT2NudjcwalNNYnhNMUl6aGM5ZWg0L0dwd3FoY01TU01aL3dEclZZZDFIR1JrZjU1TlJoa2NBZktQWDhLQ1N0NSsxbUJ4anJSVDVMZFdISGJzYUtCZS93Qnp6bU9ER1Jqbk9TYWtFY1FZS0RrWXlmcWF6Ukt4WGpnZjRWaFBQZGVhY0hBOWoxLyt2VkxjK2ZkV0VZcjNXenZWOHNvQjF5ZnBtczU4bzRPUnlUZ2YwcXRieVNZenRPTzNyVjBsU3hIUTQ5TzlTZEhOeksreG9wSXJKbkE2REgrVFZkcEVPZU92dFZLV1JJME9jQS8wckhpdWtFdVRKa0huMTVvSmxVU2FWenBKSlZSYzdUMC9sV1ZCTXBBWlFNWjZIdm1yWk1iTG51MzRFMDJPMmlVQWdnQWNqSC8xNkRLWFBLU3RheVJwbVJRcHlvSFE1UGVzZHJtTVREQzljOC9XdGlOWTVGS2taNEdUM3dheGJuVG1VdDg0NE9jL1NtaldUbnlwclUyMFlESnlPbWFtYVRhcWdaL3dGWWR1WXdUdUk2NCtsYkh5NXlEblA0bWhsUmxkRk54S3lraHMrbFY0ZHl5Y2tnZTNOYWNic3VjTHlhZ1lQdUpJeHh3YVFPQzBkM2N0dXVjbmtuZ0FmNDF6OHh1QTR5T3ZjZW45SzAvTkNrbjlTYTBWOG1RRDVSeVB2WnBFT0tuMXNZUDJseGdZNkh0MFAwclRqa0JBejZmenErYldIcWNaeCtPRFU4Y01TdGpBMitwNU5KR2lwVHZ1WjhjVGxtR004WTlLV2ExYlpnamc1TmRFMFdDU0FPM2VvcEEyUFhBelRzYmV5U1J4aTIwd3dWUFFnaysxVDdKd1N4NmNBYzVyUWtCQzVQcm42ZTlJcmJpUVJrZGg5YVZqazVGZTJwaE96bmFQd3FmN0lHeVFwUEhQR1B4cm9mczYvSzVIVHQwd0tzeFN4QTR4MDR4OUtkaS9aTHF6QVd6WUpubkhIR2M0cGZzeW94SVVFMXZUVElEbEZIWHA5YW9vaGNzU3c1NkFDbWFleml0RnFaM25GVGdBayszNlZLUG13V0hCNElIWS9RZnpyYSt3UkJVeWNlM1dwcGJWUXZ5a2NlbEdoU3BUM2YzSE9TeEl4NkE0NmZqVGxqWXg3U005UngxeCtOYVAyVkNPZXZPUHhxUW9Jd09EMC9JMEdmczVYYmFLMEprVnV2VUE0QXhqRmFpeTVRRWtBajE5NnhzbHM4ZFBXb0hrZEJ3T09RT2NpaGxSbHltckpJVksvTmtIanJTTE1OcDZIdDBybWt1Q2VNRTgvbUsxTGVRWnlWT2VldElGVVRhNkYyS1VLMzhReCtOYURYS1BuQXpqcldmSUNkdzcrMVZaRWtVRGtubmtEMDZWTFpwek9LN28wQ3k5Umc4K21lUHJWSU80NmRCL25tbnBoajE0NjRyUUVjVWk1M0QyRkloWGxxdENzWFl0OHc2RGpqbmlwbFVCZnUvZ2FSb1dWZ0FSajE5cWhBd1FOM1B0L3dEWHFyRjZwNmtVallZamFUNzVxZnl6Z0EvS1JWeUZkd3hrZC93SHI5YWdsaTJOa25KSjduTkZpdVYydjBNWm9CdTNIdDI2ZmxXaEJFdU9jRGdkZU0rMVdFaUxKZ2djSHIycGZKWU1CeFJaRVJqczdEakNOeEFJUEJvSzlBUUJtcktnYlQwR2FReGhtNU9jZmxUc2EyM3NZclI1R1dZL0x4NjA4V3hLOEhKUFBwbXJVMEEzZW80SEZhRnNpaE9uMHllL3ZRWktIdk5OSExTMldaUUR3QnlRTVYwY050dGp5T09lL2VsbHd2cDBIK1RWdUp3RndUbmo5UFdreXFjSUtUTXllSi9NR0FRQlRCYk1OdzlPL29LNll4eHRIa3FjSGdpc3BuTzREamo4UHBSYzBsVFY3dnFZcFZsd0NlZVFNZHZ3cUpuSTNFNUFKSEZYbmRneDVBSXlQenJYaWdpa1VuZzhjQ2pjelVkZEdVTFI1QVI4M0g1OWFrbWlESmtFNDlSL1N0QjdmYnpqajBxL0ZHcCttZVNlUC8xMHpwVUxxek9SdDQ5aEkyRTU2Wk5hKzN1QU1EK2xXWllDVHdPUDVVaFZncHpnbkE0OVByUVpLSExvaVBibnEzK2Y4S2haQnRKSjU1Tk1aWkNmbDR3ZWZ3cHlyS3h4dDYwRTNkOWlzbTR1b1BBNUJCTmFyUnFvTFp4My9La1cwWUtHeVNlS2lkSGJKR0NBT2MwaW94a2xxdlF5REtkeEFQclNQZlNMZ1p5TTR6azFJdHErN29Pbko5cXR4MmFuRzBIbnJ4U1JsYW95cjl2Y0E4bmtjakhYMnAwZDZ4S2dnNEo1UDlhdnphZUJrZ25xT3RSTGFSanNCanJUVng4dFpQY2JMTnZYZzlqV0V3STV4MVBJcm9IUUozNU5SR0U3RGtjWTYwN2psRnQ2bk5MSklCZ2tZcmNpWWVXTTVCejY0ck1tdGwzZ0RqSHBVc2FzaXJuUEJQV2c1NHVTbXljekhkczdEbnIycDVmcWNmZEdmOG1wVlhjTXJna1p6eDJxdFBHUHVyazRINTB5NUtTMTNMS1Q3d2RyWU9NWXpTQjN5T09nOWF5cmVQQVk4RTU0NDZWZWtaams3UWYvQUsxSUl5YlN1RXpsMUJMYytuV3FrUWtEQWpKR080eFZiemdwT1ZHZXRYMWtHTzQ0SFhuZzB5VktMZStwUnU0M0k1SDYxVGhabEErOENNL1d1a2JaZ0RQWHBudFdKTW9SaWVmcjZVdFRPb2tuY3Z3U2tESWZuQUhQL3dCZW4zRW5jNHpqNjFuSzU5RDh2ZjhBclZlU2NxMkR5RHdDUlJmVW5tZnN6UWp1SkkyWW5PQ2ZicldxMSsrMFlPY1ZpS29aQXhPN0ZYb0ZVbFFjOGNpa1hUbEs2U1pzUTNaMjVianNPYXZpZFpHQUp4aXNoaEdWTzBIcC9LbXFISTQ2WkhQZWhiSGRlYWZjNk9KMXh0WWc0OVBXcndqUmM1WWY0ZlN1VWpFaFlkQ1BXcmJYT3dFWjlqbi9BRDFxaldOUkphbzNpVUdUbnFPdlhJcUtSWXlmbFhyNlZoTE1jOFZWZWVWczUrWGs1NTVvRktvcmJibTZ5TGowK3RVL0tRc09oT2UvL3dCYXFTeXN4SnhqMjlmcFZpTTRaU2M1eFFacVNkckkyRXRkMFl3QjEvSGp2OWFuU3hYUHpEbmltSmRiTWRlYWNMcDhaUGZIQS9wVldPbjNIYnVJMW9NY0RBL2xXRlBaakh5ajI2MTB4bjRHNWVUMTVxTVJna2p1ZmFreFRwcG5KSll0djZjWTlPYXVQQ0Y0UEhwL2pXN0l5cGpkd2NkZmFvWGg4eGdjOFk0Tkl5Vk5MWTVPVFRQTXh3T2Z4b1d4alFLRGsrd1BOZHhIQUVVL042OFZGc1RPZmZIOWFBOWhIZnF6a2phYmlNRWc5K0tsamhrUjE5ejZjVjBLQUFzRG5IdjMrbFN0NVd3TGpIUEhlZ2NhYXRlK3B6emlRRW42ajB4VEl5SEJCT0NEMDlhM0hZRUhHT2ZTc3JCM0U0SFBwU0k1SGRhaUZWeGxXQUkvbDdWbXpTeW5HQmpuMHJWQ3NBRGtqT00vaFUwTWNURG5uMjlhWkxpMjdiSE9vOG1OeFhHVDFOYUtPMkJsVHo3MW9YS0tvNkJlZXRZN2x6bnZub2VuU2tPM0tyWExrVFI1T1d4ejZWWmJBWC82OVk2MjgvbTdpcHdNNHlhdXVTUzNQMDlLTGlUYlR1aTdHNTlSejJ6VDl6RXRrajErbFVJbFptdzNZZGhWbGxZRkFSa2s4bjJvdWFwdXdiQTN6SHYxOURVd2lqTGZOK1hwNlZYYkM0T2FoU1Q1aGpCQngwNHpUQzZMVFJKdFhBVUh2a2RLazh0ZHVEeDlSK2xBZGpuMDdqRldGQjI1VUhwUVdraWdzVVNuQVBlbk1NQWdqampBckt1R0tTc01IL0FWTDVqa0RQcDBwTm5PcEs3VmpTOHNFanIxL3dBOWFpQ2hNNUFJUFdxeVNrcmhqa2dmNXhVcjhBWkpvVEdtbVdBR0lCNmZwVkdXNVlLTmg5cVpOY0t5OVJ3UHorbGMvTFArOUdWeGpwbnZpbVp6cVdXNXVxV2JidHlPaFAxOXExb1EyMDRJeVBmdlhLTGNsVG5BSHVEVzVhWFVKNTQ5K1AwcFhMcHppN2FqNTV6azV6a0VaUHJSRVY0NHgvaUtKMVJqa2RmOEt6eTdwbmFNZ0VmclN1WEoyWjAvbWdyampKSGY4NnBUUEh1SEdPT2NWenBtbHlmbTc4ZmpVeXVXUWdqNllvYlpMbjBzYXF6SnlvQUovblNDUmM4c1A1ZEt3L0xaUnh3VHpta0lZQlR1NEhiclN1Sk45VWRsR1lsVFBmOEFPbUdPSnp3dzVHTVZ6YU1YYkhOU3htUlh5YzV6L2tVN210OXRORFpXTGFEN2QrbUtsUmhrSE9NOXZlb0JLMnc4RCtYTlV4TXFrQnNkL3dEOVZVUFEyM1FuT0NlbFVWUjFjNFBmclMvYUR0R0IyNTQ5T3Y0VkY5dFVFL0xqMUhXcVRLYmliMFRaVlNmVDE2VlR1WWM4akpIMHFpbDJ1Zng0SHJXeUxpTXB5RHgxejFwNkdxY1d0em14QVErMDkvOEFQRmFuMmZZb3lPL3JubXFiWFNpUnVNRE9QejYxZU4xR1I2bkhBOUtES0tqcU9oaCtVWkdDUFdsWkV6NmZ5b1dVR1BPMERuZ21sU2REa0E0NXg5ZUtab3JhRVpnVUVnS09lcDlhaThwMDZnRGowL1dyalMvTnovZHFONWU1YmhqeG1nYlVTVTd0b0JKQituQnFqTW1EZ2VuNFZkUWxtKzcrUGIzcGpSdG5uNmVvT0tmUXQ2b294MjVKTE1DTVp4eFQza1ZTQVFjZEJuM3E0KzVVSTYrbnBYTVNvekhKQnh4U01KUGxWa2pWa1lGVGpILzYvU3Nvem5jdnplMy9BTmVySUQ5bUlIVDE2VlNaU1NNbnYrTlRjeWszMEhySUdiakk1L0NsYVBKSjRIZXJzRUxnZENNakZWWmhJVHhqSGZtcXRjaXp0ZGt5N01ZSU9SNkdvUUNIOXFqRVoybkJQUEhXbGtWa0pJSGZtb2FLWlplTWtISnhnOWovQUo1cXFkeWhWWTROVlZtVUFEZDdjODA0eks2OGpERHY5YUFUajh3RWhWc0U4RHQ3L2hWbHI0OHFSNjhqK2xRZVNHR0RuZGo2WnFtMW83SEI2ZjdYZWdIS1NXaHBpNFptSHpIMTZZL0twdlBiSndTTWRqL0tzYVNFRGxleHlQZW9sa0FIVThjL2pUdVpxYnZZNnlOMWs1M1o3VmVWQUZKVmUzUHQ5Szg2a3UxVEpKNUhQMS8rdlY2MTFZeUlldUQzTk81dERFVTc4cjNPc2VRZkx0eHoxL0NoV1lOa1pHZVRtc1F6L01DMmVjR3BmdHFwZ1lKeHdhbGw4NjcyTkNSdm1BR1RWRGF4QndvSFBGU0xPckhxVDB6ejM5cXZSN0dKUHVmL0FLOU1hMTZsYVBJQXozOUt2c3hBQUxkUjJxUHpOckFIcmpnZTNUdFZXV1lGaWNkUFEvcFMwTk5FdHlPU1J6bkIvTVZMRGxobkJ6anBTUkJKQWZYUDYxUHY4b2pnNDdlcHBFeDNUYjBKc3IzQjllS0txUGNLV3prRFBwUlFQbVNPQkFZUThwMndPY1o5NnlnRUxNQ0J4MEh2WFh4cEV3eGduR09ham1zbzlweGtqUFVlbEI0dnNaTksycGhJckFER2Nub0J6VmhNL05rWjQ1UHArRlNRaU9QQXo2KzFXNTNSRUpUT0IzSjlhQldzcjMyT0QxQjJVQlZCSkpIYk9mWHAzcktkblJnM2ZqSkhQTmRqRkFiaDhGQUZCN2NZclNiVEZWU3dBNDZacDNSNXJvVlpTbEpQU3krUmkyWkFWU1czSEhmdG10OWorN3gxN0Q4YTV3d3lwSUZ3QmtkQjdWMUZyQ2NBRWxnTy9Ta2RkSlBheG53eVNJNDlDUFU4ZXhyVmFkM2orNTkzdGtVazhhZ2toYzQ2SHFUVWNNWkpCQTZubmlnMmpHVVpXdm9jWmR2ZEJ5VkhIYjNyYXRKWlNWRExqUHFhMDVMWlhsd3c2KzNTdENPMVlZR2V2YnNQZXF2b1pRb3pVNzNkcmxHT1Z2TTI0SFQ4RG10MXpsQWRvNS9PcytRSnUrNFJ4eHpVWkRNU1FTUHJ4K1h2VW5ZMjBpU1dKSERGUjMvS3BZcllvQVRuQXpqRk9WWnR3YmZuUGIrbGFjakh5Z29iQi9PZ2NZcHR0b29Fa2dnY2NmblZpUGNvQjM1L0R0VWNZY0Zoamc0R1NPbEpKa0VoV1A0Y2UxSTB2WW5lY25KL3p6VlpMcms0N2cvcFZmRGtaWTFuZVRsZ0NTZStlbE15YzVYVmpaRXlPMkNjNDR6aXFjemhaRHgzNHExRzZvdURnKzlSdkhHekE1K3ZGQTVYY2QxY3ZMSm1IbHVBUFRINVZtTXhMbmJ1SVBmOWEwQ0FCZ0wrZFRXMXR1K1lnSEk5ZXRNdmxrN0liRUV3cFBPUFgvUGFtUzNNVUczeXh1eU04RG1ycjIzN3drQmNmWC9QTlZKYkNKbEdjNXllK090Qm8xTkxSZk1wcmVTUDA1QTl2eXF6TE00eHprNHljZXRYb29JVVFMc3dlZS9XcWIyNVp5UU9lMzBwQTR5UzNMY0xuWmxqanBubXFNcjVKQTRCR01kS25POWNEYURucjZHc0M0a2NCeU1uSElVRVpvSmxVU1JxaVdJRUFrSGdaenovQUNxcFBjUjdTQ09uSHNLNStIekdrWGdqam4vNithM21XQ1FCVmY1aCtPY1VIT3B1VVhheFFaNGp4OTNnWVBYOEtsdDNVNEt2akhYZy93Q1RVVWxzd1hjSThEbmcvblZSSENrRW50eGozcWJHV3FhdWpxQk1xay9NQ08xSkpLR1VNQmpQQXlmODhWa1JOdUpCd0FPZWEwSldoTWV3REpBNkNsWTJpM0pONkVXOW1IR01kT3RYUkl5cU14anRWS0NLUU55cFBHZVJXb3drQUI1QXhqbnRUdHNFVkt6M1RIZWZsZDdaNDR4OUt4RGRUSk9lT3Y0NE5hVWZ6Wk9NRDNQWVV4bzBBWWtaWWc4K240VTdCYWNrdGJXSW5lVlFNZW1UaXM4NmhJWlFwWG4xNkhqMHJUSHpranFPUFNtZlloSVFTTWMvU21USlZQc3lMVnRjS1FDRGtrYy80ODFkRGJteHRJUFEvVHRpcVNXb2hPVzRPZXZjNXFXT1NPTWdaOWZ3cFdOWXVTUzV0QjdTbmNvR2NpbkdZWkFBemdjNDV6U3pveFVjOTg4VkN0c3ZJeWV4NDlLUTN6MzBMa1I4MXVnQjZaNzFJVmRDQ1FPTTRxdEdHams2SEhiTmFMM0NzZ3lGelR1YkszTHE5VFBLU3NjN2VvL1BOVzRyZGxHZWV2ZmtjMVRhNlVNZDJjOXVlQ2EySUxwV1U3aDlmL3IwbUtLcHVUMTFSYWQzQ2xjcjZaN1ZSMm83blBUK1ZMSTZFY1pIVUhOWmhsUVl6MTNmeXFUV1V0alJtZ1YwNkgzK2xVNEY4dHRxNXhVME4wcFlEM3E0NkRhU0RqMkZYY0ZacTZMTWJCaVByeWM5ZndxK1ZDTG5qYVBmUDA0ckhRbGQzekU4L3dBNmtNK1c0WEFIVGltYUoyUlVtbFk1NTR6MFB2MHFqOXVWTXJpdGhsalAzbHpuOHVhNTZlM0N1VHp0STlQV2d4bnpXMFpzdzNTTTJDcFlER1RqSFgrbGREOW90MVBUa2V2SFd1RVNNTUFvUElBcWFXTjlxL056Z2NZNS93RDFVcmt4cXpTZWlaMVVrNk1DTTROUUNTUEdjQSszb1QycmxSTnNCeXdCSGYxcm1wTlNLT1YzZFdwYUV2RVczUFJ6Y3hidHVNNUl5ZjhBNjlXMFpTT0c0eitGZVdUNmk1UW4xR2NqK2xXN2JVTXhya3VQOW9qTks1bXNTdVpwN1dPOWx1a0oyNUI0NDVxdjV4VmY0ZTJQOEs0MTVFZC9sTlBtdTJFZUY1T2Z5OXFFVjdlNmJZdDVkc3N2M0c1UEZXZnQ3K1VlQmtEam1zQi9Oa0dDdVNPbldyc0VCT1ZPVHhuSjZjL3pyUjJPSk9vNXV6ZG1XN0tkMmtYY004ODVyb25FUDAvejJyR2l0aEdRZW5ZZS93QmEwTis0ajY0Ly9YU095bEdVWTJsM0xpaFNDQm5QT2NWQTVpR1BsNEI5anhWV1RPTWs4WkhQdldlN0Q2YzlNNHFTbksxOURXWlY2Z0FkZWFyUk1uekt3TkpFNDhyMUIrdVJVc1p3ZHdZZENPZU9QZW1LNmJSRE5aazQ1UDFyT0FNYkVja25JcllONUVTZHgrYlByVno3T3N3T1JnNHhudCtGTzVMcHhidkhjd21sWUFmTCtCL1dnUmVZM1BVa2ZwenppdHhiSkY0enR4MEpwVUtLZHVGSi9XcHVVNmUxem41WWZMR0dIZW1pMkRydEc3SDhxNkNRQTdlTS9YaW9sMm9NNTNaNkRPS0ZZUFp4djVGR08zSzVISUdDS2xTQmd3OWM5YTBvU0dHZHA2L3pxMzVYeTVIb1BlcUxqQ09saXJ0QzRKWVo5T3RPWEJHUjk0ZnBUSjRYeDFPU1QycXZieDdXdzJSeVAvMTBHbDliRmt0amFNOStPTTVxQzVRYlNmVHNLZk9wMzhkaHpWbUZBZW9HZStjbW1ITGU2S0ZySXZLc21NZEJVenFHWmM0SFBmM3EybHNVeVJqanRUekg4eEo3ZWxQUzVQTExsc0VhUnB5Vkhya2Q4VmVVd3N3SWJuN280L3owcGp4dVZHR3pudDF5YW9SUnpoemtjRDE5NmsyU2E2R3NiY2NmTm4vUFNyQ1FRakFKNmtjWXB5eWphUmpCSHJTWVlqR2VUZzV4L2hWWE5Va3VnT2k0QkhJQjZVd1NoUU9DTWNaSi9Xb3dkdmNZSTZWQThvd3dJQTcwaGMycEhKSVczWjdaTklrM3ZqalBTc3FTVUsrVjkrT2c1cDBjKzVnVDBBcEdYTnJ1YWhuZmQxR00vd0NUU3hFL0t1NXNIcFZUYXB6Nkg4cWE1a0I0QTR4LytyOEtBdTl6YmVWZHBBT2VRUHlyR2N1UWVuUE5WVWFRdHkzQlBwL1N0SkVVTU9NbjBIMW9LdTVlUlZLc1VIemMvU3BVUnNEUFQwclZZUmJNREdSNlZRVjFEWUF4anJpbllIRzNVekxnT1Y0K252VWNQbWdaWUhCOWE2aGtWdWV2WFB0UUVRZGZUcFNIN04zdmM1YVJYa2NBOGpwZzB2a2txQnRQQS9PdFp5Q3dKSE5hYWVXdzVDZ1k2KzlPeU1WVFRrOVRPaGdjcnVIM1J5T2F6N21HVkRuUEdmenpYUi9iWUlqdHdSeCtQTlZwSjRXVU5qMy9BUHJVN0k2SlFoeTJVdFVaRnFqNUpMZHovd0RXcldZQURweUJTUVN3N3VtTVk5NnVNcU5rNS9sZzFGdFNZcjNWcWMvTmtET0EzMVBVVm1ySElwM2NnZnp6WFR5UmdFa2RmNlZtU3M2Wlhaa1pHQjNxckdUanE3c1kwcnJnQWtBOUtjaXM0d1NTYyt0WnhkdG9jZzlLMG9yaEFnQko0R1JVZ25kN2xXWldaZ2VDY2NmaFVRamsyOGpqbXRSaUNWOSsxS2czQmw2SDBvRGxYTnVVSTBDdmtqQjdZR2F1R0xPQm42ZTlTeUFFSGdoalZaWlZCUFhrZGZlcVZpckpGYTR0MEpiZDM3NDR4V0ViSE1nVTV4bkZkUHVMa0FFWXh4V2ErNUdIQXgxUE5KbU1veGRtMFJQcFlLN2dPUm5pcVl0V1JsSUhmcDFOZFBES0d6dTRMZEJUQ0Y2NUhQclNzWHlVMnRFVjFoSlU5RHp3ZldwUkI4Mk55a0hrOGR1bFRid2lnRWQrOVJwSXU3dDYwYUYyVGFNcVczWExGdXZIVDBxbWpGWENoQ0I5UFN1cVVRdmtjWjRIUGFvSjdNTGhoMTRJTk1pVk52VkZBb3JLRDZkODFtTXBCUEpKRmJ5TXJBRHVPdE1rZ0JPTytPZm9hVmh1TGF1WTZ2OEFLY0U4RGdDckkzSG5BK25yaXJEMiswY2RCZ0Q4ZWFNcmtFai9BT3ZtaXdKTmJraU0yM3VUL25OWmNnS3VDVnpuTmFTRUtNWkJIU3B6SVhISXlDUjE0RlVYeXA5VEtFdWVlUUQyK3RVMlZpV0c3dlUwbHVkeHl4eG5qdUt0UXdSNHljbkdBTTBkREJwdDJJVVdRSmtJU01qOUtzbzgrY0ZUakJxZG1VS0ZEY2VuMXFCSkZEQVpISFBOSXZSVzFBUU94R2UzSTVwaUY0eW9PUUR4a0NyN3pnREhBL3oyckdpdUdaeWNnK3VhcE1VckpyVTN3ckZEZzRHZWxRb3NtN0p5Y1pIdnhVOE1xN2NFOVI5UDUwaGI3dUdPUWVsSzVycG9WeXBVRWducDM3VkFBQytEbm5wbXJZdUkyeHdEOUJWSXNXSklYbnVDS0xrT3llNTFFSklpQXpnOVAvcjFuM0RsV0dDVDEvV3NOcnVSTWdnZ0g5UHBVUzNnUFhCeC9ubW56YUZ1c3JXMk40eUFESEl5T2ZiOFBTcWVEa2piMXFGYmxEaHVtY0QwL3dBaWtGekh5Q2M0elJjSEtMNmtuM202a0VBL2o2MVloZ0dCZ0RwbXFhM01HUmpqbi9PSzJFblhrY0hqbkZKTkJHejZrZ1lLZnUrOVk4OEkzRnNad09Lc09YeU8yZHZlclJLT09CbkdmenAzTGRwSzNZcFFTa0Rwa0h2VEpGUmdjRWNEdlVoVk1FNTcvclVlMGpCUDUxUm5yc3pLYTBqYjVsWTU5UlNwQ3FkRG4xNHJVQ2pKK1VkLzFwU0VWUmdjbnYzb0U0UjZFa01XY2NaYnI3VlllRGFCMUp6MnFxa3hHQm5IYmowOWF2aTRVc2NNR0o5YURlS2p5Mk1tU0ZTdU51RG5pc2cyaDNkQnhubXV6YU1FQTQ3K3RRN0NHeUZ5Y1VHYnBMbU9NZXc4M0JLNXovUC9BQXFlUFR3aEhBeDBIYXV2Q2txZWUvNlZXdTFBR2M1T1B5cFdKOWpCTzl0VEFNWlVZNUhhcTZ3N3lNNDlxaWxtUUU4L1RQb1BTcWNkOEZLZysrUDhLTGFHVGNFN05sL3lYVnNxTUw3MVpGeGdBSHYzRlZ2TytYUEFBSFgwOWF6a0pQVERaNmZ5cUJjMXJXNm04MHZUQnhtc3VSTU51ejc5Znd4V3BFT296Mjlhc05ERzI0bm4zb3NhOHJrWlVOeDNJN2ZuU1NUTXpNUmpBenhWY3hFU0hHM3JrZXVLR1VZQktrTjlLUm03Mkh0TjhvUEFQNTBWUmtFcWdBWVAxNG9vTTNPWFlZak1DUm5qUFA0ODhWc2xoamFHK2xZUmxaWkNBMmMvbFVxenlzVkpBMmpISVA0Y1V6R0UwbTl4Wlk1Uys3UDUvd0E2ZElOeWV1T3ZlcHZNaUJBMjgvbmlySDJjeXFEMngzNDRvWFFMWDVySE1raEI4ak1XN2ZXcFkydVF5aGcyRHllL2J0VzFiMld4eVdRREZYYmhZMUs0NkgzL0FDcHN3VktYeE4yOGpOTVFYK0VaOUNEbk5NTE9ySGpIUElyVUJRZ0RCTEtlQi9udldoSGFSeUFISE9CalBIV2tiK3piZWhsS3daRkpHUFgzcVpDRlU0VTVQNlZkbVNPQk1uQk9EeFdPOHlPdlZSazgrb29MZnV2Zld4SEtTMGg3NFBUNjlqV21qS1l5QjE5ZTRyQWt5TjRWVDllbFRSVFN4cXdMa2dqZ0UwR0tsYVdwS3JIek9TZlFWZWxad3VWWGs4Vno1bGN5Y2p0L0wwTmJ5eklVK1k5cWtxTHVtaUNLYjV3U0Q4ditjMHMwNVVISUFicjE2WXFySkpHdnk1UFB0MTlheDVVTWpNY0ZnRHdSVE01VGxGV1dwZlM2ZHgrSUdBY1pyZHhnTVNNQUE0R0s1dTJLSzZnbm9mVGl1bjNzVHljSDFvSERWTmxSVDFZNTlCMnBGMnRJUm44QlVra1RrQUFrSHFEOUtsaXM1UVFkdllja1VJTFMwMHVMSGI0Qk83ams4NHJQa3U5ckFZQjVyVmFOZ1BtT00vcFZVV0tPV2R2WElHYVpweXphU2pveDBjNnR3dzU5cWZMY2xBZHZ0MTRxNGtLSWhBQTVIR2VhaThqb2NaOXo5YURTMVJLMTlTbkRjU0Z1cDQ2K25OV0crME12SjYxTjluSEF3UFd0QXZFQmpqZ2ppa1VrN1djaktXVjQxTzd0MEhIV2xTN1F0ZzR6anNlQWY4S1dSVWJjZVA1NHhWY1F3a0FxVDcwWEl2TzZWMVpDWEYwZDNiSjUvU3NwQXNoNm5nNXpuakZicEVSRFlVSHFhcnJBTUxoU0I2VU1YSzIzcmRFTHd4RTUzQWtIaytoN1ZWanRTWkJ4OG9QYnJXdXNQQkl3Qm44NlVSSG50L1dscVJ5cTZ1aVo0VjhzQWc1QUgvNjZ4SkxLUFBEZFA1L2hXc0UzdHd6Y2NmbFU1aWZCQjR5ZXZYclNOSksvUXc0WTRsSnlSbmlwbFFDVlR4eDZlOUxJa1FZK1pnZDhkU2FaRnNiQXljNTQ1NHB0c3lqMjAzTjlaSXR1VGc0NCtsQWRKQmdjK21LeWZLRy9HRHozOXEySTR3cVp5RjY1b3VkQ25LVHQwS2txYlFvOXgxTlRKR3pFbGoyNitsWTF4TTRsK1k1VTg0QTlLbU1qQk1nOGV1ZTlPNW56SlRlajBORm9ZNDhrRG5uQnhWUzJtSG5iUzJPK08xQWtlU1BHN0dldjRVbHFpRnVRZU0valN2cVUzZHF4dFhMcVU2QWc0NzF5clF1V3lDQU93NkN1a21DbFFBTSt2cGovQUJxdkNoM25JeU9welRGT1BOSkZPSldUR1NlbmZ0OUtlMC96WS9DdE9aRGo1UmtjOVBhc2Q3ZTQ4ejVjZmovaFNSVFRWa2pTbEM0QkFQVElybXBYMnVRV1BINTFzb0pTaDNOZzllaHFVUmIxSHlqSS9ESTk2RE9TY25wb1pTeVpqeGc1STcxZXRDU3dKUElPT2ExazA5ZG4zZS9Tb2pDMEpHMWV2cDNwRnhoSk5Oa011UVIxUEdUV2E0WXBrT1Q2ZysvYk5iWlRjUnllT3c3VmJOaVhRNEhKSFVmMXFraldVSEp1eHhVWWxWOG5KWG5BNzVyV0Y4MjBKendCZ0hwOUsxa3NnRlpTT25HZjYxbXRiTDVyRUhQR2ZwbW1ZcW5LT3ozRlM0WXJrcnRJNHE0a2k3Q3hPY0hIb2Fqa2p3Z3lPbjRWVWpRbG1DbjhPdWY4S25xYlBtU1hVMHBDNGpKVTUvR3NZdkp5UjE3ZjQxdnhZQTJsVngvaDNwalFSbVFrcU1qdU9sRndsRnV6dlk1NVJNUmtLTStvOXF1K1k0eHoyNm4xclNabFVFN1NmU3FKUjJ6OHBILzFxUmphM1c1alRUTVd3VjZIazllS3dwWWdXQjI4a2pHUHJYVXZaU2tnRTRIK1RUVnRnb0tucHp5ZlgxcEhNNFNiMVJqdzZidVhhemJnUjNPS2RkYVhzakF5T1BUb2NWMFNsQUFBMmVPdElOL21EQ2NIbjZmaFFqWDJWTnhhdDh6bXJhd21ERm01R01ZN1Z1UnhSaGNZNUhZOU0vNFZmZkhsc0Fmb0t6TmttVk9PYVpTaEdLc2theTIwUURBQWRBZVB6b0cxV0FJSHJrVm1wTktwQUFKOWFaTExLWDNMeHh3Ty9OSTBVNHEyaDBqT2pESzdUODNTc29SWkxsdU1Ibm5pb1VCMmpIdDdqRmJGc1VBSUl6MHh4Vm8xVDVuWm1OS0pDZUNmVEJGVldnbERaK2dPUFN0dDNpREhQUHFQVDZWSzRSMkdCK05CUHMwNzZtTDVEQlFUbkdlMU1reUZJQy9Nb3hqclc0MGY3dkhIMDYxaW1FdElNc2Z5N1VySXpuRzFySW93eHVXeXFqUE9hMmQ4aUx0QklicDA3KzFXNG9CdDRHZld0RVJwdGI1U1IyNzRwMjFOSVF0SGN4RXVKaXpCajJBeC9TcXNxU0J3U01uSU9LMTBRQ1E5ai9ucFdxNlJNZ0o1L0Nwc05RNWs5VEFNbnlaNU9lL1htakQ3ZHc5Y1Z1cnArOFpRY1k1R2VocFZ0aEVNRmUzUDQwV0J3bmZVeHJjTW1jc2VCMzU3ODF2UW5kbkl5T2VjZjU1cUl4cnh3TytLMTRmTEE1NHgxeFZtbE9OckdTek1HeGtaNmp2VWNrUllEcDdjYzFkbEtsOHIxei85YXE4cExxQmdmbmcwaTMxTTVDVzRQSEo2L3dCSzFGUlZZZk4wTk50bzlyNXhuT2ZUdlQ1VVlLU0FQcG4xcGtxNlJZZGtDZHZYT2E1bHJyOThSajhhdEIyT1ZiSkI3ZWxVNUl0cEh6ZmdlMUpreWsya2EwY3VJeG42L2o2MHJUeGs4Z2NkT2ZXc2N5TmpDdGtZNTcxUzhtVGRnU0RQQno2MEV1cE5KV1Z6cVRLTm9JNmRpZlNzMlhVQWg0T1IvbnBUWTkrMHJuT1B3eFZVMjRKQjRBSi9IMW8xdU51ZHRCcHZ5Q3VUZ0gwQk5XRmwzWTkveEgxcVA3TW51ZlR1S2xWRlVjSElIcU1jVXJzVWVlK3JKV2h5dlFZL3ptcXdqa0I2QWpqdGdWc1J5SGFRUU9uUHBTWlFTSC9QV2xjMDVVM3VjN05lelJFS09Pdk5QVzdFdTdJd0J3Y1Z1VFFRdWVWeGoxN1ZTK3poVUcwQWV0VmRFT05SUytMUWdqTFp5dklMVmNFaDNqNWVNZHZlbFJRZ3dSakdjY1VURmVvNjR6azB5MW9pUXM0VWRPdmYwcEkzWW5Bd2VPdWF5Mm5Wd3d6Z2RxamhWZzJkMjdCSDRacDNNdWYzbDJPb1FzcThNVG52VmVTOFVZQVBIODZWTTRPUjh3NUZOYTFHZHhHQjYvV2hXTm01NldNZ3lFdVNHenowRmIwYjU0UEdlbmVzdUpBR0oyNVBQWHVLbGFYYTI0c01kL2FoRXhWbGRsSzZnbTM1RGJWd2M0NjFERm5ZY0V0N1k5SzZONUltUWQ4WjZmMXFoRWczY0FxU2NkZXRJVGlsUFJtVW9rRGJ0eEF6bnBXa0hsT05vSTlQd3JVQ29HNUdPZjhBOVZXbFJBQnUyOEVFYzBGcUhtWmtabFk1eWZUcFZueUNWQkpCT0QrTmE2b25ZajNxdExJbVFDZnh4MG9SMEtDdGU1eWM5czNjNUk1eDByTFZaUTQ1ejdWNko1YU11Y0RzYys1ckptdDR5YzVBUFlmV2d3blFlNW1SazdDU3hEWXF3c3ZBQkJ5T3RhMGNTTUFPT25OSTlrQjgyZVQrV0thUStTU1NhMk1wNWlPY2NnZnpySGtsYzRBNzhFZzlLNkNTekpCeCtXYXlYaEViRml2QTQ5L3hvTTVxV2hWRE5HQVN3SXpqSHBVY2psazNCdXZjVlBNRkk0Si96M3B5d3IvRjZaL0tsWWl6dmJvVVVuWmVnT1FlZlNxenp0bkhJd1QyNHJkRUNoV1pjRDN4VW9qaTcrdllVbWc1SmFLNWllYko3ODhaOURVQmxrQTZlaHg5T3RiNVdFNEJIVHZpcXoydzVVY2RzVk5oT011NVVobmM3VGtrSDMvV3Q1WkNVSUpQdm1zY0swWUdjZjUrbFhVa0dCZ2M5TVViRGkzMUlkemlRQUhHVGs4ZEt0U0ZnTTlUajhhcU9BSHhnWTVPYytuYXJjY2tXQ09PblFVelZkVVo3VERQTEFFVWlHUTlEeG50VHBZZ3o3ZG95QnhqcFVxUXFGVW4rSDlhWkh2WFkyWGtjQWozOTZ6Z3pqcTNUdHdjaXVqMnh5Snczcm4xcWtiWlFwTzhZUGZyL3dEcm91RGc3cGxCWmxPMEZobkg1MWZNeFZDTWprK3VCL2tWbm1OQklSajE5NnVLQWNBZ2tnZTFBdGJQVXlnelBKakhwZ24xcGJtQWJNZzkvWEg0VmRaY0g1RCtBcW9KR0FKR09lZ3puT2FaenRLenYxNmxaREl3SklKSkhJSjdmV3BvUU4vQUFQVSs1LzhBcjFBNzdoZ0RIdC85YWhGa0J6ejBQNmVsSzJoTGxxdXZtYkVvSUNrOXZlbWlUY1Blb0RJalJnQjhIUEJyTWRaUnQ1NEJPY2Q4ZHFFVTIxSzYxUnNJckU4SEZYMFJ1UVNPY2RLNStKMlVrRW5ya2R4VXZtU0U0ei9nVFFhYzYwWnJ6SUdYbkJ5ZTFaRHhCUWNkeDlPS2tqY0FLeHlEL0tvbWwrYkJVRTU3VXJFdVNkaG1KTnE4WjRyT2VPUlN4VTU3aklycjBqUTRPYzVwSjRGQ2dEampybW1KMG0xdnNjT3BuTDVDakhwNy9XdDJCcEZPUTNKUFQwcVZiZFFXeWVQenFkbFRCd09nSFQyb0ZHbktLZXBNMG55Zzd1cC96aXJpU0tGSUJ3ZXRZV1NBb0kvK3ZtcjI4Wk9jNHgxUFlWU1Jyek81cW1SOXVBTWo2ZWxLaklSMHdmZnZqMHJQVkcyOE1RVDBGYWtaS2prODgrOVdid2J1TXlyWTdaT0JVRDhnSGFjK3BwMHB3ZWZxY2VsV1lRSEROeUIvS2d2ZDJNaVhjTUErbnJWZkRLNmhHSkF3TW45VDlhMVpvOXUvcGlxVGJ3bkhjY1o5S1Z6Q1NOSVRFeDhFWkhXb3pjanRqbjlLNTRNRk9jNEpQcm4yclFTTjVCZzRQY0dsY2NhalpkZTRDdHV4a2Z5Rk5Od3Npa2M1em42VW9pa0VlQ29IMU5WRENmbU9PM3J6VEtia004aFpoeUFBRDBxQWFiKzlCUFBiZ1lxekc3UnVTZTUvbFc3SGNNT1FNVXhSakNXKzZNeHJEYXVjay9RVmxMYkFNUnRJejMvK3RYVkNkM3p0eHgrdFFGWDRKSFRIVHRTME5aUWpwWXp3bTNyMjU5NnNwMHh4eWUzSjZkcVYvbkRIdUNCa2pHYWVxT2ZtT1NPTUgvR3BMaXJHT2x1N1NIUGM0eWZhcHBMZnFXVW5uaW55U3VwOXVjWnFXT2QyVWc0SCtOQm0xSFlxb2tlekQ5UVIxNzBWRlA1b1BDMFVpZmtjakxhc3JsZ2g2OWNZNXAwVGhUdEFPY2pqcFczZFNQc09CWEhMRkk4NjVrSkE2ak9PS1doNUV2ZGxwcmRuUlMyMjdhM1BRNDQvV3RHM2trVk1ITEFaNTdWUWFhYUpCbk9mN3VQVTBXZDRKSElDOUQyR1B3b1d4ckdVRk8xN05tbzBvWG5kbnRXZkxkcUNOdzdjZ25yNkdyOXloY2NqR0RtdVJsaVlTNU9TVDBIWGltS3RPU1doMWtFaXlMa3VNODlLbW51ekZsUVRnLzU2VmlSTVVRQWRqZ2c5YWxsY21UcHlCanA2KzVvUW5PU2d0ZFJacFhuT2NnQWRxempCUEdXeGtjZ25QV25HVHkwd1FTYzgvd0NmNTFBYjdleCtRNTdBMUxJYmpiVjZsdUYySFZqOWZXdHVSUVV5RXo4dldzT0tUNXM5RGprY2MxcGVhR1RyakErWG5ta3pTTFZtVkFoQ25yejAvblVBTTNtSDVjWkdmZXRMRVczSkhmdndmMHFxYm1EUHk5ZmY2MDlDTmU1bk1reGwvd0JuL1BIRmRCRUZWQ3Z0anBWWFlubFpCUE9LZ2l2VlZnZ1U0OVIrVk5EVFVKSzczSTVJcFZjRURweWFyUlQzUm1JNUhKeVRYVnJQRXlISFBvYXdWd0orU2ZwL24wcFhDVVVyTlMzWnJSWEdEOC9IUEZkRjlvSEJKeGtWaGkyaWt3ZG9PT3hGVUx1Wll4Z2NzZTNiUHBTUnM1U2hGdDdGKzVsK1lBYzQ5cTFZWGhFV2M5ZXg3ZmhYRFJlZE50SlhISFBxTVYwY1VEdkVjTWNrL3dDVFJjaWpVazVOcGI3RnN5UXMvd0FyRWpQQUlwcEFaaGhqMTU5cXo0NEpZMk9XSHVSV3FwQUp3MzlPYWVwcW5LVzZzVlhiWmpnblA0MEtOeTd1UmdjWXFLN0RIamoxeU9LaWpsa0VaR2VwenozOTZwQTFIbWQraG9IWUl4Z0hqMzVyS2VSZ0dHUU1qT09hazJFbGpodndIK05TcEJnazhrNDZVQ2QzWmJHVXNjdThNQ1JnL1RQclZ4UktvR0RnSG9PdGRDcWpIM1FCK2ZXcVFsUlpjTUI2OGlsWWZza3Z0Rk5kKzNCOWVNLzQxY2FWQURranBWemZISXZ5OFp4bkFyT2x0bWJkaGNqR1Axb0c0TmJPNVl0cmdNU0NPby9sNlZXZThqVnRvT0R5UGFzeUczYU54bnIxcVNlMkx2dUhVbnA5S1dseWVhbzRMVFc1SFBFWFppSkJqcm5IclZlQzNkV1V0SVRnOXVTTVZaZU9WVXdEa2RNZTlYNEVLcGdZeFN1WktDNTlibGhnQnVIQjQ0NHhpbng3aTIwbGUrY25wVlFiOGtBSEdQOEFQV28zaG1Wc2hDM3AzUDQxVmpWU3M5amNsc21LYmdCa2QvNVZXYU4wUUhQcjFOV3JlNGxDRGNQcUswcDBqY0tUd09oNTlLR2pvY1l2VmIyTU1ZWkFTT2NjWTVxRkNvWThnNDYxcExiQURBSVByNlZpdkV3Y2pxQ2VtYzFLSWFhU2RpK2tqRnZtNzlzVnFmdWdNakE0L0RwVWNFQ2hPTUE0Nm1xa2s4ZmZhTWZ6cW1hMmxCYXJjd3J5NmZkOHBKT1FQWTEwdGpKdkdKQjE5ZTJhejJoaGJrbk9EMHJSaVZkcDU2RGdIcWFMbVVWTG1idjhqVW1nandRdlNxT01Qa0hHQU8vWE5WSlo1WXlwSFFWTXR5aFVGc0RPUHFEVE5lYVBNMFh6T3dQVEFQU3MyNXVod01BZmhuOHF0b1lIQnlRUjlmOEFPS3JUd1JsY2pCNDZqMHFkQ3Bjemk3TXoxdWhqS2xWQVBIZk5kQmJYYk91Q01uSDByRmEzanhrZ0hqcWVjRWR6aW9vbmpCMjdoeDMvQUswN29pTXBSbHEwZEpPd0NoVXlSeFdJUUNlQi9uNlZaYmNSMXowcUdDWkZmRFl4NjVwbHlkMzJBd3lzR0dPbzZWVGxobFRPT1BXdXZXYUFJT0FSMEh2VktlNmlZa0tvN1ZMMUtjRmJXUnljZm50TW1jOGovUDVWc01oQ2plUHdxTjVFQUdCNiszU28xdUF4SzUvcm1rakhSV1Y3M1lqNFBVbkhwNlZJczhhcVJnRUVjRC9Hc2lXWllobllTY0Q2ZXROaXU0cENEdFBKNDdHaXhsS1VVOTdNdnZQdUFHemc4QTQ5ZUtvTEJMS3VEbmoxcmFSWXNrZk1Sd2NIdFYvYU5wK1hKUHJRaS9aODI3T1BOcTZ5bGlvL0N0aU5XMkJmdWsrdFBsa0lPTnZUdVIweFVtQXdCSUdleHBrUmpGU2RpTVd3Mm5jUm5yMHBxeEV0akk0OS93Q2xha1kzSmdrRTB1d2J2dUFZNzB6YjJhc2pEYUhMcWZVZmh4VkNTTkFjRVo3aXV2ZUVzbzR4anNPLzVWUU5tV0hVNEhJelNzUzZXbmNvUnVySmpvUDVmV3B6aU5mbGJnL3JVOFZreU9PYzhWVGxSdk5BSVA1ZXRGeXRVdHZJZ2toTE9Ea2pQUmhWK0tCVXdDUWNIdjNwclJ1WS9seGpqNjFXWXY4QTNXOXZTaERhaW5lMnBxdktHRzBaSGZQYzVxbEhFNUpPT1NldVBXcmtVVE4xUC82cTFVZFkxRzREOFIrdElybHU5WFl3NUMyUU9RYXZ3WUNnWjdkYXVENXp1d1BselRFVmQvc2U1cWhwV2U0eDFVc1R0SDhxcmxrSkM3dUQyRmJibUdPTG5IK2VhNFNTNFo1UU5wQTlxQlZKS1BYYzc2RTdZd0Z4akg2MUhLWGFQT01ZckpobVlBWkFJSS9HcmZtSzNIVTl2cFFhYzJtNW1FaFdHTUVIUEpxV0pwQ2NxYzgvenFSb0FXeWZmUEZTcWlydElHQmpyMjQ5cVprcmxPZEd3NTU1UFFjMWtMTktPTVo2ZGY2KzFkdW1Tb0J3UlVEUm9EeXZIK2VLRFYwK3FrWUtPeHdSbklKeitGYU1XK1FNRG5nRDg2bWFQRzA3UUFNNE5TaVpVUElCR2NEOEtBVVVucXpEZE5vRERnNTVJcXZLQVFwSElPZU9uU3RHNGtWbFlBQWsrdGM4WkdXVUhKNUovd0Fpb01KTkorUnIyOEp3VHNHTThjK2xRTkhJV3dxOWNjbXRDM21RNTR3Y2NBbW9XbFpuSHJtZ2I1ZVZhaXhLVGdrWWIrZEpjTDdFZWdxNE1ZeGtZNkRuL0NwT01IT0Q2NDZWU1pkdENHS0puUW5Jd005OGNWWWlnajU1NTRxQkpWQUl4MHgwNjVweHdlUjA3K3ZOTXRXMEdNZ0RIRzFhb2xWVTVKemdjMUswcWJzTU1zTy9wOWFIRzVDd2JwMHowcVROa1RYS0twd0I5MzhqVVJkaUFDUHJXUE1aUE5JeUNQeTZlbGFrUmlVS0R4a2RlT2Z3b3NaY3piWkZISWNZRDQ1UDUxWTh0MkpCL1NyUWlRZzVIY1ZiVzNqWXJqZGtEZzlxYkxqRm1MOW5VUy9LT1BicUtidFZPQU1BZHhYVUxiaFY2NS9EclZHUzJROE1wOXZXZ2NxYlhRdFd6aGxVRGpqakhXbVRramJsYysyT2xTMjZsZUNlbnJTU3NDT1NNWjZaNTVvUm9uN3Rpc2dCQnh3Y1ZYbHRYSkJBNmRLMDRYaUhYb2VQU3BubFZsUElPZSthb2JTNWR6TEVENE9SMUhZK2xQWkFuekE4a0VqTmFBZENPZVBla0pWeHpnOC81K2xCWEtyR1U4cGNZK25Ta1V2ak9jZjBxS1dRSnR6ams5UlU2eUl4K1RoZ1ByU00zYSs1T3J1Qm4yeGsxUWVXWW5JeDF5ZjhLa1ppcTU0L0x2UU1zT2QyUURrZldnSDJ1eXdiaVJZemdZSUZaMGw2MGhHZi9yYzA2ZGlxRVp4ejFOVllGNXdEeCtYU2tUS1VtMHJscUc3ZFpQUTU1R1BTdDVwMllqaitkY3czeVNZT0R1enoxcmZnbUd6ODhqdnhWSm1rRzdXYjZrNWtDOHRnRWRNVm0zQzcxUDhBZEZTWEJjdWNZckRsM2dEaysvUHBTRk9kdWhwUnhLRnllY0Rta2tLdHhqb09sWTBzOG1NYnNaOWZhblF5SDVzdDI3ZDZEbjUxZEkxc25Kd3d3UjM2ZmhWQW5hb3pqMTYxV01ySEdHNUo1QTZHbnlwOHB4d1ByU3VXNVgxUkJOY3lvVGc1SFkxTGJYUlp4azVIdlZRUUt5NHpuSjVGVHdXaFJqdFg2ZTFKc21QTmN1eXlxUmpCUFhuRlVmTVZWKzhSanIyelY3WXgvTGxmU2xraEpQM1EzSFdrelRWc29zNU9NSGNPUlZ0SFVFODRJSU9NZGFwcEcyU05wQXljSHJVNzIwaXFPY2M5YzBFYTlpRXlESVBHYzVISEFwd2tjeDdzNXh3UDVWbnBEY0VyeVQ2NTRycExlSUhDOFp4MHF1aEVPWnZxWUF1SFYrRndCMnF3MXlXem4wNmUxYjcycU5rNEFJL3JXVzZMR3k0QU9mekgxcFdOSEdTNmpjT3lBOWZ4OUtwbG1VWjVHQmpCNzFhbHVBcElISHRqbW9FWlpRRC9BQlk1NzVxak9YUlhNM3ppR0l6d2UvU3JIbjdWNjU0cUNWVHV5Y0hua0grZFZtaTNOam5rZXRJNTd5VnlJejVrR1ByMTVxNEwyTjRtRzdCd2NlOU1OZ3BpSjJnTWMxbFIyRXF5RUtCMjNVeUwxSXZiYzFIeU1GZVIvSVZjWGlNRUxWWkhkTndPZU92MXFZWEcwREs1NDU0cFhOSTZPNDZIY3JrOGZoMXA3WUEzTVQ2ZTJQWEZScElHQlB0MDYwc2k3OG5CQUEvV2xjMHQ3bzhUeEx0M25nbkh0ejBxU1NKU3l1cEczcWF3SEVxSGtmS2M0UFdwbzdpUmM4akFIMG9zWXFwclpvNlZId0NRZTNJK3Yxb2tuSnh4am1xb21JUmM4bnZqcDcxVyswanpPNUc3clFscWRjV25iVTM0cmE2bkh5SVdCUFhIVDByV1RSN2hRUzZybjI5RHh6V3BwdC9Dc1ErZmp1Q2F0M0dzV1JQeXlBNDQ0SGVrNzNQdU1QZ010alFqVXFWN3l0czJrampMbTJDOUZISjUvQ3Fpd3NSdVVjVnV5U3BJKzd0Mi93QSt0TTgySUFzY0E0NTlLMGpvZkpWbFRsVms0NksraENxREl4bkZWSmhLbVNPTzRIK05UZWNEa3FUakdjam1uVFhFSUJMTmpCQU5WMU1IWnJzVXk3a0RjZVR4N1ZFa20wSEJ4a245S1ZXVndwVWdnampqRkNzcTVCSFU4SDZkcUNiN2FqSGtPMzVqbko2NC9uVmJ6V3dNWnhqcFY1aWpjTGc0N0R0N1UyT0ZPV3lBRGcvbDE2MW1adm1iMFpraEdMRWdNMmVlblQvNjliOXRJRXdPYzQ2VTVFQXhnZC81VlduRHVlQ1FBZW9ITk1wUjVkVHBGVlhPUmp0K0JwR2pWV0pKR0FjQ3N1RXNNRTgrb0hyM3FXWmdWUFBQY2R2cFZuVnpLMTdDa1JNMk8zMTZmU2tNT1VKSEdSOWNWbUx3ZnVqakFGYkVTbGw1UGJwajlLQ1U3dll6TjJKRDFQYjB6M3E4bnpBRWc5UFhGUU1nM1o0SXpuTlJ1MjJNRUhQMHFRdlpsZVNWTjU1NEI3OUsxWWJoV0FCOXVoNkhyWElOTUhiQUgrRlhZV1pRTUhvTWZXZ3pqVWQ3bTI2UnM1SVBjY1o0OU9LYjVZeVNEbkI2ZE9sVVdsWWdFOEU0L0dvUkk1YzVINTBGdWZrYU1tRndRQU92ZWlvUWtqQUU1NTU2MFVpazNiWTRScmxsKzluZ2MvaFZOWm1Sc0tOMlRuMC9XdUsxTFViaFpnRnlTVDB4K3RhbG9MbDRWSlBLam5QUEZJK2FjbTIycjZIcDFzOFU0VURPY2M1SElwc3FRd3VHeW9IT2V4eFdYWW9RdVdJR1QwLy9BRlZMZE03TWczZGZ4L0NsWTdsUDNFMnRTNnR5amNjanRnL3pyQ21sVXNjL3duQXFjcXk5UGZKcWo1VXUvY0c1eU1BRHQ2VlNPZWJrM2F4ZVh5c3Fja0R2bXJDQmRoSjc4OU91S2JzSmorNk8vSnJSdDdWaU9vYkhmTkJ0Q0xiV2hndTVja0FBQWNaSjY4MWRqc1kzRzVueWM5UnhtczY4amVFc2NldVNlZWFweFh0eUFDZ09DVjZmWCtWSVVlVlN0SlhaMFJzamxnamRPeC94ck1hT1ZDdUdQc2NWMHNmbW1NYmoxQUZaYzl2Y2hEamR4NzBtWE9HcnNtWmNyVE9oM014T09nNDZWVmd0NXo4NWJQNGNaK3RXNHJhUXR1Nzk2NnVPSlZSUTJHejBQV2taeHB0dE4zT2FqYVZUazlQUVZMTENBRGhpY0RJL0grZGRNaXdGTUFZT09uZjlhcVN4UmtMemdZLyt2MXFqVDJUdHZjd0VsVlIzNEdUazVITlUydW5lVUtyQWZNTTU5cTA3aTNjbjVmdTkrS2hTeEdDd0l3UjBGTFM1bEpWTmt0RFdqWkVIekVjbk9ldkpxRXFKTW5jUGZIOUt3cnVHZEZ3R09CemdWaXRmTW9PQmpCN25yNzBXRk9zbG8xWkk5R2hhRkFBdWQvWWs5YXZKZGdaUG9NamoxcnptMW5lYUlGdWM4NFBRZHEyNFEyOERJNEo3OCt0RnRUV05mbVNjVlpXME90Q21ZYmdPVCtYMHFqY3U4TWVDY2tyMnEwdDNGQWdCT1QxNS93RHJWU1M4U1poam8zVWRldE81MDNqYmZXeGhSWFVqdWR3NlpIU3VoNElVZ2djZFJUbWdpMi9LTUU5T0tpU0Voc2daNmR1dnJUSlVHdE43OVM5R1RnWk9PcEdCNjBrbDNHdlhKSXg3VkhITThST1ZCUDVVeVdIenZteHRHY2RmMXpRYVBWYWJseFo0WEh5NXdSVk44c01BOU9uSHJVaXhKRXBYUEJIVFA0Vk1rUlo4NTZaeUNPYWVsZ1hOTFFiQUVqeUdQSjc0NisxSWtwYVFqZVFEeGorbFMrVTI0Z1l4MUJwc3V5TXJ0QURleHFXUFZMdFl2QlVkTTdqNkExV2toMms1R1BURlpFdDF4bmRnQUhPS2JCTzhzYkJuSVBiUHBTWlB0SXQydHFhQ3BHUjF5eDkvU2xqS0s0Qko2L21CV1hidElqa05rREgrZnBWaDVVTW5KL3dHYVJuQ1NhVGFzeDl4Sis5QURuY0IwSnE5OXVYeUNBY24zN0dzaVlnS01kVGpucGpQdlhHYjdwcGRvVWtBOGM5YWFPZXJWY0pPMnR6MGkybFV0dTI4RThtdW9ZcnNKSDRacm1MVkNzUTNqREhCSXJYSnlvMm5QdDZVSTlDbTJvM2EzUm15U3pEY0FjNDZucHhSQ1BNYm5na0NySWpBQkRqbjE2Zm5WSWtDUmRwL0wyK2xNVm5vMi9rYlpEN0NDb3lQNVZ6Y3ZrdXluSkdPMWFiK1pJdlFnSFA2K2xZazlwdVRrNGJqNi84QTZxR2ExcTA1UlM1YnBHaUdnQ0hPR3h6MTVwaTNCM0pzenh3ZjhLejRyTjJZOHNNanJqQS9DcmtFTEpJYzlNZFRTT1ZPYnRwWkZXU1NSbjV6ZzlPZUtzQU9GSElJOVBXclVoUUZjWU9SMjZnKzlZdDFOSXJzcWdqbjBwNm1jclJ1MjJ6UVVzQWNZUEIrb29XVnlXRERINllySWhrbGorYlllUWM1UFErMVhDNnVPTWc0UFVWTENMY3JXYjlDTlhacEJnazQ5T0tlNmtLVHU0T09vN1UyMmhsRERKNjg4ZGExWkxTVW94R1RnZCtldElGQ1RpOUdRcEt3eU40T2UzZklyR3VkMjhrRWptcnNlbnpuazU1N2l0bU9DTUt3Njl2Zm1ncmtsTFJxeGxRenlDUE9TY2c1QnFoNTRFZ0pjNEo3L3dCSzN6REdGUDQ5T0t3N25UeG5JSXlUK2xNSnhuWlcxc2FTRkhVL1AySEFwcTJMSzRZTWZiaXF0dlp6TGtrZ2RPYTZGWkpjQWVnNjlmd29XNVVJcVN2S05tdGlHVzFTUlBtVS9oVHJTd2pnVDVtT001SGVwM3VuN0RBNkhqSXg3VXJwT1JrRTRQYXE2R3ZMSG12YTdSTEpKQ081d0NCVXBsRzNnNHhrbkhITlpyVzdmeERKT09ncENCR3BCYm9DUjdVa2pWVGV0ME13a3BQellJT2YvcmZXbmhDSDVIVDlhZFloR2RTRnJkZTNsQlZnM1BiSXBvbU1McTlqUEdZMTVPQjI0NzBzYk1SdTVISS9EM3E4eUhhUXk5Ty9UbjFxOUdJZ200ajhPdWZ3cG15amQ3bVV0NU9Ed282MVFrdUo4dCt2RmJEUzI2a2twampqM3FCQkE3SEl3VDZlaHB1eExUMjV5dERPTjJEbmtmcFJjSWpTRDV3RG42L3JTU3BIRy9YcWZTbkxHWkh6eHgyOWFrcXp0WjZsdUtMWkdPZXA5T1QycXRMR2NIR09mejk2MnpHUkdCa0hIODZ4Sk4zUURQMHBsU1NYUXFXYzREbmZ6N2pwV2hQSkcyZHZXc0psa0pKR2NkZWVvelNwSExuTFo5L3I3VUdDYnRiYzBSZUxHQnlBQWUvNVZZam1TUUhhM1RrZDZ4SGdRaHRxNDk4OUtTM1o0bnhub090S3drNUpwUFkxWlpqMGRTZUIwcUNDM1hPUmprMDR4R1VuQjVHTTB4RjhwZ01IL3dDdjFvdG9IVk94dGtvaUhKSHY3Vm5veEw1VWpBNVBQYXM2ZWNPUm5JN2UrYXVXOGthcDF3ZURqMSt0Q0xUVGxhOWthZ2RpbzcrNHF1NmxWeGcrd3hpc3FTZGkvQTQ2MVVrdjVGMnE0engwNlVHYnFSUnVReUZUamdBOXZTcjZTcGc0enp6MDlLNVJKdDRKQUhQYlBURmFFRW1UaHVQV2tWR2V4MUhuS1ZYMTdESGVzQ1lzRHlQbHlPMVc0MEViRFBJcTFQNVRSbkNpcU5YZVMxME1oWXk1T2NjQ3FrMXVkbk9PZjBxL0NmbkdDUWVmYXRJb3BBQndPYW14Q2dwSTRVQjB6amNjSHQvOWVoSGwzSDVXeVBVWnJxRnQxODNJUFhvUGI4YXR5UWhjZ1lKT0RudFRNbzBaY3Urek9ZM1RCZVRucmoycWExbVpzTHdlaDlqV3Y1WUtucG5QSS9sVk5YOHQ4anR6Z0Nwc3lvdzVaSjMwSVp4TGtGVnhqaXBrT0Z5eE9Ldk00YU5tQ25qazFUSlp6Z2pPQnhqdGlxTkxKU2V1NVViNzNHVkhZSHZWYVM0SVlZSk9SNmNuL3dDdFd3dG1XVnNNTzM2MHo3RU54endNSGpGTFM1SExMME9YV1V5RUVyam42L3BWMW9wL01IUEFQMHJlZ3RJUXh4Z2pQcFVzb1JUZ2c1OXZmMXF4S203WGJPYm11SjA3a0FIQnE1QmRYRDREWjdZTldIa2lJd3dCclZnaWpLOEtNWTdjQ3BZNDA1YzN4RTBVN25nZXZPZmFwNWJnRmNMblBGWkxodzU2RDZDb0hsSWpIOCsvSHJuMHBHOTNiY2thYVJpT0RnRTlxUmpsUmdFanZ4M3JMaG5mZnhnRHYySTdZclQ4MVdHQS9IUWpwU1pnbW10eVJJUWNrRW4ySnFTSlJ0MjhjWXorRlZra0NqSWNDa1dYRGdBOWNjaW5jclRRM0hSUVI4M3JqOFBhazI1WEk2WjU0ck9sblRBd01kS3ZMY0pzeXd3VHgxcG1zWks5alBuc3djZk1RY0hHZXBxQ01MSDE2RHZXMEhqWlJoeDB6NjFRdXJaaW9BSjU5cVluSHFrVkRQQy95cXh3VCtOV295cTdpUmtqL0o2MWkyNmJIYktqZzFkYWVJNENrSHZUWkVaZFh1YUV1MlJjREpIMDVySzJCSHdCK2xDWE94emtBZ2pQWHBVNUFrNUF4bnJVamJUWG1aOGpLenJ4a1p6VzFFVUtkY1lCejdack5hTVlBSFB5NHhXbERBNVBYUDhBaFFURzkySklHKzhUdTQ0NHAyeFNtUW9QdFZpUU50SnllT01mNDFFWXdmdkhIVTQ2MHkzdVlFcUlYVUVFblA4QWtWTzlzZTZaOU9jZnBWN3lGTC9NY25xUDgrMVhIYks4a0hHT3ZmOEFLZ3pVTDN1WS9rS3VRZlhuNjA0cGhmWTlLdFI3aWVtYzU5NkpWSzQrWGtaOXV0STBpbFl6SVhkRDkzblBVZWhyYVdTUCs1alBQVEJySzhuaGNrZ2pnZjVGYWZsbHhrSEo2ZGUxTUlwOUNHVGFvSkJKNC95S3hmdG9SOEVuSFlDdDRoZG0wanNSK1ZZWnN3MG1mMHhrVWhUVXJxeGVENWozWUI3azVwNGszbkdPRFF5YlJqajJIb2FzVzZjcVd4OHZ0bk5WWVh2YkZTUjBSV0JYanJ4L0kxaXgzNTh3L0lBRGdCczVycHJrUnZuNXVvRmM5TllEQllNUjNQdlVrVFUrblFzVFhNc2lmS01ZQjROWVlsZHBGTGRlblh0VzFieEt6QUU4ZlhyaXJyV3lIYmdBanQ5S1pEaktTVHVaaVFySU53Sko2SC85VlROYk5HY0FmVSttYXpyc1RSbG1STSsvdFZScm1kVTVQcGtkanpRUmRLNmFkMGIvQUpHOVNPQjN3ZjhBNjFSR0IwWnRvSGJwV0dsKytjZDhjazhZcDczZTdHU2Z6NUJwSVNsRm5ReHRuZ2taQXorSjlhb01Bcm5udjErdmVvYldjbkRNdVFNL3JXbTBneW94eCtGQTdwblAzQk9CbGMrOVZRek9WT2NqMHhpdW1NVWJLUm50bjJKcXNJSXhnODRIR004L1VmblMzSWNYZnlLR3dKdFp6bjZmNFZvUVNSTUdCSGFsa1VmaUJVOGNQTEhBejFQZnJUc1hHTHZvWlZ6Q1RrcVFSbnA3Vmd5VzdveDVJR1IxRmRJN3FrdlFuQjlhMW1naVpXSk9janA3VUpHYnBLVGR0MGNvc29WTUE3aVB3cW1US0NXNTl1LzZWMDB0bEZqR0tiSGFnS3dLZzFWaHhwMUV6bUVsbEQ0SU9jOWEyNFFvUHpNM1BVRDFyWmpzRUdXK3ZYc0RVY2tRajNLcThkcVNOZVNTanFLekZGOWNkUDhBUHBWRjUzZkFiakhvTzN2VjFVbDRHU0FjNHFDU0psVUVuY1BRY0g2VTdBNzJMOXNTQm5HY2UzRlZyNk5uWEFCNHgwOXFlamtJT0RnOUJuUDRWTEc3TGtzQVJ4MG9UTGJYTFl3N0RmRzN6QnNZNHowNXE5Y1NNcWNZNVA4QU90UmpHU01ER1B4L0tsbGlRRDVoMTQ5T25QYW5jelVIeXZVeVk1WDM0eG5IQXoyRlhJWExEcGo4ZTM0MDZLTUFuQjZqK0xqbW5ibzl3T00xSVJXcTFKR2tZWkdUMDdkcUZsVmdvNTQ0T2FiSVVhTTdSK0J4bW9vRlVuNWhrWTVwbFhmTm9YMG1SQ2VSK1ZPYkVoQnp6MXhUbWlRa1lVWkg0bk5aOHNvakI1QXlldFBxYXU2V3V4cWVYdFhPQWVldFdvUmxDVG5PZnBYSmpVVmZDcXdJUFRqK2xhc1Yyb3lRZVNPblNrRVp4dVhIazI0QUhPYzRIV3FUZk1lRG5qcDMvR3N1UzZ5Y2s0OXZwVTBja2JnL09NN2VuclFadVNic1o4a1dKQWVjanNQUVZzd2JTTUVjNXhrKzlZczl3QWNNb0pIQk9LdVF5Z3VDVGoycEV4YVVyRitSVkhQSndNZzVxQUE4OFo1Ny93QmFlV0hRL2o3VkNXWGJ1SjRIQi9PZzFaY1NYQzdTT25mL0FQWFJXZXBHTWc1ejcwVXJscVRzZWU2anBzU2xTWWhsZjd2SjVIK2VLdWFVTmtLamJqL1B2VmlITGpCUGZHZS80VnJvRWpWVDdIbnJ6OWFmUThXRVh6ODE3SzJ4TkdDTWdqSlBmMnBnUm5iS3FTVzVCNi81RlN4amVuQjZaL0tvcmFWbGtZSEI3MEd6dGVQWm1pa1FZY3IwQXorTlFsbHpnRHBuSDlLdCtZN0VBRHFNbkgrRlljeEtzekZEanB6M0ZCdG9rbVRlYkh2VlMyTS93OTgxMHNFdTFDUXY4cTRhRzJNazVrSEFCd09LN1BiKzdIT0RqODZBb3QzYnQ2SEk2bkVaWmhnQWp0MDU1clR0b0lraUIyODQ3OFlIcFVjb3hKbm5QdWEweUZDOE1NRmVSVTNaQ1M1NVM2aVIzT3h3b0F3VCtudmlpNHZvc2NqZ1p6MnBmTGpjRTdnSzVtYTJKa0daQ1FEenowL0Nxc09VNXBhYWx2OEF0QURBM0FkZjhtcjZUSUl4bHhpdWZ1cmNCc3J0Sko2NTZlMVU1SXJpUkFHa0F4MDIvd0JLVmtjN3FUVW5kWHRzZGQ5c2d5QjVuVGtpcGZ0VVlBSk9SajYxNTNhd09qaFc1SXlPbU8vdFhWRzFEUnFmbTQ2QVVub09uV25KUFN6WFEzemZXMnphT1Qyck9obTY0SS9EL1BTdVZrMDU0dDVNakFkZmZpbHRKWEVMWWJqakhyeFNHNnNuSkpxMmpObWQ1R2RzTmtaeHp4d2Zlc3ROTzgyVWxnVGprWXJRdExsYzRQUVlQYkdhM2pleGhWVlZHTVlwM1pqeVJsYm1sOGpuelorU1FBRDA3RE9LeTVubERLd0xad1A4aXVndW1PdzduUE9jYzlxNVJvM2VkRDVoSUJJMjljOTZhTTZxdFpSVDNXeHFlVmN5d2x0MzFHY2Y0OFZic2dJejh6SGdIdG5tdEtHVlkxUUhHQVB6cXdqUk8yZHd5ZnlvdWRNSWN0dmUxOHl2OXVjWElDZ3YvZTR4WFFSU3hsVk9CajBIT2F5M2l0NUd3T3VjY2VsYjMyTUpDT3ZiQkZPOXpvcCswdks3dWpEdXJpSmR3MjdTRDJIUE5TUm84c1k4dDJHUnlPZWxSU1dJYVVrdDJ5QVRXN2JuWXBYSUpBendPMVRjcUtsS1R2b2psZkxsV1FNUzJBMWRmYk9vQTdqK1pwc2FFbmx1T3A5S3lwb0NKaGhzaytsTTBndVRWYW01Y01ueWtyODJPZ05jcExOS1dQeUFmU3R1T09ORklkK1FPNS94cXZOTEN1NGpCR1IwUFdrZ3FhclZwSFBzWjNQK3ljZmpUMHVqRUFDUGJwMU5iTzZONHlNZE04MWhpMWFTVGhqbk9mVGoxcEhKWnBLenUzc2FUaEhUcVFTTWdldFNSV29IejV3UjlEbXJNZHM0SExFL3BWWXFRY1k5ZnhvME9qbFNzMmlwSXJsdVRrZFI2ak5PaEdKTUZPUWVvTmFrRUNCdVNPRDJQU3BHaFZTV0JKSCtlbUtGdUNoMUx3MnVCeGdlOVRBRlNvUEE0d2Y2VngwbDNKNTRRQmgzNDUvblhRRzZBVG43M1RrVTJYR2NaSitUTHMwOGJZRzVjOUNLcmJrUWs0UFgxcmttbHhjYnNBNTZjMXF2Y0xKaktZeGpGSk1uMnFhOHpyVW1VcVVCeDcrbFErV3NrbVMzNC81N1ZnQ1lvcmU0d1RUMXVnV3lXQndPMzg2cTVhbXRMblJiUExJSFhQVDBxMllVWmQyQmtldFlLWFFMWWJKT0R4akZNdWIrTlYyNTVJNE5ETmVlQ2l3Mm9IUEJIZnIycUo3WWw5eFBCSEFQRllJdUdFZ1p1bnAyNTRyb24xT05ZVDhtY0RnL1Nub2NrSndkNzZXTDdRSXlETzcwNmNWajRpVEJCQk9jWTcvL0FGNmNtcUxMR3dMbFdBck5pdFhtY0VucjAvd3BXUlRhazF5SzdaMDhmbGtaSEhmbnVhc21WQW9CSi9yV1Nzc2NKQUw4amtaOUsxN2RyZVVIQlhCeWZlcHNkTUhyYTZUSm9adzZNTVl4akJBL1dzS1V5QjJIdjBPZWEzYmR5dVQxejBIOUsxRmhpZms5RDE0OWFxeGNvdWFTdnFjb2tEdVdKT01jRS8xeFE5c2NBQWpCSFd1Z2xVSVNCanBVY2tJVmQzNmpta1J5SmZJdzdjRk4yNGQvMTk2MGxlSXlZSUdNY1ZQYXdxN2dseG52NlZiZXlRdUdBR1JucnpqTkkwaW55cXhueXdRQncyT21DZWVvcXdzc1JIYkg1VlJ1cmVkbU8zSUhUT1AwRlU0b0xwR3k4bUFPZ3hURnpOVGRvN3M2TXdSTXJFWXoxNHJEbUpiSzRJN0Q4dXRiOFQ0L2p6MUhYRlpkNDhRTFl3VDJ6elROSnBjcjZHZmF3K1V3SUo0SEkrbGRPdDZ1MWNxQ0s0VDdYT1NOdkdTZTNUdFdsRk16SGEyQmp0UzZtVk9hU3RGMk9qbmtWK2M0NTR4NjFudE1tVDBPVGpQZXVmbjFCZ1NvWEdlZmVzK1Y1RVh6RkdjOFk5ODk2ZHhTcVh1emZsVmhuSHpEUE5YTEJDWDRHUVJqbXVOVFVtWWxXaUtuSEdLNnF5dUhXUExFblBUQnBreGxCeVJzWE5wdXpnODljZzVyTmhqZEcya1p5T1BVVldtdlhFZ3puR2ZwbXB2dFVRMmtjY2ZuVE51YURscDBOQ2NTQWdNT1BVR2hwWTFqQUlISHZXTEpmS3luYVNEeHo2MWl2TVdVZ1NIa1ZGek56U2JzN25jVzdReW5uSFR0elZLWWhKTVpPRGpqdFhHV2wrNlNkVDE1eWVCWFR6T0pGeUNlZWFkeUkxVktMdHVqWFV4N1NlNXdjZXRSdkdIWGhQWS95ckpHN2drakgrZjFxMzlwUlVVYnZVZW40R21hT1YwV2JkaXNoNDZISFR0V2ZlS3pTREpJRFpPUlZpR2VNa25hZlE5dVRTVDdtSTJqT01jWjZVN2lldE8xK3BSYTBkbEdUai9QV3FaamREMXh6K29yWWNTTEZrSG5qajBySlZKMnp3YzV4ay95cEdYS3JyUmt5b2RwNXlhNUc4V1Yyd1l6dFA4QUVBZXRla1c2QkVCWlIwd1NLa2MyN0tOcFAwK2xBU29xY1Y3MXZJNHF4RElNbko3bk5iVVUwVE1BT0EzK2VLdnlSUkFIamlxVVZ1aXVTR0J5Q1FPNEZKampCcXl1WDNsQ25HUjcvalVrc243c0ZTYzlldFlOMWJ6TWZsQXorbjZWRENseUl2M21PbjFwYW1rdTFtTEhMTHZ5R3lPd3EyYnRnQTJlQjdjL2hWZk12WGJnajIvV3F6UU8vSnp4MTRPS1Z6Qk54alpYWnNKcUJCUHkvbjJyV1c3VnhqSFd1SWtqMklDUm5IQjR6VzlaU29zZkxlNFBYRk8rcHRDY3RtelZrdUZWUjhoeUNNODVxdkZEdkpZampyNy9BRnFqSk9nVjJWc2pIUEZGbnFZYkNrZHU5SzVwZE42czBHd0F5N3VPTWMvMXA4RWZ6WlZoa0Q4NnlMcThYZmhTTWs1eFYyM3VBUmdrRFBHTTlLTDZFcVVXMFR2YzRJd09DY0VaL25UNUpsd1RrZ1ZUTUtzZDRiQTc1NkduU2hYVWd0MHpTSDcycFV0N2tOSm5kbjByY2laQzN6SDY1SDQxeXR0Q1VjRUhnZHoxclJabGtQSFhzY2RQZWk3TTRTbEZhcnFhTnpIQ2M0MjlPL3ZYTkxlU1JUS2lrNXpqdmlyVWpsV09lY2p0V2VoUmpra0QxL0NpNHBTdTAxcHFkS2JwU3ZLYzhrSHVhcG0rVWtqSHBnRHZVRFNXNjQzTm5JUEJORWFXN0ZjTm5wOUtDbk9UZTZKaUkyNkFnL2x6U05FRzllVFRYZU5TM1Bhc2RiOTkvd0F3Qjl1bWFxNWxLY1Z1YVBsc1hISEJPQUFQU3RGbzRvMUc0Z2MrdjhxWkR1a1U4amc4MWc2bUpnU3FuUHQyRlFVcGNzYjJ2Mk5ocGtrVUtDUHIvd0RycC96a3FOM1k4ZjhBMTY1U3lqbVhKWVpINjgxc2ZhVjNqSDQ4ZEtabXBYczJyWDZHd1ZrakdXR0JrY2oyNlZZVzdESVJuSGJQV29WbVpsRzVSN0FnNHFsNUJNaFBISjU1cDNOMjVKZTZaVi9ieWI4Z3QxN0U5S3h4YnpLL2NqUGNIcjdWNkNaRTNBREF6MnBnQzRQSEdCM3lhclV6OWpGdDZuT2kwa1pmdkVZNlk1cTlGSUl3QTJjNTY5czFmYVFiZ0Z3U09TS0dnak9DVDB6L0FKUHJTZXhhZ2s5QmlFc3dJL0g4NjEwbktEbm5IU3FJS3JnS3h6d00xbnp1N2taSkI3SHBSMExUNWRlcDBSbnpBVGcvL3FyQmx2ZXUwRE9lS1lXWlZYT09SalBTc0NSOHV1Y1lQSHkrOU1tcFBhM3pOeGJ0blpjRWpJT2Uvd0NOYU1UcHR6NVpBWHVQNTF5czRjSUdYR2V1N09hMGJLNUxLU1I5M2pyNjB5SXo5NnozT25XVkFBZHZVWnFhUm9wQUdINDFsU2JUZ2hoNmZXcW84MERIZnNNNC9EM29OdVpyMExrbUVDbFIzNUg5YWdqdmNFcndQWWRCVU9DQ01BRURxRDJxcnNDeWJ1Y0U1K241VUJ6TlBRMEpybE55ZzlLZTd1RkJBNXgrbFJrUlpiOWFjWFJWNTZkNkM5YnZVcXh5Ym5JZmpJK3YwcTR6N2NBSGtmZHhXUEx0M0U3dW5KK2xWUzVCeUZKejZab01YSkoyTFYzUE51YkhybkdLdlF2dmpVRVpJSE5WRFBFektUalBPYzhEanRVcEtBamdENmMwRFQzZHg3U3FyamF1T3ZmODZzR1VucGprOGpQQlArTlJLaEtuTEhrRHQvT29URXdHZXVlUngrdEFKc3NGaHlOdzV3Y1p6V1pQR2h4Z0Q2VmdYbDQ4YzJTckRBejBxL1kzOFUwSTdjOWZiMnBNelZhbTVPTnluTXNVUUFLL01UeDNxOWJ3Um1QZHRHTVlxdGRSbkpLa2tkZnAycU8ybmFMamNUelJjNTcycTZyUTFJb0VWandjRHBWK1VJdUFNWjdFbm5GWVk4d3lNMzhPZU9SeFZlYnoyQjJrNHorVkJmT2t2aE5ZbVRDNGJvZW5ybWpiSjgzT2M5cXpZMmJIUERIcm1yeUZneHh5UC9yZFRRSldmY3RDRXVxNEJJQTVGVFJnUnNSeU1Ia2orbnRRa3dBK1pSakF3QjZHcmJIZW1RZVBUNjB6V051bTV6ZDJKRElwVURHUUNNZnpyVnQ1V0FJeHg5YXF1RUo1eURuR2FqV0VFbkRFYzl1YVJrbTFKdnViRzQ3TndPRDNJT2FlZ0JBKzhjZERXYkN6bjVHQUlBNllyWTh6YVIwNm5OVmZRNmswN2FrWmtaQUNDUjZkeHg3VkVqT0dKSkE2WS9Hb1pycUluQklIdURpblJPdkozNUdldFJjRzAzYSt4SzF3dVFNWlA4NmZJaU12M1NQL0FLOVJ4aUV1cE9NNTQ1NlZlZGxRaFEyYWR5VW0wNzJNd0tWSXlvNmRoMXgvV3A0NDFLRUFuSHZSNXVRQUQvbjlhaCswQU94Sy9uVEl1a1NBT2pIR05wSXo2aXBpb2ZJRFp4ajhhd3JtL1RCVUhrL3BWbTF1RHRKWVlBNzBFS1VlYTF6VEliWXhBd1BUK1pybnBIZFh5VGc4NTVGYmdtVmdjOU9PdUtvVG9wYkp4OHZBUCtOQVMxU2FaV1Niamc1UHQzcTZ1NDkyQjY5YW8rVVNnS2pwbm1wbEQ4S2VvNzl2MW9JVGFkbWFJdVd3UVR6V1pPelRLVUxlbzk4VlpaY3FRTTQrbFVJMkN1TTgvd0NlbnZRbU9VbmRJeGhiRkh6dE9CMVA4cTBQSkpCSkpQQXhXODJYQjRHTTkrRGcwb2JhZHVCeHpUYkRsczk5REFNSktIRWVSN250VThLU0tDQW5UdjhBU3RoQStDUzJNOWNtcXJUc2dPRGpIYjJGTk5HdktyM01WN1dkangwSTRIdlY2S0VJRkpIUE9lUHo2MXVXN0s3QTRBempqTldKbVR5K2dQcjlmVEZNcU5PTzl6alhNaEhDOGpwZyt0RDNFbTNCVEM5T3A2MXV4dXJGUnNBd1B4Rk91YmFOb3lXUEF4VUM1TkxxUm5XOHhPU1JqMnppaXE2SUV6Z0tCMEFKb3BXUTAya1FKYUZKVitidjh3RmRFc1ViWUJ3UFFldFlIbmhITE93R2YweDFxMjF5VGphZWg5YVMyT0NNb3h1ZFpiMjhhcWNqK3Zlb3J1MmlaQ3dVWlA1OENzMFRzbHZ4eDc1ck9odmR4SEJIWE9mZnFhTG5VNXd0RmN1NDEwMlo2Z1o2OXFiS0ZkUjFKcmM4dFhBSTVCSDYxanl5cEVRR3lDZVFNOEdpNU5rcjMyTDlqaFFRV0F4K05hanhpUTVYUEZVdzZtSDVVNXgxeFdVTG1TTng4cFBIcjJwbTNOR01Vcm01TlpLZnZjazk2eDVnNCtVRkQ2akZXMHZBY0ZoZ2tuT2VSeFQ1TGlPWHBnTnhnanY3MEdjbkI3Ym5PcjVrakJjanJucmppdWdpc1M2akw0ZitWVTFBUUVnSG5xZlN0SzN1aU01NUJQRkJFRkhxWmM5bVVaVGtlMlBhc2FTZnlzQmtBR0NlbkpOZGRMZHdzellVSGpwam11WU1VYzEwb3hqK3BvVzVuVnRvb05YYk05bGpiYm43eEhRVnV4azdEaDhGaDZWWm4weUtOQjh4K3RUV2lnQVlJSXgzR090Smx3cFNqSnAyVnpBdUJLeUVFWTRHYXlZTFFZWWdFY0RudFhmU1c4YkVuZ2s5alZSWTFqVUFBWjV3S3BHY3FQdlhiT05hQ1NPTW5IVVp4anVhejQxbDNsaVhBQkg1MTIwc2d5RndNbjA0elNMc1pPRnhucVJTMU0zU2pkTG0yT1RubW5rWGFDZW1PbkdCVUNXbDBoVDZkYTZ4clpvM0JBd1IrdFhQSlowK2JISTcwQ2pRY20yMjdvd0puMlJEY0F4T0JpcUVabElMOGpCOWEyTHZUM2syazR3QlU0dFlvWWZYamppcDBzRXFjNVM3SkVWdmNnT1JqbkhJcnF2N1FVUnFwYm5yalBQL0FPdXZLWkdtV1E0NkRrRURyVzlhcks4Z0RsQ3ZaZWgvUC9HZ3VGV1Nka2pwbklkTTU1L3ZEcHpVVUV4V1E3bkhidDJ6NzFaV3pVN2NZK2JIUFdtM1Zvd1VzY0hyZzBqVzAwcjIyTlEzUVhHR0lIT0Q2MVdBTW1EeURrNDR6V2FxZ0tQbnpudDFOV0kxazNuREVlL2Y2Q2dwVGIzVnhKYlVrN2hKeGc5ZmVxRXNhZ2dFZmwxTmFieHlxUWNodUFNZTU1cGthS1N1UmpyN2lxUkxpbTlyTzViZ3RsRVpIWDNQcjYwMzVGY3FxZ2VucFRac0lwWVlYcVFjOUs1K0taakw4MkdHZTQ1eG1rOXk1UGxhU1IzYWNyaHVBZW5wK0ZZY3RoTjVtNFpicjcxSmNUL3UvbEJHZU9NbitWV3JPNFlwaHgrbmVxdGN0dE5wUDVNaFl1aXNveDh1TTU0elhOM0YvS29reXBBSFR0bXVydVZESm5nOFk0Rlp6VzZIYVNBT2Z3cUw2a3lqTG96a3RPYWFXZmN3T1Qvbk5kWGRmUGdiZ0tvNFdNRWc5dU9PRDdWeWwvZlhhbGdpOWpuTk51NXp1YXB3ZDd2cm9kT2tVSzREbk9RZWVsSktZZHBLSEJKeGpxTSttSzhzR3FhbTc3R0dCbjBHVFdsSGMzSVlCOEhIMDVQdFNhYU9KWW1FcnRSYTlVZGEwN1N4c3Fna2RBQjFOVnJhR1pHeWR3ejFIcGlxMW9WYVFzQWVtZU9PdGRTc3FrRmVTRG5QclVwbWtWenRTYjFNZ1hnZVR5OEVuam52Z1ZxTXBaRmJjQU1FalBiUDlLNSs2c3B3NmxPVDFIdVBTcFpicVpZaytRc01kdWxVQ2xOY3lrbnAxc2JCZ3lvK1lNTzRyVHQ3ZU5sWkRqQkhQdDYxekVSZGtIQlZ6bkdmL3IxcVEzcGpWVVk5VDFOTzVyR1ViM2E2Ris0czFBd09PUDVWY3RJbWpYcmtCZVQ5S3NpWlpPK2U1SCtOWXR4Y2JTTVNZeWVuVG4wcDNSMHRSaTdvdjNGbXNoNFBCUEo5S3MyaXJBVkdBM1BRL2xXS0p0MjF0LzBIZk5hRWUwS3B6MDZuRkpNYTVYTzZWbjNPMEpqSVVoY25ya1ZudGNtTlJoODVKN1ZUanVrQzQ3SDlLeHJsMGRjYnVNZGNVN204Nml0bzlTU2U3WjNHMzY0d2UxZGJiNWxpR2VDUFd1TnRqR0k5cE9SMEhxTVZyeDNEUlpBSkhYYnovT2tUVGwxZlhvVE0waVNqRGZRNHFZM3ZZdGdubkE1cXFBOHVTUmsvNTZWUWpUWS9JUDQ4ZmpUNkRia3JXMk9uZ2xZSVNTYytuWFB0VmFTNERzd0JBUHYxcXE4d0lBakdBT3YvQU5iTlpzZm1iOERCWEE5ZURRVTZqVmx1VHNiaG40T2V2VDFvUlpXTzFpTW50MXEvS1dSUnRHQjY0cXRFMHJIekdYSHY2MGkzTzlscWFDMmhDWjJqQjdIL0FEM3BqUW9yTmpCUFhqMG9sMWRRb1VBRTlQVG1xTVlubTV4anI3OFVPdzVTanN0V1FtR0dXUU1WNzRyVGVDUFpncDhvWG5QV3NHZUNkSmg5NEQwRmEwVTRSVlZ6ajYrM3JUNkVRbXJ1NnQ1bVhEYlc4YzJkcDVPSzZJU1FFaFZQMDlxNTYrUjhCMGJjQ01WYnM3ZHR1N2Q3YzlhTGhHYjVuRlI4N2xtZTFKUEhjZjhBMTZ4bnRaZ09SMS96MnJzRXVJUzZmTUNNZjUvR25NMEtqa0U1NjlUVHVhdUVKYTNQT1RaU2c4cm4rZkZKSFp5YmhuSTY5czEzK2JmcVRpcVcrQnZsVlJnbkhYK1ZUWXc5bkZQYzVTYUZGd3h4azloU1IzUTJIbklIcHpXbmRXTHVoMjk4anQzOWE1eTIwK1ZPcmNaNUhUak5PenNjOG5KU1NVZE81dVJYSmZJWmNaNkhPZXRSVE4vQ0NHOS8vd0JWVExCSEVHSyt2T0RuOGF0UldYbXNYNkRJd0J4MG8yTkpLYnRiY3JRSUFHM0ZzZHNjODFXdlhrVEREZGdkZ2NaL0t1bWtoa0gzZU1jNC9yVWd0MmRCa2pkL1gwcEY4amFzY2hCcU1xL0tlbU04MTBpM1J5TWpBUDhBbmlxaldmemJqR09NOG1wbWl5VkJiSkdPM0FwcTRsenJyc1hKWitCd0Z3ZUI3MVFXNThzWmJIcjlLWWZOQkdSZ1o2NHorZFdaTk9hV0xLNXlRQ1Fhb3E4OVdocTNTeVNZVWpCN2UxT2d0enZQT2VmV21XK25lV2UzSFFkNjE3ZUoxZGVkb29LaXB0cHlRK1ZQTEFKSTc1Sk5Ld1F4a1k2ZHY2MWN1SUdZQThIaitmV3FSSDdzZ3NCd2FwMnVkRHZkNmRDcHZRS2NxRGpyOWFpVTVZNHpqa0VZNlZkQ1JlWHdENzRGWmpYREw5MFlIZjZDazBaeXZwY2xhRU1NbkFJNC9HcG90UFF0dUdBZVBha2hYekkyTzhZUHFLbWlXVlgvQUsrMytGS3hLU3V0RE51Yk5Ua0ZUeWUxY3hKYWlGeXlZQlBXdlNaUXdUSjdEMHh4WEp5dytiTGp2anA3VXJFMUlxKzNvYyt0clBKdWNyblBjZTlYVmpZa0RrUHh6OU81cm9tYUczVXFWd0RuM3FUTVJYZnU2OWovQUNxYkNWT0s2NjlUR21sdUVSVGdISTUvK3NEVWR2Szg2NS9pSFVkQlYyZWEzZEdVcjlmeHJKVUZUbFJ0R1R5TzVOVmJRemNtcGIzUlpLU0NRc1NCbm5HYy9qV2JOUDVUZ3RrNXJSdDMzNXlTUm5qSXF2ZFFCbllaSTRJeDAvQ3B0cVp6dnkzaVJMS3N4SE8waitmK0ZUaXhZZzRQQU9jNHFxbW03UVhqWThnRFBwVmplVTR5VGpHYUxEczlPWkRmc0xFc0Fjamp2VjJPMmVJRGtnL1dyMGNZWUU5T3ArbUtXVjIyc0F4SkI1eDJOT3hyeUsxN0dQSnR6amNEN1o2MDYzanR5d0JqNlpPUWM4MW1TUXpseU9UaHVjajlhMmJheEljNFk5TTgwN0dFVTNMNFRwbzBpN09PZWZyV1hkUmhreUJrZEQvaDNxeXNVcEE1NUhHUjcwclJnRGFRZW4wcEhYWjJ0WTVJTUZPM2NSMU9PMUxqREVrZDg0QTlhM1h0a0xmZEhzZTR6VEJiRmNBc08vOEE5ZWxZeFVHbXI2Nm5HVDNrd3VGRzRxT2hIdjdWMDl1OHZsODV5TWUvMXF4OWx5UVN1U0JXNWJRb1NGS2pyeUI2VUVRcHo1Mjd2VTVjUE9YNUdPZmxQclZzVEx2STNlK2V0ZEpMWnhEazU1OStsWTM5bmd5Wjh3bkhUaW5ZN1ZScXExdGRTbExNa2Jrc2V2Nm44S3NYRjZWakFRQWtpcHA5T2ZZTUVaSDlhWXRoR0J6a0hBL3ppa1JLTmFMYXRhL1V6WUpWWTVKUEhULzY5YTdlVUlqbkh2em1zS1MxWkF1MWlPLzU5VDdDcjhNY3BVZk4xUEE0NlZaaEZ5V2pST3dSdG1DVDM2MHhMYU5jc1Y0SjZkS3VMQTVKNkErM2ZGWEZ0QWh4a2tFY1pOQnVrMzBPYm5WR0F5T0FlY1VzY1JVTVZ5dlBHZWEwWmJjZ1lPUVNPQjYxbk1KNCtPbzl6emlneGtyU1RhS3F6eUJzRnZibWxXWXFjc3BBT1B4cS9HVUc0bGNFOU1Wbk9VTXJkejA3VWdzMUZPNWRNNi9LVHdjYzVQTlRwa2tsZnFPOVpzOFRBSGFBY3J3ZjVWWGduZER6akp5ZVQycGo1N1MxTmw5cThEbi9BT3YyTllONzVpSXBHZnhxL01XWUtjLzRWUHVFa2ZiMVllL3RTdWhUZk56SXdyZVJ0aDVEQWp2bnBXbWpodWQvYklBNW9neU1jWS9sZzlxc1NCRXdRbU92UVl4U3Vad2k0eFd0N0ZVcHRKS250Z1lOVjVtY0tBR09lMzFGU3hUdHZ4czdkNjBHWkdYREtPUjFvUnBvMXZZd0d2SFRjQjk0SGtaL1RtdENEVXQvVmNuZ2VsUlQyOFRxU0FCK0ZVb1VBeXUwZkw2ZXY5YWQwUmVhYTFWaVc2Q3lnNE9DQmtpcTF0YVNxQzVLalA0ZGZwVU1na2psL3dCV0N1Y210NjNaY0E0SXlNNFBhald4a2twVGR5TkM3TVZLNEdQd05SUGI0QUlBK1VkYzg0cllrS3NoWmNLMzhxcXZISVlnTzJCMi9XZzBjZW01a0x1REJWQnhuNXU0eFdqdkFISVBIVEZSUkZWbDI0NllGYkRMRkpFdkdjY1lvc0VJdmxldXBpNXlRZnh6VHZ0QkF5Y2V2MXJZa2hYQXdjOERBSjlldldxNHN3NjVVOC96eDdVV0w1SjlEa1pibDJtQlZ1aEFJLzhBclYwZ3VDMGVHQUdGNDlzVlhTMHc0ekgzeWFXU0tOQ1Jqa2p2UXpHQ25HN2JJbzJZbE9xZ2s0QlBXcklZRWdkQ2FjSXR5L0xqbm5QR09LeEozbVdRQW52NmV0Qk1ueXE1dXBkS01GZ1Q5VFdYUGZqSlVjZzllM1gycGhkamdnNUo5Qmo4cVQ3Tkc0N1k0Ni81NHBNVG5OclJsVldDcUd5Q0t1eVhFUlU3Y2pINFZSdWJjTEhoQWZwV1dQT0RmTWgrWWNIclJvWWMwMDNvUE9wU0JpQnlBZXVmV3RsTHNzUnVicjYrOWM5SkZKSWdaUUJrZE1kUC9yMWl5TmNSdmxsWWdBZ0RucDlUNjA3R0xyVGhGdDNhUFdWZFNNL2U0SHQrQXFqTTR3Zm1IK09LNUMxdVp3cWZlSXhtcmJ6ckllVWJjZlFacG04YXluQzlyZVE2V2JCejZDcHJMVW8yVWc1NUp3S3B5VzdTQTdzZ0grTG5QNjF6WXRuam1VQjl4QjRIMDZWYXRZNW5VbkNTMDBaNlo5b0JCSUI0N2RlbjFxZUdZUHRBNS9EbXVkdHkyNDlmcDJxNmpZazNaT09NanJqM3FEcmhOM1RPdjJLRjNkQmcvaldVOXpDcEtxTWs1NzFWbXZ6c0NxY2NIT1Fhd0FaSEliMEhPZjBwblJPb3ZzblNpY1B4bmdqbkpxMzVLdVBsenljK3ZOY2lZWlNWeHhuOFJXdEM5d2dBSTZqSTl1MUl6aEp0dThUYlVCUnc0STZWbHNmbkdQWHJVQjNxd0pVZ24rdFQ3MUF5d3lNOTZSdTNkTG9iTWNjYkFBdGx2U3ViMUU0VTRKR1B3NXE3QktTU051ZlExblhnZVE4cm5QVFB0UUZTVjZidHVWcmE1bHhnRTV6My93RHJWZEUwNUxaT0NRT0RXZkZDcXFNamFlYzQ5NjNJbGp3clp4Z1VHTk55MmIyTVA3VElreTVPY2owcmVhZG1RZ2ozL0N1YnZKVlE3Z1FDTzYxWnRaemNKOTduR0JnZXYrZWFvcU03U2NiN200cUYwR1JuSG9PbEZRaUozWEFiZ0gvUFNpcCtadmYrNlpjM2tad3o3VzlNY1UrMWlqRGxRZWpjZXVQU3BwTFZKSDNwa1l4MjlLWkg4aEFBNm5KNXhUNkhuY3Z2M2FXNXR6U1JpRWpjVnlNNTdjMXpBa3dXNUxZcDJvdko1ZTRMdTY0R2E1R3hTN2ttM1NJZW4zaG5wUWtqT3JVa3BKS0xaNlpiM3NlMDVKeDdIUEZXQXNNK1d6ajE0N1ZpL1lXV0lFa2pCUDhBbkZRckswSzRVcndldmMvV3B0Mk40emtsYVNPMlJVUlFvSXlPaDlNMVZsdDR0bTdPQWVwRlVZbTgxUVEvR2VuZW9aa21hTWpBSGM0cE5NNm5KY3Z3MzAwQllZMkJWWHlENzk2ckhNWjRQSHI2VmxRek5FKzB2ejFLbXRQS0U1M2RzNHBISzNlMmxtWG9MZ3M1RW5ZajhSMnEvTzhBQjI5MTdEcFhJdnNhVW5jUnhnZzF1MjZxWWhuMHh4eVJpbVZDYmVuNGtrRUtOSVR1eVNPU1QycS90aGpiZVB3NzRyQ25XUUU3RGs1eHQ2WnFXT0oxSjh3anJ3S2FSckYyMFVkZTVycE1aV09kMlIweldpa3FLT2NqQjRKNHppcU1MUTdqakI1d2UxV1hhM2NIYTNYb0tGdWIzZmRYTXlkeTBueWdFZHpWbUsza2I1aUJ4Myt0WVZ4YjNDUzVWUzN6QThISEZiaVNUckVENVo1UFByVkdFWlhidW5veS9jV1A3dFNWR1NPdFo2SWtRNDZqcHpWcUs1dUpQa0svVFBwUktJbzErWTQ0eVIvU2czOTF1NlJXbWZJM0xqSHJXVUxpWml3S2pBUFhwVDdlNlNTUXFWM0FkdVJtdFZZUkk1QVRHT2NEanJ4U01ydVMwWmp6eTNMSjB3Q09RQnlhcW1PVm96d1NQVDFGZExLZG1VeGtIb2NlbElFWGF4SjR3TUVqSFdpd2NyZThtY1hIYk84cCtUR01qUDByb0lva2R3Q296bjg2MFlZMUQ5TUQxUGYzcUxkR2tpWlk1N0FEcFUyMU1ZeDVYdnV5NXM4b3NUeUQzUHQyck11Snl6ZzU0ejY1RlZ0UWVSU09uUDRaRlpxTk1HQkk2OGY1K2xJcVZWYXhTTnh2bGpCNHpqOGFvTGN5NzhxdWV3OWNtdFNERWtJK1hBNlVyTkJGSU1KbGx4aysvd0JLQ21yMmQ3RWIzRWlSWlpPM0I5S3hZdFg4L0lRRmVjRE5YN3U5RXFGU3ZmSFRyM3JOU3pWQTBpamNlYWEyT2VwT282a2VXWHVyZnVRN3JtU1RhM1QrVldaWVNwSkI2anFmWDhLU0c0Ty9ETGdZK25GYVJBYzdobGxJd01VaTQyYTN1V3JPVlRHUTU1L242VnVDZUx5U296Z0RnSHIxNml1R2EybVJHUFBIT0FlY1ZoUTZqS3Q0RVpHSEhYUEIrdE1JMTNDeWt2STZxOXVmSnl4ejB6eHpXV3VwcE9vVlFjNU9PZjUxZnVqRExFTnpISFJnZmFxTmxZV3lzTm81OVA4QUNrVkxuYzdSYXNWcDdtU01iU01EZzhudFZpSzV0Sklnei9lSTRYRlB2TlBVOHVBUjducFVNZW4yNXhzZmtkQVBlbVpmdlZKN1AxSkZ0WVh3d2lCenh6MnJLa3RUSWVFNS9XdTN0d2dSbEFCeC9LcVlLckt4MjUrditOSXB3VFMyVjl6QmpsamcvZ0pKQkh0eFNXOTFES3kvS1JrWkdldzZWZjFGU1l6eHVQR01EOGFpc0lXakRGZzNUcVJ4K1ZLeU0vZVZSUjZlaGVabkViRmt3T2ZyeldSRE1zOHhSZ2NIUEhxYTEyWjI0QzVIMTZDcXNjRzF5UUFHNVBwUlkxZDNLT3VuVXNQYkNGY0J6MTcxaHJaK2JjTjF3RHVHYzRxKys4eW41bXdBRHpWc3pvc1gzK2k4NEhQNlZSRGpDVDJzbDBObU9CTm95eDM4Q3FkenA4cEJJd0NmeUhyV1BGZHlGMUo1SHFhNjJLOFNXTENrSC9QOHFEb2o3S2FhdFk0eit6cGl6Rm1PQjFKUGZ0VitPR1dOUmtrRHBtdE9TNEVjaFVqSkhyNzFOT3F0RmtaNXBHSEpGWHQwSW85bXhSazlPaDRGUUlFSVhuYjE5eFVGdGJ2SXUxbEdCMXpXbGNXRHhSSEREOE90QnJGU2NiOHVsaXRGQ2QyUms1NmVtSzIwdHBXVlNlM09jOVJXVHA3U1pPV1k4ZFB4NjFvU05jcTY0akJBeGsrcDlLYUxoeVd2WjI3RzVBWW9VR1I3RWordFF5d3hQa2pPUVFUejYxaC82UXg1M0tXUFQwcTZXa1ZUaVQ3dlhHTTFaMHFvbXJPT2hweDJnQzlRUngvazFvRzFqVGtublBIb08xY2trMTV2OVZ6ZzhjMXN0S3dqeTJSeHdLTkNvU3B1OW9QVHVSM0UyMXlQVGpIMHFMejR0b1hmNzlPbnRWRmxMN2prSGtZT2NpbGxHSWlCak9PMUZ0REZ6bHpObE5tamVWc0VBOTY2MnpQbHFDVlllcFBJcmh0S2lrYTRZc08vUSs5ZG13MkprT1JqOFJVdFdGUmJhNW11NXU1alBJQXoyLzhBcjF4OTFidTh1UmdldWEwWTVXWUhIYitLckxLT296K05OTTZKV21sb1ZRbzh2T1JuQUIvL0FGVnkxL2YzVUR2czRIVGpqclhTTzdBOUQxSEZVbjhwbUlaYy9VVXRtUTdOV3Ziek9RczcyV1M0VU44Z1k1eU85ZWxxVktxM21ZSDllbk5jMjluQXNubURJNmZoVWlYeVkycjI5ZjYwek9ENUxxVDZuV3JhQjQ4Z2pQOEFPdWR1N1h5MUxqSEhPT21LdXgzakxHY2NBY2cxaHozNWJJS2c0eU9LTG1zNVU3THV5TzNubWNuY3JBOWhXbTFrOHFqaHVwcDFwNU8zUFE5aWZUM3JYTjdCRmdzK2ZjOUtTWW9RWEw3MHREbW10M1ZDRDI5ZWVSNjF2V3NNaGk3L0FGclZqbHRKRVlnZys5VjQ1Z2g0eDE1K2xGelpSaXV1aGl5eHpaeHNCSGZIV3RxekVubDRaZmIzcDV4bnBnOEdwWW0rWDV5Y1ovSEZQb09NVXBYdXh5d2lRWkF6ak5RTkVRd3p0SXh6Z1p4VHk3NXlwT0QwcFhjYlBuUHZnZC9laTQzWWhhTlFnSVFFajhUMXA0bGNLT0QwNDl2enJNV1dGV0hQWFBlcDN1bzg4SG1wRXBKZGJHZks3T3dPTVlIMHF3azN6Z00zVWZ6N2ZXcVV6eEdUZHlUM0JIRk1WZDJUa2M5eDE0b3VaWDFlcDFGeGNoWTlvd2ZZMWpMTHZCSEFKNmNZckJ2NUpRUHY5ZVBjVll0VkVrUU9UakhKOStsTzVQdGJ6NWRkRWJEb3ZsNVorM0ErdmVzdGtMRS92TWpPZU9ldnJTUzI4ektRcmNqc2ZhcVVTenhNTWdESFhBNHAzSW5OM1NjWGJ1ZFBCRXlwempnZC9lcnBZb3g1R0FSM3JFbnVRWWNaRzcvQ3VlZ3ViajdqazR5T252U3VhZTBqR3kxMjNQUi9PamVFZ2dBNDRCUDZWeGw2eFFrZ2RPK090YThjak9tUmtuSEhmNjFqc3J5U0R1TzZuMm91VlVrNVI4em5wcEo1bDVCWDV1SzJJWW5FUnl4NTZlMUFoZFNQa09NOFp6V3BKR1VoeVFldlBQUEZGam5oQjN1MjJZWXRodk8vT2VPL1d0Q1dJTER4emdaUGFzYVdDWWo1TTR6MHFwQ0xzRXF4SnkyT3RQb1Eyb3UzSTllcHQydDFGRXhEak9UMTlxMnJxOXQyUVlJWTQ5ZWhGZWZYdGs1T0ZMWnFlMXNHalZPWDVBejZuNjFOeTR6cUs2dG9hMXhmeUxDUU1qZzR4eldkQkpOS3BaeGdkTSt1YTBtRVFnZlBIWGdqSUZWTFpndVdVSEk1SXhSY2g4em5HOHRMYkhUd0U3REdDZU0xS3NUc1NWT0NldWZmdlZhQzRoVWZlNzlNZmp4V3hGY0lNa0VFWXprNHFrZHlVV2tybGNRRUhwOWZwV2pEaFY1WEFOVlo3bU5sSk9QL0FLNHJQV1FPekJzbmpnLy9BRnFaUzVZeU5kR2ozWVhHQm52VDBnU1Q1czVQYjhLNXFUY3JnNXllbWEyNFpKQUFPQnlBS0J4bEZ1elJMSmI3RkI1OU1Ibjg2cFl3RDhvQjdtcmNseUdKRGRCNzhWRktVQzV4MjY5Znpwa3lTdTdGWXNWYkp6a2RNQ3JYbmJSeW5Kd2MweTNhSThaeDYrdjYxWm10a1pPRzVIOWFteFVVN1hUSWpPVGc3c2s5QmpKcDZBbFZJR2MvbldMOWxma25JNTRJcmFWSGhqQUgzcWRtVkdjMFZyaS9hRHIyL0dzNXJ4bXdjbnA2ZnlxMDlxMXc1M2xpT3gvL0FGMWVnc29sRzA4ZCtuYnBUc1M1VkoraGt5VDdvanVVYnZVZTlaa2toVU1RZXVNRWV2dlhVVFdxSzR3Y1o0RlFyWW82NUlIOWFocG1VcWMyMmMzYXl5bVZUdEp3YzVOZEJMZEhiODJjRTllOVN2YkxIdHlPbkh1S3o3dUl1Y0FkOCszRkdwQ1VveGZjejVMMEwxYzQ5RDFxckhlbVp3cktEazllbjVWb3cyQlpNc21SazhuZzgxcUpwOFNLY1lIUEhISXo5YWFKVUtzbXRkREN2bEhsYlFTQ2VtT3hybkxTQ1VEY1dMWXh3UnpYb3hqalk0QjRCNmRQeXFGSW9jOGREengxK3Y0VVdDZEZ1U2R6bWp2RVgzY2dZSXFreWpKWXI4MzE3MTF0MUdOaHdPY0hCRmNZOE54ODJDVG5uMm9KbkMzbWFJWkNnSFVqamlxS3pPamxjZ0RuRk1oRTZ0dFpzaXR0YmVFZ1pYSXp3ZmVsWWxSY2xvN05FTVJRZzhBWkhROC9qVmxpTmd3Mk9CeFU0QzQrNk9uclYyQ0tKaDc5ODBXME5veGV4emNZNXorTmFEUXdHUGtuL1B2VzhiS0VBNUpYUFdzdG9ESGxWeHlTZlNta0RnMHRTcEVrWEM0UEhHUFdwdnNxWnlEZ1o2OTZxTERLclozQVkveitkYXlSU0ZSa0hub1NhWk1OMnJFQmdoYmtzQm50N21xZ2lkR0l6a0U0R09jMWVlTnd1ZjhBNjlYb0lrMmtsUmpPZm9LRFhsdnNpajltS2JlRHlEMDYrMVZqSEl2M1ZPTzRJNC9PdDB5cHUyazVIK1ByVnR6QVl0b09UL0ttV294ZDlUbG10U1FmNGVQOGppbXJGaENBeFludFc4VVpqakpJelQwZ1VaSnp4MDR6VEZ5WDJSeUR5K1hJRnhuQjduclYrRzlqMjdkdVFjYy9XcVY5Q0JuR1R5ZWdySFdPVG5iSmo2bkZQUTVYS1VaYUk2d1RSbGlRM0dhcVhKUndTQnlNOU85SkJCSzZnT0I2NTcxVWxSa3dDQmp0VXMxdkp4MVdoWXRBZUFlZWY1ZDZ0U1cwZWQyMGVvLyt2VktKOGt0L1g4YW5Nb0xIRGR1aHgrZEloV3RZait4UnlPdUJqQVBVMVF1YlNTSUhEWXo2YzFxZWV5TDJQLzEvNlZZYTVTUlZKSzhqZ25qOEtWeWVXRFRXek9lQ3U1WEk0d2VCVVJoeTQ1NHdlb3hXeXpScXhZQUNrWm8yR2VoNTk2Q0xXVytwWnRyU01ydTRQb2Y4OTZ6cnJTa1Zsd2NqcjdENi9TcjBjaFVMaGdPZlNxODEyeFZnb0hQU21YUDJmSnFqTzhpTGFFNEo5TVZHdGk2a3N1RDdlb0ZOaGxEeVk5aCtWZGVrS2VWdUdUanQ3MEdkT01XY2p2T1NwVTgvL3FxYUhUb3BaT1l4OWNjaXJja0tMTm5KL0FaQTlxdnJPcXBrSHYwSHRSWWhSWDJ0YkdYSnBvUmdNWTQ2a1U1N0ppT092ZnR4VzNIZUdUcGc0OXYwNXBaeHdNZGowcWtrYmNsUGRLNXpMMkc0cjJHZld0T0N5UUtBUGw0L1AzcWNSdS9HTUQxSG9lOVdWazJxQUI2NVBiZzB4UmpGUFlyaUtLTnNOZzQ1L0VWSVk0aXF1QmtEdjI1ckl2WGxYNXdvUGZyaXJOcExtUEdBYzhjR2wwS2kwNU5JU1hBT1BseCt0Y3pkUVNaTzFoN2p0MTVycHJxRmxaano2KzFRQ1VDSEpHZW1UVFZpYWtMM1RJYldKeEY4M0hyL0FQV3JidFZSdVRnK3VSZzFpeFhjYk1WT09tUURTZmFJMWJJencyTTFMSEdjVW85VFJ1ckpHZmNCa2s0K25yOUtXT0ZRQU52VDM5S3puMU1ScjgzTzREOGZXc3dhbDgzQjdad09menBFdXBTVXI5WHVXTHpURWw3ZGUxUldOcDVLRWZMMHdPK0txUzM3dnUyNFBHUHB6VG83aG1WV1ZjSG9UbWxjdzVxYnFYUzF0dWFzdDBrYlk1SFRuSFdpcVpoZWRjZ2ZVMFZMTmJ6Nkk2T09LTUVwMXp3TVZVbWdRSEpHY2V2ZXVUdlo3aUFNQnVPRDBIcC85ZW0yOTNMTkR1azNBY2daR09EVjlEbmRhRitYbHM5elRXN3RXZnkxd1Rub2UxV1lJMGpsNFVZeVBwN1Y1L2F4MmkzTE9KQ3hEWTIrL3BYUlROY2gxT3c4SGdaNEZKclV6cDFwdUtjb3E5OUxIb0VwaThybmJuSGJqclhCM1RLWlFxQlMyTUErZ3pUV1c0WXJ1YmorN25BSDVWRzFreXk3bVRMREhUK3RQUUoxWlNmd1c4eWUzTjRwVlFlNTRBcTBHdmZNWTUyZ25nZHpVY2t4SENqYVRqcHljNXFPZTRuaWpablppTWdEL3dEVlNSTDVVdmlscHFMOW1rYVFzeDR6ak9lZnlyVk1FZ1FrTmdZejA1eldSYmFuSEl4d25QQUFKL091MWl1RWFQa2hjZTFKM1J2VGRPUzBrZWEzRnZmTys1Y2xld0hCQTlpSzFiUVhFQzRZSE9PQ2ZXdXM4MkpwQ0RqOFB5cXpINVVyY2oxNUk0eDZVMjI3RTA2TVkxSEpUYmI4ek1XUjVOblluK1lyVGExZDRSZ2o4LzUxTE9rVVcwQmgzeG4xcTlDckJBZHZROVNhWjNxS2JzemxBN1FzYzd1VGpqK3RZbjJxNnQ1a2s1eHY1eWV0ZW5TUldyeCsvc2F4V0ZxZUpFNzk2bEdNNkxkdmZTdHNReGFrSmxHNUFPaHlQOGF2dGVKZ1lPTThWWEVWdThaRUtnRDZjbkhXbmlHTlVJem5BeWMrM1FValZlMFgybDZseU9jS3dPQUFNWXdPdFVMdVh6ajh2VEhhc3E0S2VXd0FBSTZFVmcybjlwSlBqeXdSa25QWGowNXFqR1ZTV2lzMnZJNnlDeGN0dkE1SnlXNlpyZWlCaVAzZTNiOWF1UjNMSkVDUnpnRTU3ZTFWSWIxWkgrWUFrbi9PS0RvakdFYldkbXpLdkpva0liT0Q2VlNhOE93RFBHY1o3L1Nyc3NjVXR5UnMrWEo2OVB3RldwcmEyMllBN1lQNDB6Rjg3Y3JOV09XRThtOERCSXpqT2VUK1ZXVElWZGNuazU0OWVLdFJSeFJnbFY0L1hQclVja3ZVOU1kT1BYclUzTVdtbGRzdXlLa2dPQ01EcjIvS3NPNkpVWURIZ1p5QnlhdXBLWGpCd1FQcGlvZ200OU8rZU9QeHBwaEwzbHAxTFZuZE1pNGRUbnBWa3pJV1B5NXoyUDhBbnJXZkxDMmNrSG5nbnArTlhGdUxSRVZTM3pjZlVVbVhHNlZtOXU1WGxzcEpIQkF3ZXA3RHBWUXdYTUE0NXpYVHBPUEsrVWQvWFBOUUpKSnZ3eUFnWno3MG1IczQzMGJ1K3B6bjJaMlh6WkUyK3dQV29iVFY3YnpDaXBqbkdEMTRycjdnUnZFRjZaNXlQU3NOTk9zSUQ1aFVja25PY1VLeEZTblVqT1BMS052dE5uUXJjV1N3a0VnRTgvNXpYT1RXTnU1TG9WSUpQTk11RXQ1cEJzYkdGNHF3bHV6cGdOOHdBNmV0SjdtdDNMUnhUUzJhTXBZNGdOcE9CbnYxQXoxcTlFaWlUNVRranIrRlZvOU9uMzVib2Z4eGlteXp2YnRqSHk1NEk0NW9NbDdxVGFzanA1TGVHYUVoc0RrZ2Rxell0TWVJTVJnZCt0VURQTSsxd3hJNm5JcXVOU3Uxa0FVWlhubkhORjlDM09ueks2ZnFhaVNHSmlXQUI5K2xVVE5ESks1QkJQcWY4ODFibnVSS2g2YnZkYzRyblliVm1ja01DQWVNOWFMa1RidWxIVkdtdHpGRklWejlSNjFhWFVJcE53MmNackVleE1rb0hMY1l4bjA5NnZycEJWMFpTUjZnNHh6NjBpVjdWYkxTNDJUZUpNN2VDZWZlbWJjRmV1Y0FuSFFWSklrMFRZWlRqT1I3Q3R0V3RtMmtOMEdNSHZUS2pHN2xyYTNjeDQ3ZG5YY3h5TUhyMEZLbGw1bVYzQTQ2YmVDYTE1M1dPSlF1UU1ZNXJEeW9SV1Y4bmpHTzlBMm9wSmI5elppMCtQTzFpY25qanA5S3NRMlMyNU9mYm5wL0ttMmx3Q0FDM0hROC93Q0ZYYmkrdGZ1TStNZFByVDZIVEZVK1ZQVHlNK1czUjVWWW5qMHhpcDJPeVBHNGRNQWU5V3pjMndnM3ErY1o0eDZWelVWNURQTnRMNHgvRG50NjFKRStXTFN1cnNhanNHQlVBOU9BZWEwTGk4M0tGeVFlbnBWdzZkRTZESFFkQ0Rtc2lDS0NLZkJrSk9RTVl6eG50VEl0T01iZCtwYmdjcWhKYjVqMzlUbXRTRzZoWWpjdWZYdC9PbVR4UUJ3QmpIcDNGUkFRbHh0L0VZb0xpcEoydXREU2FYTERBRzBkS28zUmxES3lrQVp5ZTlhZHZER3BCYkF4MEI5NjZZUndHTEdWNmRQUTFTMk92MlVwSis5WTg3bXZ5UXE3Y2tIbmJWd3h2T2k1eVA3ditlOWFGN2FRTXhZTGprRVlQU3RDMjJiSEdSa2MwV01veGs1TlNkekZXMWFLSXNPUVB3cDF2YkJzbHprSDM5YTNYV1Ixd29CT09jMXl5ZmJQT3h1NzhnRHBWRVNTZzQ2Tm0yMFVhdUNNa0g2NXFHN2JaR3U3c09sWERORURndGc1Nit0Y3hxbDBDd1RmaklBejNxYkdsU1VWRjZtbEErNUd4eVIvaFZjWFU2eWpjRHljZXZXckZwRkVzQVl0azQ5ZWYvMTB3endzeEJISTU2ZS9YaWhNenMrV1B2V0xrOTBvUWdnWjkrb3JQdFc4eHNCZ2VNODFabTJTUm41YzVIUHBTVzRDTHRZYy93QTZOQzNmbVdwWWtTTXFRVzVHZUtodDlMaFlGZ1NDTTVIclZPY1BrYzhaNHdLMFlKaEhHQStNODhkelF4WGc1KzlINWxiN0lReXJrNEo2RTRwc3VtcW80QTV6a0N0aUtSSFlrWVBlcUxKSXMvTEhCSVB0bW5vTnFObHBjcFF3emc3T1ZCSFE5aCtOUlgxaEpMSGoyOU85ZGVWK1FEUEhybnBVS3piWEIyWTRQM3YvQUsxQ1JyN09MaHl0Nk01Mnd0Sm9yY2htSTQrdVNLMG9lSHdUd2FTZWM1QVZUN2dqaW9rbUlCQVVIMjlLQkpLTmt1aHB0TWlnN1FlUGVzSzRua2ZDb3A1NlZzcnNaTUgyNlZneVBGSEtmbFk4amdVRXp1MWErZytDN2xnUUI4ZytoTlF2ZXZjRWhjakdSMDQ1cHpsSkJqcUQyeDMvQU1LbWlXRk1BS1RrNW9SQ1V0RnphSXdVam4zc0M1N2ZoVjhobytUK0JQWEZhY2lxV3lwNS93QTk2em5sWU1BVDB4U3NaT051bzFabWNnQitudDNGWEF3aVhtUVo5NnpHaWFOOGhEZ2M5T0ttWXlTNVlrQUR2NzByQ1VtcjMzSUpya2JnQzNKNzFMRnFLd0l3WnNrQW5iV2RjUlcyNGZPWDVIQTQ2VlF2TFVQQ0hVTWNZNG9GTDJrYnROTnJ6T29pMXVOaUNTTWUvd0RoWFF3WFZwTHVKSTdFRTg4bXZGVXRaQW9KTFpBNHhYVVd5U1BDR081VGprbmc1SHJRS25pS2lhdXI2SGN5K1F6L0FDbGVmNWZTcUx4S0gvaFBwanNhNTJPTjBaV0J6NmMvclVkMnR5NjcwT1NNZlNxMEtsVmRtK1R6MFBTSWhBSXhsMVA0NXpWenlMY29OcEJQclhuTnNMa3hya2svNTZWb3RQY3hvRkxmMTVwWE91blhWazNEU3gwdjdzRmM0NDlEVkM1WGRncndCK3RZdHF6VE1jdDBQMHJlbFFrY25qdDJwN204cHhtdEZvY2xlNm90dmlKUUdmMSt0ZE5weGp1TGNTZWg2RGpIMHFnMmh3VE9yTWh3T25yVzhZUkdpcXJCY2NkS0xIUFRqV1U1U2xhMXRFVUpiWXpOOHVNWTY0cGlyczJwK21PcEZhVFlFUk9jK29IWEZjMmwxKysyT1QyMjBySXFYTEZwOVdiclFxNlkyZys1N1ZtcGJSNU9BQi9zMWV1SlRzSlhIUW5QMHJDUzRmZW9aY2RQOGFrVTNGU1doc3ZZcWVjRE9Qd3FwR1JHMk81SnExSGVxL0dUbnZuZ0NyRTBROHNIUDE0cGpTaTd1UFFvdEZrbmdlcHhXS3drV2JkMFUrOWFaV1E1SXpub0Q5YUJNb08xaU9UU0lhaTN2YnpGV1JwQVFCMi9LcnlLRTI3aWVLcERBQUs4YzhjVllabklQekQ2ZW4vMXF0TXFQYzJsU0ppRHdQOEFHb2JtSkZUQWJCSjZldFpDdXh3dVQvS29US1NWRE4rZjBwbHVVYmJGU1JuaFA4UFFIOHEzN1o1SlJnWTdjajI0ckR1VWptSDNlYzlSMHgycHRrSGhZakpJNjlmOEtSaEJ0VDhqc0dsU0lESEdEMHJJV1Z5eEo1eDNxbmNwTEsveWpqT1RWTjVHaUF4d2UzRlZxYnlxTnZheVIwcTNEQWdyd3ZmUE9LY2JsOXlrdVBUTmNDTlFsamY1dUJuaXRtQ2FTUWpNWTZmV25jbjJ6MnVkVzdoNDhqRFZEWnVxU0ZXSXdCMXpXYkpkQkNWMmpCNmpQcFdYNWp1d09CazVvdU4xRXBKclU3ZWFXTjl2ellQR09NL2hVYXd4aFQwSTdWeTZQTDBKeWNZejZVd2VlcjRPNDQ2ZWhvdWFlMHZyeW1rYmpaS1FDVHpuTlRFbVJjNDZqclhOWGlUS1Y2QUhrL1d0M1Q3amo1c2NIajBwSXdVcnlhYnNJWTNVSGNmWDZlbFVZV2Rwc0pucmpQOEFXdFMrWUhPQVJWUzBWVllIT1RuZzVvS2ExU05HV0p5blBidjEvS3NoWFFFTDE0NSt0ZG1zZ1lEakdhd0xpM2hMRWdnZDhZcFcwTlpSc2xaM01XZUtKRkRnQUE5enh6Vlcza0VnVmdBQnhrL1N0UjdlS1dQYm5Jd092ZW9vTEZJaWNaSFBUUFdnaU1YMlExSVFNN0NCbkZORTVSaGwrQjM3VTV3K1R5RGs0SFVWanpzeU5uYnVCenhqL0NnaHV5TjU3MFpPNWh6VkZybmEvSkhIT2E1c1NNOG5HZm9SMHJaRnRHeUFrNTRHUi9TZ3ljNU85aStyeFNqUFhCUFFlbnJVVFhoaVlnWTcvd0NSVk5ZSlZCQUlBOWYvQU5WVW10R1lxenFUanZUSWNwMnVscWJBMUJIWUhwNmdpbzVydGh4dUk2WnhTeFdrYXBuYUFSeFdmSkN4ZmJ0enlLR1BtcUtPKzVadDdna01EZ2M5U001SXJhaWQ5d1lZMjQ1K3RVbzdaU0JqS244NnR5bGdoeUFTUmowcEdzVktLMVk0WDZvUjBQT09PVFViM1Q1SmI4UHk3MWlwWk9aYy93QUo1SUZhakpHaThrSEhiMm91TlNxTzk5aEhJWlZ5ZXhQV21SUko2NXozSTY1cWNQR1RuSEdEOU9LSkpva1RnZ2tqcU85QlRzdXFMOEFRQWdFNHgzNzFtM2hWcERsaUFCMHBzZHdqQTllbk9QNjFuVHpxekFFWTQrdlR2VEpjbHlESlltRVlLa0FuMjYxbjIzbitZUVc0QjQ0NjFxeHpCdUd6MXFkb1FzWTJMMlBIcFNNSEZTczB5aEt5cnV6N0EvNFZpU0V0Z0Vua25xUWU5U1RpUU5sbFBXb0dLSW83SEE5NlZ6RnB2bVJxSXJNcEdld3dUNmVsTmtpbHdmbVBybnZYTE5xYnF4S2s4RURHUDBOWDR0WEFVWjVCNVVrWTVwV1puN1dtM1p0bzFpTGdLRGdsaHhnK3RKYnhsbVpaRzQ3ZTlXbzU0cEVKejF6d1A4OXF4bW5rVzUzQUZseDY4K3RVTnVLY2RiNm5RUTJaRWdLNDNmclhXcHdBTURwMXovbml1YnRiMUFCbFNNNDlzK25TdEJyMDdnQWM4WUhibWhiblpGMDFIUms5OUZ1allBakhGWjFwQnVUbGNFWkdNZGYvQUs5SzF4dklHU0FjNEhmL0FDSzFJREhqYXpldU1lbFV5VW95bmN6TnFwSmpCQnoxN0d0Q0psTGdZOVJ4L0txVjlCODJQTTl1dE1nRHFwTzdwbjV1b3BYc1VuYVRWalhtbVJFNE9PZWxaUWtEQU5nRURqR2YxcFpsVjFLZ1p6eDZWVlVLamJTcEhISS9yVVhZNXkxWFl6SjNiWVJrK3VjK3RaOWpNNGZuR00rbjlLM3BpaFZ1TTQ0UE5jMkxtRkxnNUJBSFR2VHVjVWx5dFBtT3prZEhqR1FjZ2QrbGM2NEh6amxXN2tlOWFMWGtlMWN2eno3WXoxcXNWYVJzaVRQSEF6aWhNNlpQbVdoeU1zVWl6cXlnc0QxcllqamZLNU9SM3ozcmZNQzVCR0FjWTZWVW5obVZzNVBUZzhVSEw3Rnh1OVNySlpySXB4aGVuSHIzclBlMFJEeUR6eVBUL3dEVlc0RWNqR1FjNHdhYk5iWERKOHFkRG4vT2UxTHFVNGMxL2RDRzFpa2dWdXZYa1ZuTVZRbERqR2ZURmE5c3J3akxEbkJCR2F6cjFBMlRubjFBOUtDNVdVRnBabXBFa0RKbFdDODk2SzVlTXlxVGxYWWR0cG9vdUVhaXN2ZE43N0N6RXNXNmo4L3pyTld6VmpzeVFDUnoyRldwV2xPNWNIaklILzE2cE5kcEdRckJneEk5K2xVWnk5bXIzVmpqcGJKN2E5THEyNFpQK1FlOWRORklaU0NUaFIzRlMzVHdtSUVkVHoweHo3Vm00a1laVWRSK1lwN25JbzhqYVdxM3NhOHl6TWloU1NNNTRIYXIwYU5MQ29mQXlPbnRXYkhPc01LcWVEai9BRHpTRVhEeGc3V3hqMS93cFdOazFmWnZUVkY2QklZWEcxUU1ESHJVMDl2RFA5L2tFQUFqNjQ0eFZWb0hraDZZWURnMWRzVUpIekRQSUhYK2xMcVdsZjNlVldaRThOaGJJUnRCSjZrK3BxZTJqZVVNVkE2NEZjWnIwYzhrOGFxemhkMkNGRmRscHNyd3h4L3hlNTlLYjBWN2hGcDFXdVd5V2hnM0VON0hjRUFIQTR6MHpVUnY3eUdRcWlFblBCQnhqUFd1cnUyZWFUSUdRT21mWE5SS0xOU1dJVGVPQmc5YzFKaktsTG1hak54MTNPTHVIMUFUYjVIS2pJeGtkQlhUdzNzazJ6SE9PaHpqT2F5TlZrTXliRktqSXdDUWY2VmEwNFJ4d2w4NHdPbU91S0c3b3lwYzBLemp6TnhlcmJkemRONllYK1lFNDVQUGFzZTl2NHBsWGdaNmp0MXJtTGk5bU14Q29UanYxOTZ2a0FSZ3Z3Y2ZObmpyN1Vhb3AxK1pTU2V4MEdtM3JnbFRIa2s4azlCOUs2Q2RmbDV4bkhUUHJYTFJTMnk3TnFjNHlNZENhTGlTL2t5M2w1d1J4N2Y0VW1XcXJWTzJzdTFqZi8wYUpkekJWejJQOHhXdkhkV3hDa0lPZWhyamZJbW5HVGtiUndwcll0clVMeGpBSEpPS2Rqb2hVbmJTT2xqc0pIM29DTUVjZGZTb1lFalk1MmpudjBybmcrUGtMY0QzT0tsbXVaSTRtTVp5Y0RqcFN1ZE1aM1YyamJtRWFPdm9lYWJMSEJ0MzVQVE9SWG4wTjFkR1VtY2dEUFhPT3ZOZFZCT05wQkpJNDROVjBNNDFZU1h3MjlTcTBoTGJTT2pkZlkrbGJVWXRpdU1nODRyQXVYaE1uWGs1R2MxQ1prVWc1Njl5ZWxRU3BwWDJac1NtMmpEQWV2QXh4eDYxeXlhb0V1QW42Z2ZrSzJpaXlNVG4wQTlEbjFyRnVJWWtrSlFMbmpCOTZaejFKVk5IRnBha2VvYXpHc3dWbVplT1JqUEgxcTFEYTJrcWJoT0FXQUlyTFRSVGRTaVF1NE9PVnh4V285cWtNUERodG9xdExLeHpROXU1VkpWSXB4K3lYWTJtallGRU8wWTVCcnFWbVdUQmJBUDYvalhPMnM3TmJxRlFrNTZkc1ZWYnpVRzFrWUh0NkFlOVFkc1pjcVVrMjAxZjBOUFUzaUNaUndjSEJHY1ZqZVp2aXlWNHgvbjhLeG50TG5ma3Z1R2VPUHcvS3QrSzJab1dIQlBjZjBwR1h0SlZHMjROZVI1MWZ5WGNlZkpCYkhQQXpWN1NOVHZ3QjVxa2NaSHJpdWxBYUtRaDBHMGpzQi9uTmJFbGxFNEIyNEp6MEhINDAyOU5qamhoNm5QenhxeVZ2czlCeTZtcm9wempqSFA4cXo1TlVzM1psUDNnZnlybU5WdEpZVXpISnR6eDBxbFpXY1VpL3ZGSndlL0o1cFdWdFdiVHJWMUxsU1YvUFk3STNrYmtCWHh4enp4V2UxMFlXR0I1Z3pqanQ5YXIvd0Jud2daRXhVWnpnam9hblcxakNMbGs2RFBZOFVXOHc1cTE5VWsrNVYrMXl5RS9LTzJmZXVoVmxqZ0FZWk9NODg0OXZwUkZaeGxRZHZYQTRHRHg5YXRmWjJKQTJsaCtWS3h2VFVvdHQ2dGxtQm8zR1JrSEhCNjlmNlUrTytiTExqaGVPbjZWTVlVaGdaaDZjRHR4V0ZaWEN5U2JjREk1T1RuZzB6bzk1U2lyMmJPaDgyQ2ZBWnNmNS9uV1pKSkhEZ0U1R1RqOEttOHAvTTZjSHFNWnhpblh1bmZhRjlNQVlQUTgwMmF0U2FidGRvcXlySFBDQ29CM0w2MXpEQllSNmpzbzYvaFcxRkhMWmp5OEZ2WEhBcWVXMFNVREtzQjB4N1U3bk02ZlAwdEpGblNsU1JPRndNOFU2YlNoSytkd0dLc0xaeVcwZjd0ZUIrWSt0WTBONWM3MkRSSEl5Y2owTkt6WnI3a0l4ak5YdjVFQ3grU1dqa2RpdWVEK1BjMXB3MmR0TnlyOC9VVXJRU3o1TEFnZGlUeCtHSzV1YUNhSm1FZkE1NUZDUmhMM2JlNWRkTzU2QkFpeEtRcjhrK3ZIcFhPUGF1ays3ek1Fa2c4VldzSWI4UEd6djM1M2YxcmF2WUpIUDNsT09RUlFhdUtsVHU0TlcySnpFWlVCUDBiSnhXVk5GNUF5TTVIZjZkNjBvTUtCdWJqb0FlT3RjM2Z6Zk5nRnM1QndCeFZKRXlhU3YxSkVuMUdZakw0WHNjWUhIYXVqRjNKQW9EQWxTTWNkcTUrQytsa0NBTGpMZC84QTYzZXVuVzNXVlJuZG5nNXllY2RxTEZVbTI5Sk4rcHAyOHl5Ujd5eEJQQkdhdkpPbTA4RDJybW9MSzRTWGFOcFhJOWlhMDJpWlNkdVRuak5JN0l5bmI0UzZsNG8zTGc4Y0QwcVJFRy9KUEIvQ3NTV0diY09PYy9UOEtzU3hTQk1sajdnVlZ3VW0zdHNXN20zUVlaVG4yOUt4V3NsTFo0R2NubXI4WXpHU1RrRDM0cVpMaEQ4cC9ENitsSzVNb3hidTlMajdlQlJGblBRY2tIcFVESkdwSjJnazlUV3F1UExkbDI1Nm5QOEFTc25CZkJDamp1TTBNcVNzbFltUWxvMjI4NTZBOFZ5MXlaUTJGM0FqcjNyc0ZudDBpSU9TdzY1SDhxeUo1WWlBeWtoVG1rbVoxWSs3dVpzTWpxZzNrbklIWGlyKzJHY3EyNERHT1NlYXdKcFdJR2NnRHVNMGk2ZTF3bVVaU3VjOGRlYU5EbWp6TjJTNWxZN3FKN2FOZG9kUzNzZWV0Yzk5cXVIbUs1SDNnUUQ2Vm5McHM5dnRkc01NanY2MTBjUGxEQk8wSGQzOXFEb3ZLVFNmdTJMY0Yxc1lLMmNaSGY4QXhyYkx3bFZiYWNnOUs1MlJETUJnZjAvV20rWWtDcjgzMEhmMHBYT21NMnJwN2R5NU14WlNBbzR6MjlLd2ZMaytYakFJd0NEVjlKa2RzN1czQTRQK05YNHBvMVlaR0FNWXFyNkV0cVd0eTNHa3JSZ2tkdUJqbmlxZ3Rrejg1SFRxYTBoZU1SemdqcmtmMXFDNUFuakFHUGZGTk0xc3JYVDE3R2NiU1BhTm5mbjg2cml6bjh4VGs0SFQ2VmZnaVNGSDN0anYvd0RYcUtLL0RPeW95a0QzNjBYSXRGTlgwWTJUT01aSFg5ZnJWZFVEUjU0eU05UlJjR1hkbGxIYzVIYXE4TFB1SEpQdGovUEZCUE11WjZGNjNuYVFGV1VIc1RqcG1vL05qRE1vQTQ3MHplVHVVS01kOFZuM0FDcUNmcitkQ01wemFWOTdiaS9ZbzNjbGlNbnV2dlYxN2VNSnkyY2V0U1c4a096Y3pBWkhiODZKWm9uenR4d2FZMXk4dlRVNXllR0tORjVQTGNISDYxa2k0WS9LTndPT29IK1BGZHVscWo0NUEvRG1wTHJUd0xjbE1aeG4zNHFES1ZDYmQxdDJPYmpNS3FvZHhrRDZjMXByZVd3UUtHWCtkY1hOWlNaWW1USEZPdExKQW4rdVVFZXZVKzFDU1p6S3BVVXVWUVMwM3VkckZjTDk0Z0hxUFg4YXR5U3duajhUeDNGWmRoR2o4THhuR005S3R6MnJBNERESnowNmZpYVZ6MEljM0plMXk5RThTY2pCL0RpckdSSTNCOXhqMDlLcHcrVWlzSFAzY2RxbUJRZzdmZkordFZjMVQwTldOeEdCbGllbFk4NWxtQlpUbjJ6eUswNDFTVkdCNzhaN2swcXhOR0ZLOU1VWE5KUmJXK2xqaFVrdkZsS2xXSFhCem1wWm9HYzcrcFBYdFhhVEpiYmNrWjQ0OVJXQzExRXB3U0RqbkhYL0FDS0d6amNFbFp5T2JrdUxoQUVERWhjWTdaejJycGt0WTJneXFZM1k0eldGZVhFUExDTVl6a1o5YXRXdXJ4NFVGU01qakhOSXhnNHFUVGxmUXVRd3RFU1MrRG5HTWNWTzg4aWpwa0RzS28zZHdkbTVUak9jOFZseDNyTXB3TW5CN2RSU0h6S0dpdWRkSmNLMFpBNzlxeFBJVnNFTHRPZTlZRXVxUng4TmhmVSsxUkpkTklSdEpPUmtFZXdvMUIxWXlsclorUjFoWXdxd0JCNTZWV1M1eXhCS2pkbjhLek43TDk3blBBSXBqeGh6OHZYUGMwRGxLU3R5L2NkWkpMQWtiTWVUZ2NaSFN1YkwrWTVJNVBUSDBxcXltUWxXZmdqOGFpVFpHT3luMjcwN2t6cU9WdExJMm9Va1VnczNHQWVlMVZydlU3ZUFGZCtUMDRIclVVa3JNbkRaNEI0ckpObkhMSTdGamtFY0VkYWR5ZWVYTGFLKzgzWWRTOHdEQXdDZU9lb3JRa1VOOHh4bnFlMmF4bzBpaTRVam5zS3RUM2lJakpuSjdacFhadEdWaytabFIvS1oyM1I4OWo2Vm9TUnZGSHVIVWRQeDlhNCtSSldmZUVKNE9mWTEybHJ2a2hBZGVDT1BhalV4aTFKdFc5Q3RFeE9Dd3hqOGMxVSswUDV1QW55OVJXMGxzUWNid1FPbzc0cWxOQWtVbTRFWUo3bmluY2JVN0wxMUw2RmhoVnh6MUhmTlJUVFNvQWNIQlBYT2VuMHJRaTgxb3d4eGdMalBHYXpwRmxZa25rQWNqOVAxb3VkTXIyVnI2a2NsKy9sZ01tVHh6bjBwc000Yk8zSTVyTDM3aVZLNEdjZFA4L25Tc0RGamE1eDBJQUdUU3V6bVVwYzEyN3F4dXRPK0R1YmNRRC9rVm14M3dEZ0VFYy95cXJKY09vVWxCd0R5YXpJSmpPNEpISU9jWS96eFN1eHVvMDByNm5wVWQ1Q1lSOHdQK2MxbW9XbDNZR2NqSXlhNUM1WXhSa3MzVWMrMVRXRjRvVEl6MCs5MXA2Z3EzTk5Sa2RRRWxSVytiQzUvL1hTUmlWcE9od08vclZhVnBaanczK1Q2MVlpTTBQQmNnam9QclZLNTFMcG83ZHlkMGZucnlQWEZXNDdOSlVCd09sWjA4c3JGV0dTZjVrMVhXN21TSWdnaHNjZS8vd0JlcVErZUtrN3AyTm8yS0tweVFjZnpySitmekNvWGpwOWMxbHczc3J5YlNXOTY2ZU5vd3U1aGtjZmtLR05PTW5vckdsQW9aUG1VY2Z5OXF6NWpHWkZVTmpHT09tYTBEZktZMkF4MHdPMVlKUnk2ODlPZnJTT2lYS2trdFRTOGhGaVk1SGZQNDFrTkE1a0hQVGtuMjlLdXlPZGpLRDBHZXZTbHNYd2NzT1ByMCt0T3htNHB5U01JM0VrY2c1OThWTzVMOGpjT3AvRHJXdEtrSm5PTUU4NFBwNzFkamlSazY1SjQ2WS9PaG9qa2J1cm5QRzdkRnhzNmRNMXl0emZ6RndOZ3gzNXdLMzd4RkRnQXNUbnBXZGM2YjVpaDlwNDlhWEwyT2VYTzdxK3cyMWtad01FYzl2WTFveVdyc2UyTWYvV3JNdG9oRStDQ0N2OEFTdXBUT3drZGNEUHJ6UjBKaEM2YVprVERaSDh1UjdIOHF6NFF6OE1CeHdmcitGYndWblpoamtjWUhQRlp4SGtzZmw5K1RTTGNldlF6ZDBNWnlXNUhiTmE4RjNDeDI1NHh4eHhXWGN3dElNa2hlUURudFZLMmdkR0lMSEN0Mi84QXIwR1VlYUwwUm9halBDV0M0d2NmV3FUUTc0K0FCK0hyVmlXM1Z5Mzd3bm5yM0Evd3F1NDhvTHljZS84QVdsMklrNUtVbTFveXBIYUVNeEpCVWREV1hlakRBb3VPZnlycjdQYTVPNEtmNkdzNitTTHpnT1IzSTk2MGp1Unl4VUx2YTVGcDViWXg5ZmZ1T3RhVXNFWVljY25PYTA0ckdFd3FRaEh5OGtWQXRvVjZIZGpQNFZKYXB0ZEw5ak9TT1JXQnlNWUdSN1YwRnJGRjNZWngvS3MrYVZFd3JBQW51UjB6VVRobFVPQVNCMXgzelM2bzBWbGZTOWpxRGJvU0NCNi9Tc3FjTW1Tb0dPYzhZck1pdXYzYkhwMTQ5cXpHMWFhTVlZNUI5TzRwM0puVmdvcHZUekxDM016VGxIVG9PMWRBUVVSUXZ5NTQvS3NLMXZJREt6WkJPS3QzVnl5ampyalBQK2VsSFV6cHpTakp0bHFLNGpWeHVmQjl6bjhzMVBQdmNaRDhudDByemE5dXJwcGxJWGpqTmRaYlR1SUl5eUFjZC82MEVVNnlibEYzMDZsT1ZzT1FReEo2RDJGWjgxbjVwRWlsdTNldEs0bEpYa2REanBSYUV5cU1NTTR3dzdkZWFralJ5dHVaYlhEUlpCWGdkTnYwcnBMU2RIaTNmS0QyNzBzMm1SU1FrZ0RJUFRzQlZlTzJaQVFUbm5HT241VTdHcVZXRXZLeEhjM2NpekRDZzRJQUZic2N5bGZWaU05YXFDeERvVzZlaHFHRlpGbUNzZXZmMG9OSU9vbTc5VFRGMURBd0xZVTU1ejJOYVF1b0grWU5rZE9NVncrczZiZE1vS2s0eDEvejBxclkyMXhFQ1g3OGZURkZpZmJWb1ZPWDJidDNQUUpKSVNDT1A1OWFwSkRIbGd2T2VDYTR1NHV2TDJnT1JnOUQ2bXJsdGNTdEdUdUdSMXdhR1VxeWxMVks1MHp4UXEzVEg2aWl1ZWE2WXRqQmJ2bkorbEZUWTNWV25iL2dIV3Q5bDNFOXowUFNzdWEwczVaUVdZRDI0L0NxcldkejlweUNTdUR4bnA5TVZITEQrOUlCNi9qbXJNWlN1dmVoMUVtaXRvMUlPRGdmV29ZVWpLNDJuSHRWQjdhV1NUdU1ESjlxMnJhQVJEYVN2QVBmdWZVVWROeUl5YmZ3NkdOY1dReVdBNEFIWHJXdGFlVVlkcE9NZm54VjU3VXNTVndTM1htck1lbjdRY3NlY1o0cFhMakNYUHBIMU9FdjlUZUdRcEVwUG8yQmo2R3RHR1NUeXQ3QTVQcDcxZmZUb1VtREVIblBBUEZQRWtTT3FoRHgxN1l6U1pqSG1VcE9jcmRFam01Zk5tM1pVNTlQOGFTYVl4Ukp1T1JrZFBwMnJ0RXNZV09RZndybXJ6U3QwbytiZ0hrRGpyU3VybWRTblVVWGJkbG0xdVZhMlBVZ2drZi9BSzY0TjF1MXY4c1J0M1k0SEdhN2VLMmdpa0NnNXdRTWRQenF6S3RtN2xWWlMzY0NtbmE1aFVnNXhnbkt6aStqM0kyV0F3RTRHN09NaW9sRWJic054bjNxT1RDWitUNUFjLzhBMXEwRXRpOE85VGcrM2JOU2pScHVXbXRrVXJmN0xESXhmSjNjZ1k5S1RVWHRwZ1NoNXh5T242MFJRWmxZRm1PRHh4VjZTd2pDRmhnREdQWW1uMXVDaEowM0d5c2NqQkZJTUdNOHNQeTlxNi9UN3J5WXYzd0pZNTVQZi9QclUxckhINVlQeTVQR1FPL3ZUSllyZmtaenpqci9BRG9GQ0VxYVRpN1dYeUlwcEpRV2tWdHFnL04zUE5VTDZlU1dQYkR5UU9uU3VoamUxV0RZQ1NBZTMrTlY0VGJSczZnNUxnNFkwWE5KSzhiYytqMzFNTFR2TkEydTJHQUdSMUhOYkVzdXpHQUQ2NU5PSXRZaTBqREI3anZtdWVPcGVaTXNlMk01WTRJNDRvQ1BMQ0NUa1hwN2RMbmJqQTRPUi9TckFqa2h0d04zZnR6K1ZWcHJDNExxeWdxTWM0T0t0YkFrYkFrTG52bm42NHA5Qk9MNW0zR3o3akFQTmc0eVR1OXUvYW9ycEpSRGtKK0hYSEZMcHhRdndkeEdjRHRYVUtIZmdweDlmMW9DTVZKYjlMSEpXOTM1S0tqS1N6SEF4bnRWd1F2dk11MGtIbGVlcEZYcHBMUUVidW1meXJYc3J1Mm1YWXZwemdmclJmUXFNRmRSZFJlUmwyMTBKR01aenlDYXBUUVhKbEFEazV5ZW5mM3JwSmJLQ0p2TTI0UHVPbWFjOHNUSmtIZGcwV05mWnZsdE9TdmY4REx0UE1nQUp5ZU8vd0RLdEV1MHAzYkJqb2UxTmxlUXhFQUJzZW4vQU5lck5uS1dHSFFBZS9mMnBXTm8yU1ViNkZlZTJNZ0hQSHI3VXhMZVNLSTdXQkE2ak5hdDIrMU9EMUdCNzRySmdtekc0SjRQR0RTc1ZKUVVyVzFhM0VpaWptWXFNYmhUbWdlSkRrblB2NlZsS2pSU3U0eDk3T2M1clVndlpKUVFSa0Fub08xVlpHVVpSYTFWbWNySTBrN09CdTI5elYxTGQxaE9RZnc2MXM1aWpja0RQK2ZldEhhcGpJM2NkTVk2WnBhRGpUM3U3NkhBalRiaG55WlRnOGdEc0s2T0dKSXdDeEpKTlZYdDVqSzJDZG80QnoxRlQzQWtqMitudlNNb1JpbTN5dlR1YURUUUsrQStQUVpxQzVtM2hpallCSFgweFQ3UVJTZ1pYR2VCeDNwMTNZUy9LWWlweDJwbXpVM0c2MVQ3RmRIa21qQ1p6MDVJNjFGQVZzMkxGRkE3OWUvMXJLaWE1dHBTV1Vubmp1T2E2bFpMZTQ1S2c4WnBhYjl6S0Y1SmEya3U1Q21zeE1XMng1NTcxYldkNUhCVWZRWjZWbi82TUhJQUE2ZncxcHdwR3BVNFhCNDJqcUtEb2pLZldYM0dtRXR5NDNuQkg2Vkl5d3NVS0x0SHJua1ZrU3EwVHE0eVF2cDZWTEZkYnR4VkRnZW50elFkQ2x1cldHM2s4eUtBVnlvOVJ4V1pKTXUxVDVZeU9jaXVsdHAxbVpsMmNkdjYwd3FGWWpZcEdjSGptbUNWMDN6Nk14UHRVckp0V1BnZGo3VVJ3SVV6OGl0ajhPYTJ5OGF6S0dqSFBHYVNWWVlTR0dNZGNldE5DY0w2dVNkdEN1c0xtTWpZQ1FPeDZpcUJnWUU5UjdZNlZ0MitxV2p2c0lBT09COUtqYVVDWmxIcngvOEFXb3RxRW93c3JTdjBLcVc4YkRsaWVNSEl4VllhWkFXT1JnZnpyUWxWbE9VNXptb0E4ckVrcUFPbnYrRlVSeUsrc1NBV0VVVG5hY0hIQTlLbnNSSUhiZEp3T2M0ckp2YnlXSnp0a0l3T2hHUWFnV2VWMUczY2VldEJITkhuMFczUTNMaTlWWnlCeTJPRDZaN1ZpeFgxMTlwSUdjRWpPQjYxYktSL0tYd1RuQXJwZ3NTUjdzQThBWkZJZHFrbjhWck1mdVoxRE5rOGdqMXJEdWJwY1lBNlo0eHp4VnRyOVhiRzdnKzlNM1FvcEoydCtQTlRjMnZmUlNYbXpNdFpHTEJtR01zZnlwTlhLd1JCb3p6ai9QU2xOdEpMSWR1NWZjRDFyVGV5UmxBWWduR0FQV2tadUxjSEg4VGliWFVidjdNYzhINjF0MmwvTDVSRDlDZWNlOWFpNldwY1lZY0RqbnJTK1RhbzVqL0ErL3ZRYzhhZFdMamVYU3hqeVhFRE1GYVRuc00va2FtTWR1b0JKd3A2akZFdWlXdm1DYmQ4MzYxeWQxQmRQTHRqbEtZd005aUtMR1U1VllOODlOUFhTejNPdjFPR0FXdVVZTTN0M3JsdE5tdUlISVo4alBBSXhXcWtNd2pWR0piYWY0YXF5cTJEd1FjK3VEU3NYVTFha3J4YVIxTVZ6RzdxN2pqNjU3ZDZtbldHUUtZbUJBeFhIQldTUGxTV3g2NDY5NjByUzFlVEFVWTY4K250VldIR3BLU3M0Ni9pYnl6Rk1MbmNOdkgrZldzT1VzSHk1SUc3QXgzcXJjaVdOdHBPVG5wbkdhbVdhSUxzazZucDYvU2tQbXZkTjJzYTZ5UUJnd0ordlg5S3N6S2hYY0dPRndmcm1xVWFnWlVFNXh4MHdhcUNHNkc0SDd2UE9hRGErbXFOdU84Z0tiY0ErdVJ6V3lBZktVZzd2d3JnZGx4QUEyMHNUbjJ4K05kTFpPV2orYjVPUWNBODgweTRUYmxacm9abW8yODA4WUVlUVJrODlPYWowdlI3aUJNczQ1eWNtdTBqYTMyZ0VrdC9rMHp6RVpNY2dZNzBJcDBZY3lrOTdkeWkxdVdISzVIK3llOVF6RFlnT0NHNzFZS3pOa0FIdGdkdnJXSmR0TER4eWVNWTdjMHlaTlJpM1psMjFqTEF1Y0ErdWUxWjBsemE3MlZnQ1JuR1JXQUw2NWprQjJFNVBQZXVndGJXR2NHUTR5d3lPT2MwSXdqTlMwVnI5YmxSL0xsK1VTRG5rRHBpdVdranU0WmNGV1lGdVNmNlYxeHNOcy9CeUIxenh4VzVzdGdwVW5rcjE3VVhJZE9VdXRqTXRKWEtjam5BSXJDdXBicnppTWphVDY4NXJvOWthbmFHSFBYbnNPS3paTGNlWUdEakhxTzMxcEd0cFdTdTlQTXdTc3BLazVJUEhVZjFyTmxXVlpkd0lJWHFHSGJ2WGJsYlZWSWR1ZXhIclNKSEJORVZVcWVDRGovUGVrWXpvdVgydFRtYlc0WldBUmhqL1BwV3FiMllGVjNnWjl1dWFnazA1NEVMWUdmV3A3ZUlsaTN5OERqUFQ2MG1nZ3Fpc25vems5VHZMMk9Ua0hhVGdIUFROYTJsUGRTeGpMRW50azhHb05XbGltd21DU09EanZVVmo5b3RtQTZxZVI2aW0xb1JxcXU3YU9xaWVlTWM3cyszU3NPYldyeUY4RlQvQUJBZWhJcnNwV1F4SXhCR1IweDByS1ZJSlVPVkI3a0VmenBJNkp4bFpLTTJpS3oxRHowSklQUHY2ZGFiSkVKR0hHUHg0ckpaWklKUUZRaFJuQlBiTmE5dXdQSklHZlFjVXpOTzZzOTF1U0FXYlJCSDY1NDdqaXM4V1Nsc3FNY25wNisxVmJxQWk2eXJFZER6MHJTV0tZQWxjN3NjWU5BdDI3eDI3ZFRLbWl1aElZeG5ibklKNXg3VnJ4Q0tDRUJ3Q2VLcVFHNWFWZ3k0NUFITlQzOFVqNUE2REhIcjdVMlJCZkZKWDM2bEM4MDJPWUFCUjF5QmppcUVOcjlsNUhBQTVBNHgrRmJkbHZYYUdKNHlSNi8vQUtxMWJtRldoTEhDa1l6NllwWE5mWndmdnBXa2tZc0RRekxnbHR1Y1p6akZRR0l4WjY4OUQ2MXp5ZytlNWlsenp3cFBIUGV1d052TktvSjU5UFlpZ3poZVY3clZkVE1nZVI1WEhCVWlzMlczbDNsdDdET1JnRFBldWp0YmRvNVdCSFVjZzhmU3JFNHhLT29IZWdPUmNsOWR6aVpudklRUDRsQTllYXJRM0YxTHd1VG5rOCtsZC9QTmJpSXFWVW5qbGhXVGJDUEVoR0I3Z2RhWmxLbjcyazlDRzNqblFBc3lqbnI3VkF5Q2FRNXdSa2REalAwcmJpbGpsekdWL0U5YXdyMldPMmNiRUdmWFBOSXFTajdOTzkxMU5WcFVqWEFCNEI1cExTOC9lSEc0YmgwUGVzdTN1Zk53Q0RqSGNaclRtV09NY2ozejZmV2dVWEp0U1QwUkxjWEVvazNLeDlPbWMvU2xOeXJnREE0SUpXcTBUckl4QllqMU9jVkswc1VTYlcrYnFBZXRVbWEzZDc4MmhzV2Q5c2pLQlFENmRhNmFPSXZIMEJKL0RnMTUvQktHY0ZSdXdlUm5tdXdoMUZVQVRQSjQ1cG5aU3FSdmFUMEtrOW1pRWt0My93QTgxaFBieU8rUVFBZVNhNmFkbHVSMTlpUFRGVUlyU1NGZ0ZBd2NaeU90SzFtVE9LYnNsb1pseUNJd0dBT08vSFNwTFcwdGh5byt1T01pdXFtdFVtZ3hqa0hJQXFuRmJsRnhrWUdlYUVoZXlmT25hNnNjM2U2ZUoxMnEvQTk4Vlp0ZE9paUcwc0NNOXozcEhOd2t4RzdqclNQdU1nM0Rqcng2bWp5TU9TbXB1WExyc0pKTjVVb0lRQWNqcmtWdGVZOHFjam4xeFhQM0Z1VmlZakJBNXg3MVh0Ymk1SUlPQ09PUFNydWFxbzArVjNzenM0SkU1REVaK3VLcjNLeEZ6NkhHRDcxZ3ViamNTcUZsNEh2ajFyYWpDRElMRWUyYVJ2Zm1WckVTcXUzaFFEMit0UDhBTVE5UVIwNHh4eDNwRHQ4em5PVG52VUxTRkhCeU9tQno2Y1VFN0duR3E1M0FqSG9mOGF6WnpLa29JUFhvTThWYmlVU0llRnpuc2VEVjNjc0FJSTUrbmVnMnRkTG91NVVaR2VMSitZWnlRTzFVbHUvS0xBQWdqdU85WGZ0VWUwOERIcm11WG11TFVTRTdpT2ZtQm9NcFN0cnpHcVpIM0s3T01mNU5Xb2JvS1BjZFNPZXZhcWl6UlNSakNnNS9BaXFaQ3FwVTRHU2ZhZ3pVMmxkTXVmYU4wdklCL3dCckhQOEE5YXQ1U3J3a0srNGZuWEc3SXBJbVpYT1FQODQ5NnJXdDlLa3BUQkJBNjB3ald0YS9VNlZyRmxPN25BengwUDRVSXhaY0VuMHlSM3A3WHJCQmdaUFRuK3RRUnpqZStUOVBlaTVvM0JOV1lSL0s1REp3RG5JN2V0V0psM2dzdk9BTWRxb1N6QWNEUDQrbE1pa21NWkpBSy9URks0S1MyTm1CWWRwQlRQQVBKOUt0TmJ4YldPNGRQVE5jdGJ5czc3U1NwempCOXEzSTN4am5PU01IT0tkeHhxUnZzWmNsczRsM2VuWWREVmg3TVNwa05na2pITmJMUzdseHdTTTQ3NHF0dUs1SXgweHdLa21VWTM3cGxHMHN6SElNcWNIMjYrOVRYZWtxWERCU01rbm5wVmxaWlN4T0FUMjU2Zld0U0M0TE1Gd1RqSFRuTk5NcU1hVGp5dGVoaDdabytNL2g3anZTeGh0K1hHTW5uSTlhMDcrSlFUN0hPTS9oV2U0WVJqN3c0L25RRWx5dHJzUVhkdEdZODdlbUNPZWF6UEtMSmdIQnhXeE01TVIrZkI5ZXhyS3RtWXRrdGptcFJsSkxtVnVxTUpvWGlHWEdRVDNHZXRIa1F6SzJTb09PbWZTdGJVcEZPQnV4N0d1Tk52Y3FCeUdHT2NVYTNPU1NqRzZ0ZEZxT3pLNElUQVBjVnZCWEtiU2YwL1NzMjNmOTNobU9RUVJuakZXR3VZeEd3eVczRE9meDlxYVR1SmNpWHFpL0hIWm5QQ2svNXpTRkkraXR4L2RyaVdqdTFueWdHT2M1UEdEWFNLa3FSYm5BTFkrdk5NaU5TOS9jdFl1eitXaU51Ym5zS3IyaGkyZmQ0UGNWQUZsdWNyZzhENjhtamI5bmpHR3ljOThkNmVnSzdha2xwYmMyWkp3dS9hZVBjOTZpWW1RZ29NbkhYOWVLNXlSV3V5dzNZd2VSM3F4WnJKYUhheE9PMlQzcGx4bkp2Wjh0OXp0b1RNcUViUnh4Z2oxcXMyNVpOeWpweWVPdFRDN2g4dEdKUDA2QWZXcWJUSzQ0T01BVkoyTngwc3pVTTI3WXU0Z25xS3JtRUhKT1NNOXZhc1M0bENQakhBL25Xa2J0UW9iSTR4em5QZWtPVTR0dFBvWjk5cDBjZ0h5bk9NK21hclcxdDVSS2c1SFRIcHgvbk5YUHRaa09QTXovQURxYU9WK1Y0NjBrWldwT1Ywck16WHQxODA0WUhnVVZZbHRwaTNBTGRUbnJSVE1XcFgrQm1MSHJJaWZETVJub092UHQ3VnN0ZElOai9MbnA3ODF6Q3JEUFB3ZUIyUE5XTHBJZ3lndHdwQnlPUHBtazBjVUtrN1BWTlgwTGsxOTVhbDQrbVIwcm43elUzV0VzWXo2REhHSzZpSzM4MU54N0hKcS85aDArWlNyTG4vNjFDZXByS25VbHBHU1YwYzFwK3J0TkRsV09jNHgzQnJwR3U3a1JxUXc1Nlo2ZWxjN2RhUkZINVppTzNCQkJIZjYxMDlxZzhoUXhIVEdTTzFHZ1FWVk5weTFTM1d4U1ZMaHlDd0JCSi9Lcms5Z3pJR1hqUGJzUHBWZ3RKdTJxTWdkQjZlOVdZcDVIeXA2ODlQOEE2OUxVNmVXTFd0emxrc2RRVm1ZU0VZUDNSVUVFV3E3MkRFN2NuSkhKeG11d2x0bmpZa3NNZGFsOHlOWVNDZVdIUHAwcEUreFhWeWpiek9PaXRabllxd0h2ZzFRdWRNdW81QThUbklHZU93OU9hNlpCY0VzUUJ1eDhwSEFxMVl3WGNrcitZQVFUMEl4K3ROYUdEb3FjVkhsbHE5K3h4MFVseTN5U0lTT0JuMitsYU1tcWkxakVaNFppTWcrMWRsUHB5b3JNQnlBYTRsYmY3VmNiVGpHNGNFWnovalJZbVVhdEt5VXRYdGNoaTFSUEtERmVwNHJvNGJoNW9TZHVldU1pcFUwUzNqVU41WXlPTWYwclNnaVJZeVFCMXlEbW5ZNktkT3NyY3pXMnlPWU1wVmdvQXljODQ2RS9TckVVUlFFeUE1T1NNZDZyWFVpeDNIQUdkeDYvbld0NXZuSUJ5Q1I5MzBwTkdjYk9UVjlWME9YdU1TU2ZJR0l3TWtkcTZLMzJaNVhERWZoVkYyV09SVVNKamdEUEhITmFVY3Y3d2doczhDbStoRk9LVTNycitCbTN1OXJsUmhsQis5Z2Zoem1uTEJERzRZQVo0d2VPOWRkc0RINWdjZCtPeHFHNXNJWFFFY2NaemorVlVkdnNYN3pXcnZjNTJTVzRJWGFUalA1Vm1DMm5sbStZcVRqblBvYTY2M3R2M1hMWk9lYy95cTBJRlhETUJ4NisxSWgwK2F6Ylp6VnJaeXhPU01meUdEeHhUTHpVaWlnS21lT2NIcVJ4elhTWExueUNGZm5IVURwbXNDMnNsVU1aQUhQdnprbitWU1p5aEszTEhUekV0VEhMc0xLQVQxejlhMTNTTzBqSlJjdDErbFU1Vnh5aElZRHR6MHFTM0YwZjlZT0ZPUVRRYUpOYWRla3JDcTk3Znd1QzJCa2djZHF3TFhScitPZDNMSDJPNGsvbFduSmRYNlNFcUR0NjVIcFhNLzhBQ1VYa2Q2SVZoT2QvYjA5NmF1OWptcXZEcmtkUno1azdYdHVlb1dvVVJuekQzNkdxOGw0aGtLcEh6bjcyS1VOQ3NZWjM2Z25CNkQyNXFtc1VhU0dZRGtkZWMxTjJkN3ZhTnZuNkVjc3liOE1PZmVzNmFHUXB2VTRQZkhwVkMrdThPR1pUZ2Z4RStoNlZxV3M3UEdOcWp2MDcvV2hNNWVhTXB1TGZvTEZCTEpFUWNjOTZZb2VGd051VDdjRDI2MVd1TlF2SWsrNEZCSDFxMlBOYlpLL1RyeHhuMDRvdXl1YUhMWlh1dDJhTjNJRnQ5N0RPT1RnVmcyK3FiMEt0R1Z6eno2VjBjMTU1MGFMZ0hDNDZWeTg4MGNVaDh5UEFHZXRNMG0xekpxZWx1eDBkb24yZ0JnR09lY0hvSzBkUm5pdFlodTlPTUxYTVdlc3daS28zSytwNkdwZFF2NHBzeHVvd1BmbkJwR3FxVS9aWGpKWDc5TG01WVBiM0FMb01kL1Nya2trc0xiZ3VRUDhBR3VUaGxTTUZVR0Y3OTY2VzF1N1dlTm93M3pEcVBhZzBweXZHMmlmZnpJSjVvcFlOektNNUhUajg2dzQ0R1dWbUF3TzJPYzF1eHdNcjdTU2VUMnlPS1c3UmxBQVFndDI3VXlHbTd0clk1V2Y3VXpFZ3R0M0h0Vkc0KzFveXNEdFBVWVBQNFYyTVZwT3NTUG41ZXZIUEgrRkcxSGZHZWNua0NrWXVtN1hiYXV6a2hxTjlMTEhFSW1JN3QvVTExRnZKTXBRQk9DT2VmZnJVRVJFTjJSd005TTFwVFhCSEEyWkl6VFpVSTh0MjZqYnVYMHZJTGFRRFlRU1FlblNwSnJ1SXlxU0Jnam9lQ2E1WnBWTDcyWHA3MUhOYzI4OHlBa0Fqam1nMTlxck5YVytoMTk3SmJlVUF2M3ZyakJya0hpdnBYSnlTdTMvSnFhVjR3RmJ6Rkl4MDlhU0RWdGtuekpqdVdIcDZVOTJGU1VlYlYyOUMwdG1JL25MZk1BUHJrVldobmtlYkRBOGRUN0dsdXRRWGtqSTQrdWExZE1hSnlXS2hlZVRqQjRwQ1RpNUpSWkZLemlSQ1dKR0swb2RTUjVFaUtrOGdacXZlNmNHUG1COERvUGVxbHZDZ1B5cmh2V21qZTg0eTlYOTVzM05qRVYzSGtWeWF5cTArMk1ZSVBVanFLMjViMllSc2hpSkdEMzcxQnByUXJLUXlMaytuT0tDSmNya3VYVHVFc0w3NHlUbkhQSGY4NjdCNFFiVUFZSEg0L1NzaTd1RWpLanIySFByMHpVY3MwMnhYVS9LZXZxS2JacEZ4aTU5VEdTeVpwUG5iMnhqRmJrVU1DN2czT0J4MzZWaFNYWnprc0J4MTljVTZDN2puWmM0K1plR3pVM1RNb3loRjlMczNVbnRwTXhvU0NPNDlmOEttV0xCT1NjK3ZZMXprd2h0WnhJb0JKSHIxTlhZNzBTc0NWSUdCbi82NXFibXFsZHRTdGUvUVc4bGtVakJQQTljVnpVMDRlSmdDY2djSDByb0wyL3Q0NFNXWHQwSHZYUDJlbzJOMDVDOE1UemtZcHBNNWE3Z21vODZ1K2h6Mm5XMnN6M0w3M0lRRTQ5SzYyTlBJY0s3Wko3SHJXakdWaVhlanJnam52V1JkQjJ3ekE0OVNPMUxxWVFvK3pnck50M3ZkdTV1UU1zcEM0QTNkTWMwNmEwMmhtR1NlbWVwckR0YmhZa3lxRVZwMitxSzVZTmtmWGtrZTFCMnB3MmU3S1hteGxuREVudGdEK1ZPZ21GdVMzekJSL2VIRmE0dHJlZGd3OXVRYXpiM3k0Rkt0dXdSejNHS1pEaTFIbTAwNmhIcUZsY1RBTW85QVIwQi9HcmwxcGtEdWt3WVlIT0IvbnJYSXcvWkZmSlhhVHg2VjJjanNrQUM1SzRHTy9YdlRNNE5UVWxLejY2RlYyUXhmdTg1QTZVMlM0UmdBTWpBR0JWRHpYVGpwejIvblZlU053UVMyQWVudlN1UzVTYTI5U2U5MVNGSThPQTJDQmpQYzFWbGtra1JUSHVIcms0cktYUzViaTVPNHFSNkh2K0lydFlJSWJkQXJkQnp5YXNpbjdhbzVjeXRIcDNNaUc2UkF1NlE1Njg4Zld0aE5RdEowQVVqT09CV0plMmx0SzM3czhkZXVLcDJXbUlrb2RwTjNQeTR3TVlxUTVxeW1vcEpxK3A2VmF1c2FMeVJrNS9LcTk3SEhOSGtrQU43VmxYVnJlR1BNYkVjZHFwd3JkQ01DUUFrQWNHaTUzT1RTY1hGMjc5QzIwY01hSVhHQmpIVHJWZFpsRWcyZzl1bFdHZU9UOTJRTjJLb3NIdDJiYnVJNTk2UmszYmJZWktKbGtERUU0NzU1clBrM3UzeWc1WEhGZEdKME51R2FQR1Z6ejJyT1YwQkpCSEpBeDZlaHBtY29xNnRMUmxLS04ybEs3c1pHY1k1NDlLMllJZjN1RHlEMzkrLzRWUmdScGY0aHVBT0RqRmFVTThVRE1Yd1Rucm1ob3VFVWttKys1bTZocGF5SEljZ25GV3ROdGxpR2QvWGpORjVmUkpLcmtuR2VhYkhkeHVoTVpYQkh5anZta09Qcy9hdDIxTE44anlSZktCZ0E5UHJYT3BGKzZaY2tIbmtWYmE5eGtGc0grOEQzckhlNFZUbFdJSUhYM05ORVRsSG12NVdNeExKbXV3N0QyNmRSVzdjNmVCaGdNNHgzL29LUzJ1aksyd2tGanh1SGF1blpFUkNXUHpZSTRwTmlwUWk0dTJ2bWN1SE8zYkpLVjJqQUo2Wi9DcmtFVzBaRW1SMk9PcHJBYXdhNnVRUXpScUQ4MlR4WFl4MjBTTHNMNTQ3bk5Bb1JrNVBUVG83N21hOGFNVlg3M0p4NjF6OS9iVGZlUnp4d1JuMTcxUXZwYjFiL0FHeE5sQjBJNy9XdW9TMWtrZ0pJd1RnOWVhZGpOd1UrWlcyWm14QlJiaG5rSks0NFBUbjFwOEdxWXh0QmJEZE9ncW91a1hFUmtCWndEbkFQTmRCYVc5ckV1MDR6akdUMzlLVmlZS3BkSzNMMzZtVFBxa1R5eGhWMnNQdkhOZEhCRUpRQytEem44KzlZOG1sd05LSkZPRHprOXEwSm4remdZK1lqSFFkcUVidzUwNU9RKzdVSWNLUHlISXJQa1Btb1V6aFNCZ0h2VXIza2JINWxZRThrWjZlOVZzeDdTUnVQR2VNWkJwMklsWnZSNlBkR0haMm5rU2tiMU9QNzNVMTJhWFVjYWtmTGtqajM5cTRxYVYxbU9PMkRodXYvQU91bHM3c3ZMc2tJejJBN2Q2R2puaFZVRnlwVzFzZG45c1RmOTNnRVkzQ2trSG1JekZXSEhidnpUbWlpYmF3QXhnWU5RdkhjcXZCSTZVSGQ3MW5wZGVSeGw5Y3l4emNxV0hwK3ZGVy90UytXaEpBK1hvS1M4dUpWbVJjWnljWUlxY3BFeFFlWGs5YWR0RWNDaTNLZHBiTmFORlV6UWtoaVNDQjI3VlZtYTJsbEFiNXM4OWVoL0N1c2ZTNHZMVnh3ZXZOYysyblc0bFptNHdlbjY1RkpvSlU2cVdxVDFGYTNJV1B5UWVEK25wVmFhMG51TFp3R09TTUVuZzFvVDZwRGF4NXdPZS8wOXFTejFHSzZUY0hCSjZqcGcwMHVwRDlsemNpbHExcWp6RzJzTDYwdWlmTVlxSzdKWmpLNnF3NUNuTGZYMHJYbThvc1NXd0J3Y1lJL0duR08yV1BlZHZQUWs0NjhVNU50bVZLaEdDY1l1MGQ3TXJ3V3NrZTFneHh4bkh0MzVxekxLeEFBSUxBL0tmOEFQZXJVQmNvTXFSMnlPYTBJcklPNUxESUdNajBOVHFkaXAzdHk5UzNZbGpHQ2Z4N1ZxU016YnNEc2NaT0t5NVhaU3ZsNHlPTWZTcG9MNVE2aHdleEp4NlU3TTdZU2drazM4eXRhM0Y0SkFyS1N1U01uK2RYMmFXTnZ1RWRja250WFVPMXFJOXdUSEdmOCs5WVYzSWpRRWpPUlZIUTRPS2Z2MzZtWXF0Skx2WTQ5T1AwcXZkUnhGOGhnRDE5dm9hSVoyS0ZkNHdPd0hYMnBQSVpwRGtnZHVUL25pcHRxWU96am9yNms4Y1psQnllL1h2Z1V5WlRDdVZqeVNlY2NHcTUzeE1QUVl6MndLMTBtVUpsd0FlT245S29TU3RiWjl5S0U1aGJjR0JKNUgvMTZwcElJMnp0NDcrMytlMVBtdnJmWXd5Ri93ckhlN3M1Q1ZKWUhHQU9tZmFuY0pTakczdks1dUlWWWxnQms4L2hpcU4wUmduYmtqa2RxWmFUckdtRVZpQVByK0ZWWk4wakVLUmpwU0pidkR6SnRNdTVjdWRueTkrMkJWalVYbG4yWWJCNE9NMVJoZ01PNXRoeWMrMUVWd3hrYmdIbmswR2ZPM1RqRnZjbWh0U0lBTi9QVVpPYXJMcGJNeExFRmNqcWMxYWxTYVNRWUdWNmJmODk2MEd1VmlHd3JrWndRU2Y4QUlxaTFHRFR1dEVNU0h5MlB5cU1ET1JWZlVJMUFRZ2RlK0swSGxUeWdTb0h5Z0dnZVRQSGdaLzhBMVZKYlViV1h5TXUxdEhhRld5Tm80NlUxNG9rUnp4dUhKWE5kRWtLSkdRRkF6MDQvV3FKc0JLckRibkg4UXFrVDdQYXlPV2huZVJ5cGp3dVFSK0ZKS3o5UmtBZHdEd0s2Q3pzWVk1V0J6MSt2RmJodElpQnp6ampOU3pMMmNtano3N2FWa1FieTM0YzQ5NjdhR1dIeXp1NXp6bkhhbmYyY055azdBTUVkT3RUUzI0UUpqNVRrZktPaG9OcWNLa2J0djBPYmtzejlvREsyUVR3QjZHdGxMZVQ1TUE3dW1LMTVFVklGSUFBd2V0UUZBNHpuR2Y1ZTFGaS9aSlB2MU1HWXVBVnpoaWVudFdsYVdjMjFqdEFCOWVsU2ZacEFjN2M0QjRQWFByWFN3QkJIdHh6ajE2MERqVFhOZG5PdnVpeUMyTTg4OXhVbG0ySkdjRUVjWlBhcnQ1YStieU9tUm42MDZHQllnb0o1SVBIYWhJYWpMblhaRU56SUdRTG5JNC95YXlybDI4dmFjbko0UFVmcFcvTkVDdkRmWEZWSnJCY0JnTUQwSGZpblpqbEdUdWNWTGFYRElTRkpYZzhldFFXS1hVY2hWK21lT2VhOUdDNFFEcGpyU3pRSnNCQ2pPQjBwV01IUlhNcEtUME9RdklFY0JzWkhIQi94cm41SDJEWUNPUjNycTd1M2tWZDJjRTlBT2VhcXhhV1pWeTIwL3dDTlV0Z2xCeWxaTFU1SFlkeEFUa2NtdFpOTytZTVZJSkdhMDQ5TmRKT0Y3OWM5cTZUZUFwVEk0SElOTzNtWnhvcHQ4eU0yR3lUTzFzRURybnVhWmZXNmdLQW9PUnhqaXQxRlJqeVJ5VHhuRllHcFc4eEh5Wnh1ei84QVdwTkhSS0NWTjZHZEJickVyWXlCeWF6YmlEejQySmJhTzU3KzJLM0xaNUdoMmxlTzNyeDdWVnVJcFZqempyN2Z5cVROeFhJbGJTeHpXbVdVeXovTG5JSkk1em11cXZMYVlJdVNEeDA5ODFQcGtiSUR1SDZjMXZ6dUdLcnNYK3Y1MHgwNk1GU2EydWNiRS9HSEFQSS9sVmhyWGREdUgzdVNPM1d0V1V3Z0VFY0VmNTZWblM0MkFLcE83K0w2MGg4aXRaNjZITlMyelNOamRnNUhHZXRTeTJrNFZpbzdjWjllbjYxVG1sbWpZa0FNVHhqdldvWlptaXllUGw0R2Mwck00L2N2SmEzT1l0cFdqa0dDYzk4ZE9LN0pIQWk1UHZucml1ZWpoY3V6N2M0R0Q2OU8xUVNDUndWVlNPT2NkNkxDaGRMN3pwdjdUZ1FBQUg4cUs1TzJ0SndUdjZkbHhrajhhS2h2VTJqVXEyWFFsdEZqaFl0em45ZnJVcVNSeTVia1lPVG52NzRwNG1pWUJmS0pIcWVLeDdtMVVTYi9BREdSVG5QSkhGRjJ6eTJ1V0s1VmRMNUhYbysyRWhEbkhUMXJKZzFBK1lvUUJnZXBIR2FaRzI2TWhaczQ5QjFxZlRVamlaejhyTms0T1A1VktOMUtUbEJKMjh6VG1tVWN1Y2RNZzl4NlZ6OCtzcUpzYm1BQkE0R2Z3cTZ5aHBOenNGVW5HUFQ2VTg2TkF6ZWFIems5Yzl2d3ExWW1hcXlmdTJOMkM1YWFES2c1T2NuUFVVNnc4MkpqdjNEbmdWYWlpRVVLaGV3UFQrZFRFVE9GM0hyeDZFVXpzakdWNDNidWw4Z2xsZGdNOERCeG5wK05ZanliR0JLL3c5dnlxdnFiWGFxQ0RnQW5KNm1xR25YTXNpYlR5ZWk1SEhGSVRsNzFuZTVwUTY0c2N4VFlxK3ErbU85YlVHdHdzWHdBRzlCWEt2YWt5bGpHRG5Qell6bk5Zcld0ekZJR1VrZWdQVElwNkdIdGE4WDNTYjZkRDAyQzZMcVF3M0tlUWM0NlZGSTlqQ01wdDNZejZWeTF0SmRNbUpGMis0UEpxMS9aalNqZUN3R2M0UDVVWE5GVWxLS3RHN3QxUnZwZm9vQVk1NUdCVkNmV0ZFaXFzZjN1cDlBYWZieFFwdEVvR1FNYzgvbUtTNHRZSkhVSWk5Y24zcEYzcTh1a2w2ZFRVbHRiYVZVWnVDZXg2blBOUlJlU28yNTY1NmYwTk5rbGlUQ3MrUFFmMHJDYTM4MGxvNUJnY0RqR0NmcFFYSnBTVmtyOVRxSVlvWXlYSUp6emd0VVMzRnNaTWhCa0gxOVBTczlsZU5DT000Mi9pS3lvakxIS1Nja0U5aHpReVhVdHlwTHJxZHRGZFcrUnZZRGI3OG1wSnIyMFlHTU1md05jM0ZiaVNkbU1oVlQvQUE5dmVtWEVkbENDMjlUMTVvVE9qbm1vTjZHMUpHbTNPN3FUK05SeVNvMGVCOTREc2F4SlhkMEhsblBiRlpkeDlvaWp6dTRBKzdqMnBjeHp5blpQM2VtcGZodW92dEpRazdpT1BmOEErdldydko2NUE5ZldzS3d0STV3WEFQSFlqMTlEV3Q1TEFzQnh6akhxQlR1WlJsTzMrUlpVQlJrRURHZnh6V2RxTjFPcURaampubnFCV0JmeVhzYzY3STJLSHFjOVByVzFERkpjUjR3cFBwaitkSmRBY3BTNW9xNkpiVzlqOGxWSzUrVTVyTkFnVzVMbU1aN04zSDFxczF0YzJYSVFOODJNSDBxNjF6SUl0enhyenowNS9HbVFyN1MwYThoYmk3am5pSTVHMzlQZW9vYitOUDNlQVFSMXpucFhGd2lXYTVMRk52dlhvTm5wRUxLSkFBR3orbnJTWmhSbFZxdHVLdHJiWHNFb04waFJsQ2pzQ091S3lVKzAyVDRqSXhuajBOYmNoZU80QXhnYzlxNWZYTG1lM2l6SHVPZVJoY2dFOTZFaldxMUZPVHZlUFZibmR3eWxrSG1kTURQYitkRTEzQXlCRktqR2NDdlByZSt2SkxkVEltMUNCZ3NPK0s3aTJ0N1h5RmN5S2hQUHJpZzZJVGxOV2oyMXYyS2Q0U2taOHBpV0k2RHZYRnhhWnE5N1ArOGNxQ09lZXByMG43TmJqWTZOeHlRQjYxWnRMcnlYYmNneG5yanQ2MDB5SlllRTJ1ZVRYa25vY0pMcFEwM2FTUHZmZU9PcHBYRWNqSXhUbkdmeHJ1NzIvczd1STdnb0s5Q2E1NjFhM25CUlkxR0QxN21rMHdkS21yUmhKV2V4b1c5a3VOMkNlZWUvK1JWcUd6amdsM3FwT1Iwem1yaVNDMGhZRmhqR1R4VXFYOFFBY3J1R0J6ME5MVTdveGdrcnUxdGZRc05JNGpKakJEY2UvU3VHdWJpL1ovM21QYmNNQ3VoazFTRnBVWkJqSE9POU96RGRFaFdVbmtrZFJrMDBLVW9UVFNuNlc2bXZZM0cySlF3NjQ5cXIzaXdJL21MdTllUFRwV0xlSmM0MmpqSXh4eDdWTkhFeHQ5cE9DQmtIT1JVNmx5azJ1VzIzVmsxM3AvbkFTSXdPT240MUNnQ3NpcytEM3p6aXRMVDJqRWZKQnh4eDNyQ3ZYaFM2Vmk0VUQwNXlCOUtyVXlrNHBLWFY3Nm5XUjJGdDVPVDFQcUt3SnREaW1QQzRPZUQ5S2tlV1RZQ3BKUE9EbkFyU2dkb29jeXlCZS9YMXBsOHRPYlM1Tk9wNTNzZTN1TmpFRUJ1NjhnVjBmMmlHUk51d0FnY2ZqV1hyaklaRWVKdHh6emc0elZabHVXS2dEYVRqSGY2ME01N3hoT1VVdjZaYWVRUXVVTVpmSXpXcENXNEtncWUvUEhyeFNRRHk1RkV5S1IyejJxQzh1SW9YQlZTUmpKN0FlMUpBMXk2MzBYVHNkQXR5UEt4bkpIcUt5eHF5S3hJUTk4NEhlb1Z2VWVQNUZLbHU5WlBtbERsb3kyUnhqQXgvOWFtYXVxMDQybDg3SFhpOFdTSExMZ2tjamJqSHZXVThRVGE3Tm5kengwb2l1V2tqQWRkbzZrNDYvalNUN1pZY0JzbkhRY0FVYWx1WE1yM3ZvTE5jc3dCQ3FlbmI5YTBQTmtlSUtNNDUvT3VQdG9MdExrYjhiQVJ0SjlLN2lSVVdFTnl3SGZPTWZsUXlLVjVjemQxNU13ZjdPRGdoaDM1enhtcnR2cEl0b3l5dVNRZU9hZk5md3lRNXljanBrVlJ0YmlVaGczR2UvVVVrdEFhcEtTMHUzc3pIY2FsSkt6TUFWQjZZSFNwR3VwMGpPRkpIWDIrbGE4MnBXeWdJVHdUNlo0UFQ4S2tqbFF4REFERGQwbzdhRUtLczdWRzMxMXVWN1FKTkdwbVQ1VDI3SDNycDRyTFQvTEpTTUx6MkhwVktlV0dPTUhhRDZjL3JXUkxxRzRFeGpJempnOS9lbXphUExIU1RUZGpSMmlNbFFSajZmMHJXVVE3UU01M2M1eHgrVllOcGZvK053QjZqSTU1clhFQ3l0d2NBalBYaWthUXQwKzR4MmpoRWhWQ01zZWxRVFcyd2tnYmVPNHorRmJVdW1Na29sRDR5S3NTV1Z4SWNxQjB6eFJZaHhscXJhbGUxZFlZaVd3RC9BSjZWbTZoRTl5Z2FNWklQT1R4aXQzN0NyeDdYUE9lTWV0WXNsMGxyTXNaR1J6eFZXWmNyS0NVdEYrcG1DRVBFVWNmTVBiRmFWa1VDaFNSbnYzeCtOYWp4eFNLckszYm5IclhQTGF2SE9YOHhnQVB3RkJpMDROTzEralpldlZXQ01TSGdnZnJVVm5jMjkzSGhTY3FjSEo3MXBUTkJQRW9CeVBYdFdkSFpRS29hSVlJUE9LUXZmOW9yTmNyV3FOR01ORXh5QmdIaytsWWQxUEEwbTNjVCtGYUYxY1hIbGdsQVQzUFg4NndER1RHWk5tVGdubjI0NHBGVGs3Y3RoWklKWENpUE9SM0JxSHpMaUFmT2MvWGpGRm5OT2h5MERFWjY5SzZDNVcxdTl2R01udjJOTkl3alpwdE8wdXhrV0dzM0VqRlJrYzhaT2E2aERMSWVUbjlmenFpZEpndDR0OFczMXdwcWFGcFF5OUFCeXc5UlRkcm0xTlZWWlRiWkxLa1htQWxjTjZqdldsRHZJQUtaQTlLNVM3dTNGd0ZWUVFldURnL2xYVVEzcXJHdVZHY2NkalFiUmxGemF2YTNrWjk2WWxKVjMyamtIdmdWenJORXB5azRZQWNjZGE2R1dTSzVQN3pjQ2ZUdlZDVzIwK0NNc3NtVHprNDUvQ2gyTXBxOTJyVzczMU9hM1hiVGx3M0I1UEg1VmZYZlBOempqcUsyN2E4dGxCd09NY0g2VlN1YnhodjhrQUU5T08xSXdqR0hLMjUzdTcyS045SEprWkJ3UDd2cFVKbmtpai9jeC9OK0JyWGl1blNETGpQMXBuMmlCWERKR01kKzlCbzRKYXFWci9lY3hEZE85enRud29PT2NZNXJjdlZ0clpWa0F6bnFNOWF4YjhUWEVxT3NYSXp6M3pqdldyRmRJWTlrc1dTT09QU20xc2NsTnYzNHQzL2xrMGJHbXBESXBsWDVXNTQ5YWh1aks1WmQyQVA4NHJJaXV2bktScmdEdm5qOGEyWkMvbE8yQWM5ei9TbFk2bE9MaFpkTjdkVEN0ZHlQOHJIcU9weUJXNzg3RU52Nms0OUJXSmIyVXVHWXNEbk9PZXZibXNPV1BWVm16R01LQ2NnLzU0cHJmY3hVcFJncnhrMTVIY2VZVUdBb0o2bi9BUFZWSnJsMkl3b0JKNms4Y2Z6cllzbWdlei9lTU40QkI0NzF6MGtrY1UzSUdBUHJ4UXplcGRSaSthMXpyRWRqQUEzVTlqMC9DdWNsMDJSMnlHeWV1QjIvT3RaYjZNS28zQUFjZ0VkcXRSWGx0SVJ0NjhrRUhyU05yUWt0WGV4VWdnbFhDc3h4dXdQWGlyV3B2QWtCenljZGU5RXN6QmdWR2VSalA4Nm1Eckt2NzNvQ2NrK2xNdUtqeXRKNnZ1Y1hIYnlYTVljQWpvT2EyckcxU09QOTRPbWNBZFByZzEwcGVNZ0lnSGJ0VWMwYkNJaGM1ejBwYW1jYVNpNzd0SEczbHJDMGdCSUFKSFhxRG5wVk0yU1c4Nk9yRHNHd2MvNUZTM01WeTZubmEvSEhxS3BReXRiRWVjTWdnZGY4OWFOVGhmSnpOdUZ1dDMwT3lra01pQUtNWUE1OWZTcXhua2lCRG5yV0hCcTBNcnNWR0FPL1hOUjNGMUhJeWxHQkpCNTdjVTlqV1ZlSExlTWs3a2s3U3E1TzNjYzhHcFZkSmVXWGtFY0U0UFR0WE14MzZMS0ZZTVFjZ1o5ZjhLc0hVVzgxVVdQNVdPZWV4OWFmVTVZMW9wWGN0M3NkekdUSXUwSGdkTUgrZFUyalZDU1QwNjU2OFV5MEpYSndNSEJ3TzN2VDVMeU5XeElnWTVQVDBwbmR6cHhUYnNMRGFhZmQvSXlqcHhrSDlLekcwcExkdjNRVVYwVmpkd1BKaEFSOVIwejcxdlMvWnNiaVFSMDk2R3JJdUZLbkpYOTI2Nm5sUnRtTGtoaUdKejdHcGhaM1VnSmtDSEI0OXE2NTdGcEh5blE4ODg1OTZ2d0FRaGdRTTR4K05LeGlxR3V1aTdtVGJJRnR0aWdGZ09Semlvb2J0UHV0anA2ODByVGJia0tGNEo5TWNWV3U5SWRwUTRVQmU1QjdDa2kzZmw5MVhjZEdqSHU3cVVUSVV3d0JJT2V0WEdjU0lTM0JBNTIvV3RzV3FSbkpHOGtkZld1ZXVKM0V6RFlNRDA5S2R6R1VPVzk1YnZZMjF1cFhpS2ZOeDNwMGR0S29PNXljOUQ2NVA4NnNZamFBbENDMk9SNzFteFhkNGlBUDBHQmpIUDhBK3VrbGM2cnBXdmQ2Q09HallZQTY5UWNWcFcwSkpMc1NSMTU3SEhXc2k3dkxSVURNNHh1N2YwcTNIcTl2NUkybmRuOE1EME5ON0djWjAxTnB5WGMxNTViZHhzSUpZK3Y4ODBSV1lkY2c1ejE3OU8xY2sxM2FtUlNDeWtzT2ZyWFdXbHdQTGJEQSt2YWpzYXhsR1V0V21ZZHhad3JNTXNSeVB5NjFESll4U3VtMGdrY2dkTVZ1MzhDRldkZVJuUDRWeGNrLzJlVGRrOGRlYVpqUGtpM2VLdGMycm1FUXc1VlR1OXo3VWFjR1dQY3kvd0FQNGlwRGMvYUl3eTdRYzRPVHpSR3JGRlVnOURrNDZacG1udTNUWGJRM3hkeEdEQkhRVnppeXhCc3JHcC9sK0I5YVlzTXVXM0tlZWNub2UzRldvNEYyc0NwNEhHQi9oU0J5azdhRitLOFRKSVVFZW1lbEpKQUdjOEVuajI0cXJad29aT0JnZEIzNit0YnQxQ0FPRko2ZlhOTXFMY282bk02azZ4d1lIR1NNRWRLazB4Mjh0OGpHNzhxbmxnU1NNRmdjRGdqL0FCcDlzeGlZQXFOcDVHVFJmUVhLK2RON0d3TjRQSUJ4Z2MvenJjZ1ZkdWQyQ0IrRlpxeXd5Y0ZPM09PZzdacWFTUVFvVGtIamtuMG9UT3VObHJmUXpia0dLWEtIQS9ubW9XbVpSbko0UFVqci93RFhxdGMzcTV5UmtjNHh6VTl0S2t3TzFPZy96MW9PZHRPVFNlcHNvNnVvYllEeHlTY1lySm11TW9WQ25kbmdnWXJkVzJTS0U3c0hQWDJySElReWdqQUE3Vkp2TG1TVjlHUXhibmlPU1R6MHA3Q1ZGQlhsT3hIYXBHREt3QVVZQkZYbW1DeHFjanJUTXJiNm5GWGx4ZUlWMnNjbi93RFZWMjNrdkNpbGx5QVBwai9FVmJ1cGNzQVh6K0hURlZZcm9JY051SHNlK2FUT2QvSDhUc2EwczB6b1ZBYkpyTWlXZmVjeU53ZTV6OWFxRzRjU3Jra1lPZlU0cTlkaVlORzRVWTY4R2pWQTJtNzY2TTNZNXRxNExBa2RPMUliMHN1MGpnVnlzdDdIdFVPd1ZzODgrOVhvNDRwVkcxdUNlM3IrRkYyVXFyYnNqb1Z1RmpIemtkZXA2aXIwZDVielpVRUgvQVZ4dXJXY29pQTZEUFdzVzBXNWpRY2dqdDZpcjZHanFTaTdXMHNlb2lGSHhrZm5WSzVaWWNCVjQ1K3ZGY0IvYWx3c3dVcm5KNHdjR3QrVm1lSGNlUmpuSHJUUVFyeGxleTFSb2ZhRlBCNjV4U05iT1JrS09NWTQ1cmxKZDJ6Q2h2WG4xb2gxV1dOQXNpRUVaSDFxZGJrZTJqZHFTNmFNMzRqTHYyN1JsdU92V3VpaTJQamZrREg2MXdhYWt2bkRBT01uOERXMDkwd1hLZ0FZSkgvMTZhdVhUcVF0dmMzcmhJSTJKQkFHT0JXRlBkeG9kdTBjNXFtZFEzRDk0RUhyejFyazlRMUdHTWxqejBCSFU4MGZJaXBpSXBOcHBJNnByZ2JTUm5PT1Q5T2F5b05RM01GNUJBeHlQWDZWbXBlRVJiOHNFT01namtjVmkzRjJmUFh5MVZ3Y01lZWNVV09aMWt0Vkw1SGFLOGp5OHNNa2REM0ZiS0lTdWR3OVRpdVBTUXlLSEEyakFQU3Voc1hWdXZCeDB6VW0xT2QyYzdxVVRpUlNGK1VucjZmVEZRUlR5dEdxcUNjQThrZGNjVjAyb1JLU2RvNms4aXJWckJGbkRxT0J4Z2V0TWwwMjZqczdiSE1ZbVJCbEI4M0JJcldnWlNoWWdZOXEyN3VFQmdvVUVjWkI5Nm95eFF4cXgyZTV4eFVzMzViUDBNa1J4U01RdzNkL1NpcW9sZVJtS3cvaDNvcWJtS3MxdGY1RzViMmtRWmxZWUpKUEovclU3YWJBY28zZmpyL2pWNmRvSGxKM2JjSHBVTjByWUcwOU8xUFFYS3VWcTE3SExYR2h4MjZOSkUzdndmU3FPbmFjczRMZW52d2Z6cW8rb1g0bk1aaS9kbm9UejBydGJFcVVBQ2hRZmJhS1RPT0VhVXFsbEd5WFR6T04xTFFwWm1INzg0SCtQZXVvYTJXM3RBQmtsZWhIWDNxZTV3cktBY3NUMDZHdFNOQ1lnU0JuSDQ4ZDZHM29qYUZHbXFrM0dObTkyWU5wcVVXMXR4eVIyK3RXTHpVNFdRYlZQVWNEcmtWU05uYks3Rm42NS9Dc3A0VWlMTXlISDVta2FKMUVyT3c2NWRyd0pHT0JqQnp4MTlhclJXa3RuS3FwaHM5ZS9GV0xaN1oySkdjK3VmVHBuMHJya1JTVlBIdlQ2R01WenR1K3I2bVJJeitVb1pTT1crNmUxWk1zeXB0QmtBUEdUbkk1OWE3eWFPM21oSzVYUHBYbVY5b3hsSVJKU05yQW4wb1ZpNjBha0Y3cTVuYnVicmh3RjUzWnhrZzgxc3hYVExFRTI1NCtuNTFqVzlvMFVhakpkbDZIUFhGYlVNYnlLZDJPUHpGSWRPL04xdStoRy9sRmxMcnRIdWFiZFN4eFJqeXVUNjlUbW9yblRKblhkdVAwelVjQ3l4QVJ5akJJem4xQSt0QmI1dVpybHQ1allyZU82T1hCVWtZYi93RFdLMy9za2R2R3UzcnhuaXJFc0JTSldpSEdCMHJHYTd1MmZhWXVNZ1pIQnozNHF1Z05SaTlWcjNzUlRzbkF3Y25uNmQrdE8rMVFoUUFjbnVNVWdRU1QvT3JBbnIwejc5SzU3VkRMSHhER0dPZURqSDhxU1dwbkp5akdVa1QzT3BCNDFVS0RuakFQYjBxTDkySWxFZzcvQUpEdFZYVHJHNUlWcEVBSU9UeHhpdEdXZUdlUVI3Y012SnlPL3dDbERzY3FjMms1YU9XeVpORzhDUTcxQTY5anpYTFhsMWVTQUtnVmhranJ5UHBYb3p3MnNOdmhoeVIycmpEYU5QZUtRTnE0eVQ2NTYwcmVScldoT3lqZlYyMFF6VDlYRnJ1M3NPT3VhMEYxK0NjTjVYVXIyOUs4KzFQdzhpM1RsSjg3c25nY1VhZG9jbHZsbklHT3ZQVUdydEh1ZWNxMkxqTng5bXVWTnE5ejA0U3hUV3pGdUNCZ0FjL2lhekV1cmxaUWthOXdNOS8wck1XWVo4c01RUWV2ZkE3YzFsYWtiMjBsV2FQSkczSlVIT1I2OFZOaytwMXlxUGxVdGRMWGFPenZKNUZWZk9jWkp4dFBJcmo3aWU2V2VQRGIxUGIrb3JqZjdZdTcrVlVsZ0lBSUpiT1Q3NHpYbzFoWXdobDNTOGM0ejErbEZyR0NxeXIzNU5rMXJjcnh1MFozN1Jra2tEcFZxeTFPNkYyVjJmSzNJSTkvNlY2R05NdEhqVXFlY2RNVnl0MWQvWnJqeXpGbHVtZW1LTnpxZEtkTnhmUHlxL1FyNm5xYndnbDFQVE9mODk2ekxTOWhtdUJ1QTJsdlgrZGRINUMzeUVUQmNBZXZZZHE0UFU0bXNaQUl0eWdFOUY5cWFNcXNxa1pLcGU4ZnhQUnJ1K3NJa0FZcXE5QzFjMGt5c3VZSkFVSFFEbjYxejh0c0xtMFJaWFVsaGtkdndyZTBuUnA0RUJESGIzQUdLaTJtNXBHcFVuUDRGeTlIMU5leTFhT01NU09nempGYkM2Z21wUXNzUTJNdWNISFUrOVVMcGJhSmh3Y25Cem11cDBtMWd3U2ZsenlkcDZrMGRUdG94cU44bDFicWVXMjJsYWxHOG01Z1EzQVlmL1hyMEN4TVVDQlN3TDU0NEhPUHBVV3RRM0tQaUJ1TTlUVkt3dGdrdTkzSExaeDNCcTkyS25UVko4c1U5SHUyYTEvYnRKYmtrakhxTTFRc3BMYU8zL2VrS0IwSjcvWDNyWXVtM2dJckVEcGl1WDFHMkxKdE9TTytEeWMwMzBIVmNvdHlTVDBOTEZyTnYyL1RQNjRxUFM3QjF1SGZlMlB5NmRxNSsxdDNNaklHSUNuSFA4eC9qWG9rTnJFaWdGd1JqcjBQNDFMTWFFWFVsR1VvSldmZnFZK3AzVWl4a1JIY2NjZDhFOTY1NnhrMWhyYzcwMjg0QVgxOWExRExEQmR2OHdJd1A0dTFaWjFhVnRSV0lEQVk4ZXRUMEhVYTlvcE9iV3R1VmJHamF3WFVTTzhoNit2R1BwVlUyaXp5ZWFHMjdUMHJxTHk0a2lodytXQlU0SUdjMXpWdE5KS0hHd0JmZnZUVnhUakZUVWQvSTBXbCtRREI0eG4vQU90Vk84aWt1UWl1MkFCMFBYODZpTVN1RktaTEtTTUd0VXNGaE9WT2NZQjY0elZJMGpKdTk5aklRS29VSVN3QjVJN2ZXdWlpaGlkTjdEYVFSMnFqWWhsY09kdUc5UnpYUUNXSm1LNEhCNkQzOWFPcHRUamRKdjdqbGJ0dDExR3E5TWpuSDRWcGFuYVFtMlRjb1luQjU1QXg5SzFKUmFzcWtER0NlU2M0eFdaY3ljS1RuZzhnZWxHdzVSK1BtYWQwUWFjWUZqSWROcEk2RC82OVhKb1lTMjhEcjcxUUxRU3lBN1J4M0hCck11b1hsazJ3dVNBZlVqaXBDNmpGS3lsYmJ6T3EyMnp3S0JqSys5Uktsa2lCODdtSFVkTTFqV2tFa1dmbkQ3YzhZNXJxQzFrYmM3emhoejdpbWk3dVd0b3AyNm5IYXMwMDZaaEFCenh6MTlxTk5rbk51cXV5bHVoSFRIMHpYUk5DZ0NuUHlIQkJIZW9aVmhqa1FLeDZZSEhIclRkakhsZlB6TjcyVnJrVWNVYVpMYzhuSTlhYWx4R3lrQmU1enhUN3M3SWQ1VWtZeVJpc1diVkFJQjVhRTU2a1lCQlAxcEZ6cUtEdGUybllzUVdVYzArV0p3RC9BUFhGYlFzbzRzcXJqQTVybGJQemR4TE1VWSsrVGcvU3RpNXRacEVQbHlrRWRCdXhtZ3dqdGRRdXhwUm1kbGR1T3d6VFk3ZFZKVW5BeHgvalduWjJVeUorL1l0Z0FIbk9jZDZ2cEVqUi9LM0hPZjUwSFJDRjBtMVorWmtpQ0xabEZVL1FZclNzWkRFV0pQUHA2R21yZFEyKzROMDU3ZE9POWM4MTFHOG00dUF2Ym5BUCtOUG9UZFJhMVYreHBUYXN6WGFvY2hSbjhhNmhybVJJbDJuZGdEb2E0TVhGbk9TVktrcjBPYTJyWVNTSTU0eG43cDVKb0lwems1djNyMzZvMjRwM2FSV3dNK3g5YTRyVjdHNXVKZzRVOThuUDhxNkdHN0t6WUtnZHNnY2ZuV25lVGhrM0x3QjFPTThVcjJadk9DblRldXpPZWhVeFFZWTRBQTVQTmFFRXNOeEdjTURrRUU5Ui9rMXgxL3FXNlFSb004L2hVbHZETEh0OHArZS9QTkhZNUkxcnpjVXJwTFU3QWFleVA4bWNIUEE0QXo3VTZDS1NNc0NvR1RuampHZXROL3RHZUlvc21CMDY5cTNUZG8wUllsZWUrT3Z2VFoyd2hUdm83V0tyVDI1UUIxOStuV28zVWVYOHFyMHpqdlVNRTF0TEtRd0lJQTROYU05dW0xV1J4akgxcEkwWE5KWDBZeUpJaWhESVBvUlhONnZhaVMxYnlHS3NSd3dHYzFxekdCRlVtY1lIdmlxYzEzYVI3TXZqUE5VeFRjWEJwMlduek9ZMDZXZUpDa3puN3ZyVlRkS2JnRUU3UWNESFA1MTBoRmhLY2hsK3RWclNPSlpwT2dIY0NwNm5IeXUwRXBKcGRiNmtMMjB3L2ZxZ0xBYzk2c3JjeXpvQ1ZIQXdBUld1THVOVjhzakE2WjZmblQ0V2h6dEp3RG5HTVlOQmRsZHVNdDkxNW5GM01NMGdCQWJDalBIMXBqd3lrYlRnNXgxR2MxMUYvSkJIZ0t3VUhBOWZyV2RmdjVVS2JHSjNlbnIwb3NjMDRwODkrbHJsdTJ0b1lZOTIwZXZUZ1ZjUVd4SHAwNkRyUzJjd0Z1Zk5CREhHZW5TcElURTdGZ0NPZXVPdnRWSGJHTWVXUExiYll0ZVZDVXd6WXg2L3pyRGx0bmdsRFlHTTloMnAwc3NwbEFVWUNubmowNzEyRUN4UzJpNzJCNHpRMFVyVGJ0ME9BMUNXYkM3SWgwNUg5YzFYaTg0eGhtajV4MzRydUxvMjhhREhCN1pIRlgxVkpZQmlNSE9NY1lGS3hDcE56ayticHNlVndKTWx6ekN5K3A3ZW9QMHJwWlpvazQzbko1NUhCcm9rdFlNNUs0ejM2MXp0L0RBazZqZmtuK1ZVUjdQa2cybmU3NmpZSUdJSUJ5T3ZVYzUrbFRtMW5SOEFrZlhrYzFZVzI4dU1PcmRPMmY1NHFxTHcrVVZJSjJrKytmV3AyTFNTdGRXT0x1STdsSitDMkR6Z2RqV2ZDbDFKS0EwYkFEbzQ2VjZHOGg0T0NWSFA1LzRVa1FqOHdrREdjRFBYcDYwWE9PZEJPV2szdU5sdFUreTg0NEE2amcxajJtblJybVRrQUU0QTZmclhYeXlqeWRySEk0NW9oa3RIaFpGWVpJUFE0L0dtZGZzMDMwMFJnelRKdE94Z1NPT2Fvd2k3WUg1U2ZiUEZTUTZheXlIOTZTQ1Q4cDVINFZ0d01sdnRCVUVONzBhV00wcE5weTBNV0c0ZUdiQkJISkdNMWN1cjY0NnF1NFp5ZWNWblhEMlR6N21mSGYzNHJXdUlJcG9WMk1DTUFEbnArVlNMMzdTdEwwS1gyMGtGM09BT21SeWZZMWxYd1c0eHRCT1FEbnNmd3F4SUFGMnUzeS9tUG9ha3R4YkJOcFlFWjdkelFZM2xLOFcwVjdiVG9nRC9BQSt1Ui9PdDJMU0xVZ01jYnNqa2RzVWtrb1FoUjZjSE5WcmVlY3lmTHU1N2R2em9Sb29VazB1VlA1RExuVDdiekZKT0R5ZW5VaW9IdFlIVk1SaHVPQ090U2FwRGN6MmplWHVCQTR4MUdLNHJTcnUvZ3lrK1NjOEU5L3JWVzBNWnpqR280dURzMThWanVvUWlqYW9JUHAwRlR5V3cyZ3NvQTZkY0dvSUZTUmxabXlXL2g2WStsWFhJMzR3YzlNbjJxVWJwWGp0NkJaeXBISUZQVWpudmozcVM3aW1aQ3c2WnhnRG1tSkc3eVlWQ2ZYK2RRWE4zY1JsVVpPQ092LzZxMDNORkwzR250ZlF6b3RUbWhpMkFGdG93UjM5TTVxUzN2V2xJMzd4a25HNGQrbGFqTlpOR3JZVXNPdnJrZGE1K1djeFRZWHVlL2JQZWtaVGs0OHI1N3JzYVY1TkRIc1pzWkpHSzZTRzloYUVZNDQ0SFhJOXE1OXJNM0VXVGdZQTcvd0FxeHhzdDVBcXQ2WTZVaTFVcVJsZHBXZHJIWXJPMkNEZzllU09sY0JxSG1TVEVMSGs4L05rNEI2NHJzVTh3eGVZaTVVakpxSHpyWWpESEhQUTlQenFyQlVpNXhTNXJHRHA4RTJOeGx6eU1yWFUrZENRQTRDdDB5ZWZhcFZTQ0tNbjVjSHBqdldEZFhVYnFHWGtkZ2VBUHhxT29yZXpqdnFhajZMYTNVWXk0ejFHRCt0VUp0QVdEYUEyUmc0SlByNyt0UTJGNHpSNVVnWU9DUUtkSnFNcnpDUGFUdGJyOWFyVW4vWnBSVW5CWGZVeXJxeWpqMlo2WkF4NjEwMXZaN3Jmc2VNOGVocDA5dDVxaFNCdUJ6NjVJcUNPZDRjcGtmNTYwaWxGUm03clJtdkJDTm9WbTNEK2xabHpwVWNpNFVENlk0TldvMzJ1TTVHN1A0R3N4NFovTkp5eFVjOXdCVFhxYnk1ZVZYamNyZjJjYmVObFJRU2NjRHQ2VnIyMXF4UUZtT0NPd3FzOHVUdzJjZGVtYTFvcnBGd3JTQU4xSDQ5cWR5WUtLbHBvaVdTMVlwMExZN0hxTVZUZFRIRVZJUDRERlhQTVlOa0E5elZuQmRCbkI3MGpleWJNQzJqS0Rma1k1N2V0S2I2TnBOcGJIUFRGYjd3UkdNOUFlTTQ3ZXRjNVBwRVR4aVFPZmx6MS94cGFtVW9UaXJSU1pLUkcyU0dQWHFEa2NWQ0lkek13VGR5VFdPR2FOUUFmVHRudFc1RGQ0VEFISk9jLzBwbWZNbXRUVFNSSWxHVklKSEpIZW9IZEprR0ViMHF2Sk92bGRCajFKNysxUXdQR3dKVWtEMXpRVzVhcGRMRjZPM2phTEJPZnd6V1cxemEyNHlDUXdCT00xcHl6Q05TRzlEMjYxNXRxZGpMZHNwaVlEMnpRVFVtNHg5Mktja2VoTHEwTTlyeEl1Y0VuQnJuNE5XQ3lmSzJjZ2o2MTU5WitIcjIyM1A1aFZUaklCT01mU3RocldWWTl5SGN3NHhtaDIwMU9KMThRNHJtZzR0ZmllaFNYWWZuY0FmYzljZFJXZmxtWTVKT0Q2NS9PdVUrM1hDeEE0SHlqQjQveHJhc1pWdVl5Mi9KNjhmcFU2bTBhdk8xM3NiSmtIQ2xzZnovR3ExN0tEQ3hYcjZIbnBVYTI4Nk9XeVBYSGFyY0tpWnRtd1pJUGVxVFJTYmVqVnJuUDJGM1BJeEQ3U1JuQkg4cTJZWlpYbXdRUm5qOHY2VThXOGR1N0tGd2M4OU0vL0FGNjM3YTJIM3NBNTVHZXc5S2JzeHFuSjJWOWVwNXQ0Z2hsUnhKRkpqMXl1ZXRiT2xPVlNNcjhwOXVoK3ZwWFd6MkVWeURrOS93QlBwVlpOS1dGRC92Y2M5TVVkRWpQNnU0MVpTV3pMa2t5elI0M0FFRVp4NlZqU2JVQndwM0Fua2NpcU9IODd5eUNRY0hQVHA3VnB6MmR4R3BZNTJuZ0dwTkhOdFBUWHFjVkk5eThoR3hldVFkdU9LN2JTeVdRb2NuR0RnbnJXWGFQbVlvUnlEemtlbGJDamJJT01aSDg2dTVGRldmTmU5M1prYzBKaGZBKzduNkRpc0xVSVVPR0trZXVLNjE1SUdRNytjbnVPaC93ckNNYXRrcG5qK3RJMHFSVFRTMmZReVZGdEhiak9BVjlDZWF2Vzk1YmhXWHpGenQ3OThWak5CbDIzUG5uK2ZyV1RIYjdia3FKUXdKNEI0UDUxU09WVGxIbHRGZGplZTZ0WkpmTCtYY0R6ejFxV1RTWVowSkp3Y2c1OUt3RTBtVVRxNHdRRDkzNjFzdEpLRzJwZzV4d092MTVvdnFHNmJuRDBIL0xGQjVaQ2xzOU8vcldkWjI4YnVmTlhISjZjQWdIcFY0UlhBY0YrUjA0NHJZQVZPRVFIQTVOTzVVWTNrdWxsYXhYdWJxMmpLeHFCNmNkZjFyazdoN2hiaytTV3ovRG5qUGYvQU90V2pOREhKZFpkZ09NL2o2VjFoZ2lTM1VqQjZjNDU5S215dU9VWnpjdFVrdTI1bVdNc3hqQmtCemoxNHpXbERkTkZKaHVCbitkUGlWcFU0SkozZGgySCtGVXRRdDh4c2NIZGpBK3A2ZGFWamYzb3dUVGJ0MVpxM056RGNFQURjd3dNNXFyTEhJOEpEQSt1ZTFjdHBVY2tNdzM4QTg5c1Y2ZUFreURhUmdrRDJwQlRsS29ydlI5amtkTXQ3Y00yK1hCQzR3ZTFGZEV0Z3lERDdCbm5QcitWRlJZNjZmdXdTNVRtWTd5SzlsT3hkdVBVWXlSVjVJcmhMZ29XK1Z1dlBTdU1NclFTQXJqazFxeVhseEZLa3dZTmtEanZRenlJMXFhMWJiYWFiYTh6ZGVLNGlNakZCbkhKOWMwNVoyV0FiZ2M1UHNPYXBqVy9OaTVYYUQ2ajByakxyVnIyRzZWVmlPd3NNZlE5NmRyam5pYU1iTlNiVDAydnVkVExjUkxJRHNMSEF4Mi8vVldmY1grcCtZcXBHQXZUT1R3UHBWdGRXaHdqTkJrOG42ZCthbHY5WVdPTlhqaUI0QnlCMjlxUzlCU2t1VjJxTmVpTno3R2h0MWQyTzRqb1QySHJXTEp1STJnRWh1K2VnclJzWlpOUXR0eklVd2NuSTUrbFZ2dFVKYnkrUXlucndEVE5uS0w1V3RFOW4zTSsxdFlVbEpZamNlTVYyYU5iS3VDMk4zcDYrbGNpeldiM0kzVFlQOFFQdFczSUlYYmpuQzlhazBnMHIyNWRQTWprMDhzV0NPUVNkd0dPbjUxWG5kN1pHSlhkL2R3YzRxL3RrNUNPQ2V0ZVlYL2lpYXgxSkxhYTN5R0hKQXlNNTQvK3ZUU2JGT1VJYTZ4dTdYM082c2RRVnNEeXVlaHovd0RXcnAwOGtsVGpucHdLNXlEVjRzN2lpakl3QjcvaFdySGVtVUZzRUFZNmlqb09Fa25ibjV2a1BsdVpZendHQUI0T00xaXl5cFBobitYSGZIUDFyVVM3aWVSaElNL2pqQU5SNmpMYWVWaUtKZHhIVUhuOEtMbE83aS9lMDdNdWJwZkpYWXhQR1FDT3RUMlhuYmp2WHAwSkZjamI2eEZiZ3BKd1JqSE9lRDBOYUgyKzZreEpFT0FlVG5CL0wzb0lWYW4zdTEwV3BydkxERGNaa3l2UEhhcHA1d243MUVEZlVjMXpjdSthTXZJakFqbWt0dFNralF4TWd4amc1NUlOQlNxcTNaUFZNNmFDK2VZRWJNWUdCeGlvemNhYXI1NERBOGtWaXRGUHRJRFlWczgvV3NUVHZEVVNTeVN2Y0Z2TUk2bnBUMHNSS3BWdkJLQ2ZkdDdIYlhiV3JSQm1VRUFISDFxSlBzOHR0d0FHN1k3MDliR0ZWQythT3VSM0gwcmN0b3JjUkVQd2M4NW9XeDFSVXBQVkphYW5tRnpiVFE1a1ZOeDlXenorVlFXeXU2Z3libDQ3VjZkZDNGdkRIOG9Cei9uaXVObUN0R0pBKzRaSkk5dndwSExLaW95ZHBYMHUwVnBkT2lSVElENy9BRnJUdG1TYTFDeVJqcnh4a0hGVnBicVc3dHdrU0ZEam5nSDhLd3JkcDRDc2Nzd3pqamlrUnpSaEpjcXZGclhzYWJXMWxHNEJqVDF5QnlLeXJ1S05WTEx1WDhPbmZOYTV0Zk1Ja1p4Z2Rod1ByVmRRck1OeElIVDZDZ2lTM1hLa25zUTJtcXlrS2pic2dIcjE0cmw5WHVMbWVRRk9pOGhzWS9YMXJvYm14bW53OFVtVVhxTTQvRElyTXU5UGU5dDFXRzRWWkI5NE4vS3JqWTRxdnRuQnhzMzIyVi9RdDZaZlJCRWpCWHpRdks4ODl1L3BXdE5iWFZ6THVNTGJCNmUzV2pSOUJheWlNenVHWUU4OWE5VXR0ZWdqc0NnaEc3a0hqR1BlblpQcm9lbmg2WE5DMVdYSnBkSzI5anlTYTBqamtWbFlxQWVoR2VhMDVOU0Zzb09OeTU0OXdhdTNEeFhvWmpIakJ5TUhrZHF3NTBpemc3ampQK1JVYUdUVGpmbGFzOW1NbHV2dEZ5aDh2QTlSMEgrTmRwRGNSS29WV1hnZndqQnJoNFVMdmphY0U5ZW9wRmU2dHBwQXlGa1B0eFR0b2FRcU9GM3ZkNnM2ZVc5OHh0aFB5aitwcXZjNmM4a2VJMkE0N25HUHBWR09JYkEvVG9TY2RqWFRKZjJRQlE1SHZqMDU3K2xDTmZkbEZxYnRjekxPd01NZVdZWkgrMVZTNVNjOEJtOU54NXlQclYxcnkzWU1zWlAxNzgwemY1bHVZamdPZVBVQ3FaRDVIRlJUMlhjemRyd1JDVGZ6NjV6OWVsWGZ0TWswSUVaeUNPdU1acktXR2UzVWlRRWduakFwczZYRVZ0NWtDblBwMkpyTzJwSE0xRjZPeVdxNm1oYVdENzIzSUdJUEI2MVIxT3hSbVRCOHRsUEJBeG1zNjMxVFVVakRNUW95QmtEL0FCOUszUzhGMm9KY0h2MTYwYWt3bFJuVDVVdlBYUTE3ZFgremhXWU1BT3VmODhVc0pSWkNvVlNNakl4enpYQlROZFIzc1VhTVFqZFBRNXEyWnJ0THZDcUR3RCtWQkN4QzVuN3JYTExsTzR2TGVUeVhkSStlY2cxamFmY3lYTURKSW14aGtBK3VLcTJseGVpVEV4NVk5RFhUd3d4K2FPdk9lbnpmaFZkRHBoTG5kMG11NlpISEVJdHk3c2tZNTlDYVlrN3hzd0trOGNIcG10ZmRieDVLZzU1QlBwVklUQ1VuSzV5ZXRGelpxMXRUbTU5UWFNbFdRRUh2UzJzTTB4WmprSjljMVp2b25TUXNzZTRkZVFQOGlrdHI2UFpoaUFDZWxJNTcvdlBlbHAwSTV2czBFaDNrNUl5TStwcXJiMjQ4L3dDVW5ZZnlCUFdtWFU4RFRGR1k3ZlhxT2V4cDl1OXREdUlrRFlQQjYwQ3VuSmJXVE5DNENXcXQrOEpMRWNlOVlmMldTRWVZTzV5Q2NuUE5QK3p5WE1vbElMQUhwWGJzc0l0VkJHMDhVRDVlZHk5MnlYd21ITnFDeDJ1SkYrVWYxcm5ScVVUeE8wVGpqSU9Ebm5zSzZtVzBpbmhaWkhSaGp1S3hiVHczWkxLelJ6ZFRralBHUlJvWlRXSWM0cUtUVDd1elJWdE5TbWxYYjVlNGRHNTdWUE5iR1pNaVBhUVJuUHBXdExid0xJc1VBeTNRbXJza3l3cDVma2xtSndTRG1uYlUyVVhacWIvVXpHMDZSYllORmtQMkdNaml1ZkNhcUovTTU2OUFPTUR0VzFFMTdIY0RDRUFrOSszMHEvOEEybXIzSGxzcEdUeG5uclM2Q3RCdE83ajBMVUY5NXlGWFhhdzlhbFFySGttVGprbkk2ZTljOWVYVHBMOHNhOGpIR2F2cmJOTmF0aVFaWWRPdEk2WTFOV2xxMExNdHBNV0FrSkI0NlZ5NzZQR1ZLQ1JsemtIUElQdlhVYWRwSGt4czBnQk9jOWUxT1F4VDNJanp0Q25uZFZYN0hQeWMvSzV3U2sraDVNMmxUMjh5Tkc0SXllcHdNWjlQZXZSWUx4NG8xeVR5TUhrREdhNzg2ZGF5S01GV0F4bjFOVTdyUXJONG1KeDc1NHA2dmNLZUJsVGNuQ3lUMU9mbSswUzI3ZVN3empQUFQ4S3lMYlRyNlpuUXpNT3hOYWRyZENDVHlWako1SXllbkZha2s1dDNEQUVaNmZqNlZKZkpCM2JiMDNWemttMEtXeGtlV1pqSXJIUFBQVHRXM1p6V2h3VUtnOU51YzFhMUR6SnJSaUczOWNacnorTFRKNG5TWlQwSFFIT2M5YzFUMTNPYVM5bk5ja0x4Nm5ydHlrRHhBTUFDVGtjVmdwR3FGVVZ4MXJGdWx2N3J5OW5SVG5CNi9wU3RIS2tBUG1LQ3B6aW82SFU2bDVQM05PajdsL1VJYnEwakpWUHZZK2ZyMTdWbGFmYzNheHlpVEdPb1AvMXEwNWJ3eldwVXlBbFFPUjJQc0s4M2cxVzVGN05Fem5idUkzRmNaK2xPejFPV3RXalRxUWZNN1BSSFZ1cDFNTUZiTzNxRHdldWEzSDBkVGFoV1k3azZjNHlhNXl3U2UyZDVGeVdPTWQ4L2xYb2R0Y0xKZ3RqZG5wM3BGMGVTU3ZKWGsxcWM1cHVqWEViU0VPUjdZcVo0M2dsZGhqQVBKcTlxRTEwd2RJQ1FXNDY0eFhMUXk2dkNOczBZYzRHQVJuOHZTaERuN09FWXhqR1hlKzZPb2UzZWVJa1JrRmgxNjFoeEs5dk1QTnpqMHJzcmU4bjhvS0V3VGpnams4VXk3dFl5QXpEcjF6MnJTeHZLa3BKU2k5VnYwSzA5Z2x3Z2NjTDF6NjFFK2pSU3dvcXZuSFVFL3dCYTI0d3l4YkFCdEJIUTlmUTB0ckN1SFVOeU94UDhxRnNiK3lnM3JGYXJVeEpyYUpWQ0VuYU9DQWFqdFo0WTJDTDA1enoxeFYyVFNibEE3TWUvWFA4QVN1YWpzMzNGV0RBWnBiR011ZU1sN3Rqc1JOWnVRRUlMRUUrd3pWbnl3a1RFQUErbGM3RHBXMCtZSmNzZldwMXZKa1pVY0FaeVBZMEhRcFd0ekt3eEpaV0VoWUhqR01qOWFxeVhMQlZRc3B3Y1lCeFhSSkpFNTVCR2VEd2E1NmF6Z2E1RGJ5Ty9haDJNcEtYTG85emZrbGdGdU54SU9Ca2puajhLd21hRzRmTzM2RWMvbFdyOW9zbFhid0RuR09uODZ5TGhyWGRtTWcrM2ZuMHFibFRWK3EyMk5zd3hLT0g5aU1VNDIwWmlZWTVQcFdiRDluVUtTYzV3UnoxOXVhMzNBWlFSamoyNC9TbXlvY3JUZGw2SE8yRWNrZTlXd1F1Y0UveXErYkpIWnRwQ25wK2RKSkV5ZzQ3NDRxVkxsYmVOaTJlZldoQ2lvcEpQWmRUUG50Sm80R0RBRGo5YTQreFdGcDNIbVpKNmpPRFhZdGR5enJJUUFjakg1VndNV2tYQmxhUU1BL09NKzlDNm5MVzNoeVI1dFhjOVBodFBLUWt5Z2tqaXVUdVZrZVluQUhPUHJtc3JUbTFkSkdqdUhZcmdoZUJqODZzcWJsNW1HMFlQR01IbjZWVm1TNmluQ1B1eWpyczl6UFRSRGNUYmk3aGh4ZzhqSFd1ajhsWUZWTjNRNDU0QXExYnhUeEEvS1QvaldlODZ5U3VKQVZ4anZrVkt1eUZHRVVyS3piS0YyajVRQnNIcDlheVlaNFk1eEdXT1NPaEhPYTZRUnh2T1BtQndRU2U5Wk9vMjl2STYvTW9Qc09janRtbXJYMU1La1pLODFiZEd4YkxHd0pQT1R4N0g2VTVaWGljNFU3VDE5TVZ6c3Nid1JqZEtUa1p5T28vQ3BsbWtaV1BYR08vYWxzelJWTEphV2FPaG1udU1ia3llZWdPRHgyckprdTRzcTBnWWtEa2RqM3BGdTVZaW8zWjloM3ExSjVNZ0RQR3ZQQm9zVnp0M3RMWHM5aGx2T2s1TExuZ2RENjFyTkxEdVVGMkI0K1VEcldUYXhSK1lBb3huNkNyMGxvSW4zcWNENjUvQ2g3bWxOeTVWdDVtMHVvUlJSbGRuZnVlVHhYRzZ0cVQ3Tnl4anZqUHJUVGN5WEV5eGhCemticVRVYmRvSW1CQlBCNVBTbnJkSWM2azVVNVdmdXJ5TVhTYnFPNXVDeGxIUFFmU3V6a3RnY0ZRTUgxNm12R2RPamtTL3lnR2VUbk9PdnRYck5ySytEazd2WSsvOUtKS3pPUERTNXFidXVwc1F5aEZBY0RvQnoyclBudGx1bVlxcEdBVDZlMVkxL2ZUY0txZGoyRmJPbTNCZUhjQVE0SE9SakZLeDFxVVpOUTNTUnNXU3RERDVia01OdlByVkthR1B6aUJKempwNkNsajFNR1Z0eFVEb2F5cDdnL2F5eWdCYzR4Ni81OUswUjBPVUZUUzNzN0hXWEF0a3RsTGRGWDByaDNtdFpFS3JnZzlRZU0xdVN6ZVltMHFTRDB4V0xKSGJScWNBWko3KzlTWVZtNWJXdFl2MldtcEVoWkJ0N2tkUm1vMWczWElPQVRrWXE1RVpBaStXQmc4RWovNjNTdDVMS1VJR0dTU2VvSFdnZE9qRnBKUjBRUDVxSmdESndPMzhxd1pYZUZDNVRlQjJBL1hKcnEya2JCUmdjNDRKNzF6TnpLMFoyc3ZIZmlnNmFrZE55cERxUW1WaVVZRWRUMC9PdGlQVklpR1I4OGNWVnRKck50eWJBcE9mcDlhdEd3Z0VoWW5qSEhORmpLQ3FjcWZNbjNJQkZGTVdkY0hIYk9EV090dk84dzJzUjBKV3Vvamd0MEc1V0I2OGZTb3dYOHdnOVd3ZWV4b0hLRjByL094V04wc1kyOVQwNkdvMHVwQTRiYWR1T0NLMExqUkdtVXY2WTk2cURUNUxlUGxqd2V1YUI4dFZQVldXOXllUzlkbEcwRDNPTVpxS041cFFjRTQ5dSthdFdzbHZORVY3KzR4VGhNc0RFRUtTUU9NMVRaU2JkbTVhTTVxVzNrVzQycTNJWHA3K25OUGt0NWlCZ0hKeG4welUwa2pOSzNHUmpJQjRQNTFnVFhXb3h5SFpIdVZXeG5QYjFOU2NjM0NLZDA3WDZGYTVndTJuQ2trRGprRGpILzE2NnUydHZLd051TWpwOUt6a25sOGtPeElmM0g1MXMyODhVc0FBSjRYdUtWOUFweGpmZDNhdnFWTHgzZGRxa0hqaXVRVTNVVTVPQ0Z5djQxZm12dnNzN05KOHd6aGVPbjFyTkhpT3htbE1hSTI4WkM1NC9LaGMxdEVZU3JVdVpYcWNzcjJzZGRkWk5wZ2dEQTVJUHJYRzZmZkNPNEt0a0twUHlrZHF0Rkw0eE1YeVU2KytSV1hBNkhnZ0hyZzl3ZlEwbHN4em0zVmcxcHAxT3Z1cjJ3QzVLQXEzR1Q2bjFybW90ME1yT2tlRkorWWRlbnBWZFNKU0E4Zkk0OU9uZXA0cGlycW01aXVmcDlQclFqS2RYbmt2dzBOUmRjYU1nTkVHSGNuZzRyVnRMaU16QjBRZ25uSDBySG5naGxVRXFDZWdQY1ZZczJqalBBUGJ2MG92b0VYVlZUV1YxMERVekpKZHJJQ2VDTzlkUzgwdmtLRkp4eFhGYXpxWmlYSHlxRDNIcVBTcElOVGFTeHlvTFlVKytmem8xME40MVlScVRWM2RvMExpOWt0U0c1eXg3OG5tb20xaVo0Y2pQZmpIV3VXdFpudmNveDJNclp3UlhWMkZpVHVBSUdTY2V0WHNaUXFWS2t2ZGZ1N0l3b3RVUDJrN3NxUVIxNkFWM0Z2cklrSGxrZGVLNGpVZFBraEROR010MzNESU5ZZW5ycUZ3VzNKZ1p4M0dPLzVVVzAwTTFVcVFxS0x2ZCtSM3FxVXZSSnV5TTlNKzFkVXpRTkRua2NaSHRrVjV4dHVZbklZS1J1SEk0NDlmZXRnM3JOYm5ncXVPTWNnMHVWblhDYVY5TGRiTXFUemJ6SVZmNVY0NkhQRlZiVzgySGFHZmdkQ2VNL1NzeU4vUGxZQUVuSUFJSHBUYnV6ZUNOcEN4WWdZNDZuLzYzdFRzY2JuSnB5UzJGbWx1MXVRNEc0WnpqLzYxVnRqeVhTc1JzQ25PM3IrWCtGWDlOdWt1VlFNcEg4Sko0NHFXZXlaTHJiR2M4NUJOSk8yaGxibVhNcnROclR6TEZ6Zk5FaWdkVzZuazAvVFpwWkd5NkE4bm4xQi9sVHJuVHBnQXhPNFlHVkl6aW9CZHhSNS9kN1NPZXY2L1drdGpvdkpUVjIwbDBPOHQ3aUtUNUN2UFkxUWtrUlR0UHk1T092V3VYajFDQlczTUNoSFU5angycm5ielVYdVBsZ1Jpd09lZTFWYll1cGlsR0NkMDMyVzdPa3Zkb2ZLcHhucm1yaDh3Mnh5MmVNOFZ6YjI4c2xzZ0piNmV1SzZPMnRaUkFGWmlCam5udFIwTklTbEtiZks3TmRETXNOV1piaGtZTUFEL0FKNlYzOGN5M0J3eDRJT09lT2ZXdUtnZ3Rjakp3NDdINjF1Z0pIRVFRVkgxNDU3MFhOS1RtbzZ0TkY2ZTJoR0NoR1FLMHJHY3dJRksrNXgyOXF3SjRHbHR3MFJCQUdTUFVlNXJTZ0ppalJwVlBBL0tnM2pmMm53MjAzNkhRM0htdVFWRkZZY3VwUklCODJmZk9NMFUxYzZwVGhmVm5oVjlwZDFkWEN0RStjWVBEWXE1WlE2MkxnRE80SmdZSXgvbkZkMUJvczRkV2hsM0J1eE5kY3V5MVRhNmdzUjZjODFMazdIelZQQlJqSno5NkxidTdQUTV0Nyt4dDR4NTZaY2tEQkEvS3FMengzVWJOR3UzMkhCcXpjM09pZmFBMHFGaUdJMmtad2ZXdHA5T3M1bzk4QkNydDZFWUg0NHBXTzEzbmRLVUdsMFc1dzJuUlhUeVNlZU05Y0FqakhZY1ZvWGxwZnJBY1JnakI2OEQycnI5T2dSWTVDQmxodUE1OVBUTlVZLzdWbm5JZEQ1UVBCSXpTNmt4cFdwUmkzSnQ5VnI5NVEwZVhVTGZDTkI4ckRBNTZudjFyb1pMQm1sTWlyOTRFbmpCNDk2MnBMa3FvaFpjZkx3MktpdDJaSGNNNFBQcm5PZTFGdFRzalNVWXhqek9TWGZvY2ovWWtOeGNFN2dtTTVPY2Y1eFd5TkdsdGtYeTV5K2Vjams4ZHFqdjRpekZTNVVNZXVQNjFmMCtGN2UzMkNVdDcraDlqUVNvVTFOcjJmOEEyOG4raHpWNGwvYnlneEFrSHJTemFiYTNVaVRTcU4rQWVXeitOVGFwUE1zSnpKa2U5Y3dzOHJ4RjNiYUZ6MDdnVWttWXpuQlNjYk43T3oyUjEwZWl3T3JNRDA2RC93RFZXTHFOelBEYlBFaElQT0dQNWNWbVdPcjNhdXdqYVJsWDhQdzVyV3VZcnk4aUVoVGJnZGp4VldzeUpTak9ENUwzdDBLa0VqeDI2ZmFlL0FKNXdmYXRxUHpKbkJSUnNITmMzSERkM1JFVWk1SGZQSUh2eDNyY1N6dTdDSE1jbTRIZ0FmMHFXS2s1MnU0dmxTMWZVejU5RWp1SlpHZFFNY2ZuV3JaMjBsc215TWJ2bTZaeit0Vjd5UFVicUZWaFlJeFBMRDByYXNMZWV6dHdzcDN1Qm5ucFIwM0xoVGo3VzZwdGFYNS8wTnZjVVFiazZnWkgvd0Jhc0JZL011d0N1QVBVOC84QTZxMm9OZjA5WFZMaEczOWpqTlpXcHpXMHpJWUpRRHdSeG1oblhLVUpSVFUxTGxlc2VwMkVGdTBuR01nREh0eDBOZWNhOXFjVmpkREtaSjQyZzgxMldrWHNzYk1ySm5JNVlEaXNqV3RBaTFWNDJFakFEUFRnNU5Dc3JYRmlWVW5odjNLL2VYNmxXd2wrMndDUmZsSXprRS81NXE3dWttd2h6a0hyNlZiMHpSbHNzSVgzWVhyVzhMZFVPNE1NOWllMVV1cGRLblU1SWM2czdlOGNCcVdrWHJ3bGQveWxjZE9tZTRxaGFXRWRuRWQ4ek43TndUK2Rkak5xVWlQallUK29GU2lDQytRc2Z2QWZYbW4wTTNTcCswdkhXWG1MWVJSU3hsMVFLdU9TUFN1QzFkUTBycEVHM2R2bC9tYTdlTkxtRnRtY1I5OFZEZld0dDVEK1VDMGpjNVBlcDZtbFNEblRhMFRXL1Q3amt0SlRVdmxXY0VKMEdSbml0UytzUVZadDJSeU9EaXRXQ2FPT3hqRG41anh6eFU5MUdzbHVCSElNdG5QR01qNlVudVlSZ2xTdGU3UzY3bkxXM2xRb3VDY3NPbm9EVkpFWDdRenFqcXJIMEdLdFg3U3dScXlXNWQ5dUszcksrRnhhYkdoQ09lb1BGRmpuU1U1OGpkbkhWYUczWWxKTGNxcmc1QjVQSFdxTjNDMENNeWNyejNxcFpNMEtzZDJUMXg3MVViVWw4OHh2bmEyQjA2Wjcwcm5XNmtGQ0trN1BaRml4dTdkd3dPQjZjOWNVa2tjRThoVkFDUFVjWjk2b1N4NlpKR3lDZll6RHFEK3RaMm42WkpheFNBM0htQThoczg0K3Z0UmNoU256UVRncExXN1RXaDFmbHA1R3hRcGNjRG5PZTFhTUZvNWcyeVl4empubXVPdDcrMnNuYnpTVGpnbm9PZnJVVjE0aHRwN2xJNG5IUGJyakZWdWRIdGFTVjNKWDJzZGZkcEVxTEdEd2Y5b1ZoWE5yR0VDZ1p5QmtnWjYxY2FLRXFIODFjNDR5ZVJWSVJSdTVZU2dzTzJmWHRVbU5UVnU2V3ZtV0xXM2loVGN3eDB5VFZXR3lTUzRNdHZKa0E0eG1wdFRrVHlGVnNZN2tkeFR0TWdNQkhsdG5QUFBVMDdpNUl1VVk4dWlzNzlTL2VGNDFWR1RJUEdSMnpXVktieElEc1VFQWM1cnE5UnRwbGlFaC91OGpwbXNDMVBtUk1IWWdnRVpPTzFJNktrR3B5VjJyclE1RUpQZFFNaFVBOXlPUHJWZUhSNzZJYmc0Mmc1SGJGYlRXandYQWRKYzV6a2Y0NHJYYUEzYW9obEtLTVp6enpUUE45aW10VStaYUxYY3BvSFdUekNRV0MrbzVySGx1N21lNDNSeGxlZTR4eDdHdG0vMGw0UXZsT1NlQmc4am1yTFdqL1pVWXBoZ08vd0Q5YWkyaFVvMUw4clRTV3I4emw3KzhlTUFTTjgzUUhPT3A0cmIwUkpZd3pPMjRIbko2L1dyWjBPQzdDRjRodUdEazg5S3NPWDA5a1FxWEdPTTQ2ajFvdG9heGhVVStlWHc5UCtDVUcxbXhOODhCQlZzRWsxUi90T0kzUlNKK2g1L0QxcnRiZXlzTGlKcHZKQWNqbkE1TmNlTkt0NDc4dmdJbzZqcC9rMGFEcVF4SzVYZUxUbDBWdERRYTdTT1VBL051SEFyR09obThuWm1rS0RKSUdldGRUREZZeXZ0MzVJNDVQUEgwcS9KQXR2RzJHT1BUcjlLYTBOSFRVNFhrazRyb2N0L1l5QWJDMjRxT0NEenpVbHBZV0Faa1NUUDgrbGRORHZrSUpVOG52Z1ZITTJuV3psbkh6RWZObWk1U3BSVm1sR3k3bDJ4dFVqaWZHM2pqOEtyejIwY29CT0FQWTF5ZDdxMEx1RWlKSzVKeDZldk5YNTlUc3JHQkhsSnh4bnZpbFkwZFNtbEs3U2pGYXUraHRRYWJhc1MvbWdqMHEvUGF4eHdLeUhKSGY4YXhmN1F0NS9LbGpCOHM5ZVA2VnZUMzFuTkVNRTRBeHgwRkZ6U1BzbW5ibDIwOHlEN0xha3E2bkRZSGZCcUYybGVjRVJqcUJrMXlVc3M0dm9nbUJHY2oxd0sycC90RUlkOTR3UjYvcFQxTTR6dnplN2F6MU9nOGhRZk5ZZzU5dWxjL2RUMkN5a21MRExuUGJIdlVkdmNBb3JoYzg4cVRuOGEyYjM3UExDSDhvREk1d0tSVGZOSFMzZlZYT0xGNVl5TVNwSkpQUUhQV3Vtc3JkWGpESzNJSFQxcmpKYmUyZENMZmhpZnl4WFo2VkhKYnFCTzR6alBYOHVLWnpVRzNMVkorYTJKTlIxQ0t6aFZaTWtic2NkTTFuMnBndTh1aDI1QjR6MHJUdWJxS2NORTZaejJ4V2ZENUViTXFFNTc0N1Vtalp5ZnRQaVRqMnRxSmEyMTNhZVlSTUhYSTYrOVhqZm91R2RpUVR6Zy95cUNDN2lqTEkrY3RrOU90WnhWSnBqR3ZQcDNIdm1oalRza292NVgyTFMzOWpJNTJwZ2pqSkg0MGswWWZjWFplY1l5ZTRySDFhMGUzQ2hRQWM5KzM0Vld0TCtTNWo4bGNoc2VnL0trWmM5cHVNdmk4aldOeUkwd1BYSTc4MXlrdXEzQzNIa2dEQjc5SzFKOU51UnRMbnB6bnAvS3JrdWtJOFEyY3VlL1NuMU9lVWF6VmxkV0tIMm01U1JGU1lmTjI5S3ZMcEU1Y3lTVEU1eWNEdFRXczB0VkRQdUI1STQ0L090dU1YMHlneGNqUGVrYlJoZlJwdTJ5UmdTNlRLakdRazR3TSt0WnIyTVZ3Z0tyODM5NGpubjE5NjlRTWMza3Fybkhxb3JtamJhZ2ttYlpjazU2bk9hb2NxRWJyM1cwOTFhN09TVzExR0FLcUtRTUVIcjE5ZmF0YTEwdWRHTXJTa3MzSlhkMDU5cTdpQmI3eVQ5b2oya2c1T0s1NVFMYVVsMk9NOVA4QUNnYnc4WXVMYWR2UFN4bm1HNlNja2tBSGtkd2Y4SzZtQzRnUmNNQVh4M0hOVTdpVzJaUXdiQk9PT21meXFTTVFTUkJ5UVR6bkl6VE5ZcFJrMG5lK3VyTkZMcFpUd09lMy93QmVwQXJ6S1ZkZ1BZajA5NnEyd2hFWjRCT09EbXZOZFkxRzV0Wnp0eU9SejEvS21hVktuczZhazlWMVJ1YW5ySzJFcUlCdUJPTURqRmJsdHFMektKRVhhQ0JqUEg0bXVGczJXN2t6UEdEL0FJMTNLa0lER1ZJQVBISFBGSFE1YWNxamxLWE43cjJYWTFwYjJSZHAzNUhBeG4rZFFTU0F5S1ZJT1R5ZUQrR2E0dStDUnhQbHllaEdSMDdFVm5Xc3Qwd0czSVhKSU5LK29UcnRUczAyZWtFTWhCRHFBVDBxaGVOSnZWbHoxN0VkUHBWZTJTN0tabFAzdStPRFZxRzdWSmpHNnI3SDJIdlM2bS9NcFJTZDRwOXk3QXlFYmk0SHQvaldldHpieXlzckRQNlYwTWtFQlB5a2cxa05ZRldMakFJNEFQVTBNMGxHb3JXczExUFA5WHZ2czhwVllTVXhqQUhYTk8wNk9DU1BjTXE2NXlPK01kSzZXYVJva3pOQ0R1SFFpcVo4cGdHUmRvUFhIODhVSG04cjlxNU9WMS9LMXNUVzBDTklOeDRIUTQ2anJqRmJzZDZpU05HTm9QYjBxeDltak1hZ3JqanIvalhLYTFiTENTVmxDOEFqbm1oSGZQM0lYUzIzTGR4cXN4UTdVemc1ckt2TlMzdzdRZzNaQTYxU3NKRGNIWnVQcnlLM0Rwc1VWd3ZtNEFQSUdPbWFPcHkzcVRqZFBSNlhOalI1RUZ1V2tiR2VlMVVKMmN5bGtJQUI2akdEVXR6RmJZOHRYeGo5S2l1THVDQkFGQTdFOGRmV3BOM2RRdHA3cTN2dU1aSnBGQmJzT2VjWitsUlIzeXhzc2FrYnM0ejcxTEhlUTMwSlZQbGJHRHhqcFhPMmtGeEJxQkRjcjF6anArTlhabUVwU1RpMXMybGM5Rmp1dzhTbHR2OEFVL2hWZFlMZVlFaFFDQWVRT1B3OTZ6cFBzKzdHNERqZ2VsWDdhNmdqRElCeUIvRjN6NlU3blhlN1YyckZhS3doVGQxR1J3ZnJYT3pXNlJ6QldrSTVHY0RvT3RhbzFHS1c1YU5oanZ6MUlxak5IRjlvSEdBUHhQTkJ6TlUybFpMZXh0cnAxdmNSWVBQNUNzSkxBUnZ5b3huUEI2VnV0WlRSQXRHMmUzUHZUclczYVF0NWdVakpCT2MwT3hjcWFja3VYVTVPNGdFTWdkVzR6a0RHZXRhc0VFemhHUThmVDE5YTJycU9HSEJNUU9jNEg0ZDZqdFpuWndnRFlPT0F1QlU5VE5Vb3FwdjhrWmR6YWxZeWNLSDZaSEg1L1dzYVNPOWFOdm14ejkzUDZjVnZhcEZQdUdXYmFRZS9RK3RabG5ITWdZSGtkOGR6UjFNNXh2VXRab3JXb2xqWXlzZHA0NHgxeFcwYm1HNGpHK1FjZS9HYWJOc2VNY0hqT1QwRmM1OWpBS0VUTmdZK2gvS21ITktLc3RVUW5UekZjZVlxN3NucXZwK0ZXNXJ1TURJT0NPZWVoN1Ywc2xzNGhVcStRQmpPY1lGYy9iMnR0YzdsYkFPZXAvVE5LNUVxYlRTV2x6VTB1eWpraGFWc2M4MWNzYlFmTUJKeDFIRmM5ZUpmV3R0aUZRZVJrcWVnOWEyckthUkxWV2tQem5yampyUmQyTjR5aHp4anl0T0t1MzAxT1oxSFRyMHUzbFNMZ0hHUjMvS3MrUzB2dkpVSzJIR00rcHg2Vm8zTjNlTGNIYnRVOVQyclZ0STV3MjR5WjNjalBiMnA4elJqeXdsTjJVdXoxT2cwZ1l0a0U2Z3NCNmRTYWZxRm5FU1hWUms4K3ZJcDRMcXVNSFByVTB6RXhZS2tBY25KcVd6dnN1U3pXeHpzVjJJTThxT2VlTSs5ZE5iYW9zaUhCengxeGpGY2o5cER2NWV3RUFmZXh3TTFmM3d3UmtEQnorRk5NemhVYWI5NVdSdVcwenlUYmlTdU04ZGZ6cm9wWXJaaVdBeVRqSHBYQ3dLWkl3NmtqZzQ1eHlLeXA5V3ZvWmg4bTlQWHAxbzZtcXJ4akM4bGRQcWRkTmJXYWZPRkFPZUQxcElrbFlaSFRzY1pxcEhxSzNFT1BMMms4RUVBNTk2czJza2tLRWtjWjcraDRwMzFMaTR0cTJ6VjlCc01jbm5FRlR0UFNwTGkybkxLeWtyakI5NnV6WGlCUUZHTWM3Z2UzdFVqeUtFVm1iampPUjFGTTI1WWFxNVUrMDNra0d3TUF3Kzcvd0RYck14ZGJTcnVlUmdEc2EzRXVySm15cnFUM09hcFhEd1BNQVcrbTJpOXlHcjI5Ni9UYzg4dHRQMUNHK2R1UXBPVjVKNitwcmZsaHUxWUZqZ0hqUDhBV3Q5NVlsNEFHN0dmL3JWREpOTklqWXprZHYxNG9UT1JVWVJUU2IzTVdVc2dIeWdudjI0SHJSRktKTUFvRzQ1T2YwNHExYTJyTWN5NTlzbkpxWkdoVzRKVUtPUFhqTkFjcjBkN0pta3F4Q0hhL0FQVUU5QlhNeHZBanNGa0k5UC9BSzFXdFJWcG92M1RMa0FaRzdCcnpkckxWVWszcElSaHVuVVkrdEsxekN0VWNiV2hlM1ZIZkxhcGRUYlhBSXdUbW5MNGEwK0NkWFdQNXhuQnpVRmhKY0JRV1ZOd0hQMTlxMlJxVVVmM3VEN24rVkd4Y1kwWkpjMFUzdW0wVk5SbmNmdXNiY2REaitkWTFtTFFLU0FOMk1rZTlkZXkrY2hQT0NEeVRtczIyMHBUSkszUU1PUVQxTks0NVFuS3BGcXo5VE5odG9KM2JhdVN2QjdmbFZ5YTBpMkVJZVFPM0ovR20ycXJGT3lFT2VQeS93RHJWcytTWXlYSnhtcUpwd3ZIV0t2ZlU0ZUtHY3lFbkJVRE9mVWl0SkxabU9WSjRQMHJwbG1nalVyaFNQWVlxU09GV1BZQnVmOEE2MUt4YW94NzN2dWVYWDF1NGRUSmhndlQxRlhiSmVHWEF3ZW9IYXUydTlPamNLMkFjazVCcUdHMVdOU29BK2hwMk1mcTdVL0k1MUxhM2ltM0lSbkdQU3RzdXNPSEdEOUt6YmkwamtrNmtFRWtaNE9SU1J4emdOR3pkY1k1N1V4d2k0eWZ1cEsraEhKcWNNcjdXVTlmdW4ycll0YjYzU0owMkFaOWF5UHNsdkhMbGxiT2ZyV2RkMjRNZ1pBVGpIZkE1b0pVcWtaTjZNMExtUkNYTGhTRDBBT01EM3FDeWRON2paMnlQbXpqTk1OdVpJeTJmcWY4YXVhZkI4MldHT25BOUtyb0pYY2xvWUx4eXhYRWhSU1NTTWVuUHZWaU8xbm1iTGNBRE83MHhYVTNkdkNveU1oaHlEbnZYTHc2aEx2Mk1vNDVKSEZHNk1uQlFlcmU1WW5zakhHVEZ5eEg1MXdTM3Q5RmNLc2dEWU9PTytUWHFieUZGeVY1MjR4MXJqcitNVEVNaUhkeWNnWndjVVdYWXpxMCtxZG1hdHhxTDdFR0RrOXZTczIzaGVhUXV3NGJzZTJLNVF5NmlmbFlZVUhxZXVmOEs2YUc1ZU1nYkRuakpKNFBGVHk2R0h0WXlxN1NTWGRHN0pwc2VDVVUvTmpjQWVsWTkzcGtsczI5Y25qT01jbjhhNlVhakV5Z3FPY1pJeGdaNlZKY1hublJBamtEa2dkcW03WFE2WndveWk3UFhkTkdMRGNPMjNjY0VMa1o3Vm0zR3AzTU15aFUzSUNNSFByWFFYQWphSElPU2VlZWxjKzBTdWdFaURBVWc0UHB6VENYT28yVXRlNFJJKzluNzU1N1orbnZXcGMza1QyeklIQWJCQTU2aXExbTRLbGRtMFpxU2F4dHZ0Q21TUWdFOEhKSDUwcmppcGV6OTNXKzk5Q3JvMm9Td3Zza09Sakk3ZFBXdWsxSFZ5OFFFYThudmppcXAwMjNFWmVOdU1kVDZldFpNTjNaREtTTUdjRGdEMG9iTGhLcENLaTVwSnAyWkVZMm1RRXNNOWVtYys5RlQvMnJaN3loYjVjWkhhaWxlU01YN0Z2K0l2dk84K2F6SUNaS2J1UGF1Z3RpczY1TWdja2RNZ2tWbHlabGsyc3UxT2dQYW1mWUk3Wng1Y21TVHdQODlxZHREMG9YVXROWTlqSnZkTTAvekhCUldZOCt2K2NWbVdsamU1Y0lBcWV4cm9iZTNtRjV1a1BIcDlhMTdxSWliTVRBWjdaNjBydnVZK3hnMjVjdHJQWmFIT3g2WlBBd2tTWWdrOHJucDM0cnF4Tkt0bnR5TTlRUjFyejdVOWJFTThkc3NKWm03akpBclEwMk82THl2Skp3UjA2VTJudXlhTlNuR2JqVFRldHBhN000N3hCTHFra3NReDhxODhIQXo3MWEwelVidHBodlVCVkhPU2VhZnExMWVpU0x5V1IvbTV3dWVQV3V1Z3M0bWgzTVNHeDJIUFNuZjNWc2NFSXpsaUtscFM5MXE5OW1VN3ZYWWxoY3lSS0NCeGs4R3FtbjZ5TG1FQjF3TVk0NmZoaXVSdjhBVHJxN3ZERW1SSHVBUEIyOGVuMHJ2OU84UHRaeHA4dzc0R2NjbjJwdXlYcWFVNTR1ZGVYdSs1SFM3NnNvM2tTUEN4ZEdHTUVjWitsTmpnaW50d29YSUJJeDBQNDExclh0ckhBZlBVSEJPT2VhcHd6MmNzU2xWMjUvbFVxMWpzY0tmUDhBSEZ0clZkVE5qdGJhMGpiOXgxenozSSt0U2k4bUs3RVFoUU9mclVXc1EzVXBpRVhJVWpxdkFyMEN4dFltc1JnQU1GL3oxbzNadENEY3BRajdxUzdibmpzdW96L2FBSVZLa0hPY2YxcnFMU1Y3b0tISnpqa2s5NnZYVmhDcGNxcTU2WTlxYjVkcmJ4QjgvUGovQUNLblJFUWpPTW56TzY2a3lTeFFPNkw5N0hCQS93QTgwNkM2REdRT01uUFBHYXpoZFJDTXlORnprOGdmMXJMdjU3cVRIMlFBTjFHZlgyb1pVcWlqdDl5M051NGdDTnZralQyT09lZlN1SWt0OVB1ZFFDaHlqSEg4V0IrVmJOc2w3YzdSY1NnTXZVTDAvTTEwRnRvdGdOOGlrRnNuSTZZb0pTZFZKcUt0ZjdXNCtaUmFRSXNSRGs0ejYvV3JxeFhMUU5OazhEb085VllMZEE3T1pmdWsvTHp4N0NxVSt0SkFUeUNvNEM1NFA1MEd2TkZLOHRGMFJoMjE1cWx4TktaanNHU0JqdmppdXlzOThhNXlXR1QvQUo5cXlaRml1WS9OQjJEcUZ6Ni9Tazh0MFVFekJoM0hRL1NtWlUxS0c3Yy9OczZhM01VeGJDY2c5eGdtcUt5WGNkeXdFYmJSMTRINURGVnJXOFJZbjJxVU9PcDdHc3Uydk5YYTRZeU92bFpPM25ISDBwWE5wVFM5bnZkdm9kSGNYc2UzREFiajdZL0txN3ZjMjdFYlF3YmtuNjFVdnJtMWtBV01GbjlQcFNSdE5qOTVrZmpraWtYS1N1L2UrYU1IVVlidWZCUTQrYitIaitkWGJXQjRyYzd5NVlBZktUay9tSzZtSU1pQnR1Ump2Mzk2d1hXWjd6S2tJaEh2elZISkttbExtdTIyMHJIRlQ2dGMyN1B2ajNCZnU0L1B2VTBPc3BJdVRiODQ0OWVhMzd2U0wxNVM4cWhvK2dJNUo5NmxndGJhQ05pOFo1NmNVYWRqQ0VhNnFPODNielEyMnZra3c4aWVXQjZrWXJDOFEzTjYwVWYyU0luSXprZDZzWDJqZmEyU1NPY0tGN1l5T1A2MURmSFVMV0NMQTNLUmdFYyszU2trci9vT2JyZXpuR1NhVmxhYXRkbkpMSEM4cWVlcFNVZW5BQngzcjBDQ2VLM1JZcEpEODNUSTRBL3dyRHphR0pCS1FqdGpEQVk1TmRWRHBkbXlLemtrcms1eURtaG1sSlNVV284cmQxZHZmNWtiYWRaWGlFS1FjOThBNHozckVnOE5XRnJlaVR6QVc2Y24xN2pGVDNsck9qYnJLVlZPRHgxcm5yZTIxRnJwaGNPZDVJeC8rdW1ycGJrMUhEbWplamQ4Mmt1aHVYbGxCOXAzK2VRRDJyVjgzVExjNUdTVGpwNjFtcFovNlFxeVNFNE9WNzhlbGFRdWJmZHNXUGQrR2FWeHA2dDJTMTY2bDZ6dnJLN2RZM1hsaWUvTlg3dGx0cFUyWkk2QW5ucFdWSjlsdDNFeGlJL3UrdGJ3dkxDOGdXVEp5ZW1SU091RGJpNHVVZWJwNkFieHBvR0hCT09jOWF5SjRESDh6RUtoNjU0RlU5VXRyMU52MmM0R2Nuak5jemZLK28yRFcwa25sc1J5MkRrSC9HbWMxV3ZadUxpMjdhUG8zMk9oODVRcE50KzhjRG9PZWF0YWRjM0xQdHVRSTJ6eU00NCt0Y0xwR2l2cEkrVzQ4dzVKR2EzNWJhUFZaTnNranhrWUo1eDE3VUdjWnk1WXUxcGRJWDBPOHVKZHpBY0VmWE9mclcwMXhiQzBJTzBISEdEa1Y1aERwbjJHVVl1Qysza1pKengyNXF0cWsyclhTNHR3QmpPQ2M0eitGUHFkYXhNb3hrM0QzdHJMVXM2bmVhaGJ1cld4TEtTTWdIQndmWDZWSnBpeVhrcCswelliR01FMXowSjFXelJYdTBFaStnOUswamVSQmZPUkF2VTQvd0QxMDIraHlSbmQ4ejVsMWNHZHU2SmF6S1ZseXVPblNzTFdMSmRVUWlLNEVaUFh0bjJyR3VyODNFZUZ3RzU1SElyQWkwYldaNXd3dU1BRE9RTVovQ2xIMXNSWHJQNFkwM09NdXoyT3RzZEhqc2tBYWYxeUNjbjBxL0U0MnZpVU5uUGZIRmVjMmNtbzJkOUxIZlJ2SUFjQTl2d3IxV1A3UDVKS3g3YzhuMHlLY3IzSnc5U000MlVlVGxiVGk3M1F6VGI4UEtZM0dBTWNtdHk3MHlLK2lJamREeDA2NHJqWVpZZ0cyYmlEbmtISitsU2FXTCszdUpDQ3hqT092b2UxS3gzUXFhUmpKY3lmVmRCMXJvWDJhUmpuUElPVHpqMnJRMUNHMGUxWkpJampvT01tcjBWeUVtYVNVRWNqQXovT3Jkek9oSWFKQTJmcDJvTmZaUVVKSk5XYTIzTWg3aUdPSklGaUlIUSt0VVRwNVp3Y0FLUjN6U1hrek5IMVZHSEFCSFExV3RwNzRiVmtHR0l6d09NSDB6MXBHYmtyMmFiVnRORGNPa0xDZ1paUUNNQURyL2swdHZkdENoVjR0eS9UK1Zac2pYb3doSUlKNkRyUW9taGhrRHNHQjZjOVBiRlBvVnpKU1RqRnhTV3BzYkVrbDg2SUJWR2NBZjFyV1l3M0VHMC9MblBCNHJ6QzNiVTFkbFU0UnprZk5rZi9BRnE2V01yNUJqbEkzblB6QTU2MEt4RWE2YWI1V3Q3MzJOR1cxU0NGd0ZCYklPUitkY3JiTEtib1N5eWZ4Wis5eUI5S3pCNWtXb0luMnd1bWVqSDE5NjdlR0tPY3ZzWVo5TVpPYU5qT01vMUdrbzh0bmExLzhpK1pJcG1YQVBHTW1rUjdTT1hsVmIrOGFaSUZzN2MrYUR5RHo5S3dOS0RlZThobFYxUFFIdFR0b2RibGFjVnlxKzdmWVM4ekx1Wk1LQms1SnpWR3dqdW1JL2U1WlR6Z1l6OWF0M0htVDNQbEE3UVQ2NDcvQUsxSkpMWjJFcXE3L05JTUFIbm42MExZNUh5YzNQS1Zrblp1OWlIVlVrbW1pZFpXT3o3dy93QWFJcnkyWml5TGh3TUVuMnBaWTdoSmtrUUZsa1B6QTlxdml5aVc0MmxNQmhnNEJQUDRWTEw5NTFKTksxM3JmODBjbGNhNWV5VGJVVDkyUDRzOXhYVWFiYXp5aEpIa3hqR09jYy9qVjI0MEtLTzJPeHNMMnBrRmxjeDIzQkc1ZWxOSWoyVlgybDUzbDEzTmw0R1lsV0FiUFE0NjF5TDZsUFkzb2o1MkUrL2YrZGJhM0dyR0hIa1pQWWdjL1dzK0cxa21QNzVBdjFQUTBXVnphYm03Y25ORjMzc2RIYzN6L1ppOGJGbVBRQ3Vlc3J2VVNkNmpDZzlQeHJjbTBlY1IvSXc0SEg0K3RYN0RTN3RJV0RrWUl4bk5PeDBPTmQxSTZTVmwwTSsvMVcrbGlLeG9PT0NlTThWeXNTWGsxd3dsVEdUNlovV3V4bHRnZ1ZRUjJ5UFhuUE5RMjhlNlFnc3VRYzVCeGlneXJLclZxSnpxU2R1blF4RjBoSXBDOGpsZ1JoZWZhdVh1dFN0N2FVd2grWEpBSDlLN2UvdHBnNmtTRWpqZ2RLeTJ0TkphNGptbVFFcjBPRFJvWVZLVXVXMVBsaTdyNHZ4T0F1Wk5idFk5OXZIdkRFRTljL1N1alNXYTgwMk1YVUJXVGtISXpYYVQ2dmIyNFZnaUdMNlZPTDJDNVFHT01BRWZubWh1L1FtTkdNSnkvZk5wcTNKMCtSNTlwOXZMYnR3QVY5dnovT3V4am5XNFhDeHNoSFRkeHlQNjFYblM1RXdDS3A1Nll3S3Z5M0RuRWJXNFZobkI1SEh0VE5JcFJ2clplaGN1TEJKWWlyeGQ4ZzkrYXpKN0xFWEFJNHp4VzdhWFYwSWloNTIvVDlLdzc2N2tkSkk4RUVqa2ozcWRMblRQazViMjNScDIxemJDMithVGtkUlZHWTI1UjVCd3dIQVBOY2RwUGgyZFoybFc0WWduSlhPUUs3OWJhM0VSRFozZEJUZWpNSVNxVGdyd1NPUGsxV0pvajgydzlNOGl1bXNRV3RpNG5MWkF4bm44cTUrNzAwTkc0Qzg5ejFxNVoydHd0dnNqQjJMakhPTWUzTkNaRVhVVlRXTGVoMFVrVXMwRzJUT3o2Y2ZTc2lTMlZVQ0p3QmsreHBKdFZuaTJRdW1PZXVmNTFUMUc2VVFLeUtDYzlRUFQwb05adW5MdTJscjNNeTUxbHJHUkluVGR1T09EbXErcWFLK29va3F5YmVBU3ZyOUtuaXQ0YjVWQWRkL1lNT3RkYmFMSmFSQkoyTEE4RHZ4N1ZWMVpHSHNwU2xPTlJQMmJ0Ynk5VGxiTFM1clNBRlRsc0RPUFg4YXk3eVc2YTVJbUcwQURrazgxNkZQTTIzTVFVajM3NDlLeUpiMWJnTXJJdVFPL1VVdEdYS2xGUlVWSnEzVG96RXRibUlobDVKNEFQK0JyTmNDRlppWkN4WUVZUGJ2MHBOVGxTenNwR2pBM0hHM1BBSkZNOE92TGZRNXVVK2JCeHhuOHZhbGJReGlwUFM2dXJtajRkV0pJbmQxWVlQUThjK3RkeTBzRG5jR0hJeHp6L0tzS1NLQ0p0blRJNDlQYjYxZzNtblhLc0g4N2F1ZU05QUtlNXFwU2hUVVZIbWEzT3JsanQwTzl6d0QzNTUvcFQ0ZkpudUJ0NkRuR0t6TGF4aW1SQThtY0RxRHpnMXRMSGIyamJkeHdlbWVSbXBlNXBGdHE3aWxHNUJkMjlyNStCanRrZ2R2ZXBieUNLSUlVWUQxUGNDb0pmSWRpM200SUhicitQclZPU1dGNUFvWnVoeVR5S1pUY1VwYUxYWTJJY3pMZ3VkcFh1ZVB3cERCT2lQdEFKN1lPUHBYbjkwbC85dmlNQ0VKd0dPN0dQd3J2SjB2bGhVcWhiYUJubit2dlRld29UdnplN0wzZXZmMEtpTGNiTXlzTWpPUmpOYVN5SkdxU2M5S3lvYnVOaVJQOHBBeVFPZWZTczY3MVBUb05pQnNsdTNKR2FTUlh0SXhqZm1YejNMZXEzajNLL3V5UXc2ZzgxanhhcEhiSnNtWG5QVWRLSkxXNDJlY2h6bmtEUEZlYUpxT3BUWGpDVzJPMEU3Y2dpbWxjODdFWWwwNVJiVFRrN0xTNk85VFZTOHpJcWNaeVNSZ2ZnYWd1VjJnYkhQSkhUbkJQYzFtUlA1N0NOSTNCSU9EakJIMUZhcVdGMUF1NlFEM0pwbU1IS1VYMVd1dll1VFJYa2xzQkdjSGdqbnNQclhNeHBxRVVweXBKejFIVG10aWQ3Z2JHamtSVGdaejZWTTE4L21Md3BjOEVkQlVCS01YdktVV2pxV3Z3dHVONkRJSFhwbjYxbkhWb1ZWUVZCeU9SNkVWbVhOektVVlRIOHVNZW85T2FaRXRxMGVGWDBPTWVsUloyUFFWVmN5dTlFdGpWa250cnFHVjR3TjQ1d1IvaFdUcGR0ZXpQbVNUaFR4MnBrVnpiMnM2cVF5c1NUOTA0OXpYYndvWkZEeEhIQnptclJtdVdwSy9WUFZKbWJMZG1HY0t5ajJyUGwxSm1sVlZPRkpJOWV2TlZiaTdrKzJpSjQyNjRCQzV6NjgxUnZJRnpnTjZkT3g5YU5Mb2lkUjhzclBaNm82NjN0NFlvaTRRRm02Z2pxVDYxYjNXc3NUQmsrYkdPbnRYRDZlbHg1TG9QbXpqcWEwTk5tUnNpUmNISkdBMmM5cUxXdU9uVmI1VnlwSjlEazd5Vy9zM2thTGN5NHpnL3BYVCtIZFZudldkTGlFREhUUEdhNndSV3ZsY0tXUFQ4SzUrMUV5VDRFVzBjNVBzYXJTMnhNYU1vVll5VlI4cmZ3N282Qzlzd2lreHRqR1BseldXclNOQUE3bGV3T2Y2VnBYKzQyNCtmQkE2SHFhcXcyNGx0d2pFZytwN2tlbFNka2xlcFpKcFc3bVU5bTZTQW1Rc0NPRFUrb3lzMGFwdTY3Um5OVTduUzdpS01GWForZUIweDlhZ2p0eGNwMFlNT001L3p4UjBPWnFTYmlvdFg4eUp0TG1nVVNSU0RjY2s5ODFPOEYwd2pZZ2hzWWJCNE9mV3JPbmVlaFpYWGhUNjU0RmE5eGR3QURkMTZDbnFDcHg1TDZ4VDZYTUxlMFRJR1FnNUFPVG5tdG1TK2toWU1COHB4MDdjNDVyYXRyaXdsaFp0bnpLTVk2MWhXK3EyOTVOSkFJeUdROTF4K1ZDUnZwRkplMFY1ZkN2UTJFbEpYSlVaSHFmV3VmbW1oREZSOUFNOG1wOVFsTnV5Z0FIcGtNY1Z6d3RaYnU2Umh3TWo3dkdQeXBvbXJPU2FpbGQzMk5NUk1PVks4ODhtdVBpdU5ZVFU5aktERXg0T09PZlN1NHVvSkF3d09uZnVLaEVpbVJTVkpJUFQyOWFwUFRhNXlWcVRrNDJuS0RqSmJkZlVmY3FZNW93UVJucU94SXE1Y2FQNXNSYmRqQTdIc2FyNmlWWUk0eUNlbVR3YWpGNlk0OGx6ZzUvOEExVkRPdGV6VXBLU3V1Zy9aZlc5c01OeHdPZWVsUlcxN2ZPcmxrTGU2OGY1TldoZXl6d05rL0xua2RLa2l2RXQyQlk1d0FTUjZVMTZDWEw3clVta2tjZEJmNzlRMnVlU1FCZzR4ajFydnI2N0pqVUFaSUgzZ2E4NjFQVm5odlkyamdCR1JrZ1o0UHJYVHgzOFYzakNqUFVIUHAzK3RVMVpJd28xb0oxSWM5NVg3V0xjVnFqUnEvTzRkUDhtdEg3U3NhQUViYzlEeGtmalhMWE1sM0FjeFpJSkh5bjNyVDJtYTJWbkdEMHlQVVZKMlJrdFVsWnBhOW1hS1RTU1BnWVB2NmY4QTE2dUpGY3lFNGpPQU1jSHQ2MDIzRWZSRkozWUpyb3JhZDR5Y3IxeU1lMVVid2plMTJlZlhFRXFYSHpZSUE2SGpuUFd0NVVqMjhLQVNCZ0hyaXJHb0x2Y2tLUFhwbXNCN2hZeTI1V0JIVEhUOEtUTXJLTGZxUlQyY2tveXB4azllZUFLMEYweEJCZ3NTQVIzcXJaYWpLd2tEWTVIWEhQNDAzN1JjQ1Y4NDJqcGpyVkdhVkorOWE5eWxLaGdSanVMWUJ6ajBxeERkQXhxUWRvNmZYNjFaYWRaQUVPTWdjY1lQUFFVVFdJOHNoU2QzZjYwRFNYMmVuUXk3aFhsY0hjU0JnSEdPQlVFOXZHQUNQdmV1Ty92V2FzVjFGTnRKd2ZZY0Q4NjY1Sm9EYUVzMkNQeC9PbmN5VFVyM1ZuNW5IcmRTR1hhd0JHT3ZwajNxL05HeU1ERSswRW5qR1IrZFNMYndTUnNTM0FQUTljOWNWbExxVjFGSVkyVlNveHovQVBxb2VwbEt5WHZQUjdNb0MrbldUNTQ4akh6REdUMTlhMm1hMG1od1ZIc004ZlhtbkxMdkRQSWd3b0dmZk5aeGEwbUJTRlNDRDA2Q2xZd2FhV3NrNzdKN210cHNNVHVWWTRZanR4VzNOR3NSWTRPQjF6OUs0dlRyZWVPY2tnOVQzN0h2WFkzZHdxSUQ4eEk0eG5yVXZjMXB1S3BPNnMwUVhZSnRrMlA5YW9xSXRtUWczSHFmZW0yamZhZHdESEdDQUNQZnZVa1ZpWXBjSCtMc1RVbDNjN05MUm9rc1BMa1J4Z3F3SnprY1ZCUEdaWTJCWWJnT3VNNHFyY1hVVnMvSTI4NCt0VFFTQ1pNbGgzL0VWSUtjZmhlL1U1QnRhV3hrYUZtTFp4OTRmMXpWNkdDT1dVeWgxWGQyem5nOWVsV3RRdExSd1JLQWNOeC9oU0pacXNPWWlvMmdlL0k3ZlNxdXJIRW8xUGF5VHM0cXppdXFGbjBPQ1REWURaOTgwVllzNzJmRFJ2SG5iMzZpaWx6U1hVMDlqaDVhOGkxOGpiMWpVTHFDWnZNRzFWeVNDT2NEMHF4cGVwMjJvc2pwSTJVR1NDT09QYXI5L2JpNHV2TWxqTzFUeUFmU29vZEh0WUxwcG9Zd2lzT1FQNlZlaHZhcjdadGF4dnFudjZsMi9memJjdEd6YndlQ09PL2FzMjJGMndLeXlFTm5nazF2SUlJMDNPZVdPY0huSHBtbzd1SjVkclJrS0Izd092ZXBacTRYbHpjemJ0ckZHUTFwOW5rSkcweUgrTEhQL3dDcXIwZHhGTnZVNVVqUFQ5S3czZ0VZTHRJZHc1eUQweFdGWTNkMGJ5VStXZHZYT09EbjM3NW9XcU1aeTluT01VcktYVGM3Y1dOZ0YrWDd4UFFuMzZWWnZsbWpnVFlRTThWVmpFSkt5TmtOMEtqcm11STFLSzQxQzZBKzBTUm9weHRCNjRwYmxWS2lqQjhzRTI3SkpPeDNxUlhhRkNyS000eVQ2ZTFZbHplWER5ZkpOdkNkVkg5SzUrYnhOcE5pcTI4a2p0Z0FjWlBXcjBGN3BNTm85d200QnVwTk96dHQ2RU9yVGFTalVTdHJMM3RySFJwS2x6RUY4a2c5QVNQWG5JcDhkck16cUhISEdCN0QvR3VGc3RWaWFiSWZBYkpBeng5Yys5ZW9OTzZXNVlNQ1F1ZjhtcHN5NHVFN1N2ZnZZenBMcVFYZ2pDbnA2K2xVcGJ6WERPcXdydGpJR1dJeitJcXhZM2ZtU2I1RTJrbnZ6bjNyYTFkV2F5SmlPUUJ6ajJxbzZNNk5aVTNKVGFXK21qSFJRenRIbVZzbkF4eHdEV1ZGQS8ycjk2UnNCNDdrWjRyQXNMNmQ1eEFJV1pjWUwraHgwTlR5SnFWdk1TVkRxVGtkdndxV3RTSFZUakdTaTJrN05uV090a0NJOXdJNm5uOWNkcXhkVzB4SjE4eTJsSUs0NVUvcFhPUWFSZlhOMDB2bUZWQ2tFRSt0ZGRZdzNOcTJIWU1wejZmbFFLN3FwcVZPMFgxUncwZHBxVWlIQkhVOGtmeUE3MTAyblIzdHRONVhKRERra2pqOGEwRmxTRzhKOHpLdC9DRG5uNlZxeHpXclhETXpiY0hqaW14VTZNWXROVGttbnJxWTl4Y1R3M2c4dUlGTVpZOVNjZHExRzB0THVEY0lnTThEajFxdzhWbkxnbzdFOVJUVzFDNHMxQzdmazR3VG5tcE91MFBlNW5lTC9BNEhWTlBhRzdnajg4SWg1SXpnOFYxQTA2T0tSSkJKbFIvZTZaRlo5NWFXV3JYRWMwaEpLSE9CMS9HbVhrOXg1ME51bHVkaWdEZG5JT1BXcWF1am1wZnU2c3A4cXR6TGtkN3Y1blQzOTVQTGJpQllWUkJ5VzRIYnRYbmNkbmVXc0xQSGw5eDljNE5hOFVXcVNUTWpMOGdISGV0djVyYlpFMmVTTWRxaU1lV05rdERweFZTcGlhbnRLa25kYUo3V09BTUdvSmRwY0tjS2M4Yy9wWFh2dGtFYk1wR1J6L2hWT1NTYnozUUg1VDBCcldhRytDSnRIQXh6VlBvZWRDTnVhM003dlhycWJrZDM5cHR2TGpCUUFkVCtWVFIyRUtScUpaTm95Y2ZOMXFNWGx1OXVVeDgzc3A3ZTljN0xhelRrZ01SajlQOEFDa2Q4dW0wOURwTlJ1MGpnQTNFZ0RqQXlhNUNhN2pualZHQ3I4cDR4enpYUHhTM01PcHhXOHpseXdHRDB6ajFOZEhKcGR5TG91dUhUSENubnJWTzZPVDJrNnZOWlBkSnJzY2RIYStYSktFdjJ5VG5hQ01qSGNENlYyVVhudEFxRVpmdG5BSnhXUERZeEpkTkxjUnFyQThIdU0xcVR5VzRaaWx5b1pCd01aNlZOOVRPbkRrdTNwZDdYNmZNcVQyMHNlRE5iN202OGZ6cGtjbUdMYndlKzBkYTVtVzl2WG1iYTdaUEdDUDVWZHRySXdGSkhsWjNQWUR1ZXROa3Fwek44c1h5cDZ0bk4za0hpQyt2ayt4djVNYXRna2R4WGJHejFTelNLYVdUZWM4NDQvblZuVkwwMjZSeVIyeGNEcU1ZNTlxNk96djR0U2hLdkdVWUxrQWpuOWFkN3BHMEtVT2VjZWVYUG8wOWtaSUNTb1oyZkFJeVRYS1d6SkxleVBiekIySk9WQjcvalcvTE5JZ01iS01BbGNjY2oweFhLNnJwTjliSWx4Wm9FWTllT0RuNmMwSkxxYzlSelZtbzNVZFpkL2tkZmYzMTIxb2Q5cndvNlk2aW85SDFQVEgrV1NQWVFlblNxYjI5OVBaV3dsdU5wUExnTi9PcDJtc2tBSWp5UU94eG42VW5ZNkZLZnRWSzlsWmZFbDE5RHVvZFd0VE1VQkRBam9jMXhsM05EbWJhQ0Rra0RwdTl4Vk85bXRMYU0zU1FNV0MvY1VITmVlYWI0c054Y3VqMm9UNXVweVR4N1U3TitobGlNUWxLTVp5Vjc2V1hSN0hjVzE5aFhrMkVzbkFHT3ZldDlkVXRXaFNZdzdjOGtuanJWaFRIZDJwQWhBRERyampOWUw2SkxKQWtFamxVQnlDT2NnR2gyTFNxcUh1dm1UV21sdFRBdU5ZdTNua050YW1SQWVldmNWdTZkNGxzR0xwSzNrbFRodDNISjYxMmR2YVdOdXlKbk9BQVNSWFBhL3dDR2RNZUxlc0p3eHlTQ2NETkM1YmJDOWppcWFjMVVqSzI2ZjZXTjJYV3RCdUlSRWx3akhqaklKcUczMHF5bmpHOWdlNC9HdkxiRFRmRE5uT3BPOFM1eU01R0NLOUZobWhkbUViNFlBY2UzcFF5NmRXVTIrZFUzMHRGL21aOTFad1FPQXJGZ2NET2VtUFN1anRKcGJhTjI1SnhsVG5uNkNxQmhpTEtYSUI5ZTJmV3NsbDh1OUlONW5BNGp4akk2OTZMYUM5Nk1ycGJ2UzNReExtOTFHN3VadDBlM3FBU09NSHBXcnBNbDZtVXU1QVU1SHIrVmRrbGlzOEJMb0Z6MElIV3VBdXRLdjRMOVZBRHhET1FjOVA2VmVtdXh6U29WWVNqVWNweXU5ZGUvZEhVM1NXRVVJWkR3Y0hwMjlxdFdPbzI0ZG04d1lBejljVm5DU3hWVENjRnNjZzVPY2VudldGZDZyYTJ6S3MwV3hCZ2JnQVJ6VVhPMXo1WlhVb3BKYW1oZmF0YlhraW9yNVlIb1B6NzFKQmR4eFFzWFZsWURqdDFxdGJXT25TWEFuaElMSEpIQTcxMEEwNjZ1REo1Z0FYc0NCVE1xYXhEdTVjcmsyN1cyc2VYWGozczB3WU0yME1BTWNZK3RlblEyVTA5ckhJU01nZFQwcm1MancvZExjaVMydUF2UWxTQVNlK2VhN1NacGJUVHh2YmF4SFE5S0xiRVlhRTFLcnpxVmt0NzZNeHBJcFJqREVoanhrMUhOYTNBWkQ1aCtZam4rdGIrbVJMY1dyTTh1NG5rSG9QeHF5bmx5SHlHR01ad2V1TTBlUjFxQ2NiMzMyMU9iSWFCRHRPNDR3Y2M4Vlh0SUxxY1pVa2srbkg0MTBuOW56UVQvQU41VGpuajlhNlczYXpUZ0VLY1p5S2pxVXFEazF6UGxTNkhuSjBLemFZTk11MThja2ZYcHpYUXhXYXd4dUluSUp5QVNLeGRYaHVHdUVaTGxRcDV3VC9oV3pack5Db2NzSHg3azUvOEFyMVY5RVJDRUl6Zjd1M21Za0ZucUpka3VXM29UeGtuZ0gwcUZ0TFczSG1SRWtaempPZndydHJGSGxlUmowSkp4enptdWYxNTdxMmp6YmZNeFAzUi9JMEpzYzRRalNjbW0wcjY3c3hwNU5RbWsvd0JIdGlUM09Cbkg0MCs3MCs2bDhwcFl2bUhVZHFxMk9wM3RzNGFXREI3MTJGbHFwdTk1WlRnOEgyTk8rbXhFUFkxRlp6ZDMwYUhRb29pUlNSZ0RuMytwcTdlU3JGSGc4L1R2L3dEWHFzejI2bEkyQklQT2YvMWQ2MG9ZNDdseW9YN3RTa2RxdTlFMWZZeFo3NzdRaUx5TnVNZjU5YVQ3ZmRiSTlnWTQ2a2NuL3dEVlhWUDlnREZTbklHU2NlbGNtbHdJcno1VnluYm1pNHBjNmVzL1ZvMWpmU0k0OHpPRzl1UlVjNk5NNE1iRUFrWnh3YTNGU05zT1ZYUEF3ZmVpNGx0N2ZhN2dBNHdLbzZIRjh1c3RDbE9XZ2lVK2RuSjdHb3JHZWVaWFU1Nit1S3NRVFJYVGJpZzJqdGowclpTNXRSR3dSQVBmSHBUVEtWbTc4K25idVl6R09CanZSanV4ei9udlhKYXRaWHUxbmlsMmxsR0s2K2FSWmRtU0d3TThqdDYxV1crc3BGWkdaUXlrQUFuSDA2MG1SSlU1SnhjclgyNkhuK2o2ZnFrU3NKN25lYzhaNHJxTGkzY3dGWEFiUDUvcFdQTWorZnZVdHRHZTFkQmJhcFlHTGE3SGc0NmZrYWxhczRxU3BSanlYc2x0ZDN2OTVoN0lHZ2FQWXhidmtkS2tzR1NCUUhHT09EMDQvd0RyVjE3eFc4YmVaeHRaZTRxcWJLQ1VNdm03UVRrWnAyME9oMG5vMWE2T2J2bzd4THBKcmFRbFFPbFRMRGRYT0hZZ01CMEEvUDZWcEcyaHRJR0xPVzI4Z21yVnRld1BaWk9NOWpTUm1vcFMxZG05ZVc1eHE2WHFNZDN2U2ZDOTF6amdkcTYrMlJZZDVrakxaem51RFQyZUZ4OTdCOWUxT2lTSUVOSktOcDY1Tk5JMWpUdEs4Znp1Y3hKY1R3djVrU2ZLVDkwOForbGREQ2l5UmlWbElKSFExbTNzWU42aXhPaFU5Yy80Vm1hakxxVUxnUmtCU09Sakg2ME14azNUNXJwdTNSR2l0eGNHU1FMRUFPblQ5YTVDN3V0UmlHRmNjKzI0NTlhMzdVWHF3czdzRkJCejZmalVkcHBtWkRJSlRJUFlaSDRVN2RUbmw3U2NZcE9TYnZyZTFoOFZpSjRON2tsL3A2Vnk3MkdyUHZVREF3U3A2WTlxNks3dnpCdVFBTDJ6bitWVmJWN3RpWGFmZzU0QnhROWdmSXBKYTh5M3NjL1lXT3F3dnVZbmc5K3VhNjFsbHVFZFJQOEF2T2c3OCsxVmJpWFVVbjI3V0t0eVNCd09PRFRKUkVqaVNOdjN2VWpQK0ZTb3BKSTFxMVoxWlhuSnUranZwOTFoTENEVjBSMGx6a0ZzRStsU20zd1R1Kzh4NkRvZnBtdHlGcnMyN1N1M1RyM3o3MXpEMzBqTmwwd3FrOVJ4eFZFY3NLVUl4NXBQemJ1YWVvYVJIYzI2czR3UitOVkxlNnRvZ3NVZVFSd0FlQ2NlbGJWaGNDVjk3T3Uza2daelJNc1VyRnhIamJ3dWUxRnZNYlVicVViSnZ2MU1XV1ZXSlpueTR6aGU1eFZCdFhqdXYzRWpCV1hPQjNybzVVaGtSUmdnbkhZZjFyQWtzSVZMUzdRU0FjajZVakNvcXVuSzE1K2FMMmwzQ3BJVU9HMm5xVjlQU3JGemN2SmNMaVBIdWY1VmdwT3NqamdwMkpCNlk2ZGE2U1N6RWFDWlpDVGdFZ1ZMWmROdHg1VnJaM0pMZFl2Ty9lY0Q2ZGExWlV0WTFMcXU3SXprYzF5dm5oc2hpUmtaWGp0U1c5L05zYU5WTEg2YzU3ZmxUUmZ0WXJTM29kQllTck1XVlFPdnB6Z1YwOGQvQWl1a2pxU0Flb0EvU3VIZ013QTJxUUEzSkFySXVyQ1NTNkRPWFBVay9YMHFreS9iVGpGV2pkL2Nqb3JpSkw1NUJHNm5CQkdPeHJ6N1hkUHU0WTR0c1daQWVPL0h0WG9GdGJpMVRkRVd5QjM5cWh1THBwb2R6TnUyOXU5SlM4aUtrVk9uUG0wayt4eW1uM3R5MFNSdXJLQjk3M3JzNUk1WTRBZklEQmgxUEpIMHJrSkwrS2FKaXNYekprY2RhMzlIOFFLNEVVa1lEZEZCSCtOTksrcG5TbEJKUmxVdmRhTXdva2xGMHpHRUtPdmNIUDhBV3RTK21sbmoyZDhjZDY2KzZudGlCeUFTY0FIak5jM2YyTUVheHVaTWUyZVAvd0JkRnRUWDJUaENTVHV1dlF3LzdQU1FBdEt3MjQ0NmpIMTcxT0xheEVoRzRzUlhWclpXTnhicWQ0empuSjcxeU9vNmNrTW1ZNVZmSkE0T0NLWk02WEtyOHNXdE5ibVhkNm1JM1pTdzJZNVBUR0swYmFhSllGa1Q1czlzY2ZqVkp0T2dXRXZJQU4zQjQ2ZXRkSmEvWUVzRkVUQmh0d1FLVmtZeGpQbmJjbHRkSE9HT1c1bERZMjlSZ0huOGEyTHk1dXJhRUZNOU04SCtkVUhzSGxIbVJ5YlFPdURYUVdGcXpxdm10bkhRL3dDTkZyQ2h6TjJzMDM5cTV6ZHRxYzF3Z1owY01NOVIwcTNiNldza3JUTnkyT2NjVjFENmZFMC95dHdSMjkvNlZ2VzlyREV4RGJjRWNDanFkY0tNcE5LZG5aN3M0Qko0b1pHRElBRDFQUVZZT25RcSs5WlZHNzByck5RU3g4bHNvRGtZVWdWNXk5bHlKWXJnWUI2RG5wOUtMSW1wU2NKTFNNbDBzN1dPamt1bnRFUUtxdGs4ZXByUUYwNWlEbU5seVIvRCtsY3JlelhPMk40WXQ3Y2JzaklHUDVWM2tWd0pMQUdTUGJJRkdlY2MwTTFqYm1hVW1yTGEyaHd1cE5mT1I1ZnlqUFZ2NlZ0YWNqc2dWd2QyRG5jYzR4UUwyT1NHVlFuekE1SFBXb05KdnBHY21SZHUwOVQ3ZHZyUWt5S2JqenIzbTdvOUNlMWorekJkdWVPdWE0YTljMjRCQ3NPRGdoY2l1a2ZWNEZkRklBUHA3aW15ckJPeCtVOCtudlRPMlhKSy9LMWRhSG4xdnFUUlM0YUpTRHhsZW8rdGI2VzF2Y3g1dzQ0SndPZnhxY1dRaWNmdXdRUFRxZnlycDRiZEdqeHR3ZVBZZlNpNWhDbkxadTZYU3hpMnNGcmJvYzg4YzRIVVZpUzNXbXdYQWRWVlNjOXdNWjZtdFlKZFJ6T0hqT3pjY05pdWIxTHc5QmRTS3dBUUhuR2FMYmt5Y2xGY3NGbytwY3ZiblQ3Z0w4NGM0NDV6K1ZSMjlyY0s2c2dPT01jWXJIaDBIeTV3eXVDZU9SMEJyMFY1MGp0Zm5kVkNuQi93cHJZamxjMjVTVm10ckVMS2p3bmVTQ1FBUFdzR1MwamM1VE9RM1RQTmFjVUJ2RkRxNHdNa0VITlNXMEVsdk5rak9lcHozcFdzYXRjMXJ4MDduUDNkdTdJa2U3blBmblAweFhQTnB0NkdQM2duWGIxQjk2NzJaMGVUY0d4Z2tuMC9Dc3lXYVpKbTJwbGNlK09mclFudVlTcHdidTcvQUNQTzU1OVNVdkV1T2hBejBIMXJmMFcwKzB4WmVRYndNOWV2YXIvMk9hNDh3am94OWV1YXAyZW5YZW5GMnowNkJobjNOVzVhSEhDaytmbWQ1THN6YnU0b29HR1ljbklHNFZpMjJsM2ZuZVpqWXBPU0IweDJGYWRwY1JYa2hIQUlPT1IycmZtU1lnTEd3QXdPZlhGUmV4MThrWis5clpiSkZYeWlCbGhudjE3ZmpUR3ZJNUJqeTE5eGlxMDhMQUhZNFBHY2lxdGxDeWJ0elpPY2pQdlJmUWZOTlRVVXRPcGJqbkVaQkNFNU9QcFhRUTNFampKWEE0OTZ3b0k1SmQzQklQZkhYdlYxN2lPRzN3bzVIYnZTTGhLU1YyOUNDNXVmS1l5RUE0N0gzK2xZazhwdVFTbzR6MUZVbXZmTkhLWTdaQTQ5SzBCQTYyNUtLVDdEMTY1cTlERnprM1pheHRjdngycmlJQkNSNzk4SHRVa0VGdzBoamNjYzl1U0t6N083a1YyYmFTVjZqL0N1NGd2VW1ZbFVIQTVGSldONDhqUzF0NUhHMzFyNWJxd1hwalBZZm1hdWVZL3lzQ01ZNmU5YkprRSs1RGpPVHpXZERha09GMjkrM1FjVWlPVzByeDJsK1pnVFM3cGM3UzNZRWMxbUxMQklHVGZ0em5QMUZkKzBGc1Y2WUhIYnZYTVBwbVpDQU1BZFNlQm4vR20xb1oxSVM2YWxSRmpkTm9sM0Q2WTQ3VTQycEQ4UnFTTWpPTSs5S0xhZFpGdzQ1WWZKamcxMXNYMmVPTWIyQXlPZlROSzdzUkdEZWowOHp6V2E5YTMrUjBBVW5CSFQ4cTBZTEd6ZFBQREVibDdIOUsxTlh0YmVhSXRzM2Q5dzR4aXZQbFc4QU1VUmIrVlZjNTVxVk9UVWx6cTE0NmFuYVJXY29aanpqMHoyUGZtcmwxWkxKYjdXT09lT2VtUDYxakxMZlIyOFM3eVcyNE9mVTByenp6eDdjZ0VqOWZyVTZscjJlM0s5VnN5TzBndUxWeU4veWs5U2VtS3UzRWhsSjJ5YnVUMDVySzhpZVdNUWwxTGUvV3RxdzBtNHQxZHpqcGpIK2ZXaG8wcHhhZktvdmw5ZGprSGhNOGhVazdsWTlzY21yZHNKMFJsRGc0SkhIWGdkNmoxRFRyaVM1OHhISStiam5qQjdWMGxuWXl4Uk1YK1hrOUJSWXlqQiswYTVYNjl6enZXTExVY3F5RisyUjF6bjFxUjIxVzMwNE1NWnlNajI5cTZqVXI1NG5VNUpIYXNPKzFkMnRoOG13SEdRUnorVlVrN1IwT09yQ2xUOXMrZVNrNHV3elNycWU0dHkwaXQxNElKRkZkUlpXQmUyU1JIQzdnTThmNFVWazl6c28wYXZzb1hUYnR1ZFZQZXZGWnM3c0dCUEJQRloxeHFXcUxCSDltaDM1SEl4a2RPZ3JYdm9iUjRQS2NIUHR5T2xUUVhGdGFXWkFYSUh0MHFybTA3eXV1ZHhzdDF1amk1TG5YcDRsTXRyR01FY2NqK1hlcjJOUWV4TzFTckEvZDZWMEYzY2Fna2NMeEl1eHlBMmZRK252U3gyRXhsYVh6VGh1eEhGTzVoR2hkdjM1eWR0VzlOTzVsUVEzbHBwankzV1c3ZzhmV3Vkc3RldExvNWlUQjZFWTlhOUlsUnBWYU9VQXFBZXAvcFhHUk5wRnJMOGthaGdmWUhOVG8wd25HZE9VTFR0QzFuZmNtdDRwVmx5emI4ZEIwL2xUN3FaR2JFbHVFeWNaeGpJOWVLNldBUnV3bEdCbmtEUElQMHJFdlQ5cUFSU0RqT1QxNytvNzBGeWhhRms5K2oxdWNYcUZucHp5Q1ZyWVM0NHhnbkdQcFhWUTJzY2x1RkVDcW82TDIvS3FGbG83UlR5WEN5NUFPTUhvRCtOZE5hWFVSYWJleDNLUG9mMHFyNkhQU2d1YThvcU4raHk3dzZTWENNQ3JLUmphTWM5SzZHM2ppS2dlY1NBUGxCUFhIU3NzV05wY1hmMmdObi9BR2M5Q09nLyt2U1R5eGwxS3dGU0R3ZTNIMHFDdVhsbGR4ajVXNm8zTlFTM2d0bmVXVUtBTTQ3OVBTc3ZUZFlzbzRHQ3MwaWpQQTYxNXQ0Z2tudUxxSVJ4U08yRDY0L0d0dlRiVzZSVUR3Q0hKQUl4MkhQNDFkbHk3Nm5OTEUxZnJOb1F0RksxN05tbmVQWXpUUU1MNTdjQitWSHZWOUxlK2p1M2R0UVZyZkhBeno3R3R5NzAreGtSR2FKSEtyMTROZWUzMHR4SXpScmJzVXh3UWNWTjlORFdjVlRxYzBvMzFUOTF5VjdkN2REM0IvQzJxalRQdFMzaU5HZVFvNDQ5Yyt0ZVlqeEZiUlRHMnVTVTRPR3gvS2wwdTY4UkxhZVdkK3djQmM4SEhUOEtzeFFXZDFJUmRRS3N3N2tmcm1vanpLL05aK2g2dU1xWWVyN0Y0V2xLaTdlOHB0eVRIUWFGQmRUTk5CY3RrODdlbytsVnJxNXVyTzZTTjdjeUtjNVlEcDI1ckJrdTVkTXVkc0EzcHUrYms4VmV1TlMxSzh1VlczZ1YwNUxkaldtdlhZOHIybFBsYWluR2Frcjh1cU52Vm83a3BISmJ5K1d2WGordFVvTDY3a1Q5N0x2VmVDTVk0SXJYdGJUVUpJbE0wWTJqZ3JqRlY3dlIzWXJKSGhWYmtnRUhJRlNqc2xUbmR6anpiTFQvQUlCMWRzOWw5azh3WVRQZm9PUHJUOHdLaDJ0dVk4bnB4ajZkNnludG9UcHdpMnNwUFU1L3hxS0M2dHRQa2pqQ001UFU5ODljMFhPbm5sZFhTdHlxNzh5OWVUVDIwYXpJNUI0QjdkS3BpL21ralZ6RmxmN3hIVTFwWFdxVzg4SVh5T0JqQTZuSnJpa252Z3NwWlFJK2NLdlBORFpNNXBUOTJiYWEyUjJFWnR4R1pXakRFZndqalA4QTlldU9uOFZTd2FwRkY5bWRVWWdENWVQVHJXcG8xdGRsV0xLd0orNkc0NDlxTlMwb3p6UmhwTmpqN3ZIcFJwMUltNnpwUmNGeXU2NmJuVlhONnlPdmxRcUZJSkxIcU8zTlFHQnRqU2k0NVljRUhnY2U5WVVWc2tVWmplNUVrZzZqT00vU3RlUzB0cm15alh6V2pJUEJwRzNOS1c2MXRlMTdXWmc2ZFkzRDNlWjFXUitjUDF3SzJiMjdGdEl3UkdKeHlCL1N1VDFIVDU0TGlJVytvOS9tVTkvV3VoOG1ReE14bXl4SGJuOGFaendiU2xIa2FhZTkwN21UYmFSSE9wbW5tYmVXemoyL091aXRkTzBwVVppZm1YalBjMXowdWdUM0VDT3M3YmkyYzlPdFFwcGVvMjl5WGt1QVkraEJ4MjcwcmVaRm5HVWY5bjAvbTMzNmwwWDFrMTVJbTBaSEhwK05kR0JaaVFnYlNRTTRKemlzcWJTcktkTjhKVVNEbk9PYWpUVDdXSnkzMnNISUdlYUdqYUh0azJtb3RYMFphYTZzcmh2TDg0RWhzYlIvU29OUjIyOFhuTGxTT2dXc2k0c1liTlRQWlJCNUNlY3Q2MW9pNnZUYUxKYzI2NEEvaHBNRzM3eWtyUHVrN2ZlYy9EY205czQ1WlkyU1hQNi80VnRzMC9tUmZ2ZmtBNmZTc2hidTQxQ1pvWXJZb2lqaGlPNTdZOXE3Q095OGkzVVRZRzduSTYwYTNNYVM1bGROdXlzNVd0ZG81dTUrenRLMjl5R0E5T3ArbEphVzdHUU84ZVU2REkrOEt1R3drU1RFUkRBbmduay9yV0RMcVd1MkYwdm53cjVBUFZleDcwL1FtVFVIZVNsYSs2Vi92OGpxTHk5VC9WeFFnQTlqM05jQmRSeVF5UjdyRGZJNUh6RGlwZFhra3ZJa2xpM3hyL2VYTlg3VzduaGp5ek5MbkcxU1A4YXV4enprNms1SnRwZlpra3JmY2RicHZuVFJGQUZVako2OS9TdWN1UnFNV29xV21QbGdkRHgrUEZkckQ5cWExV1NDUEx0OTdCQi9TdDFDajJ1MmEwK2NqbmpyVW5wZXdVb3BjMGsxcmZXek9LUGt6SXpKS0NlTVlPY0hGVjV2RUxXMXFZbXc1d1RWRzkwdlVSQzM5bnhoWGJxYzB0ajRkdkdqOHljanplcjl3ZnBtbjBNVzhSek9NWXROcldYUW9TcEJkMmU2WW9yRnNxQjFCNjArMzhsSVF6bG8ySE9SeDByclVzNElsMnZGMXpodmMrd3Jucm1DemptVGZQZ01TVlZ1TTU2am1rcmtTZy9pc3IyU2JlaE5mWDZUMjRFTEFzdUNTVGo2NXgzcHkyZW5TR0s0SUR6S0IwWW4vSnBvdE5ObUJFYmJlM0hjZCtsUTJ0cnB1anlGNVpzcE0zRzd0bXF2b0Q1dWRPYWc0dmVWOUkyMlpwUmF2TmNYQWhFWkcwOGNZNlZzYWdQSkFtZVFoUUR4MDZkcWt0cHJLSnhLRURLMk9SNlZEZFgyblhyT2pFNEhhbGZzZGtiS0w1cWljbTlMNkhOV3Q1WjdpNGcza25JT01WMFdvVzlyZVdvU1NGVnlPUjBJckVtMHk0YTJ4YXlyR1NlTWRoV1pidkpic0Z1Sm5aZ09TS2FNdWJsOTJVVlo5ZExha3NWakRieTRpT1FPM1g4YTE3ZTJ1cFVaZk80T2NZejF4VnVPMm12WS93RFIyS0E5Mnhtc2kwMFRXYk85RXB2Zk1UK0pEeCtWSlh1WDdOKzdhbkp4ZlZiV09XZUs1dFVrRW9kbURBZ2pQZnBYZFNUM054WklHaDNmTHdQV3VtYVNDUkdFMkFCMTQ2MCtiVVlZN1ZSRUZiUEF4MS9HcmJiQ0ZHTk9NdmYwdDh6R3NabzdhTTdZQURnWi93QSsxVnpxT2xmYlkvTWtLek45MVRXeGFrUmtHWHVhbnU5TXNMcTVnbkVhSEdPUlU5VFZVNU9DNVhIUnJScnpOT1JabVZtYkJRZ2RPdFo2YWJiSzZ5SzNEanBYSzMwZDBkU0FqdkNxa0hLOWNnVnBXN3VHWHpwZnVnZEIxeDZacVMzS01wdGNtenRlNXo4dGlzbXBPc2d3bjhKOTYwclBTZFJoYVJ2dEFhTVpLODVyVmxSdzdiY01NWkJQSnFXem11aXJLV0NuR0FNOFk5YURtVktIT2s0dTkzcWlsWlRiNzFjVGJjSEJYclhRMzhaalpkckRjVG5QQnJGU0swWldMWTh4ZlRybXNTUHpyclUxTzl0aTlqNmozb05VMm84dHJ1VDBzenFicTF1RGJzN0FINWV2YXVNdFk3eVBKQkJESGpua0gvQ3VvdXI5NFhhRUJuVWp0eitkUnEwLzJkSFZEZ0hwam1raUtrWU9wbzJuRzl6SWgxY0YvS01IN3dFakk5YTNMVkx4THg1Wkd4R2NZVUd1RTFMUzlUVzQrMXdUNFVZeWpIR2ZYRmIyblg4cGdJbkNrNDZodXBQc0twMjhqQ2xVbjdUbG1wTGxkNHUyalh5T291THlOMC9keEE1Nm12T05UdGRUZVdKb3BndTE4N2NEcDFyYmt1citMQWlqM0Fucm1uU1hyc0Fydy9NQVNDQWVvbzZsVm5Db21tNUwwMEk0ZGEvZkxGUEpncjc0eU85TjFYV0RLQWtDK1k1R01jL1htc1NQUVYxTzVaeUNqZE00eG44VFhXaXhtc0pPSXQ3QVkrdVBXbTdYUmxINnpLbkpQU0xla2xxekZoR29tSkVpYll4SXozNEI2VjFEdmR3cTRaYzU0R2U5WkFsa2t2RmRvbWpJeG5nOXF2VDZvenU2R01BTDBQc0tsbzNoeVJVcnlsMlJUc2pOQk96VFMvSzNRYnMvaFZiVVcwdklabVBQUWpuUE5iVnZERGNJUS9mb0RqOGF5N3Z3NWJ1cUdPVUxoaCtYb2NVK3duVGw3SjJTYTgzcWE5anFGcjVRajhrNEFJNmNmU3BGV3dFVWpDRUhIT0NQNjFML0FHZkhFb1FNdWVPL1FDcVZ4RzdXM2x4cVNXNE9PbjQwOUxtM3ZxTm1vdXkwMEZoMWlHZTBmQXlGeW94eitGWWJ4M0VxZVlDNHo5ZWxidHJhUVcxbVl5RjM5U0QxQi94cmxCckV0Z1hWMTNqZGdlMmY1VUdNNVdqQjFaVzAxdDBPeGd3MXZzbEhVZk1jL3dBaFhHUzJzd3ZJMlJ3SWdlUjA0RlVOUlc1dVFraVhBalFqcDIvK3NhMjdKYlpvMkhtSGdIcnp4VTZHYmx6dExsdGJhVjdYT2hsS3pRcnRjZE1rNTZrVnlEaDVwSGhYUEk2ampQOEErcXRLTFRIWkN3dVNGM2RBZng1cVMzMWV4dHBnaFhjeTlYeDM5YXBNMWNtMUhtOTM4Ym5KSFJ0UXQ3aFhlWmxWY0VjYy9uV28xMWVTRmd3T3dFODU2Zld0dTcxcUsrMnJHeXVCMUdldk5jdnFsN3FOc0lpdHFHaWY1V0FYdFR2YzRwUm8wdWVVSlNjVzd0N25QK0lZTlV2N1BGdGRNbXdESUJ4a1ZtYUJyMTdwRnVzTXBhUTg1T1A2MTZIYVJXUGt0MUhtRGNWUEJ6VmRFMEJwV2prWkMvSjVQQU5DYTJzWTFLYythRlNOUlJrVVlBTDI3KzBNMlY2bnQrbGJtb3p4SUZFSU9GQTV4MVBwV1RCcHJ5M0MvWmJvN1F4QkdPT1JtbmFuYXlvUkc4cDI3UUNBUUNmNjhVbmErNFJkUlVwdmsxYitMVFZtL2JYanpXMjFzSGFPby9tS3hvTEdkNVdkQjgyZXZwNzgvd0FxaEtycHRrWlVZa0JlZ0hweFVGbnIxemNRNzRVSVBUa2M1NlZPdlEwNW90MDQxRytaSzlrZW14cko5bFNLY2pmMFBPUHpyRmxzNDFsS2h1Q0FDZStUWG42NnJkVHpFVEl5T2hKeGpyNjRwZFB2dFN2THg0L0pZSVB1c1IxRlBYc040aWxKd1NVbmQyVzk5TzUxc2R1STV5bUNReHlPZUJYVG9vOGt4a2tic2tuRmNiZDM3YVhzKzBLVzNramdaNTlxcUR4RmE3R2JrNDU0K2JHZmIxcDY5aTFXb3drNHVWbXQxMlJ2MitqdkZOSTdTa3F4SjlldjhoVHJqVEpveHVobExBNHlBZjVWbmFUcWtOeEU4aXNDZlRQYXVoRTVWd1hJVGQwRkp0dDZtdEtOQjAxeXJSNnJYdVljbGpFZHJTQlFSMTc4MUc5aHFoUWVUSmxRZUFCbkFydmI2S0tlM1FxUjFyVHRKbGdoU05nQWVuUDlLWnQ5V2k1MmJ0cHVtZVJ2YVhvWlhrVWhqdzJPQWZwNzExZHMwY0xBc3AzSHI3RVZ1YWtaRlpaQ01BRURqK3RNRFc5MWJFeHFTNFhBK3ZyU1phb3FOU1ZucjVsRy93QlF0TGVJTzI0RHVUMHE5YVhsck5haDErWUhJQkE3MTVmTkRxL21UUjNWdXNrVEU3TURKL0d0NjBRMjlxc1VjYXFEMkZEdFl6aFVuN1Z0eHRHMnpWbmM2ZElvNW9wSWxrK1luT004K25OWVNhZGQyNDRKY1pQSHNmNTFhbmF4akt5cmRLajUzRUh2Ni9qVmFMWDBua1ZJcDFJSGYzRkt4ck4wcnBOcFBwWml3UWkzTzd5c0ZzaytuTk0xV3hFbHNraWhVd2NrOU0vald6RGUyMGdLTzN6S01nWjk2eHI5cmk3aWVHTUJRT25QcFZKbWMxQndrclhUMlNMVTJucGMyY2JpNHd3eHhuSXF3Tk9qbXRoNWpxMkZJK3RlWjIwOTFiM0hreW5qa0RCeDFyMDJIRFJIWTJkdzlmV2hzbWxVcDFHL2NzN1draWxKYkkwV3hYWmZYQjZWald0Z3RxakNTNjh3NC9qSFBQZXVqczdTNkVrZ21JSjlQNWMxeDk3cGhGd1M4ckRjY2NjNS9PbjBNYWlhVVplemQ5dDdXTjZHRVRRdXJFeUQyUDYxNTZZdFdndUNZSVRnbm5PQ0QrRlh0SHVOUXRMbVdOMTNJYzRPYzQ5cWdPc2FtYitUSmpVZHNkL2FucW05bWNrcWxLVktrNUtwR1hOYlJmNW10RHFWenRaWkk5cE9jakhUOHF6TFRXZnNOK3NkdzVQbWRDQmlubWU4dUxwR2FJbGM1QkF4K0JGZExkNkhiM1JqWXg3aU1jOU9EL2hVN2xwVkc3dzFjWHBjNDdXZFp1NExwWGlZbU1qUEFPYzEyZWplSkJkUWp6RTJzQWUvV3R5ZTFzRmdSV1ZXN0FldFdvOU0wMldJTkhHaUhIT08xSFRiVTZxZEhFS3ZKcXFtbXI4cGJRaTVWZ1FwNmRlb3JHL3N5VkpHOHNxb0pQc1FmeHFxaVBiM0RFbmN1U1JqMnFGdnRWd1dkSml1M2s4L2pSWTNjbTByd2JhZXlJNytiVXRPalhiRXpBbkhUUDhBTDFycmRPZHJpMUx5RUFrWUEvb0s1YVMrTFJDTmlHUEhHYzR4WFYyZUFnNTQ5Q2VuRkkzcHE5UnZtYlZ0bjBPVS9zMlFYelBIdUM1QndlYTFuRTJDREdGNFBPT28rbGI4dHhieHVIVENuazQ5L2VzK1J4THlHVWRPbmFuZlVhcFJqZTNWbkFtR05weVc1MjRJNTZIL0FCcjFYVHphU1JyKzgya0FmbUs0eUZJMW1rTWtlNEhrKzRxQmhHWEx4c1U5TSt2NGVsVWptcHRVNU9Wazd2VkhXNjA0UndxWTQ1NFBOUjIrb01FVExrWXgxOUs4N3ZJTDZPNGptZVJuanlDVko0NCtsZE5IYlcxMWJNRWsyNUhyNjFXbWhhcXpsT2JVWEh5Yk94bHV4SUJoZ2MrbmVzR1lsU3VTUmtIL0FQWFhNUlc5MWF2a3VTTTlDZlN1eGUxZWExM25nbGNnKy9wVXN0VkoxRTd4YWZZeDQ1ZnN4WndWSXdjVlR1a2U4dGlOKzNJT01WemMzMnBwdGpBSEJHQjBGT2gxSlZZd2xoMDRBR2VhRWM3cksxbW1sK3AwR2lXMXphdzdWbEw4OWU0NDlLb2F0ZVhyVEpIR2VjODg4azFzV056SEFDNWNFa2pLK2dOV2JtQzF1Y09vK1ljNDZZb2J1N2w4djdwS0x0OCtnYWJDd2hMU2ZleWVPd3lLMTRKWU41OHdZYjM2R29rRWFSRkRNQWYwcmtaM3VEY2JVY0ZPT0tUc1h6Y2lXbDlUMENLU3kzNFVqSE9BT21UMXJBdU5UQXVCQzZqWTNVOWdhNVBWSjRySUs1YzRZSEk3ZXRjcVBFZG5KRCs2SjNIa1o1Si9Pbnl0b3luaWttNDZSYWZROVZuc29FWGRDK0NlZ0I5YXpiUTNFYU1zc3BZWTQzY0d1WHRKYm1ieTNaMUJ6a0R2ZzFYMVRWakNoalZDMlFBRDE2bWxiV3huN1dITDdScHhSc1E2Zks3T1VicVNTUVQxNjFpWGNHb3dTc0RPM1hKeDM5cTJOS212SGhZWUNuSXhuK3ROblJwWndKWkdCeHdCeCtkRjdNem5HRHBwcFNUZm5ZaTAzVXJoQ1ltSmJPY0gwclhhV0tLNVV5a1lKNDdWajZwSkZwWWlsOHpobUhiSjZkNnJ6WDhXb0lvVmx5MkQwNjQ2MGhjNmo3cmw3NjJUUFJKdE9ndUxmZEZnRmgyL1Bpc1Mwc3BiVXNydGxjbkdUNjFaMCs2TnRhK1V6Z055T2VDUjdWek05emRtVmxJTzNuRzcvR2hhM095YzZTNUpjcnZib1g1b3BSZS9JNDJIUHk5YTZDQ3h1VWZ6RWZ0MzlhNGFPR2FJZWFHNTRKNXlmZW9ZOVoxRWtsVG5hT21PMVVZZTFoR1M1azAzcWpycjY2dW9wQ3lxQ2NuT0Y1elhOLzI3cUJZTjVCSVBPU0szck85bnVtQ3NtQ092NDk2Nk45T2Q5dzJrQTVHZXYwelNLNUoxRzNDcEpLKzFqQWl1WkpNTWVEMzdmblc5YjNxdGxXQzhkUm5PYTVHTUphWHBWcFZ5VDB6V2pjdkRFeXVwVTg1eDZnZDZOVFNMbEdOMjlVOVNlVzZDU2tCQmc4NXp3S2t2YlkzQ3B0YkhQYmlzR2RaTG9aVGNyRWNkODU1cWV5ZS9iTWNpc052YzhWVFhVVjNMUnhiVDJPaGhpajJlVytlbkxjZzFlaTA2R0lGbEdlZWhIUEhyWE13WEp0cm9wSzNIWG5rODBzK3AzVFhnUkF4WHJrOU9hUnE2bE5KWFdxZHZNWFZaSlk0d3lvbkp6Zy95cm45Tmh1Sm5KWlZIVWhjNXJxcmp6SGh3eEJ6a0U0cGJDNGJ5eXBRWXgxQXgwcDIwTVhGU3FKdHYwTWNXVXFYWjNFSG5wMC9Xcjl6ZlMyeUtGakk1NkhyVXQxZENGekpLVTJEbkpQT0s1dlY5YnNaN1pHZ2xVdG5BeDlQV3BkN29ibEdFWisvWjdwQzNkdzVqVitTQm42NTYxYzArNzg2M0VZT0dHUnljbjY4VnpWaGR2Y1E0K1U0T0RnNDVyU3RMU0tDVVNSc1FlcEpQSnh6aXE2bk5HcEp5akpheGExS0RXbHkrb2tTNVpNOGo2L1d0Kytzck9TTFpIZ0VZUElCNjFWMWJXWlk0eVJGdUlBeDJJejNxcm8rb1J5bGQ2amw4RGNlZWFyVklmUFJWUnd2ZHkxMU9zMHExL2M3V1lOZ1pQYWl1aGUyaWNER01EMU5GWkhxeFRqRksyM21jNURQOXVRdW9aR0F3M2FzWHpKSUpkc3hKajY5UWZ5RmRCcHpTWHJ1RVZZbFU1WS8zcTREVjRMeTh1amJ3WVlyanFNWngwL0NsWThDckp4cEtTdktUZWx2dEd6TjR6MGxJMWpsaWNLcEFYQXpuM3JwYmU5RXJpUldQa3N1UU9sWjlnSXBZVnQ3MndRRkRqZGpnWTcxbzNzTFJ4bElDQUF2eW1xMDZJNktjNi9KelNuR1M3S05tdkl6TGg0bzd4V1M0TzF1Q3VjNHJUdk5NczdXMyswaUl1V0FPY1pKeWE0bXcwMlZCTTE5TnU1eU05QjcxMEtYQ0xGRUk1VEpFQU9jbkgvMTZMR1ZOM2pKemdsZlZKNnRkTmh0MjhyV284dENqa2ZMejA3MXpHZ1NORk5Jc3pnU00yY2V2L3dCYXZRaExJN2Z2b1I1YXFmbUh2Nkd1Y1J0SnVwU2JWZ3NtQ29ZOEVkdTlDZWpRVktjUGJVNXFmdks2VVhwZjBSME0wL2xRTm1OdHVjOEQxTmExdHEyZ0MzWnBNWlZmbXp5VFhGMlZ6ZGFmSk5CY3Y1Nm5vMk00ejlLYk5wc1RGcGxpTEYvNE1ZL0Nsb2RFS2swdWFLVjB0WXlXcSs0NkNHODBxV1hmSHVIWGpzYXJ6M05wS0RJMlkwVmdNNDQvR3NpTFN0V2tRUnFpUmJnTUVDcUx4YXdrN1dzcW8wQUlPNERrbWdoMUt0bGVtOVgwanBmejhqcVV1TFFqRUxSOWVwNjFlbG1nZFFKbVZ0d0dBRHpYRlJ3Mmx2T1ZhQmxEWXlWenRxdnJGZ2JpTld0Ym9vUnlCVTlTdmF6VVg3cWJYMlVhSWduaHVaU2tzaklTY0QwQnFmVmI2OFNLRkxhMnlSeGs5YXpOTmoxdTNKa3lKRWs0eDZmNDEyRmhic1hmekN6TWM4WkdCLzhBV3FtN05iTXhwYzBvU2lsT0YzMVczcGN6Tkd2OVFrVjR5bTFoa2M4ZmxYSTM5enJaMUlxMWlXQXhoZ1QzcnVDWjU3b0tGS1liQUkvVDhLcjZwTGMyWUo4d3lzdjhJL3JRbXI3SXFyR2JvMjlwTktMK0xUOVJrUTA1RVZQTDJTTVBtSE9mZXQ3UzdhMGluSlVZVWpKN2c1K3RjSEEwazEySGRIVXk5TTU0UFN1cUR5UlJsQktETVJnRDIvR21aMHFuWGxTU2J0cGIrcm5aenpBaFZPQU8rRGl1YXVQSjg2T1FYbXhRTTdUVUQ2Vko1SU0xNGVlcWc0NHJOMVcxMHg3ZkF0alBzOURuSjY4NHBKSzU2RTUxVlRrM0ZKclZKdjhBeU54OVJHRkxLR0JPTWdkRDBxVkxLUnJsNUEyUmpyd2E1U3h1SVdrV01LWXlxNUNjMWEwOWRSa3VwbEVwUlFNQWZqMm90dVlScWN6aS9pdStuYzZLMDByeWJoNWZQTCtaeHNQYkhTcjRCaFdRRk56RHAvOEFxcDFwZHVrbmxQQ1FlZ1luL1BOYjdSQlZZeWNNZW1LVFI2VktFYmU3cFovbjZuUDJzV3NYVXlzeUNKUm5iOUJXbWJaWmlVZFFUL2V6ak5VQmRYa2MzbHlPZGh6dE9NZm5XYTJvclpobVp5NXpnQW5QdFU4aVBSK3YxRkJLVFRTdmR1S0xVV2dXL3dCb1psaElZOUNUbjlLMG5oYUVNc29YSis2Y0Q4aFhQWHVyYTNLWVBzOXZnSGt1ZU9Qd3BxeTM4OTFpNWoycmpBeHp6VHNlZE9yQnRxTUdtbi9MWmFraVdXbXd6aVdhTUZzSEJMZFB3cnBmS3R3TStXQ0R6aXVKbTBpZWQyaWtZK1d4NE9lY2Y0MXJYZWx6eFFyREZkTU05Q1R6elI4ekdtNUpTdlNTUys5czFKcm0zaldIb283WTZtcXQ2OXhjeXhBd3JzNmRNajhhaHNkTW50NGthVmQ0UTdoK1hiTmFrZXYyVTQyaU1JVlBVNEhTam9kQ2xlS1UzeTMyWG9VZnNzY1lJQ3FNam5IR1B5cmtwYkMweUdVNzhua0ErOWJkenJWcDlwa2hJeXBVL1Ayck9iWHRGMDJPUHl3SFhuSkh6WTQvU3AxT09wN0RyS0NTM3VYazBkN2kzS3hxeURBQXpSYjJGOVlRT3NyZWFvNU9SazFkc1BFeTNQRnVvY0RxUjBGSmM2azV1aUdkVUJJd0c3KzNOQ05mM0RVWnFWM3RkYkdwWjNkcThHWUlEOHh4eU1VeldMVnBMUUtYRVI3RWlsY1hYa3NZd0NlaWJhd1pOWHViTlA4QVRiZnpBRGo1VDBOYUkwcVRpbzhzOW10WGJRd2RIMDNXZnRSV1diZkd2M1Q2KzNzYTczYll6SDdQZG9BYzhISEJOUVdtcHBKbG81QXU1ZUZJNkNyMExXMGZ6VDNFUlk0SUdjWXozcDMxRmg2ZE9NRW95NWwxY25kV0tGN3BtbndRcEVuUHRWdDczU1liTUpMR2dLOEtDTUVrZTFRYWo1VFRSeXRkQk1jakI2Z1ZsM1E4TjNiZ3U1ZVFIdFNOSk54YzFCUVQyU2I2RmE0dGJpYUlHenVQS0o1VW1yOFAyMUlkbDNJSFBRc01jMWZ0clVNVUNXNUtEQno3Vlh2MnQ0cHd4aWNCU0R4M3Fsc0NpMUZ5ZC8wWTJ4dGJ4REo1Y2hZRVpYZFdRTDNVSnIzeWpsTUhHUGFyaitJb1VCTFNCQUJ3TWRUN1ZSdHpLc3J6Q1JaR2Y3b09PNHBHTGNmZFVadlI2NjlEZFcxdTRvWGJpWURvZzRyajczU24xcmw3YnkyanpnWjVOZEpCY1QyTjNDOCs1WTVud3hBemdWMmZpS3lpaGxpdUxHWm5EQUhGUTVKU1M2Mk90NEoxc0hVcWFPRUdsT20ycnUvV3oxUE03V3dXMnR0N3hiSEdRUGZIZXNvYU9sNWJIN1d1NEtjakdlMWRERmMrSWJ5OFdPU3pUN09PcmY1NzFzWHIzRnF3Ukk4am9jNFBTcVI1MGFkS2NMdUw1RmRXY2JYK1JtNmRiUXh4cXNBUGxxTWJULzhBWHF0ZmFiQklYZUJ3a3BIVHNUVzB0ekRiV2JGb2dHT01ManArZld1Y2oxQzNTZFJQQTZBODU5U2ZwNjBGU1ZMbGpGMi95L3lNS3ppMXExTWdta0QrNDlLMGRQMFM4dkxyN1J2Q2c4YkNNWjljWnJxcGI3U1hCQm1WSFlZQVBCckdtdVdodGdzTndkK2ZsSk9SN1ZOM2NYc3FVYlhrNVJqcjhXdHlySi9iOXRxUzI3UTRoWURES09COVIvV3VodUlwWVVZY3lKam5CNmV0WW8xUFdHUVIzSlVuZ2JoMHErYmk0czNqVFlYUi92a2pqLzhBWFZYc1ZDVUVtK2FiVGZYZFg2V0x0ckRGRmJzVCs5NDZIcnpYTXorSWRBdG1OdXFGWmY3dU8vcFZpT05MaTlhZUtZRWovbG1ENlZidUpMRlpGbHVMQUJoOHUvQUpwSnJxVEtVK1ZjcmpGSjJ1MXpYWHIwT2Z0emQ2a3JxSlFrWjRPTVpIL3dDcXRyUjdXS3lJajgyV1ZRY0hkMitsWDQwc1k1VmtoZnl5VHlNZGMxWW52WHRzYkZYWVRsajlhTDlqT01JSnFjbmVVZnRiN2pkUWpoVzZqSVRqR1JWU2E1bEFMTkVwUWM1cVJyKzN1TWJ3UUNEMC93QThWbXhDMG1hVkMrRjdleHBObTdrdDR0YXNzVFhWb0xKekxNSVZJNVk4Vmo2Tk5hVEJtUzQ4MVZ5U2VPY1ZWdjc3VE44VnJPcXV1Y0VZNjFhdEwvd3p2TUVPSW1CQU9CL2hUMDh6a2xPUHQwL2FVL2QwczNadHZvVzVMOVRLdjJlTElIVUgycVcrdmJXQzNTUzRrRnVjOVIxcXpQYVdZblY0cGdWMjhBTjNIdFhDK0pMUWFqYXFKRVlCQ0NSME9Qd3ByY0pUbkNNMjdOOUV0anBkSnZyYWE2a2FPOTgzSTZFZmxVV29hM3FubWVUYStXekJ1bWNISGZwWE4yVnhvc051SVVoWldLQWJ4MSt0WjhmaDViSlpMeXpsbG5rWmd6S1c2Z2QrZTlWYU92NEdFYWszVGFVOXJ0dUR2OHRUMGEzL0FMVHU0NVZ1Z0VPTUREZjV3YTRPNHNGMCtWOFR5RXYyejdaNHJjdDdwaklzNWprRXpBRGIyR09hNko3NjFtZFVlSUYySHpjWnFFelJxblVTdkwzbHRLWG45eFZzSjJudHc3dDhxZXZyOVJUWkxuWndWUHpOOTdxUHpxNWE2VFkvWm1pYVZ4dUo3a1kvQ3NyVTdtNTBtM1VmWnhOQ09QVWowK3ROcTdMZlBDbXBUMmpIVnJYVTZ5MVlxRmJ6QnoyQTVIdlUybzNNOEkzaE53SjVKN1lHYTRqVGRVMCtlRkdqRzF1cFRCNHJ0V25Wb3hJeWxsSXdGNmZsUzFSMlFxUW5TZkxQZGFOTzVHbXEyY2x5cUVoV0l3YXc1NHJjNmlmTWtJUWdZd0JnL2pYR2VYYVQ2bks4VUxoeVNPNEdmOEsxbXVMMkVmdnJZdWhQeWtjbm1pek9aMXVhTGNrcktlalYyanFabzNUWjlubEJ6MnppcWwwMXlMVmk4WnlEa1lOUUo1WndBcGpPM1BKNkd0bXpsZWUzbGI3d0IyOU9uYXBzelJ0TnZwZGFJNUU2MWhZNHloVjI0R1RuSDF4MnJxN0xWSllMYVFPbzNnWkRldkZjdGVMYnhiM2xZRGN2QTQ0cXhvbDdaT3BqTW5tWUhwMEFvMk9lbk5xYVhPbGRhSXpMYldMK1pwVzJoenVLOWVPdmVyMTNETlBHY3FxN2x3Y2V0VmY3S2d0N3FSb0hJOHdrbjNxeEZIZEJwRlhjVGc4azVINFU3bWE1Mm5HZDMzc1hiS3l0UmJMSE16TU04SCtsV0pZYkpJbkVaSEhBN1ZXdExlZTViWkp4ajBQYXQxckczVzNaL3dDNmNISFQvd0RYUWJSais3MGl0RjEzME9Fc0lyMlV2bDIyNU8wTWZ4eDlLM1p0QVM4Z1B6N1g3a2NIRlNSRzJqa0daUUJ3TndwODE5WjJpc3hseVNPTUg4elR1UnlRVWJTZDExMU9CdE5KMUxTcm94MnlySXI5UzNKR2UrS3VUdnFheWhKVHRVLzdKNit0ZFRZaStkNUo5Z2RTY2dqdlYrNzFLd2s4c1NXeERxT3VEL0tqcVpRcFI5azdTbEZYMFQyc2NJMWs3U0ZvQzNKeWVlbnVBTzliZzB2UjNDdklDSmY0dlhtcU0wZHpienRjeFBpUEdTdVBhckExVzJ1YlVGa2J6T001NTZlb0ZHdGlWN0pOcWFTZXJTZXp0MVJhZ3N2c1VNNVVsaHlSem5QMEpyeW16T3JYR3JlYkpFMnc5V3hqL0pyMUFTeVFlV29Ba0REa0huZzljMXY3YmVOeWpsVlVxVHRIQUgrRk5hWHZ1ektyUWpWY0VueXhnOVYwdVp5cERPcklBZG9HQUNmMHJERUU0dU1MSHRWU2VRTWRlOWFsejVrRG1XMndjY2tIcitacVN5MUh6VmRpRHZQVVk3OUtteDArN3pKU2xaK1Ftb1dVczlzVEN1MlFyem4xcm1kTE92MmdhT1J3MjMzNmZuMXJ2L3RNNXRSTDluYmpyMUh0bXRDTzR0Mmp5VStmbk9SNlVsZTJ4Y3FNSlZJeVZTVVdsMDB1aml2dDF6ZHl4ckxicmdzT1RuajFGVjlYWFQ0TjhZQ3JLUVFBbzV6WFhQYnQ4c3U4S0IrT2MveXFndzBxNG0zU2o1K2cvclYvSXpsU2s3cHlWM3M1R0Q0YjBPUzNWcmlXUUJTeElBNHhXdHFydGRUeFJNakJXeU53R2Y4QTlWVU5RaTFnem90dTZMRHllUnp6L1NycXhhcXE3bWxEQWRSbkZEZXQ3a3dwcUVIVGpUa29wcTc3bU5ZUXkyczh5UGNGa1VEQUNuSUgxOTY2TnIzN1JORW9rWlFyWTYxSDVzT2R6dzhzY2ZuMXEzTmIyNGgzeG5PUWNEUEkvT2pkbTBZV2phTFZsMHUvMU9saVIzWWlXVGRIMEFQWC93RFZVaVEyOXJJcXhsY01lZWVsY1BwdDFQSFBza1p5U2NEdjFycmIyd2s4dFpGYkpJNEdPQjdWSjNVNWMwVytXN1gzb0wyUzhML0x5dmZIVTF5VTBHeVV5TlA4bmRTM0I3OFZzUVd1cTdWTXJBWUk3Y1lyU3ZJSURLQVlEanZqMzljMHpLcEYxRnpOU1dxc24vd0R5dHJPejFHVjBVbGNER1I2ZmpXemJhVHBtbklWTXBMSGtCai9BQ3hYWWVYWTRBU01nOGdGdU9hWmNhSkZNd2xKUHluUFhqbjFvdjhBY2Nhd3l1NUtNWlQ3bk1TNlVpVENkV1pTd0FIMXF0R3VwVys0dXpGTTR5Y1o1NXJ0cFpIaWgyc0NRcHp6emlsdkx1T1cxQ0NNQW5BeWV2NVVKZzZOTk50U2NYdlphWGJQT1dnaW5tQmViSVlmZDdacnI0ZEhuaWpEeFRFOC9oOWF4YnpUWmpiQXJKc1BYZG5waitsUjZmYWFsc0JONWxSMS93QUtOZTVseUpUczZUYmEzVHNkVExjM0VDNzhFN2VjQVp6WExycjhGN01rTElRNVBRakZkWERmSkVySktkMkRWVWFmWlMzVWR3SUZVZ2pPRnBhSFRMbmNZcU0xdnFuMktFb2UwS3JnRVlQT01rQ25wcCtuWGFxeCtSc1ovdW5OYVYxZldUM1loSklicDh3cmF1ZEJoa1dOaEx0WTg1ejJOVkZPeHQ3UG5ja2xHYWpiUm1kcHR4YVF6K1N3REZlaEo1NXFyckJ2SFpSYnF3SFU4NHhVVVduVzhOMFdWMmRoMVBiclcxY3ozaVNqeTBES0FEMEZEM05GemV5Y1pLMnYyZFdZME9ueW5adWY1c2R4L09zMlEzVnJPNGJBVWtjakl4Z2NtcDd2V21FRWptSmxZSEREcFdwWjZyYTZuYkp1ak9TT3VPUjI2MCtqTWYzTW1sR2RwV3V2TVNDL2drdGdHY0UraDZIOGFyeW1HMXQya0h6Qmg4MkNjZjFwdDdvc0lnQlZpcDZqRGUxWU1KdXlUQ3FsZ09weHgrVksxMFc1emlrbkhWTFJyVW1odmJkcE1vcUlXUFRyejYxb3k2ZzZNeWhTRGowL3ppdUUxQ0crdExsSkl3QmxpRHhrQWRjOFYxd3VaYmdSc3lja0FaSFBYK2xQbHRaMzNPZU5hVjVSMVRWdW05eXZJbDNQSWRtY0VZSkI0OWVsYXVuYVhPay96eU1CejdjVTZ6dXBJUXlORU1BL1VWMGxrN1BJSExBQThaRkxUWTNwd2c1S1YyMytScnRZd3gyN3ZzQnlPb0hwWE1Xc2NjNFlZMmtaN2V0ZGJxTjRZNGVlNDl1dGNuYXp3T2hKWUszcDllMU02cW5KenhTdHRxaGwxTWtROHBsM2NESUg5S3BlZEhiN2NLTUVjNVBUM3JhaFNPYVJnejdzZE9PM3Y2MXptc3BOdTJBRURPQmhjNUh2U2FNSjh5anpkT2h2MjBmbUtaQ1FldzcxSmMzVTBTZ0RkOU8zU3VjakU5ckh1TW9LamtqSGF0VWFyRk5ibGhHcE5LNWNha0VyUDNaV3VDRVBINWpnRGpyakZjSFBwdHZkVHN5YmtZWnhnOFYwR29pOGFKZkxsQ2dzTTU2WTdnMU5EYmhRR1ZWSndUblBGTzV6VDVhajVYRzZWcnM0K3d0TlNmVVZFb3dvNkVucmdmcFhXVDZuREJjQ0lxKzdBNUhhcjBHcXBFTXlLQmdrZGY4QUd1YjFreXpYdHZOR2dZQTVKNmRLcTZaeWNpcFVmM2RSeWZNcjNWM1psKzdXTzhtQWFUeTJVRTR6akJQZXE2NGdsWlBNTEE5Qm5QdlhOei9hNTcxZHE3UW5KS2pQR0tTT0pYdTJMNWJZY1lCT2MrOUxvaUhWL2V1ME5YSzEzcGNzWE4vOW9ReFBBU3VjSFB2M3JFWFNiWHl2TmdRTEpqb2UySzZ1MjFTeGQzWEJ5dWVTT2MrbGMzZHlYVXNERzJiYnp1SG9SL2pRcnA5aUp6aTQzNWxQUjdMVTFZVXZHVUdVaEU1NmR4WEw2aHFkM2JYZ0FpTHJrWU9CZzRyWldlYTVzbGp1SE1USmozd08rZnJVUmEydDlpTTI4c2VHTGRmd28yM1JsS1NjRTFOcGI4ejM5TEhSYWZmM0JJWmtaQUZIQTVINFpyVG11cmFaZzJHM0FjWTYvalNSUXhUWUNyeGdaR2NmaldSSTl0YTNzYUZGR1FPVHlDYWp1ZFNuSlJqZVNjYjJiWm10cUJ2Slhna1VnSGdFSE9mVDZWMmVpNkpZUkpreWZOa25CNElxdWt0cXo1S0JUbkhwK1ZkR3NWc0lUS3o4REo1NmZTbmRXTmFWUDMrYVRqTnA2TjZXUmthbGJGSDJvZHVCMEkvR3FkcGR5dWZLa1FNTStuOHEybW10N3JHd3NDdlVyejlEeldSZG55SFZkNUlib2VoSHZUc2FTZHBjeWZ1K1JldTBqZ0lHT1QrZE9zckllWEsyRzU1d1Q2MVlrZk96ZWpFQVk2ZC9XdVd2TmNrS1N3d3FHT2NIQncxTkl1ZFNFWmMwdGt0RmJVczZWUEVKcGwzYlNwT0E1d2Z3OXE2TnRldVlZU213bkJIVG5QNVY1aTJrTk9pU1BLNk51Qk80NC9ETmRqWVdLUDhBdWxZY2NBZzl2OGFyUXdwVmF5U2lsYnp2dmZ5S1UwSW52bzVIZmtET08vUFN0RDdaQlBMSkUyTUxqR1QwL3dEclZ0LzJQc3VDQ2VleHJDZlRyQ0s2YmNGREUvZS94cHF4dHlUanEwdFhxbjFNMVpybEhJaERaL0lEOGEyMHZMbFFjZzU5Ty84QStxdElXOXVZdjNaejc1L3JTMkZySTBoRFlHT3c1T0tWeW94bW5aU2Y2RWtlMjRDbVE4K3A5cXk3aXduaGtEeGc0eDFYbXRUVWR5SnR6Z1pBNmU5VmlsMGJSeHVCYm5CSEIrdExxYXRSYmFhYmExdU5zcjhQTHNseHpqYm4ycnN6SGF2QVFwR1J4bjYxNVJwZGpjVHlCNVpPakhHZUNNMTMwMGUxRkM1R2NmcDYxVDBOS1VtNDNjZE9sekMxV3drbnRIVmlBQ0RnOXE4aVRTSTdmQ2liR0IySEhOZTIza2pKYW1JZnhZNjhnR3VmczdDRWsrWnllT1BmMXFiczVLMUdFNXBXVjdiczRWWWZLWmRqcVFNWUFIWWZTdGxybU5icUhETVFlT2MxM01XbVdTeW5HT25GY2hxTUVVS3ZLVk9FWFBvQmpuOHFUWmc2RW9SYnVyZGpvTlR1TGVDQldlSXN1T1NCbmozckorenhORXM4U2tjNUdSZ2pQUFNzdXg4WGFMZktiZHdRNHlCa2VucFNhbkxmUlcrTFZOdzQvUE5OWEhLYW5EbVRUVnRrdGJsVzk4VVg5aktWRUJjRThHaXUyMFMxaTFDeFI3bFFISHR5UFdpbmRkaVZoc1pOYzBjUzBuc25GRHBQTXRyZDN0NWZ2QVpVNDZHdEMwdVlMaTJnTVl4TmprNDYrOVg3U0lYVVJFc2ZsSEpBTFZ4czloL1pieU1reGRtejAvcFUzME9pVjRKU1Vid3RyNWVoNkpaUzRrZnp3dkk0QjU3MXFNMXFrREI4QWpvUFN1RXRKYmZ5a0xUQjVNYmg5YXpiYXp1WjVXbGFaaWhKQUJQUVVqZU5mM0lwUTVtNzlkdlUxcjJPNG1UNUlnVVBUM3g3ZXRjZnFWblBIRWdMN0U2YlY2a25uTmQ3UGRDS0FSYlNNZE9ldFppTmNQRVhlRU00YmowRkk1S3FqSnZlOXJQeU9aME8vd0JMaW0reXozY3JOajdyQTl1M05ia0Zsb3QxcVJNS3lLeUU4amhTZlg4YWdnTVViVHl2WUNTWGR4dEhOYUt0ZVNlUzBLZVVTZm1CWHA2bklwdG1NRkZ4aXBSakxsbGRMbGQ3ZXI2amJ1UzRzNUNteFh5MlFYUEFIdldoYVg3Rm8vT1JCa1pUYWFxYWxwU09oYTRsZVRQVUxXWE5hV0VWdkVxYnM1R0NTZVB4cVRkeXF3YjBzdDlXZGJxN3l5UnFJcFBLazljOEFWd3dYVlVEcTB3bHp5R0g4c0N1d211dEdheTJOT3JTN1J3RzV3S3dvYm0wZ0RGUStRTTg4OUtkMzJ1T2JpNmwrZnAwZjZGaU9LNVNORVoxK1laeXg5ZmVzdlY0VXQvM3F4cUh4Z3NNNElOSk1rRjZwbEZ5WW05dURTS0EwSWd1cHljREc3cFIxTXBQbmk0Mi93QUx1YkZuRWdzQThjcGZDa2xjOGsvNFZnWGQxcVJsaldMS0dWVGhzOGp0WEs2ZDRiV0xVUzhWKzd4NVB5cWE2NndrMUlYc3lTd084VWJaUWtEdDlPMUVvNzJaRUtyWHM0enBTU2J0N3J1dlcvUW5pMFcraEJ6Y01DY2t0MkJyaGRVaU1OdE5OTGVUT2NnRUx4N2MxMTkvNG1nODhRd25kSXpZWmNIajN6NzFzSnFHbDJzWCtrNHdSbmtmcFRYTXVoRlNPR2twUmpOSlJ1cnQ2Sm5GV3Q3cTdhY2pXMGJTYmNmZjY0SDlhNmJRb2Z0Tzc3UkF5ekJ2dkU1QkhYOHFpYVd5dTVSY1drNzhaT3djS2ZldGk0MUhVL3NrUGwycXM3SGtrNHpRN21jSXBOU2xOeVVWcGIzazEzVnRoK3VpNWxVSWtlNWVBN1o3Vm42UHFGbEdUYXhSU3F3d1dKenptdFFXODZ3QnJoZGhJKzUxL3dEMTFwNmJiQ0NCbmZsaVNjbkdSVHVyV1ozcUVuaUZOT3p0cmRkTzNrWldxQzIrMFJUU1NKR1Y0NU9OMy8xNmx0YnBYdXo4bUVBeUc5YXg5UjA2MTFHSWlZL0tyZ2hsNjlhNHZVdElTS1NOSXIrU0pkbVFwQjZudWFOR3R6T3BVbkNvNXFDY1cwOTBtL3ZQWE5idkYrekszQVZYKzhUMHdLamoxTWVYRzhNNnpKZzd1ZWxlUTZYYTYzTEg5bW1LM0Z1WDJ0azg3ZjhBUGF0K1ZOSDBjU1J3b3lLM0pISnhTdHVTc1hLVjZud3hzcnQ2YStYa2ROTDR1c252RGJrWTJnZk5qR00xMEx0QklDeklxcHN5TUhHYThuc1BFbmgrNnVsaEVTaVRrWlpRTTQ5eFhweGUwdlpZL050aXFoY0FkaitYV2xFNmFOVnpVbTZrWk8rbWpYM21jbXRUWERaVWJZMTZBSHFCNlZaZTUxYVJGTFJCVkkrVmhuTlhwTkxzb0NDcWVVQUJoU2V2ZXFOeHJ1bVF5dEZKTUk5cThaT0IrWnAyMVpjcFRpa3AxTE4rZGsyYSttUlhNVTNuVHlzUVY0WHQrbFZwOFhNNEpkOEtlZzZjVkJwMnNXVjJGQ1RncGpDNE9mOEFJcStiZS9ndmcwU0JvbUhQNCt0Sm8xVDVvUlMxamZYcnVhOXhmelJRaFVCeDBHNnZDZFQvQUxWbW5aWkxZeEp1SkRxMk0xNmpxZDVmT2RxeGIxVmh1NTlPOWMxcmFYOTlac2JaUXV3WUt0eG5IYWhMVG9jZUpsS2FrazUrN3RGTGY3em1MV0M3QmtERHpvMitVRUhKSHFhUzFzTkswWU9SSUo1Skd5WTM1NjBtbVhHb1IyajJrVnZ0blliZ1NlQjJ6VHJYUzdtUzhBdXRQSmZiODBpdC9JVlhMYStwNVVKdDhuTEJ1WGRwMmkzME9xc0JlUjNSbGlnRUVESUN5anFEL0w2MVcxbnc2K29TeE90NnhRSE8wSEdQeHJUa3ZZNUlqYkxGUEh0RzB0Z2lxTnJaM2tNQ3FpRjR6emtrNS9Lczd5MzZub05RbXVUbGM0dTdldXo3V1hRNk8xVFdvTFlyRE1zcUwyeHp4WE02UGQzT28zVjRaQXhBK1hZdzR5SzYyenR3VlR5cDFRNXdWSjYxamFoSGUyUWxOa0JLNmtsa0dQNlU5ZFNwUW12WlN2TGtoZThiODE5T2hOYStkdTh0b0VWMTdqMHEzY2FmcHMwQm5OdVZlSUhQWHFLeExDVFVMbFhhWkRDNXhsU01jaXBielM3bDRRclhQbEk2NGNrKzlWZHBta1pOMHY0Zk91elMvVTB0UGF3dXd1d2J3RGdaUFljMXBTUzZSWjNDcmNJSTk3OEhiZ0g4YTQ2ejB2VDdWMFdEVWk1REhLcWM5YXM2N3BWeGUyelE3UklOZ0lJKzhEVTlkd2hPcXFiZnM0ODZ0dHF2d1BRbDFlQnJnR0NmQ0FjcjI5S3NUc2wwR1luSEJ4bXVBMEhUWTMwMFJTUmJXajQ1NFBISFd0Tzd2SHN6SEY4aUFkODR6U3VkOGEwdlo4MDFhTC9VczNhV01aUkpZdDVQUWtjZi9XcTFIcDZzQTZ0dEFPZVBTbVBlMnJ3Z3pQazU0UFVDc0s3dmJhR1BiNWpCR0hCVVpvdVl1clRqZHlhdFplVFIxVjZJWVlGUG1qSjZFZ0g4cVc0MUc5dGROWjQxRndkdlJUMXJtUlBiU1dDUnN2bktmekdhdVF4NmJwRUlua21kVVk0Mms5UGJtaTVyQ2NtNU9MVVk4dXJ2c1l1bmFscVZ5QklVa2hjbjdtQ2NWMjV1ck5Rbm5Cbms3bjN4M3JrLzdadDdtMmttZ2NPRUpBSUg2VlBwVjNkVDI3Z1I0WndjdC84QVdwOVRucDFWRnFLazV0cmUxMHpldUxxd3VpdjdzNEhHZW5TckZyYm1WQ3FKdUdRVkp4d0twMjdTVzhhUnloRG5xUjY5TzlNV0s3ODRtTysrWVkrUUR0VHNkRGR0V3J0N3BXVE1IeEI0TjB2VUo0dDdzSEJ4dVd1VlBoU1cxYnlJN21UYm5oajFBN2MxNmdKNVZES1kyTW5xZU9mVVZrWEZ2clVxa0l5bGlPVzU0cHBuUE9qUmszSlUzZDlqanJmVE5SdExwUzhyU2pnQU4xOUNhOUQxS2RrdEd3RnlFNHlmMHJVczdab2JRaTYrYVJWNmdWNG40bzhJWDF3LzJxTFdIVTV5SXllRGpzQlN2Y2ZzNTBhYjVJdDM2WDJLbGxaYTlGSjlwamdBZmRnODlzKzliOXpwL2lDOG1kWTcxVjNFRXhrWnhpcldpM21vTGJpT1dJcHh0OHc5NmpzNHZNdlp2S3ZpSGpiTDg1K1gwRkYzZm9lZkdsVDluQk4xR3BQVmMzTHIrQjNVRHoyOWlzY3NBZVZWeGtEakpybGJPUFU1OVlrRjh1SUQ5MElPbGRIZFhVNzJiQzJrUXk5aWVtYTh2MW5XZkVtbElDMFVjdm1ZQ3NEeVBhbGIwT3F2VmpCdzVsTnhpazdwWFh6UFlKTk1oR1RDQ29VZFQwSTlEWE5SYWJCSGVTenN3SkE0R2E0Q2JXZkVUUlcrWWZMUXFDNUJQNDFzblY5SFdTT0tlYzduemdrOGZYTlMwMWJ6RThSUW0wdVRsNVdyY3lzcnZzZFJOb2tWNlBPTUtqSDhRNjlmV3VCdllKOU51RmVEVGxsRGNFcU92dGdmenJjTW9Vbnl0VlhaemxRZWxUMjhPb3RjcE9sMENnWEpKcWs3R1ZSVTVXVVUxTzY5NVdaSnBTczBXK1NKa0xOa0tUbXJPcCtUQWh1SkxuYkd2M2xyUmE1dEp5b2U1WGNQdkFFZm5VTjFhYVBQdEp1b21CR2RyTU1Hb3ZxYjhudThxYWUxbTNiWDVIUDJGNXAwK0xpMmhhWU1PeTk2dVRYVFFTZVlrVEovc0VISXJPa3U3bFlBZE84aUxhU0dIVWU1NHE0bXNUU1hFRnRKRUxocFFCSkl2SUJyVHFjM3RZUlZ1YXp1ck5SMGJmYnFVN0h4SEZjNmhDMHNma3JrcVZJd0RuK3RlZ1hOdEFzeGtnQUtrRE9QOEt5djdCdFVsM09WMmtaVlQ5YTI3Qzg4cWFXQm8xQUErUSt0Szl6dHBScU5jdFJyV1drcmEzT1IwdTJ1TDY3bjg2VW9GT0VYb2NlK2EwUkhIQmN1czdQS004RHJnZXRXOVlTRlVSMG1FVE1Sa2pwWEZTSmRQZnh5VzkySkFnd3dKNisxSzVpMTdOSldjbmU3ZDczdjVlUkpycHRJb3hOYktGWmM4QWRhMk5EMU5uaEszRVpSVzZaSHI2MTBmOW4yODBTdElGRGtaYkhTbVdlbFN5c1N3VjA3YzFTYUxWR3RHcXBSdHIwUzArWmdKYlF4YW04bU55SGtIUFQycm9icUNBbVB6WlR0SkhBL2xTQjBTWXhMSHRJUE9lUGFwWm9VWGF3QnprRG5uaW5jNjRwV2xzOWIvZVVuMGVFM0JrZVkrV1JnN2pnWTlLc2liVHJSUkRDNElCNTkvd0Q2OVR6UU5KRVk1U2R1TzNiTmNzK214MmpHZEczS0J6eVNjQ3B2ZEVUOTFQbGd2TnZkRmU2a3RMcWFZUEZqWU1CandQU3VkamUwbU1rTU1peE9PTnlqMDcxcTZkcVZ2Y1hrcVNBS005S2xtczlKdEpublJveVNTVlVIbW03Zk04eVh2eFVvOHRyKzlmUm1zTGF5c3JXSHpyb2c5Mko1SnJqcnU2djB1MGtodzhaYmc0NStocmo3M3hEUGNTVFc5MUFZbDUyTWVjZi9BSzYwTkcxT3hDTGJpNlpwQzNEWU9CN2MxVm1sZTF6bWxpYVUzeXdmSWxhenZaMytaNmVubUY5Nk1VZGgzOS9TcXNDM1psYUdTY0JDT1NhdnhReU9UR1NGMnFQM2hQWDZWZ3pmYVlKRENTSFZpZDBnOUtnN1o4eWNXK2ExL2w2RjY0T2l6TTFpOGdMRWNNRGpBK3RZMGZoM1RqdURPV3dmbEpPY1k5UGF1UXROTmhhL2NyY25lNVBicDY5YTEvUHZiUFVJNERoa3lja25HVFZOTmJQb2NpcVJtdWFwU2o4WEttbGZUb2owV3psbHNiZkRnbE4yQWZTck54TWp4LzZ0Um4yNXJIdmJrbUxMU0xnL3dEbk9heXZ0ZGltMlFUa3NvKzZlNEgrTlFuZlU5R1UxRmNxZWx0THN6clcvdHJtNGt0Z3h5Q1FSanJnOUFUWGRMYjJzQzRXTUFuSlB5am9PdGVheDZqWVNTbWFHQUNSM3dHeFdicThPdnZmK2VseXZsWSs1eUFlTzlWMXRzY1ZPdkpVK2JTbzc3cGREclp0ZDBsOVFVSTRMQTRJQTZudDBxM0pxc1R1VzhrcmxnQ1QwQi9xRFhtbmh1eGplK0Z4TUUrUnlTTTl3ZmF2b295YVplUGhGUWtBNEFBcHlzdExtbUhsV3JLVDVvUlRlaXR2NW1CSEZIOW5CeDk0Y2ZUM3ozcWhGYlJLVDVSVVAzWmhuaXV6RnE1Z1pVVUVqb08xWVUybTNNTXlzL3dBb0pHUjB4VW83cWxKcTFvNmQreG54WEdvUW82bTRqZE1aSTlPYWErcmFleWxHVlFlZ09mNVVzbWlZU1dXMmZPVHlNNUdUVmExMEdQVUZET05rcUVjZlQwcWxxem10aVUxR01iMzJUZDFiMUdKcUJqODFaRUorWGc0NzlxOHlTZlY1cmwyalJGUmVtUi9uRmU4TnBzZXdxeEdWSEpQV3VkRUNSUXVnZ1U1ejA0NlUxZENyVUtzcFF2TnFLdnR1ZVpSZUlydG9kdHpiU2ZJY2JsQnhnZlN1cnRycGJrT1lESUFSajV1blBzYTNHdWxqUXE4QVVFZFNNOXF6RWtsa1lHS1JObzdBZzVwWFQ2R1BMVWkxZXE1OTlOZnZOT096dVBNUU9RVlAzdU9lbGFjK214UUw1eXZrQWs3VHoyN1ZYaGFaN1o1SE9ESGtmL1hyUHVMcHJtS09ORktnSGs1K1dnNjA2Y1kvRGR2VlhLbGxjeVN5dkkwSVZRM3lqR0s5Smd2dk5pMitXTURHT3h6WE1XOWxFYk9XTHpWWmlDT08xWXkyR3FXc1c5WmNnSGpPUDZVSXVFcWxPMjdUV3RyR3ZxK202dmR3ajdQZGVXeXVQbHp3ZnhGVFcwMnFRd0JIS3U0WG5Cem50VmFDOHVZOE9VM0JqbmdISG9hdnp5cXBNa1pKa0hRQWQ2R0NVT2QxSXltbTBrOWVub1Y0WG5lRStmaENNOGdmenBOUGl1ZDd0NXhaTzNQYXVhdVp2RU53d3hFaWdEL2dKeC9qVmFBNnZiUnVIQlhPVGtVclB1am5kUlJjWHl6YVhWcXgzQnVvcFpaQTQzS21RTURGY3JjK0lMQ0ZsV1VCRnlBQzJPTWQ4VnpWamQzQ1hJM0xsZjRpUm44L1N1aTF6VGJIVnJZZ2JWOUdHT3RDU3ZxYy90NTFJdHhhNWwwYTNOcWE3MFNXRkNiaEZSeHg4MkI5S3g0ckY0cnJmRGNiNFd6eG5uOC9hdk80TkR0VW1GdE16TnNHYzlDQitGZDFiMjZKYXV0bVd5bkFYUDZHaDI2TVVhczZzbTVVMG5Iczlib25iU3BwcFRJSmNEZDNPZnhOZGhKTGJSV3FEemNNQndNOU8xZWYyZXVYTUplSzdoWkIwLzhBcjFWKzAzS3p5bU8zZVNOaDhoSEg1VWtyM0xwMWFhVGNVN3ZScHAzWHlIQ3hOMVBNL200bHo4cjl3ZmVwYmM2cEMyMmR5K3pHQURucFZtM210NWJOblJIam1VRGdqa2M5L1hOYXNGNU5PcWxnQTNRZHMvU3JWMGc1YVVuRnB0TjYzV3o5VFMwdThXUjNKVGFjZ0RkWG9oK3ptTUh2WG1Fa2M4RGlRcVNCMnFsZGF4ZExFMHFwdFgwNjBkVDBGV2pUVFV0MTVIVGFwRGJpTTRUT1R6Z1pGVUliaTJTSUlxRE9PVDA3MGx0ZlFYTnFETXkvTUNENmpQV3NtMGd0WkpBc1UyV0RaR09oeDZpbGJjeGM3empLTnZlVzNVa2sxZU50UWpnNUdPcTlzVjBOeGJxbVpZaUFRdklGVjlSc0xHV0pjekJKVkI1Qndha2lza1dKR2t1QVRqQU9lM2FoN0kwVWFpbEpTU2V6VFR0WTVtNzFRUkNKSkViRWhPV0FISDE5QlhTYWZZUi9PNk53ZWcrdnBVN1c5aktRdTFaR1VnblBKSDQxY2t1ck9HVkY0WEh0aWgyc09NSmN6bE9jWEZXc2VhZUpZdGNnZ010bkVHMjg4ZGNlbGNONGQ4VFhkM2ZtSzdWb25Bd01jRDhhOWVlK21FekJXRFJudjlhNGw3ZTJ1YjgvS3NjaEhHUmduM05LNjdIQlZVZWROVGVzbG8zMjdIUTNUM2dac01XallISGNFZjhBMXFacDh0cTc0RzRFWXlNWUZkYlltS09FcGNmTWNjSEF3Zndyemp4RE5GQTIrQlRIaHVTRGdjVWxxN0ZWWDdPbnp0M3NyOHIzUFNMWkxLU1RFVXVHVUhBejE5NmxudVkwdVZqdUU2OEJzOWZUODY4bXNOU3RuZklZaHdNSG5yK0ZlZzNOM1ozS3BseUNoNFBUcDYwUFEzcFloVktmTXVWTmRPak5qVklJRmdKM2hldVFlUmpGY2xhWDFvamJDNElQUmlPS3pwbmt2VmtFTWpNUUNwT2VuNFZGcE9tUDVDQ1JUNWlubkpHZnJSWldNSjFKVHFweGhiUTZ5NzI0UVpPRGo4UFNzWnIyeFZsajgwQnM0SlkxMVVTdzdmbWZHd0hjTzVyaGRSczlKdkp2TFJnSlR4d2NkS2FOSjgwVmRPTjNvazJhRjVaTFBoanRZSEhmdCtGYlZ2SExIYm9vVThjZzU3ZSthNU8yaGVHSm9EdTQ2bitWV2wxdG9nRmR3WXVoNHlSOWFFVENjVTd5WEszdVdIdkJiM0lSbCs5d1NSMEdNOEVWVXUxdFduREtDTS9lT01aOStLM2JpS3lrQWVOMFk4RSs5YjBLMmM5aWR5WUtqRzc2ZTFIVTA5bkp5a3JxMjY4amdaTkZobWZkSHdXT2M1OXF5UEx1WUpHVHloc0NqUHJqcFZ5NzFtS3drTWE1MnQwWmVhMDQ3clVKYmRuQTNic1krWG44YXAzK1J3djJFcDJqcEpmRlpYT2Z1ZEppdm8wZUpwWW1IOTA4ODF6MDlwSGJvVWtnSzR4aGlDVHgvV3ZUZEt1V1JwUFBqVld6bkJ6Mzk2Nnk4Rm5xRnRobEF4MzZITkYzc2JyQ1VxdExtVFVaTmJXMytYUTgrc1VtVzBFcU9HeVBweGo5YWpNd1hiT3lieU01VUVldko5cTJ6R3NDZVd2SXh4akFIclhDV2VvbjdkSW9BWVo1VWpqOHgrdFNrekthalNVSTMxYnQzMTdtM3FNUnVkanhaSFRvZTNXcnpYRURxdHVKUUdPTy9QQTZWWWtlM2lHNHVCa2NCZjZWeDhxTSs2ZU1CaUNjQmNaNG9TMUhLVGkzcW5mNHZROUcwc1dVRGkzWTdUMko2VmR1YlR6WlVaY01GQklicVFCWEFRWDY1amxsM0t3eG5wMHgycm8wOFFLanFRUXlrOWNlbnJScWRNSzFIMlNqb29xMXZRM0Vra0JLU0RzT3B3U0JWb1dGdXJ0S3BWc2puajBybkxqVVd1cDQrZ1FkVG51ZTRyYlN6a2pUZkhQdVRBNlZSckdWMitWY3lYVTUyOWFacGdGVGpQMUJ6V3ZFdUFPb2IyN2ZXdEszblNOeUhUa2RjaXFrOTViZVljcVZIR1NEMHBzTEtPcmVyTW5VYnkvQ0NaQnV3Y0ZjNXorSXJsNDlSL3RJcWtrQmpjY1pIWE5kTlp2Tk5kT3VBMEl4akhYbW9HMWpTb0wvQU1xUlFHSklQNCs5UHBZNWVaTzBwVmJSazdOUzJZelRMYThTNEcxeHR3QVFlMks2cTllU0hZWStwNjl1ZjhLemx1bVdRUEFNeHNPZStmZmlyOGx5OGtMczBlU01FVWt0VHBqeXFFa20vWC9JeG1oMUYzZG5rK1hnQSsvdUt1M04ybHJiYnpoL2xQVG5PUFQwcm5XZlUzTE1HTzA4QVlHUnovT3Voc2JSTGlJaVFBaFQzSFhGRGVxS3B2ZmxVays4aWpiMzBsM0MzbHB0S2tFZ2orVmIwWmVTTUkyQTNwNjQ2VXlkN2EyeUVaVkFPZUIwTmNwYlNYVXQ4enhTQmxCeXlnZzgxVmlwVkZGeGkzZHQyYVIzRFpoQzdoeVJqbnBrMXkwODdwS1dHM2s4cUIrdjBycG1jekhzdTBkRFdQYzJzc3FnQmdRYzdzY0dwTHFYYTkzNUZxNHVBSWtLa0U4WkF6K2xRdmJtNXRXRWk3Z1FjWjlQZWx1OUx1VWdSa0o0TzdIWGdER2FrRjVjVzhhaDBKWEE0QTVwV0dyODB1ZFdWanp4UEIrbnBjTEpFQ2o1OS8wOWE3Qm9MeUNFeGxoemtBRVpCclZrbVNSMWVJSGc4ZTlYUTBsd2gyeTVPUFRtbTc2R2NLTk9OK1g1V09PL3NxKzhzTDU1UUU3aGs1NjlzQ2l1RTF5MzhUQzlZUk9kbkdBV29xK1h6UndPclRpMnZZMU5ORDNXUysyMjRqdXNEY2NESEZVYmFDenVKZHZta3NUZ0FpdVZ2Ymk0ZlU0eXNLc1ZQSlkrM2F0UzYxMnpSQThxREtuQjJaR09jZHF4V3hxNnNlZjNwS3kydXQvbWRWL1pWdmJ1MjZNZk42YzRyRXUxbnNvM2xqQktnRGF1UFduWFQrWmJ4cXJzU3czQWc4alBJcm1UcmR3R050Y1hVU3Z0L2RranFUMHpUdG9hMWFsT0Rzb3VQWnJ1YzVlK0picVBVWXpKYXlOR0Y5TnZ6SG9SWFcydDFxTXF4UEdHakRuUEl5QVA4YTFvM2tOcUV1VVNRNEJPMERqTlhiZ0xQYXhDMWNvb1BJOVBXcWV5ME00VXAzazNWYlRWMUcxbmNraGVhMXZqNTBxcEdVeVdQZXNlNDFXMjg5ekRNc3FuSlpzOEQ4YXZUYUJaYXBwODNteXZ2SzRFaE9PQjlhNUNIU05IaDB6N0hJNFRKSG1QdXdXTlRwWWRTVmVOa3VYbGQybTVhMzdIZDJHcVdndEdra2J6YzlBQ0NQOEFKcnptOTFGd2h1VEY4cGJidHlPQjlLNld6MGZ3N0JiK1REY2tMc080WkpQUDBxdE5vdmhhNFZZVnVwUXpEL1ZnOWUvSXBJaW9xMDZVVmVtbjA5NWJsZXdoMG05dVE4U0tyNHlUanIvOWV0b1RKUGRTUVJLU3FkVHQ3MVRTK3N0RmhaUHMrNVlsQUI2SDZVNjcxeVNXM00xc3NVSkNobUJIekVmU25ac2xTaENGbktLbHZKUlc1US80UnU2bE1yTkk2S3BHTWNjL2pUTGszaVRpSTJBbVJWRzUvd0RBZXRhRnhyR3BiSXpCRzB4SUdlZ0gxcDV2cFJJc3R3d2pYYnlnNzUrbE5NUDNOcktVb3RXYmR0UHZlaFlnalczdzBWdjViU2Zld09TVFczQlBLMGlpVDVCazhlMWN6UGR3WDAwVzZTV01KZ2hzWXpRSmJyN1VZZzZ2R3c1Ykh6WVBRMU50RFpWb3FYdXR0WFNWdXAyRnpZNmFaRExESEVHeDk0RGs0OTY4djF2WDlKdGJkb21DU1Q1SHlNTTgxcjI5dGRyQUZpSktDVEc1dU90UGswT3lsTW5uVzBVcjVCNTY1cHAyZTRxcnFUaGFFWXhiV3Q5VnIyRjBTNWgxQzNWWWdpRWNNcWpIU20zMDZXN3FNTUNHK1ZRZVNSL2pWZXlzYm5TMGxrYUZSeVNBZzZJSzV1NTFhNm1uRTFoRkhLanNBZDUrWUg2ZW9xclhma2M3bmFtb3lkcCtuVDBPOXRiKzN1MUN6QWliSTR6MHFhOTFGYmFSWThoMllEQ0U1eml2RHRTZ3VHMWxRSG1nY0FPWEgzYTlHdEw3UmJPQnBwNzlKNWUyUmxzK3dxTkxyY21HSW01U2pLMGJYVG0ybHQrb3R0ZTZwZEs2SkdMZFJKZzVCYjhSWFNYdCtWMmcybm1zcTQzYmNkYTIvd0MycmQ3S09WYlFPTUJnb0dHcm5wZFNPcVFTR0tBd2c1QjNjTUFPOUYvTFE2M0dNWU5LczVPU3Z0dWwyNkMvWjRuaUlGNDFzN0hQeW52MXJvTE8wMHg3V1R6cFJLekFjdUs0b3hhcXBqV08xamRGWC9XRTVPZW40MVd0dEw4Uk5MSlBkekpISEgwU1BuUDF4UW8zNm96cHlmdE5LTW4wdloyWG4yS0Z4YjJWanFRa05oR3NmVHpPZ0h2WHBjcmFlOEZ1WG0yQVlZQWZ5cGtsdnBGeERHbHpJV1RhRDY0SXJuTGg1WUxqNVlvekdvQmp5ZXVLSDBOTE9rNS9DNHl0cGJaL0xvYTkyc2Q5ZHB1bGZZeTRWK01jYzVxckg0UnNwSlhhNVVTcXd4dTU3RDFxOGRhMHE1MndTUEVzaEhLb1FkdGMzcXZpRFNJNHhhdzZ1MFQ5Q1FNOC9XbW0raFV2cTdibEp4bHJmZGI5ck1wWFhoeTFzWTJXQ1pZaTdmSnp3UFN1ZnNkUzhRMnNzeVhOMFNwT0VjYzQvTDFxYVN3TnJBalQzZm14eVlLeU1Ud2ZZMCsyMUMwdDdvUWgvTjh4VC93RTlhcTJuYzhhVlQ5NnJmdW5va3VhKy9kSFF0WmF5WjQ1SVo5NFlaWXNjQTFhazFDNXM0cFB0UGxsZVI4blVrOXE2V1c2czdtQ0ZGY282TDBPTVovd3J6blVXdDFpYUs4MmZPZUFuT2NkS2hibzlPcHl3VGNXOXIzYjAyTjIyMVc4YU5wallMRWdIRWhQUDFwOEhpVzVLeStWQ3NqZEY1d1RWS3lsMG05c3BJWTVaU0NBckprL0x4anZXalA0YnM0NDBUYzBPT1ZDakROOWFxNjZveFR4R2txYythS1dydXIzZnlzYXVsblUzREc1ZzJGOG5rNXhuK2RZODJyeVEzeHRaYldiYXdLaHg5MGVtY1ZXdHRPMU0zTHRGZHN5c01EZC9EV3RaV2s2V1U2M1U1bmxCSkhHT3ZwUzBPMkRueVJWNXExL2VkbmYvaHpEOGlhMW1qQVg1YzdnUzJXelhVV291cFlubnRtS1NzTVpmcHhYTjJkN0VSRVpiTzRVak9OeHorTmVpeFMyN29EQkM3Y1lQSnA2OVNjUFRwKzl5enN1aTZyME9hZzFONVVZWFNySklqZk15ZHNlMWJGMCtsYWtpd2VUS3B3Y2dqR2FwVzBNVVR6TkREc2xZNWZQclZ5YlU0a3Q0MW1VbzVHTWdWUE5xZEViOHJVcEszVzZ2ZjVuSmFYcGVtMmR4TXJ4U0lUa3F3R2NpcjlocEYvSHFNbDFIY3M2T1BsVm00RmJNbXNHeXQvTW5kWlV6dFVBWmJudlZ5SzVndUJHVXVPUmdnZER6UmZjaFVzUDdrVlpPR3FTMFptM0Y0WTVGU1cza0M1K1owNHhtclV1ajIyb0h5eVdNVEx3UzNQNjFoU1hqaTVhS1RlNEp3Y0RJQnJwWkpvUElTT05uTW5yMG9WaWx5UzVsS3pYWjcraGcyT2c2YmFib21TV1RZU1M3bmdqNm1zKzlmV2x2QTFqcDhadGtBNVk5dmFtNjQyb3dXY0VnUm55NDNZUE9LNmJUZFZrbnRBVENWandRRmJqT2Fmbll3aDdGVGRLS2ROcEpxeTErODVpMjhPYWxQcWYyK082VkkySE1RNEFOZGJjNmJGTEg1dDdsOW94c0I0UDRkS1lJM2l0NUJDcFhlM3lrbkkvL1hUbzdpSzVVMjhrNm1SQmhnRGtpbHVkVVZUVVdyYXZYVjZObUlsL3BGcEl0dGJXSnc1NUlBMmozTmFLd3hXa2toRGVXSlJ1SE9SbXMyMjA0eEpMYnM4a29mZ01Pb0I3WnF3dWx3b2dodzd4Z1pKYy9kL0dqNW1FUGE4cXZHTituVGxmYlFwbWZWbXUwSGxyTkgvRTNjRDJOWjh1dFBIY3ptRzJaWlVCMnM0d0dJNkN1L2hXelcyWllKVDV3d0ZEY1pya0d2RnVaamEzVUpSd2ZsWURna0hybWhlZzVRa25IOTdySjM3cnRhL1E0blRmRS9pdDd2ZmZLa1ljNFZBdlVWNkhhemVKR3ZSOW0yT21jdUd6K2xPV0JZclpUY1FoaXJIYTJNZTJEVzdZNmpLSTlxT0lteGxNanFLZHJoVFVsTlJsVmxxNzc2L2lXemRhcEhML0FLUkZHeU1jRUwxQTlhdlNRV3N3eWloc2M4bmtWNTdyOTNlTlBIRDlvMnl0Z2toZU9QNjF1V2QwOFVKYVFjN1JsdXgrdEk3VlZpNXVMYmE4N2FHM2ZXN1RSZVdBcWdET2ZTcytYVElOTnRGY0lyeVNmZUtqclVFZm5YTWNpT3BRTU9HQjZDa0dxWE50WmlGZ3NpcGxWUFUwd2x5U3UzRjZyU1hiNUhLejZuWW1hTklvcFZiUE9GT09hMTVKTk5aZGx3cnlNZXhYcFV3djQ5MFlXMjVmK0wwSnJObWx2STc5QUxmZUdIek1NRUw3MHJIRmQ2M2FkMmw4SnJOYVF5VzdyR0NVMjkrdjBGWnkrRjlMdllvMmtpWEtIbmNjZTVOYzllMk9vM0Y4eXc2cUxkQmpLNDUraDk2MG5pMUcxaGFVeUc0V01ad3A1SnAyMkZLVUpPU2xRdkZhWDB0b1FYdmh6d3hGQ3hqZGxmQTZIak5aOEszdHJMSEg5bmVhR1hBeU9nRmFOdmQzdDNwMGVkSWRBN2Y2eHNjRDFOZGxKZXdXY1NRUEhnRVpERHRTZDdXZXBqR2pTbSthTnFhVnRWRzEvTFU4cjF2U0xXT1ZIaW44dWNEL0FGYmREK2RjdnBlaTNVOTdpWll3RDBPNzE2MTZCZGFOZGFwcWNOeDVvTUVCNUJITFYxa3Ryb3NjYnZDUUpjNFZWUHBWTFJibkpMQndxMVpTbEZSaXBkN2Mzbll3dE0wVzIwdTZhSUhlWnovRjByZWFDMnM3bG44b0ljNUxDc0prdkFZcE40ODNKQUI2RFAxck9tVFU3Y3ROS1JJYzhKaks5YW0ydTUxcDA2Y2JLbTdSZDFwc2VoTmNXOTdLalF0eUFNZzlCVEpVdFRNWGsrK2dQSVBCSDByQ244NmVPRWZaMXRoSXVDdzRQMUZlZTNVc2xyYnlwTk93OHM4UHlTYW0yeHRLdnlwM2hmcTNzdnhPL3dCV2ppdWJSb2tCTGRTS3lOSTBVUTJETzA0aUlKUFhvS3FhZGZQY2lObzJaK1BtT090YjJFRVUzbU1DUDRrUEJ4NllwOUdqTmV5cVRWV3lsbzB1eGw2ZUx1VzRMalVQUGlKeHdlbGRYTkRjV3RwTktKcEdBVWxRblVWbmFmbzlzbGc1c0pVakpKYjE1cm5qYzZucDhqZWRlaWFSdVJIanNPeHBXMTNLaEYwNHE2bFozZDFLNlgzczJQRDkxRmVzNVpaVXdRU3pncmtpdWkxTFY3T3l0OHl5Z0FIQXp5YTRHMTFYV3IyYnl2SVJHQXprZE1EclZxNWp0Q3lKZklNOWUrQlRlNG9WbXFMNUphN2MwbHlxL21hWW5XNnNwYmhKR0NnWkJJeDA1cnorYlhQTUVhMmR3SFluRDd1Zy9PdGorMmRKVytYVEZtQjh3SGtaeHoycnBySHdmYTJLU05DSS93QjROeExldnJTVmpucVFyMVkycHlXMXBOUFg1SEpUYW5aV3AvMGhZL05QVEhUcFdoRnBlbjNhQ2VGQVpCeUNHNy9TdWMxR3owbWRuVy9oYmNuQ09wNis5YitsK0dFMHFOYm1LWnlrZ3lvQkp4K2RWODJqRlU1U2s3d2pPSzZkWStac2YyUWJ0b3hzVGNvdzZrRG9LamxzTGRKR2hTR05Yd09tQitWRVdwUVJYTWdXVEUyTTQ2ZnJXWXFSNmdGYWE0S3lzM0dPby9FVXJNMWxLbWszRkp5YmQ5VjAwKzhicVZocmNVTHZIY1lUSFRJeitGWW1uMldzS0I1eFlmTnVPVGtINlZZMUt3OFVSdytYYXlySWhJenU1SS9HdW8wYTV1SUdoaXZVTFB5TWdEcjdWWDJlaGx5MDVWazVLcEhTMnUxek84Nk16UHR0c09nNVBRODF6ME5vOS9kdmtGY0hLc1cvV3U1MVR3L1pMZGVhMXhNaVNZeHNQQXpVTXZoUkk0R2VPL215RitWY2prZmoxcHBydVhVcFZ1WnIyYWFpNzJUV3BraXhZYmtqbjN5S0NBaFBIcGlxOE9sU3BNRWx0OHRqbHNEbFI2VnJTUS9ZN1NPUkkyM2NmTVJ6Ny9pSzNrMUMzdnJKMUVnTW9HQ085Uzc5QzR3cE5wU2RwSlhTL0hxWUZ2cDlyWmJ6Q3U4bmdxQ092dlZ1NGxtamlpWnJJRU53M1BhbGkwSVFTTElzcmplQndUM3o2R3RpUlQ1aU5rNEgzZ2NmNXpVTzl6b3AwK1dMU1hLbHNscVpNY1dpT0pGaGpDc2M1N1lQVTFYdExTMmhjU2lSZ3hQeWpPUjFxeGZYZHRiWlkyMkVZaGNqMVAwcThHMCtHMVdXYTRRRUVGTnpZOXhUc3lFb09vMTdsNDY5ckd5SkwyRStkNWhQSDNjZWxjVy9qTzQxQytrZyt6T0Fnd3hLNDZWdFdPbzYzUHFPQmJvYmZBdy9lcjE2enhTeWdXeUhLSEpGWGRkamR1VWsrV2NsSG0xdXR6azR2RUVVMFBrVzhjZ0liQlBUcDcxMFF2N21BQUlHREtNTjJCRmNYcGR2ZVRTdElnOHZhK1RHRDE5c0d0cVc3TXM3eFRxcWJsK1VqMm9ma2NsR3BWNVc1U2E2UmRyTFFmcCtyYjlRWmJoOEVudHgwcnBMdlVvOU9jcXdESTR5RDFBelhqTTl4b2tFaGlONFJNckhqcm44YTlCc280cDdaRGNEemwyakdPZXY5S1Qwc1hSeEZUV0thNXIzNXIzdDN1YUxBNnhieUpDcFhKQkp4dFBIdUs1T3p0N2Eza2VCRmRuRFlPVG5CelhYeFhhMk1vOGlQYkdRZWNWaFFYVVA5cnlUU3NOdkRGY2VuZXF2b3dxeFRuQ1dqbGUwbjVFa3R0ZC9LanlNcUhJT0d4bjYxb1Iyc1N4cEdKUHVuSkI3OTZaTGYyT29YWGxwSVZCenQ0d2ZmazlxNGJWdEsxM1RyZ3RESzBoa1BUdVBURkl5cWN0T01weGc2a2RtMDcyTzhYUjNoamxudEpEdlk1S0hrSG1vTlRPb2pUQ3NnOHRtNzljZmxXZllYMnJReHhmYUdSZG82azR6VjNYYnhicUJGaGxCa3lNQUhBNDdmV24xMEM5UDZ2S1VlYUxjUGcyMzh1NWlycUVXbVdzU1RYSUp4MDVQdDNyWWcxSzN1RkVxSE9NbGVlL3BtblR3dy9ZSS9QdDFhUUx6bnBWSllGdUlBNlcvbG9CMEI5dW5GVHBZdUtxUWNVbXJjdWtiTzVkZldMaUJQTnVGSWpIRzREUDRWdFd1dlcxNVpuWUEvUUFZeDlLTGFTMGExOGdwazV3UXg0emlzcWF6c2JFQm84S001QTZmeXBYWFk2T2FxbGZuVFZ0YjdsQVF6Um1lVjRjUmtkTWM0K29xcnAwTU1yN3JXVlc3Yk1uK1I3MUhxM2pDVHlVVzJ0V253Y05qdGpyV0ZhNmxiUm43V0FiWi9mcHpUUzNPTjFLRHFSU2twSmI5TGVqTnlTT1M1bGYvQUVWNFpGSkc3SFhJL2xYTjZIRHF1bTNrelkzb1RnOS9iTmJKOFV6cGFOY2JVbEdjRWpBL3lLcjIzaW1hNHRpNnc0VW5EQUhuSXBwdXowTW1zTnp4bHp5VTFyZEx2NkhkTXRyZDI4alN3Z09NNDZISDFwK2t5VHdXNVB5eUwyNzQ5ZnhyZzdMVUpWMUlwTEcvbHlMNkhyNyszTmR4Q1VzazJ3RXNHYk8zUEg0VkwyTzZsT01uekxSeGJUN2xBWEIrMXZKSmI0NjRJSE9LdlN5d2NFS3hBSU9DdjhxaHZOZWtoaUhteExqZ2M0NStsVXRRdnBMWklKL0szSStPaDdIMXFscTFvWXpuVGdwKy9lM3ZPNjFWelp0OWMwKytmWVFZekdjRUhqcFVPcjJTWDhTQkQ4aWtrNEpIQXFnRnQzUG1OYWJReHlXSHRVdDlQcWNkcVBzTVRNRCtPQlR2cmRHemx6VXBxcDd5ZTlvNnY1R3RiNmRwNHRBQ0FDQU1yNjRybnJlQ0czdmxaZmszZFJuam11V2E2dW96NXpvNWRNYmxBd09CMHJwVzFHRzZNVCtYam9NRVlJUDQwYTl6bjlwU2x5MmdvdUxSdjZwb3NFbUozTzRBZzRCNEJybE5ZYVdLMGphTU1xcmc0SjlQV3U2aFVKWnY4N2JPb0JHYy9TdWZtdHJmVTRSRWtwR2NkdjFwWDJPMnJTZzcyU1RrdHU5anorMi90aGtGeERKczNZNFBwL25yWHFLNmJjWHR1cGVZTTJPV0hINC9Xc2VYUWY3UFRhOG04RGtBK3ByRTB6Vkx4N2g0MGdkVlU4Tm5nNDlmYW03djVITEdFS0dsVG05N3BkdlUwZFp2eHBheHhKQ1hKNjlPYzFsVDIzMmdDNWRRQ3VEZ2RlUHBWL1VMcXh1SGRuQU96aHZ4NTRyTXNKN2VYbnRramJqN3VQVDJwTW1haE9jdmVUaS9oajBWdXAwMXZmMlJWTnpoU0JrbGozOWFpMUs0MDJRQmRxU0tUei9uMHFnMmoycnhUQkZCM2R4MnJ6WlpQN09FMjJDV1RHY1pHUmloUlRlN01hbFd0R05wUmhaOWR6dmRJZzA2VloxaWkrWmM1TzNIWHNjMXo5NU5lU1NHM2h0eUVHUmtEcUs1clJmRkVVbDNKQXNUeHZJTVk2QUd2VHRPdDlYTnVweUdjTmxzZWg3MW8wdVl5VUpUcDA0KzlGNjgzS2w5eEhvdW0zZG5HSkpCdEkrODJTZXRkVGRUck15eVFZSkdBUmpuaW90Vm52N1MwSSt6dEpucUJ5TWUxY1NtdXd3eEIvc3J4Zy8zaDF6eDNxYlhPcVVxZEQzSEpxS1N2ZE05Qit3elRBTnNLRmxBUFkvL0FLcXN3ZUdMVzFsV1p0cFBVQ3JHanNiK0FPc2dBenhpdXlDeHNOanNUZ0hrNDc5K0tHckhwVXFGS3B5emNiOVl0OXpqTHhiTGV2UTd4dDlobXNMVXRNc0liY0lRekIrUUIwQk5kM2RDMCt6TW9RTWZRZGpYQjNXdGFaWnA1ZDBjSGphT3Z0MXFkZWhOVlFqZm01RmRidlpISTJGdTlyS3l0dVpQNGM5Z2ZldlFMUDdJMFpVdHQzQTVPZWVheHJHSnBtZVZHREkzM1IzcXZjTjVUUEc1QXpncU00NTlhZDIyY3NFcWNicGFPNVExalNiWnBCc2l5TWdnZzRxRFZydldOTnNWTnZDWFZobjF4VzdHOTVQRXNZNHdRQXg3NDlLN1lXckN5Q1RNcGZBem5ITk1VS0trNmpoZUYwdFVyZkk4d3NialVackVTWFVUSVRucUFPUGV0eTR1RGIyU09xRnQzcDc5cTNOUlJURUZCQVhid0t5dExzcDFDbHlHanllMmNjNDZVRnFNMUpSdTNwOFJkMHUrMCtTTE1vT1NPcFhIUVZ4Y3QzcHNPb1NNcXN1NDQzWTRycmJ5M2pnZDJTUDVEMkdlTTFpeUxwTjFha0ZDamc4bjBOSmJzaXR6dFJpbkJTaTdxNjNHWEZoWmFuQmdUQU5qR1FmeEZhK21hR2JhM0ljN3gwem5PYzF5a1drR0YxbFNWenVBSUE0SDF6NjE2QmF2Y05HQTR3dlFuRkhvOUNLVVl5bnpUcEpTdGJSM3VlTStKYlM1V1VGQ1ZpT1BsSFA1WXJBKzJYTHhlU2tTOEhMRUhvUjMvR3ZkYnkwUGxGaXVSa25yWG5nbjBsWFpWSVZzbmpIcjFKclJOVzJQUHhPRy9lTnVhaXBhV2IxK1JXdXpxMFdub3BDNGM5UmcvZ0szdEQxS1NCQkZKbHNqbjBBK3A2MW9KRmIzZHZ0TEJ3bUNPMzhxNHQ5YjA1OVRGbXNES1ZKQWZIT2VuRk5LNmVubWRIc25DY1pxcHNrbGQ3OXoxb1NzMG13S3JBNXhqdUJ6K1pybjNSSlRMRzhRVXFNZ2RlS21nYVF5S01yZ2R4em5GVXRVYTl0eVpsVU91TUhqQk5RbDBPeWNseTNkN0xkVzZISVNKY1JFK1hjbk80S1JuSFhyaXVraDBhMGJiUEtjc0FNOTgxeDhObThyQ1Z5MjVtQjI1eUQ3SDByMHJ5NUpJbE9kdVFNNUdQdytsT1hTeDV0Q01aeWJsQzYwc2l6YmFoYU5idGJ3TUEyT3ZjVnA2ZGIzVVR1SlJrSG4vT0s4WDIzRmpxQWszQXFYeU1jOWVLMlg4WE5ITUl3c25PQm4zcE5NNklZcWttdWU4WEYyUzZIcXdtVHp0cHhzSFVrOWZjNXEvRTlzRWtqVmdDUjF6bm11Slo0ZFNneXJsWEE1N0g4YXhtaDFDRzVWdytWR0FlQjgxSTdaWWlVVnpLSE5GN05GUFU5UHZHY3NzbUZEOUNjOGRUVzNad2ZZSGpjTUZEbk9PbzU5NjNsUkpJYzhBOTFKL1FpbWFvbm5hZXNVWCtzQTRJNS9ROTZkM1pJNUhSdHpWSTN2YTZOdStsVkkxY0tEa2RDT2xaVm84aktKQVJqMFBhc3ZSWU5TY0xIZEhJem5CT2Z4eFhWM0Z1Q2ZLVTRKQXhta2Q4SE9hVTdOZVQzdVhUNXNpL0xrNEhiL0FEM3F2Sk1UR0JNcFplUFlpc2kxKzNXOHBYSVpzZGU1cnJMbWRKb1ZWZ29KL3BRZE1aT1VXM2RQc3prM2lNVWdlTWtLVHlPdGN6YzZyY0pPOGE1STdZR0NNYy9yVzFkNnRCYXEwYktPT2M0NkdzeTNtc2JvSytRUnUrOTJQdDdVSEZWa3Zoak5KM3Z1WFRxTVRSUmh5Q3dIMTYwVXQ1cEVNdXhvM1FESDNzOS9TaXB1aktVYS9Oc241M09uK3pXZDdkS3R4KzVZREpHZXRjOWQ2WnBFVTZwOHpBc1NSaktuNjFqeVNlSlpwc3RGQXJaWUxKMXl2T09EWGJXc1FlTEZ4aHBWNzlzLy9yb3RaWHVXcFU2c212WTJlL05LTnJpSkxmTks3UndJWTFBOHMrdnNhekh0M3ZwY3oyRUFYbk1qZFJqdlZhOXU1SVE1RWgrVnVTblFZckppOFQ2Zk5FWWlaa2NuaDJYNVQ3NXFsWjlDNVZLUzBuTzNXenRyNUhaV1ZsOWxra1pyaFdqY2JVVDA5cXk3Njl2N1M0Q1c5b3pxMk9BdkdLbW5TZHJHRWlSTndJSTIrbGREQnFrZHRacWJoeEd3SDNtNHpUTm1rMVpOMDB0ZWIxTmlDV2U2U05TZ2hDL01WR00vbFdCcmVqYU5lMm1HQU1nUFk0Snh6eldJK3FhZE04czlwY00wcWo1Z09uUDByalk5RmcrMkNZM2R4bk84b0NkdjBxTGE2c3pxVlZLTnZaeHFYZG03cTF1alBRTERUZEtoajJzRUJJd3dCelZpNDA3VDdLNVdlS01NemtBTWZUMEZjcE5GWWk0anV2dGZsZ0Vaako2bXJGNVlhbmZ3bDRiOTBUM1VaR1BRMDBtRGxGUXRHakZ0YXh0YS9xZERxdzgwZ3p3UnBFUmxqamtnYzVybFRiNk14WjRtaEtIQUx0d3ZIMXJRczlPdVh0dktrdkJOS2hBazM5NmkxVHcvWTN0aXgzQmpIMVJEZ2ZwUXROREtyQ1V2ZlZPTHVyNjcvZVFuVjRvWlREQk5DNkRHWFhCd2ZTcjk4am5TSlpyZDQzbEFHMW1IR2E4KzArVFJyYTVpZ2dzcEZiZHRJd1NDZld2UUpWZTNtRVU4YXBDNHltM0o1UHJTdGJvWjBxam5HZDVwcmJTL3V0bm0ybXBxYithbW96STRsK2JDRGFCMzQ2VnNhTmYrSGJXNHVycDlRa0tLdTB4a1p4OUJWbGJEV0RmbzhvRHc1WUJFWHQ5YTlGL3MzUlJESHRnU05tSTNIYnpRbnVSQ2czSlNVVXBSYitOYW1GYytLZE9saGlaWlFsdklQbGsyNDJzUFVWeVU1dTQ5U1ZyYVZKNDNDa3lFK25YSHRYYnRENGFaamJGbzI1eXdZQUtQZXRTSmRMaWlKdFBKbktuQVZDUHk0elEvUTJsVHFUdTVWWTdyNGQxYmRITmFuNGh1b0lVRWRnOGl1dnpzT01mU3VLRWxyYlQyNlc5b3lRejUzYmdSaDY3N1VCSmNQRURISkRnWjI5dnI3MVV0TFJrekxLVm1RTmxQOWdlbFRmUXluQ3JPYjk2OW1yTnBhZC9QVXNUdGFRckdwWlhHTUV0eVIzNU5ZR28ydWp3STF6QkhES1ZHQWlqZGsvaFZxWFY5TmdXNmE1Z0JpSng4b3lUV0xjYWpZSllEK3lRRkdlVVpEdUpQcDZWYVYrZ3FsU0NVMjNCMlY3ZmFWdXlKUDdhMGNPc2x6RzFxd2pJQjZBanQrRmF0cE5wMTdFWllMdFpHVTRBSGY2MW1YL2hleDFHQ0NhUldKVlJ1VW5ISjYwbW42UllhUzByVzZIQVU3c0hkdDc5S215QnVyRzE0eGFmOVhPaGU4ZUNmeW9pUEx4OHhKd00rbEdreVFMZnpBM1htcy9MeDc4Z2ZRVmpRWDNoM1Y3WklmUFBtTVNDaHlyWnpVMXA0UzBTenVSTFpTelJTa0hjemZNRFNTdGU1ckIxSEpTVGpLTjAxNzIxOTBkbFBPdm5sWHQxRVhBLzJzMWkzczJudGNORkdqeVJqQUpJNmU5WHJRVHM1VjNYZi9DVzZ0NjFvWE4zSEN1eVhZdnpmT2NZRk5uVnJLTHUwdGQydndPUHNkQjBlT1NUeTRFK1p1Wk04ODlobXI5eG9tamd2R3NNTXJZNFVyaHMvV3RlYTBnbGhpTnBENWhsSUdWYmdlNW91cmUvdENSREdyVEFBRXNPdWFMdTI1aXFjSTcwbFpkVXI3OWp5dTNrZ3Y3ZWEzdXJKNDFpY3FEL0RnZHdhc1crZ0tHaWt0SkVreEpod2NaeFhZL1o5VWxobWlsaWpSemxnVmJkeDcxeE5uZDZQRE5OYVRiL09mZ2hBZURUOUR6S3RPSE5UYzQ3clNUOTEzV3gzOFU5Z3QxSkVzME80THlHY1pBOUtTZTBzcnVPS1NPU04yVnVNSFBldVNuOEVhRmNJOTFESElyWitjbDhIQnJTVFRrdGJBUHA2SWp4QWhtWTU2L1NvMHVka25WdHJDTFZyNlA4QUk2eTUwNHBBUEtrQ1NBaGd3WHJqdFMyOXBybHpQRGN6RlZFYTRYdnU5NjhXdk5mOFgzazhkdGFHT1VERzl3dU52NTE2RlkvMi9ZM0VRbG5rdVZLa2JCMEJOWGF5MUNuVmpPcHBUbTQzVjdOV3V1Nk5DVjdOTGw0VXYxaWtkOXhBSS9FVTB5WDluY0ZvSS9PVjI1ZGprVkcvaFhUcis0VnBMY3d1M0xuZnlEMXJ1WUxTejBheFZKRllvRjRmcUtscEhWQ0ZaOHphakNLMmttOVBrek4rMUdHN2orMVdwVkpGQUJIUEpwOHQvZHgrZEhhV1Q3Z2VXOVI3VlVPcTI4aWttNXh1eUUzRGdlOVpWbjRnOHVZUVBjcTBoemtxZXVQWVVuWUhWU2FYdExYZWowdjZISjJkN3J5M21ibG8yUW5sT2pZN1YwMnIzYzhzWVdKWTBHUms5U1B3cUszdkwrWFVKdnROb29DNThxUmVldnFLd3I1SUliK09XU3ltYVFqSmtpQks0OTZkdGRqaWpLVUtMOStUVGx2SzZhUjFOblpKZlJrVE9yT296bnAxNzFyTHAxcENRN1NwNkU5eFhKNmJwTHozVXQ5RlBLMmVDcEJBVWZTclZ2cU5uRmV5UWwwS0p5Vkk1eWUxRE9pRTQ4c1hPQ2pkdEp0NytadHhQYjNFNkxFd2pEWkpjajcyS3FIVDdTeldTWjlSZmVXeXBmN3VQU3N2V1lFMUMwaWUxSndqbGxRY0ZzZWxZbDE0a3Y4QTdFVXV0TEtFWUcwOG5BSFVWVm0wS1ZTRWJ1YVRzcnhscmJWZVIwY3VvYWhFOFFNUG53bnFSMFhpcTk3ZDNkeEVxdzIrNVdPQzVQVE5ZN2VMRld3amRMQ1Y0K2pIR01ZcVovRStxeVFOR21rSFpLZzhzNXdmcWZTa2s5TkRIMjlOODM3MlRUWFNOelhhWTI4WUZ6T3l4UjdUbFJuSjlLU3l2OUJPcUxMSER0bGs0SlBHZTNOUWkrMUVXMFVVNWpqeUFRY0FuanNhc2FwSERjMmNTelBDWlRqWWNoU2Z4NHF2ditSWE85V2tuWkpwU1d0L1U2dUM1dnZ0a3pMRW9Damc5c1Z3MnIrSmZzc21EdGFRa0JsWHBucFhVU2FvdGxaUUlzaXJsUG1CSVBOY3BKZmFTOGVKYk9lWGNjbGtYdjcxQzMxTjYwNWNsbzFMUzNkK2haajhST2tabk51aXNBTm80SFd1bHQ5V3ZyemFUcFNxb09mTUp6VmM2YnBzaUxpTENoUVFwNmpqdjcxVDArNXVicThrZ2pLeHhSZ2JkM0J6M29XMnhFWjE0VGlwVkcxTFJKSmF2NWkzTjhHdkkwbGlieTg4anNhc1h1cVdtbjZsYkNZRHltR0Z3T0I2WnFYV3RFdkx1M3k3N2RtZm5UR1NSWEZXMXBxVnZiZWEzbHpxTWdHWS9NQlZxMmdUbFdqS1NzN3RwcVZyN2RMSHJTT0x1WGNMWHpFYkJXVDJwd3RpN3VyWWlqNkVOemo4NmdzM2xheFdVM0N3N1Z6aFJ3TzljNitwVzl6QkxKYjNTemxmdjV6MTlxT214M3VwRkpYM2F2MDEvVXY2dDlsQmloZ25Lc0J5ZTJLaTA5SXA0MlpKVmtkU2NqcU0xemRsclNYUldDUlBsenlkdU00OUQzcnNJckMxRU01U01ScUJsZHZVbWsyVFJuN1dmTkhsYTdkaTdHR2lneklnRzQ1d0JuOHFxckpicHFKQ3VxeWVYdUliajZtczJ4bHZiYUk1bFdVcVN3RGNFRDBCcHd1a3ZsKzBTMlNoZ0NvS25rZ2ZTazdEbk4yamF5ZDA3TmRGdnFpVFViYUtXSGZHSXQrTW5CSDlLcXdRWGtscEcwRjBJWk80eDJyT0dxNlBZUnZJMERzMjRyaFJrODg5SzFyRFVMR1cwa21pRWh5VHRWaGhxdTJsem45cFNsTkxtU2JUdWt4SjdmV0k3ZkRYeGZPTW9BTUQ4cXd5dW9lYVRKYTdvdG81SnljK3VLNkZKWm1qTHh3NFVqdWM1cXdJcHBSRXZtRWtuQlVkaFVHaWpHVnJTa3ZWM3Y4QWVWOVBZUldzdjJpVVJSNFB0d08zTllVZHJwSXUydUlyaFNNSG8yUWZ4cnJyK0dMN0tZNUdCakl3UXc0cmo5SVNMekpJa2UzVlZ6dFRIUDFQclNJblpWS2NHayt6ZTl5c2ZHV2pLSkJOQzI5RGdlcDk2MFlicTdtdFV1SUVkb254OHB3U0tpMVhUYmU1a2hrZTNUY28rWXFPMzFyZHNyVmhaYnJXNUVhRE9jYzgwT3c0S3J6TlNrbjJzck1jMXc1aFVUb1dJUEE2YmNWTmN4V01zSlNhM1VFanIxelhFM2NXb3l6b2Z0TE1GUElBd1RqdlhVRFRKTDFBcVBKR3lMOTRqdUIxcFdFcDFKdWE1RytpdmJVNSt5c29MUEN4U05sbU8wSGdWYTF1eWFLME1vUWt1TU9FSXp6M3F6UHAxMnRyR0psM3NyY3VPR0hvUlRwN3UxZ3R2bVptbFg3bzVPZnJWYUdTcHBVM0RsNUZiUmRqeWZUN0R4a0xrZVFqUlJNT0dKeU1WMDhHby9ZZFFXMXZWRTAwb3dHQzUyZzk2NnFIeFBQY1dJK3p4a2tmSzVZRUgzckZrOFY2VkRPaXlRQXk1SHplWHlUNlVOTjlEbFNvVWxCeHhEV3pUbHFuNkkyTGVKa25hT0ZTTjUvMW5kZmJGWVQyTTl2UFA5cGtGd3ZHTTlSK0ZkNWFYWDJwR2xoaTh2Y1FBVzQ2MXhkeGIyZG5lVFQzMXl6bGgxR1NNZlFVTHFkRmFNT1dMdmRYM2J0Rkw5VHBMVFF0R1MzRTZ3bzBweVZmdUNlM05VYnJUYjI1bWdZVE91T29CNE5jYlo2bkpjWGtsdkJlb2x0bklRam5rK3Rlb1dTV3R2ZEpISk9UbFIzNEZEVm1FSlVxc0VsQktOMG0wN0s5L0l4NGZEUk04alRUQ1ZNZktuWEJybHJ2WE5UczdvV1VWc2NnREJjWkdQNlY2SHJUeFFORlBheU1EbnIxSFNpeW1tdm9qSXdoWTRJTEVjOFVJNkpVT1Z1Rk51RXY1bHJkUDFPQ3VkSjFHOVZKaTBjYll3V1VZcXpENFVpbGpaUmZPSk51ZDNZSEdLNkt5U2VTOW5ndW9uU01EQ0VjRGp2Vy9IQmFXRE1GeTNISE9SOUtkMmpOWVdFdmVsQzYyYmJkNytodzJnYUhyK24zRWdrdXZ0RVJHUnh5UHJXaGVhbm82enF0enVETjdFSGppdEdQeExMQkswS1djbTl2UmVNZmpWNWtsbmVKbXRRZDV3V0k1SGMwaTR3ajdQa3BQWjlVMmtZcTMwRU1zY2NVTXNxdWNjOUY3MTF0cHFDR1o0Mmh3UUR4ajA3Zld1WG44UDY2TDY1bU1nOGxvd0kxVWNxYTBiTzZhSkZTU0Zpd0gzcVRWanBoN1dFdmU5M1hSTmRDR1FHUzZUYmtJZXFNTzU5S28zV2hRTGRwTHlnUWNoZWg5ZWxTeVMzeTNoRnhneG4vQUZlQjA5dUt3ZFp2TlVNSmtoVXNtTUVMMSt0RjJjMDNSNUp5bEJ5YWQ3VzEwNitoMExTZWIvcXk1QUF4bjJyTFpDR0UzbHMzT0RqcCtsVnRHdjdocldOQkM1M2NOdTRQUHJWYlVyK0pMbUN6U1l4SE9UbmpKSFhtaFh1UTVRY0ZOdTNsdHFhc1VhWE55ek9ENVo2cmpnR3NMVU5DMHE2RDczYks1S2pQSDRWMUVjdXJ3eFA1ZHVzMGVPR1U4NXF0c2VTM1hNQVFuNzJSemsrbE80VGhUbEd6amU5MitaSE5hVkxleFhLUXh5SXR1cWpvZWZyVjNXclcwam5oa2oxS1JDNTVHZXRWb3RHaWp1c3JHVWNnL01EbnJ6aXVqZndpbDdCRkpJNWJZUUJ6elQwdWM2cDFaVXBSalRUYWVpYmRsOTFqbTRiQUxlS3l6U2JUMzNaengvS3VQOFFXMXhmYWhEQkdHeWhCM0EvNDk2OWV0Tk5GaUNrcmtSZHM4N2E1MWRSMFFYQit6NWN4bjVtSFRQdlRUOHJoVW9wMDFGeWpDOHJ0ZFg2SEZyNFVoYVpESmJqUGRqd2Nqdm11MjArdzFLemJhazY3RkdDcE9SZy8vcnJkdTlWMC93QXVFT3BWamtLUnoxNXJqbGxaWlFzTS93Qi9QRGRhalVhalJwdjNiTjNXMmpYa2RSTGI2aEM1ZVVvWVdPZnArTlB2dEtzY0xNamJuUEI3RDYxalhGdTA4WnQ1cFpRd0dRUjB6WExMRnExaXhpTXdrVmoxSitZWi9wVkpMdUVxemkydlpOeGZWdTltVzdiVDcxZFFMS1ZSVkpJYnYrdGQzZmE0ZHZscmJ0TEtCZ0hzVDZacmpOTHZVTTd3WFU0VFBLN3VBUitOYXFXR3BQY1RQSGRSaUpNQlQzejdpbXlhTXYzYjVMdHR0TzFuYTNreHNzSDI2QU5jUk5FNC9oelRJZExzb0hMSWpiKzNPYTNiWk5WRnhGOW9kWklzWU9PbzlPdFpXdlhEaTRpRUxiVlRPZW1md3FYZGRUU1VJdW56dUxiVnQxcitBNlM4d0JIUGFrb3kvS1IwUC8xNnhQN1FzWkVlMWlkNFdBK1ZYNEJwMXRxOE9vN1l5NTNJZlFucFZ5NnVMTDdRcCt5Tkl3NEw0cXJlUm43VG1pcEtwRzIxMnZ3MExOaFkzVWdCYWNFaGVlK1IvaFVlcWlJQ05rK2ZCd3c2OWZXcG9yMkdMZExLQ2lqZ1k1L3BXWmRYTVZ2WlBMQzZ5Ym1MRW5uR2FtMnBVcFJWTzE3YU50M3UvdUpJR3QvdFVZaStVWStaZHY4QUtzeSsxUFFaNW10M2ozWlBUb00rbFJ6WE53bGdMdU9FU1BqbkhYbnZpbTZOQmI2bXhlU3oyRlNBV0FHVDlhcFJNbldrK1NFWEc4bmV6anVqaTdxTVEzUmlqc3kwRGpheFU5UHIyR0s2MnkwVzAweXhhZEpHSWRnZHBIUDBydUxUVC9zb2VGZW1lUXdINTFnU3I5alp2UERUUWxzZ1krNy9BUFdwTjdvaFE1RzN5NzMxNlJaMGNFNlhDcjVlMXlvNUJYQitsWU9vWDhNWjJpTW9WN2dWdjZUcW1tZWNEREVFTERudjlTYXFYOXRjM2JBd3VtME1DNDc0cVZ2cWQ4NWM5RzhKS1QyMFZ4OW5iUjMxdkZJNks0ZnBrOXg5YTd0NFlrS0k4WXdNZWg2VnlaVWlJeEQ1VHQ0MjhWNTZieTlrdkNzbHhJRlFIakhIU3JTN0E2MU9sQ040YzBuWk43SHFWL2ZXNnN5RmdNZmRCNTU5NnlScWIyMXVqdWVDT1Jqam1zYU9IVHJoWTkwKzVpZU8vUHBWU1MzRnhHOFVueUJTTnB4NmZTbG9ZVHIxSlhjYlhhOTJ6L00zb29DOGp6N1JzZnRudFd0UExwcXBsVjR3QngyNDdWemNjMm93WGR0Q2lnd2dBRTlmd3JyOWF0N2ExRVJSRWxNZ3lveHdEUTB6cWcyNk01SldVWDcxMTE4aWhiM01aamJjaHhqTzJ1ZGE0dURkZ3doVlRkanJuSC8xNjdxenR4TjVSRVNxd3dHWHB6V3ZmNmNxeEZsaEFPT094eDNwSTI5bE9VYnA3ZVJ6czgwYzhjY1V6aFc5YTUyMHZMZUc0dUlGL2VGUm5QQjRQSDRWajZ4WXRlZVM5dEkwYmdrT29KR1NQUVVzRUQ2WXJNSWQ4amdnbjE5YzFkbGE5empkV3M2MnNMUlgyOTdxeHplcFgxbGJnU3ZHUUdPQ01aeUIvaFZDMzF2UjVwRWlpQlhkZ0hqQXorRmVpV2xuYlgwUCtrVzQ1T2R0VUwvVGRIY2VYRmJpS1ZjYlhBNy9BRkZMM2V0ekYwcXlqenFVVW5zbjFMK21XMDhhU0JiaktqSkdlTWZRVm1DZVZMWnBIUkpFUWtuQXpXM3BxSVlwVWY1U0J6bmpQZnJWQ0ZKQk9ZbzRHTVo1T2VRZWZXaGIzTnRxY0VyOVVscTlXUjZlZEV2c1BIYm9KRkpBT0J1QjlxelpKanB1cVNTdGRLc1J4OHRkRFBEZFFJc2tkdXBBT0NvNE9EMTZkNjR2V1pyR2RGU2FJaDVmWGtLVFRXL3FaVkpTaFQxc3BSczcyc21lclhHcXdUV3F5SzZ1cEdjZzlqMTVGY3hQZldYMllMc1Z0eDU5ZURWWFNkR01WckVHSEdPbWNkYXQzV2hyZ3VyYmM0eG5qalBURkxSUGM2bFV4RWttNHJWYW91Mjhlc3dRN3JlTU5DM3VPaDlQWVZZUzdJZjk1TDh4SVU0R0RWQ3kxdlVMT040UEpEYk9Qcm50WFF4V292RDU1T3pjQmtIcitOVTlScDh5U3B5bHpMZUwyWG9ZRi9GZlI3WllKQm5PU0twVDJ0bGR3QTNrVzQ5OGNZOXhYUjZscHpvSTFFcmRCakM1L0g4YXdicWFDRklvbkpiTFk1K3RLK3hsVWh5dWZNdE96ZDBSd0liU05mczY1alBBRldaTkZTNHhMSTdBazVBL3JYWVJDTXFpS29JN0hwMTZpc2ZVN29Rd1RyZytaajVWN0drbStodjdLQ2plVFRqYlJkUGtaV28yOGxqRmJtRGxmNHVjRlJUdHpOTEc3WEsrdTBIT2ZiRmNocHcxRzZqQm5PMVFUaFQ2ZHExYjNTckFQRE9KenZYUEFicm5tcXNyN25DNXlhYzRSMDA5MXUxajBpUTJVMEJ5MjNJd2VjYzF5K25YMEVNclFOSm5KK1hKNFB0VVV5cEpiZ3hnWnpnZ0hKL0dvTDNUbWh0VWRFd1F2NDBySFk2bFRtYmlsN3F1MzNOTmhpOStaOXlEbkJQRmM1cU54cHB2R1dQQ3RqcG5IUHI3MXBhSkpjem8vbXhnTU9BU1BUajhSVVRhQzg5d2pORDBZOGcvNTYxVmpDYXFWS2NYQ0s5NlY5VUxwdDNOREN6VFI3a1Rwa1o0N2RLMUlkWG5rQmNRcnRPZnhxN05Zd1F3RU8rRGdZNC93cm00NEJCSVZMa0kvUUFlbFptMFhWZ294YjArUVNhcEc5OUhBVjZqcmp1YW96NmRwdjJ1UjJoQUp5Y2c5L2VyNzIvK2tMdGlKYkdBY1k5NjNyY2gweGNCU2VjSGo4NnV5OURGSnpiVXJQVzhiclk4NzAyU0ZMbVpJMk9DT0FlT1BwV2xlV3RsREFiazI2K1pubHNjL25WcTlzTlBtbUR3RUkyY25qcWZhbEx4dFkzQ3ZJb0tuNWhqbjhhVGV1aG5GT01aUmJqczdOYkdScCtwQUs0V0k0WThIcjE5VFc3QnFOdzBNa0JYY1ZIR1QvS3VlaHZiWnJSbHNzRngyR2VLejRyMkt6dUM4allaanpnY2M5YWRtemo5dTR4ais4dXJhdGJhblEzV2x6d3dHWmZtN0ZUNis5Y3F2aVBFWHp4YzRBOWM0NDQ5cTYrNDFhUVd2eUFuZHh5T2hybWpZSkxxQ0VsUXBHQ3BHM2FEM0ZKUGU1VlNMVW9PbEsxN0pycHFJOTFieTJyU01RUWVmbDlxdjZkbzluTVBOTWFzRDBJNDdlaHBrR2xXc2R4SVRoNHovRG5PQitIclhYSUZ0N1ZoR1BsSndwUGJJNHhUdjVzMGpSdk44eWpaYkhCYXpIY3dvR2dWZ1ZIRERQT0t2YVJyRzJ5UVR1VmtYSiticVIvK3V1L2p1NERDaVBHR0o2RTlDU0s1alV0SHNacEluUTdTT3A2ME42V0tsaDV3cWM5T2FlbXNXVUl0WTArVzlJODJQT2NmNU5hT3BYUDJXUlpsd3dHTytNVnhzR25hZFkzVS9tekJ0MzNjbjlDUFd1cnRuTXNVcU9oWlN2eWdnWXgxcWRFYVFjNVJhbFpTdjAxdGJ1WWx4cmVvcmV4UEhHckk1empQT0FPRG11c1hWcHBuL2VSc2hIM1d6WEoyY1NRem9aQVFxay93ZFA4QTZ3cnZyaDdlVzIzeEJHT0FOMlA2VTJ0aFVuTjh6Yyt0N0VyM2J3VHhPUVNXNEhTdDhySGVxcks0SEI0SXJ6ZVN5djU0WW5rQTZuSXlRT09sTGI2aDlpWmNuSnovQUFrbXB0cWRpcS96UmFpOWRTZlhyQ2J5VHRUZVZJOVNRZndyRTBWNXBnOXZOQ1U2NEo2SDMrdGVsdnJDZVhFKzM3L0dDTzFjYmZYOFBuc2ZMMjhaSlBINDFYU3lNSzFPbXFpbno2YUp4N212Wk0wRzVKQ0NCMjZjMFZrd1F5WFVZa2pteG5PU0tLajVtMFcxRmNzVzEwMk4yN3RtbXc0QmliZDhqTnlCV2xxMnlLd2pVbzN6RDU1VlBUUGV0MUlkTmtpTXAzZzUvajZEL3dDdFhQelhyM0xlWEc4WmhYNzJWNi9TbXJqY0ZGTjZYa2xzY2hwMXRwSmpPMlNZcEs0QkxudUs5Smh2dEZ0NHZJZUpTRlhPTm9PYTRxNnRkR1dPTjN1bGljTVNGTGZLM2FyQXNQdFVHMktUYVdQVWM1OUtWK3BOS1VvZTdHTUcwdWh2UWExcE1oTHFvQWk0NEI0cmlkUzhUYUZlM0VNVnpBSlgzSGF1Q01EMU5ZYytsNmphSis5MUlSQld4d01sdlN1cDB5RFQ1ck1sMVY3Z0hBZVNNTDFyUkdVcTFhYTVHbEZ0WHRKS3orUnJXTnZhcEs4Y0N3cXJwa1lJNEhvYW0weUl4VzhxdXBKM044NU9NMXpGenBOM2IzSWF6akJkamlUSk9PSzVyVXpOYlhBZWE3OGxRTnpCcE91T29GVDEzSlZYay81ZHU4YnJUYlU5R2dPbDNGdmNDYTNUekFmbDV6MHBaOVExT094OHNXekRhd0s3T2NyWGtta1hVdDdaM2IyMWl5THU0bGQ4QmgzeFhmNld0Mm1uTzBFN3lzeWtoR1BISG9mU2pZbUZXVWxGY3RueXU3aXY2dVdudWYzWnVKMGRFWlR1UDhYSGI2VWFSYWFQY1cwOTNhenlSc21jOG5IMXdheExUV3RZTUJXNmhpRW1TRVFjNUhiZzFyNkZKcUwzTTBFeUpFU0FmSkM0NDl6M3pSclltRXFVcXNFNDgxNzd4MVQ5ZWc2eHVMNEM2a0QyMXc2Z2lMQkEvT3Awdkw5NEZudlFDVndER2d5Ri9FMVZ1N2Ireld1SG1zU3dKQkFqR0IxclBoMDJTNGFka25saVNVY0prOEhyUnVXbk9Ob2F1Vm5lTi9QUjZuUVFYOGtseDUxdmNONVJVNWk2bkk5SzZDd21lNWRnV1JTQitQTmVkMjJublM3ZVFySzVra0d6YzR6ajZWRllXTU5rSjJlL2tNcmpLTTNBREdocGEvZ1RTcVZWSmM4ZTdrdWJSR3BlZUM3ZTVsblUzN0I1V0FLazlqNlZWdkxDejBiVGhhV2wzRERPcDQrYmxpZldvWkxiVWxXRjdpZHJvcmh2aytYbjYrbGExcDRWaXY1emN6MmtTeXhubGR4T2M5Nk5iYm1VSTh6bW9VT1dUN3Q2TDhkVG45RkhqRzNjdmVTcExFVG5jT1d3ZlN0R080MCs0MUtXM2drbVRjRGt0d29QK2VsZHJkQytlR0tDT01Mc2JhRzlCNjF4OHIzRm5mU084U1NvRDgyMWNNUGVoV3NPcEYwN2F5Y2JxN2FOVWFSSG84YXJmeS9hUE5iaGdNa0RyakJxOVBxbWl5U2dSeEZGd3FncXZQNG50V0F2aWJTcnd5cEZaWGNreURJR3pJR1ByV2hIcmR0OWxhYVNSVVVqRWtUTGdxZndvMXNid3Ewa25HbktQTGErcXU3THpkalhsTVBtS0d1WE9lQUdJQU9lTVZWdDdlMnM1WFVzQnU1WXEyN09hNVFyYjY5SEdzVXUweHR1QlVucDc1cnNybTNuMHEzZWFLelM0WGdrRGxoNjFMWFRxSk55OS9sWEt0ZWJmVHJvY0ZyZHJwK21YbzFBUmtMdE9jTDEvTHVhNjdUTmJzTlFzaExhSzIzeXh1Umh5RDdacmUwL1dEcTlsdWtzSGppSndHa0dCeHgwTlpjdW4yVmhjTkl1VUxMZ0VkUHlGRGZSN28yNUV2ZXB5WEpKM2QxYjdqeXVQeEZaM1dyTkZlVzA4RFF0aFhZN1ZyM0V3V0Y3WXJpSHpsMjRYblBQWE5lY1gzaCsxMWFGdnRNek1Ga0JRTDhwNDlhM1d0MzBtYXhlRm1XM1BES0R3UGMwdDdFVUZLTGs1UlVvdTEzYlh0YzR6VURweVNJMWxxazFqY1c1QWFJamh2VUN2VTQ5YWEvdEl3RW1MbGNGd3VNL2o3MU5lRzF1NUlaRXNGYkFCRWhIZjYxWTFIVVlOTXRZNStnTEJjWTRCUFVuSHBXamxmUXVFSEIxSk9wRlF0cmFMWHoxT0FrMExVb3BqTFozRTBjZ0dHM2tzckw2VmJ2YkxTTHUwVlpJNUlyZ0RtVkYrYmQvV3ZRTk9ubGUwa21qdW8yREhxZTJhenJlK2ppdmdaQnVaVDh1MzVnZnJVM2R3V0dvcEtQMlpyVlBWZkk4L0hoT2E2czVvanFzMGg0eEdUdHdQZXV3MDJLUFNMUDdPOFNzb0JHUUMyZnI3MXA2NVl5NnBiM0p0Wm50bVBMT0JnajNyZ05EdkxIU3lJcDlZa3VwY2dIUFRqdHpTZHc5blFvVGkxRksraW01YVA1TTBMYlU5Smh2dU5PbVVjNTJwZ2RlL3RUcnExSDIzejRKekdIWUhsengrRld2RWQ3Y01WK3d5S0diQU80Y0VlOVpjRDZSWlJ5UGVRc1pDQXpNRGtIdHhSZlE1NU9QTktEYXRGMzU3Y3FYbzBkSFBjbTV1Z2tNeXQ1S0RjQWVXTlpjbmlhRlZTMnVHYTNkMkkyeUx1NDljMWhKcnZoVVJLVEk5ckpLNXdTTUhHY1ZuNjVyK2lXTVhuUE05MWh3cU1WQjI1OURTTm5XZHVhTmFPdTl0YjM2VzNMbHpvUy9hRElMNkpyY3Q4cXk4QWtqcG10S2JTZkQ5cEdyN29ZcnA4WU83UDVDdkZ0TzFMVTlSMVc0aU1ZdXJkenVpVnNoRVA0ZWxkbm9Xa1NmMjRmN1F1SVVWZjhBVnFXNEI5Qm1uZTU1Nm5UZFQzYU1Yek5lODI5R3owT2ZYcElwWTQ3Q3pOeVhBVm02S3A2Wk5kRkExL2I2ZVdta2lCSnlkdnpZejJySjFIVWRLc1JOSGNBckhJcEJsaEhmOEt3cmZTWTN0MGtzTGlkdHAzSXJuSWtIWFBOTG92elBUNTZrSnl0TG5kbjdxZHVYNWRUMEZyKzFTM3RyY1MrV1hjdmpITDE1MWJ4YVkydVhMdGJUU3lON1lRQ3V1MC9VMVdXSVhscWZPUEdOdWRwOWo2VnFJMTR0MWNsUkhzSXlBY1pIdFNkMWN1VW5XOW5KdE8wbHB5NnBKYk01cXcxUFM0RDVjVWk3Vlk3dUNkaGJ0V2g1Z3VMa3pKYm5ZbUFKRHp1SDRWSmFYVnBGRE9ibTN0MERFbGlvNU5OWFViVUk4bHJNcktVd3NXT3c5UGVreFFmdXhVcFI3MlN0dDZsaVp4RGFUTjVVYkFrN0IwK2J0bXVXanRiT1NhRzlrZGpJQmd3cEp3RDZZOTYyb0w3VWIyNFdLVFMzamcya2wyR09lK1I2Vm56ZUhKV2toa2doaGhLUG5PNDRPT2F0TDVCVWJuRk9GUG5TZXpUWFhkYUVzZWxUWFYwODd5S2dCK1dFakpBL3hxVFV0RnRMeUNKU1Bsak80WkhPUjJ6NlYwcXhhaVlmTWxpakJVamxUd1QycnkveEhyR3BXOTZzRng1a2FPdVQ1SzVHT3hwcTVGWDJOS2xKeWc3U2V0MXYva2JzK2hRWDhBRzFVZEZPMGdaeGpvYW82U0wyMWlDTmQ1K2NvVEl1QlRiSHhCczBlUzRqUnYzWXdTdytZZ1ZyMnV1YU5xOW92bGhqOHdWd2VPZmVwdFl6aTZEY1pKOHM1Ujd0WFh5TjJHQ2ROVWluWlZLYk1aWGtNZldvdFhnMGxpODhwSkp3TnFIQkJyQzFGcjdSZklFRVllM1kvTytkeFhQK0ZXYmJVSUJkcSt6ZjVuR2NZK2IzbzFOdWVsZVZKcXo1azJwSzltK3E3bkdYSGkyODAvVVlMYVhUNVRaNEg3MVNUMTdtdlM3TkxDOVVtTU1XSElEQWpnKzFjYkxQNHBlOWtYTnRIYnRKeGxRUVFQcDNxZTd1THV5Z21WbDNNRGtTS2RvSU5ON0dWT3BKU2x6S1RpbjlxTnZ1TzduaVdPeDhpQkR1bFlyazhnZld2TU5PMExXOU1lNFNlNGg4bGlTTnE4akpwTkJ1THI1N28zV3dGc2JHZmZtdTFtMVNXVzFsd1k1TnhHVnlBVDlEUnNYUDJWUzA5WXRMM1V1eHptcHpYN0pIRnBrRUxzQmt5UFczYVdXcXlSS3pha0kyd0E2cUFlZTlabGpjckxNVlpKSURnQUFqNWFxemVHSm11cHBsdnBvc2pHRk9Sayt1YUVUeXltdWFLbE83MlV1VzFqb24weVNPNkFqMUFuZVBtQkhHUlRQc3ovYVlTa3p3bERsZ09WYkZVSW83bXlrdFlVdW81aXB5d1lqZHg2MXA2bHJFOHplU2JjSndIM3B6bkZKbTE2ZG56S1NhYTAxZm51WW1wVDZkRGZSWE10dzRSY3FRRjRKK2xZa0d0UGY2aTYyOFFFRVl4NW5UOUtnc05TaWtaNHJzb3BJTzFuNXoyclY4K1V4TkFKSVVSMkFSb3h3eEhZMDJ0TFdQUGRUMmpVb1R0RnU3U1d0L08reDFsclBNdHNBWlEyVDZqR0t3NVpibVdaQkZJUVFlU0JuSXFkdEttOHFGQVBOUkNDMjA0NVB1SzZHMmgrd1FtT0sxeXhiZHVIT005cXlPK0txT05uZEpXN2o0OWIwMHdtQzUyNS8yeGpGY3hxVjVCRisvc29veXhPR0pIWSs5SnIybUxjektSR3FyNWVTNTU1K2xUNlBETEhwdmt1Nk8yZS9vT2dyUzZTL1F6bE92T3BLbTRwSko4czdhNkdtZzFKTFBleWhzL3dCMGNZUGJGVzQ5SWhMcExETkpBUTJXd2NLZS9JTllBOFFTV2NpeHlLUkhJY1JxRjNIUHJYS2FyZjJ0eFpMOXJ1WnRnbDRLWlg4RGp0UXIzWG1QMitIVWIzNW5GZFhhejlUMFNmVmRLajFOUTJUTStGSkM4Vlh2WXJwTlNFME9vRUpnNWpZY0gyeFdQSGFTcGFac2RobVZjeHBMajhNbXBMRFhQRk42N3gzMmxRUlAwK1U1NmQ2cTV1NmtwMzU3M2NycHhUMzlVemNtdTVaN3VCcEhTTlNjSjdtcU90elJhVmJ3dWdReU8zekhHZXZ0VnZVMzAreGpnbnZReEFiQUNqSkgrRmJzRXVsMzhrY2tMSThRVUViaGpINTB2a1ZKT1hQSG5qN1IydGQ2cnpzYzFDcTMwQ3lSdEhuL0FHUnQ2ZTFjenJDYWRQRUxhNFFReVNINUh5TjNIMXJwTHZXZFB0NTNNZmxtTUg3eS93QjcwNHF0cWNta09MUjU0bFdWamhIUElCb3RaMzFPZW9vdUU0ODBHMGx6WDIxME03K3k1N1BUeERIZVN5aGh6bHVmd3JLcy9JMCt6Mnl4U3l5RnZsTW8zQWcxdjNlcmFkcFlpRjQ4cmc4cVZYUDRWdFNYOXpxS1JOYjI4U1c2cnUzU2RUK0ZMVzJwTGpTdmFNdmVpcktLOTVyNUdGOWl0eUkya1dHSVozRXFPZWE1dTF0djdYdXJwVXZVOHVOc0t3eUNmeHJyWUw5SjNOdGNSd2xBUG1ZSGo2VVhuaG1LMlkzc0Z5VlRHZktHQVAwcHBreXBLb291TVZLS2Z2cS9LOWlLSFRMaGpHajNCWlV5T1QxQi9yaXZUcmFEVGJPMmpoQ0RmOVJrKzllWUhXTENPeWNuNW96OTV3ZVJYRzNsdGFYM2wzTU41TUJHTXBLcEpIQnJQVTYxaVkwMWVGcHV5MGI2Zk0raGx1WUNoQmlLam9WYi9QU3EwbG80aGJ5VkdRdkFKemptdkVZYnZ4SEd2bXdTdzNLTUJtUnpqYVBVajFyVmphL2E2Ui90M21CaDg2aHVNRDBxdm1hdkZ1VWRhVXZWYWI5anNvN3hmTVpaWkZEUmpjejdlbjFycHJtN2xnc1lwVWo4NVMzOEo1elhtMW5JcmFsSjVkeWtrZTM1NHpocytuUHRXMWIzVjdKY1NScHNDRGxRT0FCNlVreTRWNWNqVjJydXl0cVo0MUR4TExmbG9NUng3UmlLVGpOWEh1Ynk2aUxTc3NURE9lT2hGZEltb2FOdlZIbmhNcVlPTjNPVDJxZVA3SmNXOG02TWJUa01jOFk5YXE3SEdOOVBhdVRkNzNmOVdLY01GMjFuZ1R4bHVBTTk2WnBOZ3lMZFF5cnVZa2tNUGVxVnVMZTB6ak1pTWNyMzQ5cXlielhCQmNBSVNpc01aUFNtbm9aVHFVb0tEbDluUnE5OXpmV3lOdE1JbFpmbkpJSndNSCtsZVphMW9Gck1YRnc4d2xCT3h3TTgxdmliVmJ5VEZ2RHVkQVdXUnVtZXdxdmJhM2ZRdkhIckVBRW0vQ2xSdzJPNTlLRTNlNk9PcTZFb3BPTFVYdEpyM1Y2czVPeThMZUlyV3pUN1Bxa2czTUNWSnptdlVMTy9taVRaZFd1U281WURQSTcxZ1grcHpYYXh0YVhDeG9yRU42bjg2cTNJbWtrdExvNmdWVUhEcjJhbnE5N0dVSlFwWDlrNVBicW1tdTZ1ZGhGREVYbHVvdHhaaDhxdGdjK2xjOXBPcTNCbXVYdTkwTWFqUHNhNXlEeGhCL2F6MmR4QzNsTUJ0bEh5ajhxMUMwNzNDUTJ5TE5iczJYTGYzVFNzOVNuVmkrU1VKYk4zaWx1MzF0Mk5sOWEweWUxa2FDVlo4NXlEbklIVHZYRlJhQmIzMFR0Yk41UmI3eURxYTZVUytHN2Uvd0RMbVNPRmxHUU9uNTFvM1YzWjJpeVhNR0FDUWRnUEpIclN1NzlnbEZWSTNxU2crVzZsYm9ZN1dGdmJ3SUdSbk1mTERxYyt0Y3JOcUt2Tm0zZ0oyTm5wemtlM1lHdS9rMVV6S3NpUTdRd0h6WkhmMXJHc05SMHkyWmhjVHhaZjV1ZXRNd3FxQ2NVcHFLZjJyZHZVenJwOWNtakV5em9pQlJ2QlhrajJxRzVDM0ZzVEE3TXdHQ1ZyUXZiblNwcDFpV2ZsaDl3SEJPZWxkRm8xcGF3d21PS05sY0RIekE4ZzBYdFlyMmJxVGRwcHhhczN6WDE4amtXVFQyRU1kNVk3MUlCV1JSaXUyaTBpd2ppVklNcnV4a0U5SzVUemJxeHZmTm1LeXJ2TzFRUHUvalhvTTcydDRWaVFCR0lCVXFjZGUzRk5tdEdGTnFUY0Z6TFRWYS9lakRNTnZHemg3MERIUWRNVm1QcGRudmVXS1F6T1FjNVBIMHhVZXVXbW5lVmp5ekpMMElCNm4ycDFySmFRUitiY1JQRUZYb3AzWTQ3MFcwRzdLYlRqRkpkYnZRNTZPM25qdDVqYjI4Y2N5bkk0NjkrUGF0SFRFMUNRU0c1a0FPTTRDNEdPdFcwdEV1YjQzRUV6RkNPRjU3KzFiT29xdHpwNWlhZElwMVB5NDR6ejNwdDNNb3dzcFBWcU43SlBTWDNHVThNWXRpaG1PN2Q5MXVSaXRTMGlzUmJPczRqS01PYzgxcHdXUG4yaXhtNFNTUUx5dzlhNTYvczd3MnJDSzJ5NjhZempkaW9zOURxczRlOXlYU2p0dU5NTmpiU1I3RHZqWTR3TzN1YWRaV3lMZXkrVEtGajQ0eHpudFZuVG9VdHJhS1NlUHkyQnd5a2NmNSt0WDdpd25lNDN3TkhzZm9PL1BybXF1UnlYNVdvYk5QbFc2MEtRWFVJdFNJOHdNcEhjRCtkYjYyTHZMbVFnb0RuYmpOY3hQcE91V2wyQzBvZEdBd01BbGMvNFYxbG5iYXRGTTAwczhMUXNQOVgzSC8xcUxkMmpha3BPVFRwMUY3M1hwNStodzk3L0FNSTZsMDdOTXNZNERkdWxjL3AwV254YXBKUFkzclRvNHlVSElyc3pvK2pUR2ZmQ3Azc2NqUFVudFd2RHBtbTZiYXNMRzBWU1J6bmswWFhjNTQ0ZWNwM2NhYVNsZTZ2Y3dyS2ZUN3lSbCswQkpBRGxmcDF6bjZWTlBxMmtRSThTeCtaSmtnbkdTZWU5UlcyaWFiTmZwY3U2cTUrOEJrRDhmcFc5cU5scGxoQzdScU5yREpKOStnNXFUZU1heWczN2lzM2Q5MTZISHBZUVhoaWRIVkZKM0RuSFN1bzMyRUVEckttUU9TY2RlOVZyTjdLNnNZL0pnNEhPZjdwOWNWbjZsYjZ1ZitQZDQ5bTNuY09mVDhxZG5leEVZUWpGeWpDN2FWMmxlNXF4M2xoTEF4UU5rcVF1ZU1kcTgvdHRXa1M2K3lYS2M3anRrNS9DdDZHdzFpT09RWE0wWkRmZENqQStsUEMyTUx3L2FXUU4vRHU2bjJwcnIxT2VvcWtsQjgzSlo2cHBKTkhZV01za0FDTVFmb01mblUxdzJxcmRKdWxIbHR6dC93RDExek45Y3lYZG9KTEk3Wkl5RHQ3SEh2VTFwUHFPbzJ4KzBFUXlJQmdnNUhBNzVvc2RrYWlUNVZ6dlM4V3RuNVhPZ1JvNTJNWjJoaDdkZnJWS1dVUjNBaVlBbnJ2NFBhc09lM3ZyWjRuUXErUUEyRG5IdlhQVGFoWlJTUkxmWEd3czJVeHgzd0JudFJjVXNSS3pUanl0UGQ3RWwzYVNGWmRzeFNSanh0eU1mbFdkSGR6YWUwY00wWG1zVnl6NS9VVnU2bGFYYUNDYTN1VmVJWU9HR2MvalJQSGNYMHlCUUk5MGYzdUNNNTQ1b2J2YTV4N1ZaSkpxU1NYZE5NenJUeEpiM3R3MGNkc1lzSEJadU1tdG5VTHA0eXVXQUNnSGc5Zi9BSzFjL3FGblpyYmlPYTZTM2tVOE1Eako5NnFXOEVkeFBCSFBkaGxDRWJzNXlQVTA5TnluVXFxOFhadDIxdWw4bWpUMUdYVXJoYlM0c3B2a3lONmpuSTZaL0NybDlhVzVsUXlSWitRYlc5Q2ZZVlNab2JPNit6SStVNUk1OTYycnEwdTNFVHgzUHlGY2tWVjlocThsSnlpMjdybVMxVjEydVh0UHQ1bVIwbGRoa1pINGZ5clQxS3duR21Lb2tKT09vNHJuV3Uvc3hqV1NVbGx3ZVJrbi9HdGFMVzdXUGZKSkptTGpLbnFQd3BYZlk2bEtnb3lqSjIwczIzc3ZNNUh3OWNUNzU3YTVRRmxBS1NkTWcxTmN3M2Fhb2pKS3doVTRJejNxN2RYV255WEltdHdBekx3ZHZTcUs2aE5hYWZ1ZEJJU2VnR1RpbmU3Mk9KS25HbW91cHpLT3ZPdXk2SFF5WDhxdkdWRzdQZHVmNVZtNnhMQ0pMZk1CWU1RV0k3RHVhNXVTL2U1dHhMSEcyNEE0VWYxclZ0ZGF2cG80VmV5WldKQUpQVG4rbFNrN2xPckdTY2VaKzlacDh0MGRsWnp3ejJ6SWpmT004SHB4WFBlSXBOVGhzRm10b043SjFBUE9QVEZkSWtHQWdFWURISEk0TmJ5MjBhQXJ1M0E4a2Q4MEhlcWM1VTNHOW50ZEhrT2w2dHJkeEEzMm13MnJ0emxmVSszclV4bER0R2hqS2drakJPTS9UMXIxcTF4aDQ5Z3dPbkdPbFpkekJwN1NGWmpnZy9LM1RHS2Z5TXBZZVRoRnVxNVArOGNnNHRMR05pUzI1eU1nRGpudFdyY2E1cHN0dEZHeHhnL1RQNG1yMTZxckVFU0VUSHR4bjhqWEZTNkxMY296WVJDdk8zcWV2WVU3YkVWT2VDa29SVHV0ckhXK2FwWkdqa0NqMlBCOWpVOTNyQ1dZRGx3UWU0NmpzYzU2VndWc2I1VkNORHU1R1dIVDlLcmVkZXBjdEhMYks4Y25HN09jZm5RazJIMWlTaGRKcS9rM1puUlRhellYRXlxMHFxRDBZOEd0VVEyeFpaQ1ZrQ2ovQURrMXpyYVhwMXhHSTFqMk9wQkk5L1Q2VmUwVzF1VW5NVGh0bzdFZEtMS3oxSEJ5YzF6Sk83MGFMVjFyMXV6aU9LTWh1Qm5BNmVtYTUrMGl2amV2SVgzUmR4Mzk2N0tlendyc0lSMjUyODFtMm12V01VZ2phSWhpY0VGZWxKRTFOSng5cFVTMTA2REdrMDk3bU5CbU51TWs5L3pxcFBaV3hra2FQNXNnZ2pQNmNWZjFQU0xPOUxNcDJrcnd3NmoyOXF5N1BUYnUwdFcydnVIT1c2NW9zdEJPblU1bmVDYTdyL0l4b2JSTGVRQkxaazlUakZkMGRNMDJZSThrWUpJR2M5TS9Tc2U2aysxV284bTRVeWRPYzl2YXVXdHhxaWd4elA4QU4vQzNhcStaZy9ad3VsRG1pL1N4NkhmUVdqUkJFaVViUnpqMjdlMVk0MCtHWldkY2doZllrQ3NLMkYrcGI5OFdYcHVBejA3bXJLWEY5RklVVkY4b2duUFQrVlNQMnNYWnlnMTB0Yi9JNTJMU3AwdWdrTXVGM0VuL0FPdlcxR3VwcjV5VHB0VkJrSG5CeC9qVzhoaWUza0s1VjE3amdpcUl1cnlaREVUbGgxeU1nKzFPVHVqT05PbkdWN3l1OVVscy9JNS9USkw2ZGlINEc0aFRqM3hqNlZrWG92NDdxVkVVazhrYzdlRFhUZVlMV0p6c0lLbmp2eWFXOGNYT25tZUZ2M3lMZ0RIU2wyTXBRYmpibWQ0cS9tY3JENGRFc0MzTTB6QitoQkhQSEhOZW9XTmpiQzNBV1Rqc2Y2MXh1bDYwSTdaWXJ4VG5nTjA1enlLMm52WVpabFcwa0dDT005S1R1M3FYaFZSakZTaXJ0eFYwOTdsM1ZJWkxXMzJpSHpCbkkrYklOY0REcWwwREY1ZG4wUEliZy9qNjEzZDdQcWYyVmRtR0tua0VaL01VN1RMN2FoTjNCdE9QVEg0ZzAxSkx6TjV4Y3E4VXB5Z3JmeTZmZVR4YWc5eGJFU0lVSFQwL0NtdEhicmJ1U2drSjl1ZnBXVStyV3lYREsrUEtPY0VqcFRveEhLLzJpM216RjBZS2MrL1NrZENxUGJTVDI4L1UzZExpdGpFR2wyakE2SG5IMHJKdklsbFovd0IzbFd5Q2NkTStsTGJYT250RElUdlFqT2M5dWFvdGV4MjhUK1Vwa0Ruam5uSHRSZlhZaWRTTGhGYVd0cStvc2NjRmhDcVIvTVRqY0FNR2l1VHY0ZFgzK1pHNVZXeHdCa2oyK2xGQ1Y5Ym80WFhjSHlxbE95MnNqMW1QVWJHNHRXTnM3VFpHNGJoajhLaWhhVzNqWENSbFg1Wk92WHNLeXBOT2pNZ1dLK1JDM3pLRUhIUHA2MW5SaXl0YnE1VzR1cHBKUW9QQzlEMklxRHNuVW1wSzl1MTdwTHVhK3BhTkJkYWUvbVJiSGtPUWNmTXZjWXJsREhlMmNsdEJGUE9PQUF6RG5qcCtGZExIZjY5TWgreUxFVlU0M1RIREhGUlNXMXVsM0JkWGtxaTRRWVpBeHh6M0ZPeGszQnRTaW1ycFhrOUUxZm9jNkxEeFJkQmpjUkJXU1RjR0dNa1ZwdzMwelhQMlY3Y0NhSWhnNU9BUWU5YTQxR05yNmRiTFVGbG4yOHd1eEFXaWIvaElKVk1qdzIwTHF1TUQ1aWZlaS9kSkVPRm90eG5Vazc2L2F1bDU5R2RSWVFpU05sQy9PckU1QitVMTRQY3hlRzcvQU1VTXQ0c3JGWEtiV3p0eVBTdlNiWFVJUHMwMXVaV2psaVlOSVY0UDRWeFZuYlNOcWhuRWJUTEtTVktqZ0U5UHhvajU5aFZaYzBhS2haNjY5Zkk5ZGwwcXhGb3NWckMrdy9MdEM0QUI3MW5Sd3kyZDRiU05vaEZzQStmaHZvUGFyRUdxNnpCSWtZaGFKUndYNmdmV3F0MWQ2Zkk3VHZFV25peUFXNDVwM1BRY3FWNHVOb3RXWGJUc2pQbjBHZUx6SllHaldWaWVXNUFHYzExRU52cmtUUXV4dDVONi9QTGpEY2YwcnpEWE5iMUZiV0JiTWd5U1NBWVkvcFVMV25paHA0N20vdUdOcUVVR0dNOS9icFRUME9iMmxHTTVLRVp0cTE3T3lYWFU5aSswUHY4QUtsalNVRlQ4d2JuUG9SWEJYK29YN1J5dzI4SmpLTVQ5M0p3T2VwcVRUZEoreVBMc0xvc3dEQkhQellQb1RWSVIzOGR4TEhEY0dJeUE1RHJ1S2s5em50UzZzSnpxU2pmVmF1OXQvd0JDaDRmdXRNMW05WXZjVEpOYkU3b2ljQSs5ZXBTVzhiMkxLNWpHNWlRU000UHJYa3RzcTJSdjBlUlo1aWdBT3paazQ5UlY3VDc5MHNZdk9qenRKTEE1YmdkaFExMU02TlZjdHBSdTJuelAwMDFzYU5vOFVlb3VEY3BJQ3BBRzdsU1BYOGEwcnZTTlN1NWZOdGIrT0JnUG1SZWNudG11TnV0TzAzVnBEY1IyY3RzUWZta0h5NStncWV5MEthSzdGczE1UGxqdkxJMkRqM0ZWWmQ5U0k4K3FkTG1nM2VNbEpvMlBzc3NGNHMxemUzVWgyNDJJY0xrVkphVHhmYTV0dHlXRW1kd3hsaFhUUHBKUGwyN1R5TEd2Vmp5VFhGWEZqTG9FTTkxQklrbm5NYzVYTkpMVGMybkdWUDNuSDNGZHlkN3RPMzRuUlhXci9aR1dPSzFaQkpnTE13NUo5TURwWElYOGNVZXBxOXdiZEEwZTBoamtidW9KRlZZZkVPcnRxVU51NHQwalpCbVBCTEFkUWNtdXF2MjhMdmhwbGgzRWJRV2JISSt0TzF1blRvWnovZXdkcHJTU3NwYUxUME9ZODF0TGJ6MXVJUXN4NnhER2NkOFYyRmo0cmFkWm8wdEpDd1VlVTVCQWMrK2F5UHM5bk5GSWtzRWFLdVZpS25QQkhVZTlYYmVIVWZzdTBTNGlYNWQ3QWJzWnFXL0xVVkdOYUUxeTFMUnQ4S1YvWGZZcHA0amVYYkZkdXNja21VOHYzOWEwN2lDVzEwMWd0d1paQU55TS9JTlVVc1ZqMUJzeG1mWXYrdEtnY04zSHJpdTAxRDdKSGJ4eHMwY2tSNDJqN3d6elExNUhYQ0ZSeG56eXZiUlBxVXZETjQxMXArKzVNS01TUXpxY2cxbkw0WlZ4Y3FieDVQTVlzQ1NTQjdBZHE1ZTcwM3k5Tmx0Tk9VeCtZUzRETjA3NUhyL1NyZWw2dEJiMmRxbDNOSVF2RWpxQ1Z5UFVpbFo2MjduUDdXSzluR29ydU1maWI3bEMrcy9FMmtzY1hFVFFBYmxWeWM4OXEzTFM4ZlVMRlh2VUd3aktKR2NnNDduUGV1cmtOanE4U3ZibDJ4OTB1RGpINDE1bHAxbjQ2MDE3b3pXOXZQQUpjeFlPMTFIc0twN0xUVWNvT00yNHVVcWJXM3hJOWJ0eHA3V2J4UTJZRUtNQS9PQ01qMHJ5bnhGdkZ0UE5hcGRSN1RuQ0RKT0s2eWZYN0dLM21mOEFzNjZNc24rc2pLN1RucDFyZjBlNFM1VVJHMmx0OHFOcW5HTW4xUHI3VWE3bThuR3NsQlRWN1cwVnJkanhPMDhZYXRjMk1DV3lQSkkzeXlqYVFSampCN1YySWdEMzBDM0dsUTI1S2p5NVdZRGtldUs3bUxUenBqU0h6UTQ1WTRRWnhuK2RWWTdLRzhTYnpybnp3eHo1VDRVb1BZVTlHWS9WcWlsRlNrNU8raWRySkw3L0FNQ2plK0dOVnVMTzRadFJqWkd6dFdJY0FIODZwMjhHblJRSllHR1R6Q0FFa0tramoxTmRiYlR4YVpZWmdrTFJzMjNCYjVoN1k3MW1YT3M2amQyN3gyTm9zVTIxdHJUZktHUHI5S2l5c2JxbFFpN3B2bWExVHZPK3ZTNXpHcmVENDVyTkdtc1lyaDBCOHRXYmJ6WEhYQnNXa2pobTBvaGxRYll0MlJrZjFyYXRkTThWYWhhVFE2bnJhUnpLTnlScGc0eDcxc253bGIvWTdhNHVMd2ViSGphK2NGc2MwSzE3SEZXcFZwcTlPbmFQOTdsZXh4NmFqZTJKaUkwNFdhQmlYR01rajZWbzNsam8rdDJrY3Q0NVpTK1VXTUZDUFFuRmR6cWVwM2dqaVJiU080RWlaRDVBeGpzTTk2NE9MeHpwY2JHMm50NUlHYksrWjVmQVBUajNwTGZZVVVxZFhsbFdiamE5bkZwSitWdENLU2U3MHFQeW9OTzgrQlRoU0FTU0R6em1wdEV0SG4xSTN6L2JMWTdzTEU3WVQ4QjZWWDBheDhSVzkxUEpQcVJ2SUd5NGkyNE9PdzVyMTJLemgxZTFnTG84WWpMTVZ6ejlNaXFhMU9tblJtNWJ2UnB4aTFaZkptTHEycE5hMjg5eGRRT3FSOHE2amR1L0t2UExWUnFFVjFQQmF1SkpWT3h5eFhMRHRnK2xic3VuUStjOGNWNWRlUVpSbU5tNEdPM1BhdmFJN0cyVkxRN2xaTUhCTkZ0QTloUEVUbHpPeVc5N085OUwzUEs0TFRXcDlOaWluOHRKVUdYa0NnL3ovV3VmWjlaMGVSZDFvMm92SStZL0xBVUw5VFhvbXFhUGJpYmRCTy9tTWNzRmYrbGNQSDRIWTNJa2JXcjBOazdZZy9BOWM0cHg1ZFVheW9WRTRxTVc1UjB2ekhhUmEzZXlRcEZkMkVsdVdHVGx3Y0U5c2RhMHIreCsyVzBNTE41Y1RNQUR1d1IzTmN2cUZyY1FLV0Uvem9vM1N0OHhBNmRxek5NMDdVOU52aFBjNmkxd0psK1JHSHlodXhvNkczUE5Qa21uSk95YmR0RjVsaWU1dmJTNWFPMDFRU1JxMjN5blRPY0RnQTExaVhsNDl2bTd0Zk5ZSng1WXhnK2hOVXJHUFVIWnJtNW10a0VVaElqQzRCWDFQdldxK3NhSGRXTTBndXhHaGNxeXMyeFQ2NEpvSnByZDg4b3AzYWpKNlc5SGM1aVBTTFdRZWFXbHl4STJnNUFCOXFzYUI0ZDB3VFNTR0ZtMnlIYU1ZR2ZYRlRhUHBzVVYyOHR0ZlJyQ0Z5QjVtOEhkOWZTcnNkcHJ1K1NOTlFVd014SmtYQUl6UytaTk9sQnVuT1ZCTnB2YXpYcnFhbXBQcTBBMndhWERQRHp2L2U0eDlNMXhJdjdTL2xLU2FjSXdueTd3MkFEK0ZkYmRhYkREWm0za2xkeEkyZHdjaHZmSnFhV0MwU3dEeHhpUlFQdWc3aWNEcmtWV2xqZXBDcktiOSt5U1RjWFovTFk1K2V5c2tkRml1NUdiYVdFV1FWQit0WnVwaHhwYU5kd29xZy9lM1o5cXc5UHVmQ2I2Z0dBdVV1MnlQTEpQbGc1NzVyclpiKzJSYmd0Q1pJRVhMZ3FTQmp1S21TU2FPTlNqT0VtcFJWMDByTzYrWngxbFk2WnA0UjFHNXBHQkpZL0szMHJmbDFmVExnR0tHMVF5UnlCU2Njayt4SGF1VjFxKzAyOHRiRGRhU3NHT1FJaGdnZXBGYW1pNlpvVmpjdnZ1eGI1VU1xc1RuSm9kcmRiblBCdFM1SXVtbzZYZnI2bmMyOXRGY3luN1VUdEdDdUJnQS9Xb3RRdmJlMnZCSi9hU3JFY0tFUEg1MHI2dkdzcnBDc2t5Z2NOdDRiNlZET3NWN1p4TjlpVWJEbGxrVGtHbG9lazV4NUdvTk9TMXZycmIwT2Z1TEhUTCs1bG5aZ1hYSE1iWXhuMXF6YVNUd1RTaEU4eUhBQU9kelZzRHc4dDFCY3RCSXNUT1VCTWZHMGoyOUt3THVDOTBzUytaTEpNSEFVTkdtZWZVZ2RLT3h6dUU0Mm00Y3Q5WEpkVG9adEcwbDFoa2tqVU56aFc3ay8xcDhHbTIwWWRzUUZJY2tMNlpya0xXZlVibDQvT3ZWS1JINVQ1WlVnK2h6MXJaMVNPWjdJeVdtMW5BdzduN3A3SGlvZnFPTW9OeW1xTzNwZC9jWmNNa1VaTWtOM3RhUjhiR2JJSDRkcTJ2TjhrNW1rZFdVSGN5bktnSHVBSzh3c3ZEbCswY3NsN0tqd3MyNk40dmxianIxcnViTzVSVWxqaWdrbTJJT281eDlhTHJ2Y3doT2QvZWp5OXRiMytSMTJuMll1YlRFRjJKa1pzOU92dFhLMzF2cFdtWE1ja25tN3pJUHVFbXJtbWF0SmNMSUV0NUxZeGtLSWlBQS8wcm90U3NmUHRBVms4dVpoeVc1d2FMV09tMEowYnhpbTFxcnJ0MnVlZjY5cml6UUs4ZDFIYjRiQ2xvOG5qamlzK3l2SjRvSEJ0MzFDTmwzRTdPQitGYlVDYWZMZHkyVnpHSkgyZzRQVU42Z21wNExlNDBjU3pNOHp3RS9LQ003Zlk0N1ZTMlNzY01sT2NuSnlhV3FrMTltM2RQUXJMWU5mN3J5S1dTQTRYOTMwSEhiRmRMYldsNnlpT083RWJqK0x2ajhhNDNUUEVUWHhraE1hUk1yWkJRN3NqMUlyVnYvRDBsMjBUTHFzeUFITEZSanAyRkVyM3N6U20wMXpVNHVWOTdQbEdOWlhmbW1PZVEzTXljaHNjTjZaRlk1aTFTT0dhYThEUXhzeFZVaFhxRHgycjBjWE1OaGJxVW1aaW93eEl6L25OWWtXdTNsM2V5UkJJMWpFZVJ1NjVQY1pxVS9JMG5DQzVWenlVbm9sdnYzN21GcG1rUlcwVVMyZHNHaWJEdVp1Q0NlZU0xMkYrbW0zdHJHbHlvM28veW92cU9SaXZIcjJmeHZhYW1QTW1odUxPVUZTRU9TcW4vQU90WFZhVm9FN1N5U0M1bGNqTFJvY2dBbmtpcXYxdll4NXBwK3poUzVycGMwWldTT3l1cjZOYklZMDh5U0lRUExaZVQ5TStsY0RjNnZhdXJSZVZORStPVUl3bzlxMFgxTFY3TTI3M0VPRVJ5WkdmbmoyeFhYZjI1b0YxYWlWR2piMjI4OCt0SytteGJicWFlMVVIWlhqS08vd0NSNXZvbW02SE1rc1NYdzgza3lBSEJ4NmMxZHNOTW04cTRnYStlY1I1TVNzMzZFMHlUUi9DNXZqY2lSbzVwRkt1cW5BQVBldVVlRFQ5RjFhRkxpV1o0NXgrN2RTU1NEd09CVk45Ym5OWlUxRDNJV1RzM0dWclg3bzY2SFM1elpGSnJPT0tOc3RJUWNoczhWaXRvVFJiRWcxRjRGemtLZVFmYkZkMXBlbTJrYmt0Y3RNTWZJcEpPUHJWblV0TnNXdFhtWWJRblBQUVlvdXI3bC9WN3dUNVZlSzZ5MXQ4anlDNjhQMzhyQ1dlOHVWZ1I4RkU0elc5YitINHA5T1BsYjRvdDNSczd5byt0ZHhZWDd5UmhyWUM0UkdCOHZkeGtWMzhkNVl2RjVqeDdKQ3VOdjgvenBYWjBRb1U1SjNlbHJhMzErWjRMQkRhdzMwc2RoRzBjc1NEbGdjUDY1SnJ0NzNVNXJHMWhudW9DUXpBTjVYSlhqcWF0dHExdTVtamRWUmRwMnVPRHhTYURxZG5mZ1d4Y0hjN0FidWNnY2MwSzk3Z293VGNJVkVtOXJLeVd2WTVPNGswKzVtUzZzYkl2TXJBc1dISnlhN3FlSzRsczFEdDVLNUJkUWNaNzRyYW1zcmJUNXlZTVkzQU5qbkI5cTQ2Uyt1N3E4ZHBiWlRHQjh1MXV2WVpGVzJtYXVDaHpLVHU1dXpTVmw2NkhZaUc2dVlyY1c5dUJDQVF6RTRQSGNZckZ1TkRsaWNra3VOMmNaejFySHNyaTRTSndra213WndoNjQ5SzVXMjF1OW4xRzdXR0djR0lZRzQvS1Q2WnFkQnluU2xHS25HVjIxK0hZMjMxYWV6MUcxRm9qRk4yMlVBZktCV3pydDdQYzI1bWl0a25tamJBVE9BQjYxeU9tWGRyZFFTd3lYb3Q3bmNXZFN1RDE2RFByVzFEYjNNa3BmN0pMdUJ4bFQ4ckQxcHRKUGJZNFkxS3JoSmN6Y0o3VzZmbVpWbGZhWTF0dWxqamhJWWlTUGR5Q2UvMXJSMGZWZEVlNmExaGovZERrT2NzQ1Q3bW1ONGE4TlQyczF6RkMwY3k4eXhzU1RuNlZZRnlVc3diS3hFeUtRR0FYQnlLSHQxMVk0cXBCeGI1TEpYdWxkdGZJNmVmVGRQbHVQM3NhREhBSjR5RFdYZHl3YVJjUlFRa1I3aVNHNnFmcG1xeTNlbEdTVmJscFUrUUhZUWVDZXRPTDIycnlOREZoaEVRRVpoMkgxcVVqcWxPRFQ1T1RuYjkzWFhRZ2ZRWHZKVnU1aXJjNUh5OVI2VjBxMittNmxEdFNFcUUrVmowNmYwcnFiSXhSMk1pTWhHM2dBZmxtc0J2dDBYbWlDTldCQklVbmFUaW5yb2RMb3dqRzlyODN4YVhiT1oxRHd1djJmYk9Dc0NFN1NwUEk5NnlyYlJiVkk0cFZ0WXBZVjVEbjczRmRQWWEvcmpseGRhWW13REFBTzRFZTliTVZyWVRRU0hhMEpjWjJEb0Q5S2QraGdzUGhwdm1qSFczMmxaNmVwQkdtaXp2Rk04VWFTam8vY2JlS3k5WTE2Q3h6dGY1cEJoU295TTQ0QnJpdFQ4TWt3dmNHZHBJVlhMUWs0UEhjWXJiOE9XVnBkV3liYkJsdHloNnR1SXBPT2x4KzByMzVGQ01XOW52ZnowUlowbWE3MVdPVVQyYVkyL01SL2hYRHRwOEVWMHlxdHp1eWNPc21NWVBRL1N2UlpyMncwaThXS0tPWUxPTUJzWkFOVnRWMHljdWdTTjIzakpaUGZ2VldhK1psVWdwMDliU2xCNjZYMzJLTU9qczdoL1BkMis5OHpIUEZhTnRiUldzMldsYk1qRElQektDTzNQU25hWllYc2M0U2E0VUl2S2h1dGFtb1h0dFp5cEZoSExuT01jMU9wY1l4VUZKeFViUHFTVGFqQmE0a0VVZUFNY1lCSEhhdU0xQUk4a2MvbGVhak9PVno4dWZwWG9iYUZwTWtKbmt5bTljN2M4YzF6Tnh0anRtZ2pVYkdHUmpxQitOTmFHbFduVmE5NlNzMWRXMUhycUZqcHk3dkthUEp5ZStjMW50cUZ3Yi9BTTFBN1JNTWdZUEJwMWhhWGQyQ2tzSktxY0szcUswYnZUcnVORldKc0puQjQ1cFhJY2F6VjE4SzJzcmFvanU3bVc0ZU1YRURGR09NajFIclVWL29sczhrRHdUU0p0WVpDTmpJNjgxYzA2Szd0SUpUTEl6S0grNi9OWG9Jclo1bWtoY0xJZjRjOWZhcjBXd0pjMStaWGNyYVBkZWhOYmFrL3dEeDd2RVFRY0Iyei9Pb2J6ZEZPdUczN2hncUNlNHJ6ZTl2dkY2NnJKRWRPVXcvd3lkUHhycTJ1Tll0YkNPV08zUzVkY2VZcW41aDlCU2ExRXErc2sxUDNldkwva2JPbjZSYXJBMGduSWRpZUQyUDQxYVNDL1ZwMGtrQlhieGlzYUR4UHBsN2J4bDQydG5ERElJNXlPMWFOenF0dERJaDNzNXdTTWpORmpyalBEcEp4bWtsYlZPMzNveGx0NFlwd3lYTzVnZVU1clcxQzNpMU8zTUx6R01LUnRLajA3VmkzTjdkTkpIUEJhcTZrL000NHgvOWVxOTFKZHBFMDBjeWJpQzIwYy9sUjJNbk9GcEsxNDd2UnE2TjJ4dHJYUzdFZ1hEeUFER092VG5pcEdsdFpMWmdqdXBmazdoakZZTUV0KytuK2RIQ0JMbjdyZDgxb0Iza3R5SmtDazloeGc0cDZrcWJVYlJWbHk2S3o2K1owdHNrQzI2bG1KQUdBRHptc0RVZEcweS9aWFpHRWk4QTV3UWZ3cm4wKzFLVVNCdCtEMEk0cnZOUFM0bGpaSmxFY2dCd2M5YVcyekhCcXFsR1ZQVHpWMWN5dE5pZ2lnTVFaU3d6ZzlDY2RxYTgxd2pDTklCSUhKM0VIOFRYSjNzUGxYSDcxbUJWdXErbnJXNWMyMS9MR2s5bGNEakhiMHF0eWVlVnBKUmFjZWkzdDZNUTZqRmFPeVpBYkJ5cmNIUHRYaEY3L3dBVGU4YnpGQ29wTzExUEsrbkhwWHVVZGkwNE0xd3FtUlJqanFmd05RVytsNk5LV2tqMkpKMEs1OVBTaXkxME9PclNyVnVTUE1sRzk3UFJuTVRhcEJwdGpiUlMzYXlScXZ6WTZtb3Y3UnQ3bXpFbG5Pekxub1Z4aXV1ZlM3S2FkZzBjWkM4TU1nOWZXdTVUU3JPS3laSUlvMVVMZzdWOUtteXVkRU1OUFZYaW9wSzI3ZW5ROEd1UERGbmQ3Ymk1dVhaanlNbkdQWWY0VmJ2YmFDMXRvcFkyWGFpNDI1NXgrTmVod1d0cHRFSmxCMjlSeitsSkxwbGhEbG4vQUhoWWNLTzJLdCtyTXBZZUxYdXhqZHJkOUdRNmJwbGpjYWREZEpIdVk0T001L25YU1h4Z2NRaEpSRzRUaFQwNHJ6alQ3dlV5azhidXNNWWZFYTU1SS9DdEM3a3NTb00vbWJsNTNLTW42VXJhbThLa1ZSMGpiVFZ2VFltbVV5MzBJZUZkMFlKR09tZldxdDNPNkZKSGhXSkZPQ0Q3VjE4VmxZeVJSU3h5c3BJN24rZFlUM29WeEcwYXpMNW1NSG1wWkxwdFIxa2x6UFI3K2x5QjVyQ1J4dGk0d2R4SEhOTEhwelJKNWtUNzR6a0ZTZlgzTlkrc3p4aTFuVzJpS3UvR0Y3aytsY1ZvK2c2L0lQdEMzTHFBY3VqYmgzNjRwcEpyY3dxVHRVNVZUNTNadThkTEhwU1dDUTI3eUVIY3crVUtPbjFyRFM2MSsxdVltVlJMQ3grWVlIRmVoUmVhbmsrWTRZYmVCak9EV1BxcjZoZ2ZaVVhkNkhIYWt0enFsQktDYWNvMjFYTHVkSjU4TXdTWEJCSDRaSXFqZExFMjFrbGNISUpCNzFoeWFsZXd3SWoyNnFTT1JqanAvT3NXYWUvdTVWeEJ0UUtNbkI1K21lOU5GenJSMjNidGZROVlhT2NHSjQyQlVqSHJ3ZXYwclB1YmNLY3lFRThISjVxR3h1VEZZcWtqNGJzQWVmclZDU1EzY2JwS3hBSUl5S0RxbE9MU3N0V3RtT3ZKNUxWNHBJRGxlZDNmT092QXBJcEZ1TVNnc3JrOUQvVEZjYlBkdll6eDIzbFBJcEdBNVBwMitsYXo2OWJzeVJXOFFEaHNOOWFHbWNTcjAyNWMwck5OWGo1K1IxdjJxVzFrOHNRZ2grcmV4cm50UTBtNHVidmZIYzdVQUp3ZW1mYWdhemVmYTBoTU8rTTlUNmQ4L1dtNnpxYzFsSHZqaEpKNEE2QTUvblRWN28ybFVvemhPN2JpbnF0VnNjWEhwOHlYYmI3b3J1STZaN2R2cFhwZDViWE1kb1dzV1Y1RlhqUFEvd0Q2NnpZSnJhU0pHbFJRN0RLODk2M2JPZUdKTjBqY0FuMitnK2dwWGR6T2pSakdMVjdYNjMxUjV4WnplS3BWZExnSW1PQ2VuRmRJWVBLUncwU3NYR1ZJUFNxMnEyTVY5Y2xsdTJTTnNaN2UrYW94UXhmWnBJWTc0VElSdDY4cWFyZFhNb3FVRzc4MHQwbTVKMytScFE3bzR3SGxaczhEOGFpV3hFSWR2UFk3bXpnbkErZ3JPdGJDU3poZjk4WmdEbkpPY2UzMUZYRU1NL2x4UzNDSmxzODhINmZqVFhRbE4yanpRcytpYjJPanM3U3psVjhCaElvejA1NlZ6bHhxVmhCRE9KRllNdWM4Y2tWdHczVnRZWFlSSjBaQzJNbHZYMHAyc1FhWnFNTXNPRUpkY0VnOXozcFhWOVRxc25UbGJsVWxkSEFXViszbXMwU2xvSDdsaDFQOWFmZnk2aXU1RkJLYmNnZ0RyMkZhWGh6UzRyYTBlMmVkV1VFN2VuRldOWHM1a2dRWSs2KzRIQlBHZmFuN3R6em5TbTZON3ZYV3k2ZVI1RllUZUlHdjUvblB5ZFFUMUgwcnRFTjJaUE01Qkk1STZIQTUvd0RyVjFNcHRObm1GY09xRGR0WG5wNjF4ZTFaN3FRSksyMStBZW5PUDUxTzcyU09iMlhzMmw3UnliZTF4dWxXdXRqVkdNdzh5Qnoxeng3ZlN2U2J5enNDdTFKQkd3R2V1TVpybVp2dGxsWThTZVkrQVBmbmpKTmNXOW5yRHdoNTMrWmpsY2M1b3Rmc2FwK3ppNDhzcE42dS9ROUVYUklReVNzVmtVdGducC9uTmJ6ZUg3WGM4c0Q3V0M5QnhpdktyWFc1TFlmWjcrVWhHR1ZiR2NpdThzUEV1bHh5YkVrTGJsejBQVHB3YUxNNktVOEs0cTlsZDZwdlZNcTNYbldVYnlPWFl1U0J6em5wajBvOFByZnpGdnRjZVFRTUU4bm4xcnFJV3RyOHJEdlVnZk1BUnlEMUg0VUM2c0l0NmxobENSMVBicFU5TmpSVTE3U011ZHFLNlgwZnFjcGUrRjQxdUdmY0NoQklIY1pyT3Mwc3RPdURISEtOcmNzcE9jSHZ3YTZPOXVaNFlBM21ERW1jTVRqajEvcFhBWGVqWlpyaDJETWNuQWJubnR4VCtaalZzcFAyZEwzbHE3OUV4ZFNtakprMjQyNUFHM3FmYjZWRHBsL2RHNUVRZ08zSFU5dmZuMHFheWpnV2N4VHdFWi9pNi9RSDYrdGR1TDBXUGxIeWR5TndQVEI5UGVucHRZNVlSbEtmTzU4cVQxME9DYURWWHZKdDhycXZWY2pxT2xGZDlmMmNFOG9rVjJWaU9tQ2VQd29wYW5Vc05hL3hTMWV2TVNYMFdxdGFKTEExc2hUY1FYYkJBK25yVkhUWnRiVmhObTN1VEl2WWhjWTZnMGx4REJMTUhGbkxJa2hVcStEOHg3NXoycmMweThNbDBTYmFNUnF4d3UwcXk0R01IMXpVcllFb3V0SDM1UmZTemJYcnNTblU5SGxna2U4aWFHVmZsMnhuSURmaFdIcnNtaDIxdERjTktzcGp3VlZ6azU5Qml0VFU5TWdDUXROcUZyQnZsTHFOdkp6Mk5ZTU9qNmZld1BLcXJNZ0JXTmlNQmllOU95N3NkUjFYZUxoQnV5MWRyOTd0SXo3VFRJSEVkNjFuNVJ1R0d5Uk8zMUZhRDIyZ1RhcVZhZG83amVRQzdIREgxQXJNMDIzOFFhVGIzRzI1amRGbE9ZbjdyN0gxRllvMXZTakdXdllTMGhsSmphTWJtWG5nSEhhbTArNXhwMDFHTVhCWGVyNWxwcDJzZG5yR25TMmJLRXRUY0xOR0R5UU5wSHY2VnkxbmNYTTdJM2t6eEZId3FSWTJ0NzVyVm11dkZRdkk0RmhaTmcvZHE2ZkpJcmM5ZXhGTGR4d1IyeGpNZHhDMzhVaUFoRlBmbjBxYmFiRXlsSG5sSktVWXJvOU5mVXB4V0hqU1c3ZTNuMVNFUk0yNEVFRmtCNTVyMCthQjRHalZiaUo1QUVWdHlnNy9BSHJsZkRqMmtFMXhiaTFNN0VDVHo1T0F4UG9lOWFjK3BSZWFmSnNwbmtqVTVSUVR3TzRwL0k3cVVxYXAzYjFsWld1M2EzWXI2dm85L0xxWWtoakM5RHNBd3ZYazVxOXFGdEFrYk1ZN2lRbGR2bHhqSUJJNjFmMFhVNUxpMHUya2psZ1pjRlduSUdmWVk3Q2tzUFAvQUh0ek5ma2hnd1lLUnRVZTN2UzErNDBqQ2kxelJ1L2FhM2YyYmVwYnRHaHVMYXpqbnVsU1JVNExmZUdPMWN2YzI4MXhNMzJ2VVV0OFNrSTZrYm13Ty90WE9UM3VyMkZ6NUZwQ3MxdE51WVR5TGdvUnlSbjByVmpsdW1rRDNHblc4anF1NVc2cno2azBOVzF1WnlyMDVKUmNYZFc1dDdmZ1pOL0pyZHRMSEZieVdkMUN2elNGM0JZajJxL29lcTYvNWFyZXhRckd6bkVjYUFzRnp3VFQ3T0xTbm04MTlQVzJkemhVSHpBNFBCUDFyUjFIdzFEZFhrTjBsMDhHRklJais2eHh4Um9LUHRXN3diZHZzODNUNWxEVWRSdE5MMWFPZWFad2x3TnV4bHlEanVLenJtNVhXSlpaTk9tbGhhTmNrcXYzK09nTmJGbGY2RGJueTU3cU9jcWZMMm41aWZ4UFNxOGVsV1RSRmJDUnhESkorOUNOZ29UMkdLdlJkeVc1VGRveVRUYmJpbnFuNm1wcG1pNm90bktMbTZaaVJsaTdZWS9XdWlnUXpXc2E4TVZPUW8rWWNkT2E0WnJZd080bWxtakx1RVY4bVJTUGZGYjBGcklpeVJRem1HSnZtejlhaG1zSHFrb1BSV2xkNm0vRmI2ak9zcG50VVdYWmdTTGpBQTZkYTRhODBhem1WcDdpM2lsU01Bc3dHRzROZG9zODF2R3R2TmNxeXlEQ1NxMkNmd3JpTGlPOUdxMjBTWFVnalk3WlVPTnhYSFU5dWFFMlhXNVBjdkZ5MXM3MmRteUQremROMVNKaEdKTmpqNVYzWXg5TVVrVUdxYUlQS2gwNXJ1QUtOeXZJZHkrdld1LzBMUnRBc3I1eEdqb1dCK2RtSjU5aFhINnZwMnVUaWVTSFV2T0lrTzJKVHRKSG94cWs3M1Y5RE9wVG5Dbkdhajc5M2ZrdDA5VFVtMC9YZHR2UEZjb2tjcWxnamRVQjdWeUQ2TGZXNW52WGRQUFZ1R2ZKRHFQUURqcFdUWVdtdGwxMCs4aWxqamM1QkRrc1BiNlY3My9aenl4ZlpoSVdUYUJrakdPUFdsZTNZeXB3alhpM3lUVFZyS1V2dGVoNHVadFNqVzF1R2pNYys3Yjkzb3A1NHIwN1F6cDkwdHh1WmlNa01Xd3E1OWdhODZ1ZE0xeURWWkhXYUowaitXTXlaSjJqdDZmU3JPcmFacXNvaWFmRXNPNWQ2eHJ0MmdmeFpwTzExcVowM1VwU20xVGxMbDZQOHowRVFhMURPUHNzMFd4MitWV1g3cWpyaXFsOWZhL2JYaVRtYUdXM1UvT2hpTzc4TVY1bmY2cGRwcWFUV3Q5Q1lVVGFGbEp3b0hYN3ZKcjFTeHY3Ty8wKzJta3ZvcEg1NGlKVUVqL2VvTytuVWpOelVaeWkwN3IzdE5PeHg4L2lydzFkelJpVkpZNVZMQWJrNEdlK0sxYnJXWXJPMmRvcmFlNFpreUhSZmJxQjdWU3Q5RjhNZjJoT0ZaL3Rjb0xCeSs0RDFJK2xkR0w2NnRyeUcwdDRZcnFBSm1XWm1BS2djWi9HaE5iYWhUZFZwdWNvYXUxNEs3djVuRTZONG5zdFpFbGxQSGRCOW84eVJoNWVQWWYxclYwM3ducDhHdXJjWmFTVUVNbStZbnB3TWp2WFdMQTVtUnJtMVNORGdSRWZOdUhyOWExUXVtbTVEbTJIbkl2N3RsVThEM05VMmJRcGMzSzVwTnhhczVLemFNRFY3clJJN3RUZVJKSGdnSVZCeUdQUThWaHo2SHIwa25uVzl3c3NSWElEakdQb1JXckpxZ2tSeGNXNkk0ZkVjcFVNTng2Q3VQbmsrSkZucVNRMmsxdjlqa3p3OGZHVDFJUDhxV3BFbzBwU2JrcGNyZDd3Vm1uMlo1N3FPbWVOM3ZoT1JFU0FOcXErQ0I2VjJYMkxWNHJVdHFkODZSc09DdUZWTytBYTlBUkxkN1dLSzRkM21ac1lWTVlJOS9TcnVvMnhqaHQwZXdOeXVUOHJOa05udVJVNm5ORENLMG1wUFpYdTI5WDNzZVM2Qm91cVMzMXRjdHFjazlxckhiSGtFQUR1YTYyODFQVFJkeFJnZWFvbHdaQ29HeHV2OFZhTnRvbC9wa0Z5MXE2VysrUmlrYkhJako5ejJybjcrL2YreUxvMzJuUVg2cXk3VENUbVE1NXhqMHFyZVphaktuQlJmdXlkMjIxZGFIcGw5ZXovQUx1T08zODRTc0YzQVk0UGMxSHJhNnRHdHJEYTI2UWpibWJhTXQrRmNWWlI2aGRhVWs4RnZlNmVWd3FSY09QcmpyWE0vd0RDUStJOUNzVlY0WnJ1UWIyZVpsSnlDZnU4ZWxLeHJLdmFNdWQxRkdWclNTMjhsMU9vMVNmVjRkTVJtc0RjS2tnRXNtTmhDLzNxMDU3UFVyaTJzNTdOZzJ6RzZIekJnS2UvdFhFNmpGNGkxbTB0SHVkU2t0cmFVS1RIR21NbHV6ZXdyck5COFBQcHEzRUp2TFp5UmxXM0VNeSs5UFpHUExLcFZWb3k1SlJXcmtsSlcxUkxxV3FSNldrRXJTQ1BJUG1MamMyZlFaOWE1cUx4OW8xNkNMV0o0cmhDTnhuWGc1NzhWM3VxcllteWplNWdpa0laUUU0T0ZYcWE4NTFmUkxQN2RibExRL1k1VDg2b3Z6RUgrN2p0VXBYZGpvbFVsQ3BMM3J4OTI2ajhTdjExTitVM2ltTzdsdFdsTEx5c0VnMnY2Y0U5SzNJTFM0dkF0MUxBMEFWZ1ZSemtxZlU0ckt0ckxTTlBlM2h0YmtoU0RpRjF5dzU3R3VyVmJhVzVpV1M3bWlsS01VaVloZCtQYnZRcnJmVTZxandqbGFsR2VsdVpUbkdWNWQ3cElwM2hTelZtUzFTN1Z6dWtkY2pGY3ZNUENPc1JyRmN4Z082OFF4bkpBSDBycHRiZldJclNNV2tXOXBBZDhaWUFFZSthcGFMcDFqdEYzTmJ3Mmt4VG1SRzVHT09uYXFSenpVNVZlVlJWdDJwUjB0NU04dzA3dzcvWnQ5T21uMmNpeG5KSmtmUEEvdWcxNkZwbXNheVZXS1RTdHFIamR2QjNZOVJXRjRpbDBlQ05SQkxkVE5JZVpJeVd3RDM0cG1oZUlZbExXZHJCZFRNZ3kwc2lnQlBjazBYOGp6NFhoWGxIMnJXN2RtcGI5TmoweUF0TEVvbm1Eb0N3WGNBcEdlM05ZMDlvTERFbGhDcDNLUkp1ZkFXc0VTVFdzLzJxNDJYTm8zSlZGM1NLMzBGWG9OVXRwUE9TM2lZUnVRNkpJaHljOWNacHJ1ZHNaUWFTZWtsdGY0dlZlVEpOU2UvbXQ3Q2RVdHdjQVBnL2U5ZWxkTEJaM3M3T2h1bzBpSTZiUWNuMHJuN1dRVFdsemNYT25yR2tiTmhGNFBBNmdWa3d4VytwYU5IOW11SlJFa203ZUd3d1A5MnBhVmlvdTA3L0FCT1ViOHQ3TjIwT2kxTFNoRkhFb2NMTm5DeUp3byt0ZVhUYXJGYjZoZFEzZjczeW93VitUdUtnMWY4QXRBdXNFTVZ3MEdOMDAzbWZNdTArOWJWdHBuaDJXNVNTT0I1SkREdWFZemREakhUdWFXbG5jNGFrNVRueXdTalpyNG0ybjBGWFZKYnI3SmMyZDR6QXg0TnVxZmRQcWZldWgwOWRRa2dOeThyN1E1M0t4d1U5OERyWG1PbTN0dnBWNU9KWkoxakxEYWRtQUNmWDYxMDBTNjhyeFhTM2dlMm5IM0FvVnVleHpTY2Z1NkUwYXlrazVLVGxkODBVOXVsejB2VDd6ejRGZU9WTjRKUG1SbkFjZTQ3R3ZNcmpXdFkwNi9sa211Z0ZrSnhGNVpkY0RwazlqWFhMWnh6V2NrdjJVSXFydUNGdHBQcWVLMTdQVnRJbFV4TEFqRFlHWmlja1k3RW1sZEk2NmluTlUwNm5JMVpwM2V2eU1PejF4dFdzbWVLM2FGaDBCUURJSGZCcnlZNnpyV24zNkw1Nm0zbGwyNVpBRjU5YStqajlnbUZ1WVFGaUl4azg0UHA5SzQvVkxPM0R5czlrc2x2dHp5dUJnZFN2dlFyRVlpbFVjVkpWWGRmYVczZm9hdHlZVHBwREJDRzVYWWVBYTh3MUxXTmIwRzFrV0d6bGVCZ0dhVWNrWjlQYXQ0ZVRkU0xGcEtreG9xbDFkU3ZCOUFldFp4OFZUVFhqNmN0c0pqSGtibjRFbnQrRkZqbm5VVW56T2ZMcHl4bEhWUHZabDdTTmN1MnM5OXRZQ1ovdkJwV0NZejE2MTBOemNUU1dzc3NxcVhreDVjUmNLb1AxOUs0L1RCZDNjMDBadGt0LzNmN3VCMitiSU9DY2VsYnVvNkhwdDNZTi9hc1hrbUlqRElTcFgvYS9HbTdXV2hkTlZYVHMyN1dlcjBYNWZtYmt1NlMwZ3paUk5NeUhlMjdidHh6MXJpcExiV3IyZDRsbWtqWGFGRVlPOWVlTWtuclhkR3gwcTlnRWNlSjR6R0Nrb0pBSHMyS3dpUEVXbDI1MldpelJpUWdDSnZtQUhUcjJvWGx1RldFMjR1VitTMnJqcnQzc2pTbjBKN0t3RVNQRWtySi9yTm5KYjE0cUhTYlR4UUZ4TmZRU29wL3U0SUZQL3dDRWdzelBBcm8wYnZqOTI1eXlrK3RkQnFHb3lXaDgxYkF2RVV3eFVaeG5qSnBKTm04VmgzZVVadFJna3ZkYi9FbzI4VVY1ZVBDMDZJVmI1T3hQMXFuT2J5eXZCRk5Zd3lHWEtySXZVZ2RqNlZxemFmWlhsdXl4ejRPMEhjcHc0ejNGWUZwYjZ2WXBKY3l5dmV4SWZrQkdHQTZkNkVreXBLYXQ3ajZ2blRUWHpSbFdPbnczTnpkeFBiTmJCZVF6TmtFNTdIMnJkdUJybW4yOFVPNHlCV0dKSStUdE5XOUxzTHVhN21EUU1rY2pNUVNlTUh0WFhXbDZzTnlsdGNXWkNaMnh5TDBPTzVwL0lLVVBkNnhiYlNsWm80dUdIVXJ6VU11NG1zNUV4aGt3UitkVTlRMGpSYkM0Mnd5MjhkdkxHUXk1Mm5JOS9VVm9hN05xOWhPOXlXYVcxUVlNYUREWUo3WXJMdk5KdDlUVFRMbjVZaXI1WXlIb1BRajFwMjIxc2h6bCs3cVUvWTgxUlNUVGs5YmRiZVJ4V2tXNXZOYm1XekJtaUVaRWpTZEQ5RFY3VmROOFllWkJKQWxpVEczQ3R5VlVjZDY5ZnVZYlBUSVpXQStWRjM3NDF3UDByQU45YVhkc1hSeHZXUE8zb1Ruc1FlcHA2bktzTlRwdHhkUjh6YmxaT3lNV0N4bmEzTXJYVWFTcXZJak9SdU5XdEowb3FqdmRhaklSMWVFZ1lHZmIzcmdMYlJOWDFLNG1NR29iRWlaV2FIWnNPQnpqSjYxMU11dTN5ck5GTG83TmhRUE5WL3ZZN2tVMnRSMDUwNHBTbkJwSk8xN3RTZm5ZaU9uZWJxY3RyWnRKYmgxeXNpRHFUMnJXdHRLMUszZDRIdW8za2pIQVk4azA3VDlYdkpsejlpZURnQ09VREl5ZlgweFhMemFOcUUxL0czMnhYbDh3c3o3c0hIcDcxTnRiTWZPbEJTaENVMjMwOTNUdFptcGR4V05qSGNMZFhLT1hBM0tSOTBudlVXbjZ0b2MwelIya1N0TXFZeUZJSDUxMjFuWnlHWFpKSEc3RmdOenFPY2RxME5XMHl3Q09pU1IyMDBoK1FvbVBtL0NtN1dPaU5PdGR6WEtrdWpXdnBkdmN3TGRZdFNqQ1hMQ3ltUEIydG44YVdheWEwdW8yalpIUUVySkovd0RXcmxyK3hGckxETE5jTjlvR0EyVkpWL3BqcFhvdHRMYlBaNUliTXVRU0J4azhmblFraTBveWJUMGtyYXQ2L05iSG1jMXRORHFraENOTFp5ak9jWXhucWFmT3RxZ1dLRzB1QWpPQ0Q5MzhlYTJyL1cydHdZYnF3bmk4dGdJNUJ5SDdkQlhWUjY5YnlXMFRXOXNaTnVmTUxuQkczMHEybmM1cWNNTy9hUVZUVnU3VFdxdjAxNkhCWHZpYncwc3B0bVR6SnlvREtJOHQ2ZGE1M1Y5ZTFmUzdtQjdkNWRqS1BrQ0ZnQjcxMTBuaUMxZTVVeDZBelRuSWQxUVl4L3ZWMXRsZWFlUVhrZ0JEZFF4R0ZQMXFiV2EwS21sVzBWZExWV2FUVnJIbkY5cndhRkpZcEVoa2ZCTHVwNUo3RVYwMmx6WDdXVHpSU1FtUi93QzZmbEo5YTdUeU5EbGxWU0l5N2pJVEdSdDlSWExheGFhS2xxMEFna2kydnVWME9QNVZMYXRZdVZHb25LcDdTTHNtclh0citKd1ZsWTM2Njl0MVBVVUcvd0QxYWprSDJydnRKTExxT29pNGhSYmVMaUtSQmpQcWE0L1VkUDFacmVPNHRUQ05xL0swaDNNUU80ckVzZFo4WkpLd2t0NG1pSStjQURHQjN5TzlWcSt4eFFxS2hPMG96dHpjeWRyM1RYVTkza0dsWCtudkZEZGtxM0c5RDh3SXJ5eTk4STZ1SUJjVytyenkrVzN5aCs0QTVCcm8wVXJhTGNXY1d5VmpsUVY0eU90WEwzVWRmT25ERUFFakhnZFB4eFFuWm5vMWZZMUkrL0NWMUc2Y1U3Q2FMWTZneTdnSlF6a2J3L1FZOUszb2JhNW1udVk1OXJoUWR1MFlQUDBySDBUV0wyMmpuKzNYNk13NVZGSFRQYXVrdGRSbTg1TmxtU2tpbk1nSTQ5RFE3WDNONk1hYmhGUG1YZFAvQUNWem1uMGE3bFkvYVdZeFl3VXpnWTlEaXIxdmJMYXliYlZBUU9ESHV4d2EwTlRFVnZiTnZ1WGRtWUhaOWF4bm4wOHNYUlNYR0F3WHFQU2d0OGxOMnNyM3ZkdlVmcVdyTmJYY0ZzK215U0xMZ2VZZ3lGSjlhNzVwb2JXM1R5NFdkbVhqUDhxNTJXKzA5TVJvMGhZRFBUbXVWc0l2RUY1ZmdnNWdVa2pQVUVmNDA3bzBWV1VadTE1T1Rzckw0UzlOR0NQdFVrcUlOM0N2Z0g2SDNxL3FlbFcxL2JLNFVLeWdFU0RzYTQvK3pyaTQxT1NIVUxBbUVObEpBeEF6OUs2MFdOaGN4UzJSTXFJZ3h2RFkzQ25hMWptanl6VTA0S3p1a20ybTJ2VkhIalNyeTVNZjJuVURMR28rUkU0M2ZXdTBzSVYySGZiTXUxU0ZicWVPbGMzYWFmYjZkY0pCYUdSb3l2TzVza2tudFZyV2IyOXQ0MmRnMFVhZ2tITzdwUTlXWndqQ21uS1VXbXZpMTV2eFpkbXV0U2lsL2NNbTQ4Z01NWkZVTCt6MXJVSTF6ZUMzZklKSTQvRGlzdGZGRm41RnFzbnpTeWY2dVFEc1BXdWlYWFBQc3BBMXJncnh1OXhVMnN5bE9qVVVvZTFiVnIyVGZyME9Lbi80U20xQytha2R6RU9CZzhzQlUwbTNVbzJDNHQ3aFV6NWVjRWU5VVlMbTZlOGFRYWo1aUoxZzdqNjFjMUdheG1TYTR3MjlFeHZRZk5WdmZaSG5LRm96YXFTbEhyR1RUMDhtamV0M3VyZTBqamxmZjh2M3U0OWFrdDBCaG1lSWxaR1VibjY0TmNERGJ5M3VpMjV0cDVmTzNZTE53VDdHbHNiSHhJMW5kckpkRlRGMnhqZGlqbDMxTkkxSjNoYWxLU2NieGFkOTEzT3pzOUV0WW9YbG5iekdKREV0MTkrdGRGZHBwODBYQStaMTRJSElyeTZ6TWIyVWJOY1NzM0laU2NZSTdDcnVuNmdrZHJjN1ZCWU93WGNhanVYQ3BCT01lU0tVbytyTnJkUEEwY1M4eFB3YzV6bjJyT050RVppcFdSQ0J6bjBQY1ZpMk9xMlg5b3JiWGNjOGN3QlpUOTVXcnE0Yjd6cHNyS0NwR0NXSFFVbmRMMUxvd2pYYWlxa1ZibzNiNWFtZkZaVHgzaVNwZC91MUdQTFBjK3RiTVNFd1R5UktwemtEYzJPUjcxeEYzZFhWaHFxcXVudFBITXhBbFVrZ0UrdUszRjBTMGhsa2trdUpFUmpuYVd3b2IwcHU2U01rcHhsS0toczN6YTdlZXB3ZWphaHIwZHhQTGNwSEhDR0lES0FlYytvcjFaZGR0MlZTdHdzaEl4aFR6bXVXdUh0cldOb1l0ajdtd1Z6a2M5ZndybnRKczJUVjNSclhhQ3VRY2ZML0FJVTlIZG5JcTFXbEtuVGkxSzdzM3E3Tm0rcVh4MVpwRG1TS1ZmdW5rQ3VvdWIyNnRyZk1TQXEzQUdPbGJXbjI3TkV6RXFBcE9lZU1maldYZWFpRWNSeDdaeHprREIyKzVvdnNlakNtNmNKU2NtdVp0cnJ1Y3o1Vi9kQXRGY2lHVlFEdGJnSDY1cWpEb2wzdWxlY0F5REJVeG51UDU1cnE0NzVQSVlHTGZMampIOVBXcnRycVVVVER6clVxVGtNZW9IZWk3SlZDazNGdVYvVzl0ZjFPZCt5U3hYSmFGR0pZQXQzK29yY0Z6OW1RdERJekZ4ekdlTVo5SzZjdnA4MFc2S1Q5NTJQYXE5dllNdHlaRlZTR1Rsc2MwN3ZjN1ZRcy9kYWFiKzQ4ZGxzcDVveExhcTI5MnlUeUR6MUgwTmRqcGVvU0dYeVpJdHNrYWpKSXorUE5YNUxtenNDRVp3dTU4RWRjRnFXTWFVMXcrR0R5RWNFTnppbTNkSExHbW8xYnFhdnB6SXBhb2xsTXFzcGpFbkdSa2V1YW94L1poSEdYdW9sOUNTT3RZRi9vZG5OcWlnUlNCd01qQjRQZXFGL3BkaUlsdDVyYVVNemNPQ2VDTzFRN2VaenVjK2FiNUlxMmw3dlYvY2RQcFhtMjl6Y3BjM0FlTnNtSWpvQi85YXNuVTFLdkhKYWdQbVFlWUJna2ZnYW5HbjNWdERISGp6VlZPcmRmWGsxSFlXMTNJczI5UkNDcEtuNjlldEY5aktTbjdOUWFkK2ozYTY3bW5aYWphWEdvZVF3TzhLQ0JnWXo3NDcxM0VZdkVrR0NGVW5rRVlyd1I3RFdiR2RwSThNWEoydVJ6d2E5TE4xcmMxamF0SnRhYm5lQUJ6VHRaYUYwSzg1Y3lxUWtwSjlGMFBSWm9iUUkyN2toY3FUbmowTmVYWHQ2c0xaRjNIdk9jZk55ZmFrdTlaMTlVaU05cXFvcDJzdWNaWDYxMEY1cCtreVF4M0RXcTd5QWV0RmtkRlNVcWlrb0xsYXQ4U2EwSzF0ZHpYQTJ6UUJtSzREWUhYdjByT21Pc1FTd3FycjVZYklYZ05nOXFXWjEzUjdoNUlVL0x0NTRxYit6NVJxYVh2Mmt0SHR3eXRqSDRVSXg5NXBKT1RkMXFuWjJHdGEzRWt2bXdxMjhESUI1N2RLNmJSN3FXUkN0NUY1YkFqSXdCeitGWnJYTjQwMG4yVzhqQXh3R0hTdEY1N1lXTzI1dVU4d25ERlQxbzBPdUYxSnRYc3J2VzNLeUh4QkdpeHE2a2hWT1RnY2o2VndFRjFaWFE4MkpncDNZNXJ2NXpESkRnemdwczVYMXo3Vng4YjZTaU5Fa0JSZ2VvR01taEhMV1g3MjdjVW4zL0FFSzYzR3ZvcFZMWGVkK1JKNkQ4ZTRycHcxMmJlVVN3dElvQUlBN0gvR25XQjFHVlhXT2NoQjFCN2owcXMxN2VRRW9pY0hJWTR6ajNwa3hhakcvTk96MDFTYU1sYmRqZHdUY2hRcEdDT2Yxck52OEFXNExZeVJza214aGtPQWVDZnJXdzR1SEVUTEtEbHVCakErZ3FuNG4weWEraGdpallKdElac2pHY2ZTbHBkWE1tcGV6cU9GMDlIcnJlNW5XdXFXODBTaVdiYUJuZGs1QnFIU05DRnZmU1N3ekZrTGZkQkhmbml0cTAwV0NXMUNCVllxdTF1UDFOZEhEcEVscDVYMlppQzMzZ1R1NUhKbzZseG95azRPVWJxT3FhM09lMUNlNjB6ekpJNE42bk9SNlZRKzAyT3FhZkcxeEg1VWdKMmdldnRpdWtudjFpbGRwb1djS01FZW5vY1Z3bDE0WWt2djN0bGNrRWtzRVk0MjVPZUJWTFYvcVRYalUycDJuRnAzZy96UFRVMFhUYm5TWWxUY0hKQTMrZy9HdU5uOEs2bHAweHVJNy9BSElTTXEzekgweDlEWFVhZEpkNmRwd2U2bFVxZzVQYXNleDhaYVRxZXAvWXN0OHg0SkhGVGQvSTZuSER5akJTWExPeXNscGI3akFqaWhXRjBhYmJJNVBROGpzTWZqV2pLbmlDMk51R2tFOFpBQUl5RDdmWDNwdDlieXczTW5reCthaVNZT0FEajNycVk3VzZsUlFzaDVIVFBUanBqMXExb2NpcEp5a2twSnExbkYyLzRjeHJ5NHUwMDZiYlpndVIzUHI2RDJyTThPUjdJd0p3aXlaT091Um10VzdodmJVcXFydkxjbFJrZE94eFdWWjJNSTFJWEg3ejV5ZHludFJwWmhKUDIwVzAyNDZhOW4xT3kxUzN0V3RXQWJhVGdaUGI2NHJsWUwyUVl0Wm9qamFNT0FmMXJkazBoNWttZFpHd1NkdU9PM2V1ZW1pbEV5ekVNeGlIekQ3dWZlcDBzYlZIVTVtMURsNmVxNmtFdWwyYk9wbStmYWNLQzNyeGcvMHJKMWpTYjYzV0dXMWhDL01NNDlLNnk0c285U2ppZUdRZ2dFOWVsZGZFMXZiVzNrM0QrWUdISFVucFZLMm1wTUtVWHpYU1VXazFPL1U4dkZsTkRlV3R3TWhUSDgyMDVIcldqY0ZraWxhUkdrWGQxQjV3ZVFhNk9IU0VsUndrd1hZU1F2cC85YXJGcHBzeERXc2pCdk16MVA4QUtsY3RZZVZuYlRtYmE2cTU1WnFmOW95MnFHTU41UzlEMS95S3FNMHNWcWlDOTVZSHYwT2U1cjBpSFJKSTVwVW1sQlJUd3A0QjlqWEtYM2h5MWlET1ppQTUrVTU0SGJGUG1pY1VzTldqZVd2TTFaM2RyR1RwSytJSjVqR1VWNGNZM0Vldm9mU3QvV2RUdk5LaGdpaWgzdG5JNHpqbjlhd3JUVU5TMGVPUXl1SGcvaDVIZnBYVVdPdVJYMnh3Z2R3Y2pQNVUvTzF5bzhqcDh2dEpScVArYm9yOUNlVzUxR2EwaGtLYlhiN3crNzI5S0t6TGkva2x1bWplTUx0Qkk3NUdhS2k2N0cvTXY1cE8ybjNIb1ExRFVKWUpFTmpNcnlSNUJDL0lXempnOWdheEpFdUxTS0FYVXNrTXJvd2paT2NrZXYwclVlL1ZyUzdSYjU1U0RpSk4yd0Fub09Pb3JudEoxTFZKMWUzbHMzOHlCY2I1QmxUazg3ZmIzcUwrUk1wUmNvcm5sSnRXVDZiOWJFdHRvZGhlQU5mVHlTY0RaTkkyTnBQVEdPT1RYVFJhVmU2YnBVY1p1SHVTQ3pLRkFBMjlnS3k1TDJKYmlLM0dtenVwVlE1QUd4Vzlmd3JyUWJsYk1wRGN4eXlINVNHN0lEeU9PbERiTnFVS1NVa2xxazA1TGUvejNQTWJmVXRVdVlzUG8wcmh2TU80bkdUMnlEMnEzNGMwaXphMkFGakxDKzRpVEoydHU2OFpydGRXMHQ1SUdET3BqK1g5MnNoVnZ3eDNxR3h0bjAvYWtOakxNck1XOHd0bmIyNUo3MVY3cll6cFVLa0trZVp0cEsxMnRkZlJIZEZVdWJGN2RwVEE2Z2dTOVdYM1d2Tk5abHVMVnhCQmRTWENQSGdxNkFsOGV3cVBWTlUwcTF1SWplU1hjVFlaQkdzWllBbmt0eDFyZVU2T2x0STBVcjRqUldFcmZLV3lNN2VmMXA5RHRyU1ZSU1Nrb3RhYzNOclplUjVKYlhtcXJmV3JmYlpJN09SU1FJNFFURzNUYjdWN0ZCSkwvcURkT1pHUUtKTUJTUVBYSFNxR2t1MTNIS1lZcDRJWkVJUm5aVGh3ZW9BN0dvNTlGZU84VjU5U0RPUjgwWXhnOTg4ZHpSc2N0S05TTUUwM05PMnQya3Z2WkRxdHpvK2sydUx1UmRoQVptUHprNDV3QVBXc3ZSUEV1aTM4MXV0cll5cmJ6dXdNclJsRVVyNjU5YWRxSjhHVHkvYVpycVdFUk1BeUFFcm5HTWZTcU1PditISlpKb0l2TVlNY3A1WUlYQTdVOXR5NVZZeG44ZE5hcExXOTEyTzJ1YjRYTHkyNDhndENSKzdSdU5wN211YnROWWM3MGFKeEVqL2NZRE93Y2ZqWEZSUjZKTnFVazFuQmRwT1dLeTVPVjQ3RStsZHF1bzNWdTAyNkJ5RVZBQ2lBOWVPL1VWRzNUY3hWUnp2SnowVGF1dFUxdWJySmZ6WGMza1FXcVJ0RVJISjF3MysxWEl6K0c1NDdVM2pYMDI1R0c5WWM3R3oxSUhyWHBrZW9SbEJicTBVWkEzYlVHNzgvZXZOSjcrQlpwcmVlVy9oRzhNdXprT1I5T01VUmI3R3RXRkJSdktUZDcydTdKTTA5SDBmd3A5bHdzWjNaZDNNaW5kdVAxcmJodmRJc2RPbWx0VmFUWURsQXZKK3VPOVlPa2FTR3VOaVQzVWJTamNIbFpYUStnOXMxVDJ1MnFDem0xUkVMc2RxUkpqRzNqQklvK1lvdVVZUWFwd2kzZU4wbHY4MlBpMWFUU2ZEOFRTUUJ2T2xaekhuSnc1eUJrODVycUlMeXhrdFlieExhU0ZuWGFGa1hPUGMxenFXbWtXVTdlWnFGdUpWTzdMc1cvSVVrSGl6U2hjL1o4YmdWTzFoR2RtNzB5ZXRTMjMwSmhWVk9haktyRkpSU1VYWnROZFNtZFh0ZFdubEx3aTJXME9JTGgwS2d0M3g3Vm1TYWJxVnJmMnpHK012bkV5UElBRCtIMHIwSy9Pb1hLUnJIWVEzSTJaTVR5Yk92UUFDc3EwMCt5ZTdld09sR053dThGNWllTThqSXF0QXEwM0sycmJiWHZlOUc3M3RvbXZJM3BZWnJxWllUS0ViSWJjb3huanNmV3MyVFRZMkIydkxielF0ektSOHBCN2M5UldacVkxV2U2TmdsbE5CR0VMQzREZ2dFZGhpdVlnZElKNXZOdWJobm1Pd0pJYzV4M1VmMXJQVkl1cFVTbHJCOW5KdTM1bHk0bFN5eDltdnBibVR6ZXB3T3ZYOEJWZnhOYzZsSnBqS0w2VzFhV1JWM0ZndkhjZzB5MDhPNlBwVitsM2RSWEpKWWJXOHo1VzlUZzEzOXhmYVRjd3lLOEluaGM0S2tESXgyUHBWWFdqM0pqQit6a25OUWxiU09yc2NocHVyQzZpa3N6Y1lsV01Lc3VRemtBZGZUbXJGdmN6V0NxMDJvdmVFSzJZVEhoOEQxeFMzNXRJcmU4R20ya01CTVNCcFNwNEI5S1crMHdXdWc3MDFCbGFjeG5ka0huMjlLZWpiTWIxWXFUdnpPRWJ1VjNiUitxdWFGaEw0VTFDMFI0ZHNFc2l1aEJHMTF6Nml1SjBIdzdaUnhEejdxU2Z5N2xnaHlDZzU5QjNJNjFxV2RscWN6eVNYa3NNU3BIaUpGVDVzajFOWEpmQitsU3hwZUdSN2VYZzdvMklYY081WDBwWDh4eGpPcEZOMG82THR5MytSclFMYVcxdzMraTVLdWYzZTNKeDE3VkhiNjFwMXhxVXFSMnMxdnRBSE1meXZ6elhMNmhaZUtMYVlUV0dvV2x3cnVESWZ2TXYxQXJwbzd2VkpJWW8xa1F1dVM0aUFCWW51Q2FXbmMwaTV4ZHVWeFNkN2NxZC9tanZZNXJoUEtLYjJqRzRESXlPblE0N0NvclBVbHU1NUlnWXpLcS9NcTVHRCtOWSttWEtDWDdJSWJwSi9MRWhsWWhnTTl2cldKcW1yWGxwWkdDemtSN283OXBrSURFbm9TeEdNajBxa3REMHZhZTdHWE5wZlZiNjlrT3U5T3Q5UDFBbDV5UE5PNG94M0twTmFOL3E4eGdTSnI0RjFHNHg4Y0FlM1d1WnN4NGlpaTA5cEh0cmlWZ1RNSlNGS1A5ZTlkUHBVbHRjWDF6RGRhWVkySjNOT01FTTMreWV1S2ZUZTV3cVVtNVJqZW56T3lUVDlkMGNEcVd1Nm94amF3dUM1Y0FHQjRzREE2N1QzcnN0THY5VnVFbGtaNG9CR0ZLTm5KejZZUGJOYkdwRFVOUGozUkxiM0tvU1ZSbUN0K0dhNDZLN0VZaXVaTGw0Zm4zVFJjT3UwOUY0OTZWOUZvWi92S2RUM3FrL05iTDF1MmVxRytodTdmeTVyNVpKZ3VKSXdvMmtuM3JCdE5MdExPRlNyUnBHakg1VjV5RHowckUxVFc3V0syRjJMVHk0RVkrYktEaVFBOTl0WHRNR2szOWdMaURVSlQ1dUd4SVIva1VibnBjOEp6V3FsSkxmVmFmTW1TL3dCTjFHT1Y3YWFabmpMQlZUS2drZldzcTFtdDRMZHhkd3p3c2pZZC9NTERMZDZ6OVdPbTJGM0hOL2JLV3lJdk93NTl3Q3RXbjFnM0tXKzVWdTFtYmR2OG9nYmV4UHRSb3REamM3Uzk2eWt0TkxOTy9sdWM1Y2F0b092dWJmejdoSGhiWVRHRHo2RnV3clF1ZkNXbFdVdHNDMDhtOWdSSVh5MzArbGRGRm9la3JITGNKWXhBdjgwcFhLbC93SGNWNXpxY1Y5cWlSVzZ3WFFFY2hCM2phbTBIcHVIVDJvOUdaVmFhVHZVcHFjM1p4YVhZNlBWZkJ2aCtDNGplNDFhYU9NNUxRdkp0WG52bXVTMUtTK2dDcGJPajJpeGcycmJzNEJPQ2QyYTZ1RHhWNGFramgweTR0L09tRGVXcXpvWHlmUUd0YWVYUjc2eSt6VDJ6V1pqSkNSaFJ3cW5nOGRQcFRUN2tUcFVwcHVtNFF1dExYMzdOczNvVzBpU0dBNFM1dklGREJGa0Fja2pzVFRiZTZzTlZ2SXA1cmFTR2FBbGN5akRKanFQL0FLOWNiTnAxcXNVTTl0QzEwZ0lhUWhQM2k4ZFZJd2ZxS3VXZXIzTVZ4NVZ6Qi9yRHVFZ3lBeW5zYzk4VWREczVuekpTVVVycTlsZE8yenYzT3F1SUxlUzZrbFp3V2pCT1ZPY3FlL3BYa2JIVEpwYml5bDFtZVppZHhSWWlwSHR1SGJGYStwYXBhMll1cExPV1IyaFhQa3N1Rnd4NkNvZEgxWHhoY3pKSzloYlJXakFFTTJBUTJPbkhVVW16bmxPbktmSlpONnQyMVZuNk5Ham9maFdDTkpnK3VYRFc4eEhsS0k4N1FPY0UrbGIwdWphUEdaa2tpU2FTWlFwTzh4aHNkQngzcm9GdWRSaysweVdsNWJMRzBYeWhnZmxjZGZ3cmhJNzN4VkZjeFJUR3luakpCV1ZPZ3dlUWM5Nkw2Ym5USlVvd2orNitkcnJ0czJ6cnJFSmJRUVFtMGp0WlJ3a2FreURDL3dCNDEwQnVVaFpmUG5TRWxHMmhRQjc5NjRHNjhWNjM1Nnd5NmZGdFhPNlZmbVZjSCtJanA3MVJ2ZGQwNFhGcmNRV01WNERHVXVKQkxsWTE3bmFhbSt1eG1xOU5QM1o2UnN0VTQvZ2lTMVN4U3p2cG9wNUwxeklYZVB6ZTQ2QmZhdU9PczZyRmR6U0NOTGRKY0UyeEhKOUdCSHJXL28ybldkOWYrUW5teEZBOGdTSlJHaklUeGs5Njd5MnM3eHpkd3JDa2hWZjNEU2pBT1A0Y2p1S0x2N3prVk90VTVXcDh0cnBPT3QydC9NOFBqOFc2bEpFZkpzSGVRYmcwVGdydUh0N1Y2UFkybGxKdytsZVJNVVYxbUlCWGQzVTQ5Szh3MW1IeFFzNnozem9KSVN5K1RBMmNJT2ZtNlZxUDRpMVBVSmx0YklGTGJ5Z3ZtRkNXSlBVcm4wb2NXa3JmbVlxcW95cUtiY3JQUk5hdm9kK21reVFlYk0wZ3VKSkh5eU1RZytxZytsY1JlUjJ4U09XNGxkQzEzeCs4d2loZVBseFhTYWZvVWt0c1piaTZOMEZKVlNTZlRCeUswdFk4T1hrZmhHK250ZFB0cEJhbU1TU3ovdTRvek0reFNjbjVpT3UxZVRpcmpkeXNkTlBEVHJSU2pGUlZtL2VkL083UEo3L3hMb0ZqcWtRbGx1UWszN3NZZktlcE5kSkZxL2gzVWhjbUl1M2tKdUpVNEQvUWR6VmE1MFhTUEVFQ1dyU3hDTlVDSThTaFN6TDFJQjZaNjFrcDhQcm5RYmFPNGd2RlNMUHp0TXBKVlNlQ0F0RmpGcjl5NVJ0SjNiZWk1YmZvYU1QaVEzbGxIYXBjelFTODRsbVhac0hvQU90ZWg2Sk5KYjIwbHBkYW1MbmZDQ01qa04zSTcwNklYZDdvOGhONUg1aktkc2hpd0dVZENBZWMxNTJMZTF0REJQdGtaZ3piNWg4ek14SFRiVTJYb1M1MUtVb3lTNW90TDNuMFQwdHU3bm9hUzJCbFV3M3Njc3laQ0RPQ2NEQkhIYXN5QmJ0Wk45eFlRUElweWpLd1hIdTJmU3MrUFVyWXgyN1FXTndMa0ZWTENFSWNkZVNleHFucUdqa1habGpTVkxtNVlrbHp2aS96N1VGeWx6SlNqN3pYUmJhK3Q5VFh2dFJ1WW5OMHVraDVaVzhvU0lmbXdhMTExSFdJdHNNdGpKZFN1TUJTd0lHT2ZtclhobTFTMWdnbGttaVNLTURkbUU5UFVlOWNOcXQ1NGpzNytLNzArU0M3dDV3U1VaZHJEUGZubWkyMmh1MjQzL2V6dTlkbzMxNjI2bmIyVVRSV0puaXN2czhpbGpKRXJnaGlPMU0walhiaTRpbmFXMGxWWThuTzN1ZTJlOWMzYStMSjRabzB1OVBsZ2VUYUN5cUdIemNaSUhTdXpsMUtPSU8xeE04V3dzRlFMZ2UzQTY1bzY3YW0wSnBwY3RScmxWbW5GTC9JclhFK2xPVGR5UWh3ekJEdEh6QURrVlZiV0xmVUJLKzJhRVd6QWVXQmhuQTlxaXY1MWx0bWFCWkdDUmVadVFmcGl1Qy90U3lndmJXVnA1aDhvM0F4bm5QSjNFMDBtY3RTdEtNclhpb3ZmUzEzM090dnRJbDFCUDhBUmo1RFpRcVMrRy9FQ2lYV0o1TG8ybDVMTEcwSUNlV0Jqek05NnR3WHVtYW9TTE1xa3FxR2NzU01BY0RCcmxIOFEyY0Z6SXVvM0c2UURFVHhqZjhBUTVGS045UWM0cjNvMUVsSjJidjdyOGoyQzB2RzBxQkVqeTBiSEcyUi9tQjlRVFZ5NTFhMHR3em1NNVVBdDNBejNPSzh6a1M5dnJQeWJ5OWpsaUMrWWhDNFp2VG11VDAyTFVZcmxoRHBpendNNUUyK1U3K1IyOU9sT3o2czZJWXFvcFJnb05SYTkyNnZhM3BmUTk4YlZKUHN3ZFlES3BJTGJDRG5JOTY0SFdkSisxV0NiSGF5ZVNRTTUzWjNaN1ZZdTVidlNvN2VXMHNaRkV3d1Z6bkJJOXV3cnlyVDdieFRxT3BUdnEra3l4QW5LU1J5WVRiMDZVR3RhVXBxVVhGeWFTVFd5MTZwMnVlN1dsaFBESDVVa3hhREFIcm5IYzFRdVpvMGx1Wm85UDhBT1pGQVU5TTRIYk5hSm1tTWRuQkdrb2hSTU1vNU9PbWMxaE5hdGIzMHFtNW1rZ2NaVlpHQUVaK3Zlb05KYVJWbDIxN08zbjBLdW1hbnFGMUlycGJwYkVNUXlsTTVBN0UxdlJTeDNFTHVXakZ3SkNyTURnS08zV3NLOWZXcmQ3ZVNQTXNlTnNzU2dIR2VocXZjMzltOGttNnh1SW5FZi9QUElMZXZGWFpuTEdxNFhqT2NtMXZ6S3lkMXVyYUYySk5ZTzYzbllOYmxzTTJRdWMvU3VPbThQdmE2aW9ndUk1b1VKTHhuUG1BZGV0U1RpeEVsdmZYY2MySTFWWlZRa25KNk1WclZ0TFhTYmlTN2diVDd0U1hWMHVHQlZXWHJ3YXE5am1halUwc3JyNGVhVHZaOU5qVHR2R1Z1ZFZpMC93QWlSWmNmS1dIQXF2OEEyMWN3eVRXMXdwdm15V1R5bzhIQlBUUFNxV3BhZmJpNGJ5VXVJMllZRWlMdksrLzBwMmx4K0k0NHRqdkJLaU9Oc2pEWXpEUFJxbFdPajJtSmMrVnQ2UFJwWFZ2TkczTDRqaCt4eEY0SmJaendES01nRHB5VDNwTGk2aUN4QjVRN3MzeXJId2ZZNHFoYzZacWdzYjVIbml1SGtZbFZjNEVYMDloV1ZvZW5YRFhrY2x4YVlraUcxWlZrM0FxTytLYjVVT1VzUTVxTGkzZExkYmE2N0hVWEV1cVhDUlJRUkFvaHlIbVhjVHhVc21sM2d0NDV3UE5rM1lieStGQTl4U2E1NG8wclNyMnlhOFc1bGtmNVZFYWtnYnU1QXFVYTNQUGR5eGFmTXlrS0daWFhIV25hNk9ybHBjMHIxRzN0YSsyblJIbGNueENtc3RTbmdPblNza0xFT1ZUakh0V3BaYTNGUFpYUG0yTEpaejhNemNIbnVCWFgyd2tnaWxFOFBsdkprNytEbjF6WE02eEhjbTFNTm5jUnFYS2tCdWdZZFFLaFdad1M5cWxkMUc3SjJqYnV0dFRMczlEdE5QbUUxbGRpZEZWbVlQSjg1SG9vcnB0Tm1zTmJtUlk3T1pGaFVtUXMyVitnck10OUpFdG5EY3pXMjY3REJHMnRoU0R4bkE3VjZMcDNoV1MydTQzV1VSQUtOcW8yQWMrb3FpS1ZLcTV4NVlMa2JUbEczUitxME9VMUpiZXhqaWxkbVdCTUVnOWd2WUR2UzZOcU9nVFFrMlM0RFNaT2VRekhyMTdWdmhHUzd2eGN6R1NFUGhSSUJ0REQwOXE0aTk4UDNGMFk3aUpoWnRHeFlHTERLUjdpa3JXMVoxUzVsUG1qRlBmUnJWVzAwWjZ0ZXRkRzVpSldPQ0dQN2dIYys5WTZ5NmpkbVZqSkhJSWlTQmprZTFjTG91clN5YW41VnpxOEVraVpVeGxjWUk3MXRwZGFmSnFjdHpiNVI1UGxkbEpLT1J4bW0xWWJ4SE0wK1pxOHRZdHErM2tjenJPcldscGUyc2NtbTc1Snl2M2UzdlcrMnNwYlhrNGVBaUZsQ3FkeHlNKzFjL3J1cVI3a0gyYVc1dUlqdUNvT1FQcld2b054Wlh6ZWE4VWl1MzM0cEZ6alB2U3RzN0hNcXpsV2NZMUZkeTB1bDAzTnU4MFpyaVA3VGI2aXpScUFSSG5PMERyVWVrejJpenNEZHhvTm9adDNCSi9HdUZ2dE4xeXgxaVdXeXZvcmVHUTdRa3B5dWZ3ckhzTDF6cXNsdHFzU2w5d1hmR2gyTVBYSXF1aUNWV01LbC9aOHNuS3p1L2QvNEZ6MWxyVyt1Uy9rVEJDVzNKSjFERDArbFl1bmVKWnJLOG1qdWlzYlI4a2JoODFkRGNYeTJ4aHRvVXdnQXdGVWtZUHYycHVzNlhwV29KYUdSY1NCU2NqbkdQWEZTclcxT21TbnpjMU9wYWNXcnB2Um1kUHJXcDNhelQyMEROdVhLRHJ1OXZhc3VTNDEzN0hienlzdG00Yjk2cnJuUE5hME4vZldCaWpkVjhnRGlSUnoxNHFhODFmRGtTQUZKR0J4S01ZQjlNMDBUSlhUY3FzMCtxMlNlOTlDOExtejFLN2dpRXdTU1BESGJuNXZyN1Z0WEYxWnpTdUpJbWRBQ0dCNDZWa3JxVmhET0NyUkRJK1VqQU9QWTFuSkhKZDNrck5kS3NiakNjak9lOUhrZGlxYVdYTEtUbHJaZmNWNDEwKzVsYU9DejRVWUNxQjh1UGV1anNJYmlGWm1GcVFoWEJYL0FHaDcxUTAzUlBzbDVQT2t6dUg3RHBuM3JhdGJ1NzgyUkNyNFZkd1Zoeno3MCt1NFU0dEpPY2VXVjJ0TGREeTNWalBFVSt6V29FOHJBT3hYc09veld2YVMzY1ZrNGxFTFBJZUFPT2ZlczlQRU9zUHF6MnN0b2RySDVTUFQvQ3VyYUQrUHlJeGs1YlBVWTdpazVhV3NjVUhDVXB5akp2V3pWcldaaXdDN1FTRXhFWitWU09NSDFyVHNadFJoTW91cDFJVTRZQWZlWHRWZWJVNXhDWWJtR05Sa2tNdlUrbGN4ZitJOU0rMHh4L2JCQzRiNWl5WkZGMlRPclRoeXRWSHBwWnUyL2tiZXN3YVpjUGJ4eXBJdnpiMWFNSGo2MXl0NXBPa3lvbHVwa1VrRXE2azdqL3ZHdXMwcldOOExtUXhzcFB5dWVBUjdWeWwxNG10N2J6emNXUjhvU0FKTkdjNHAza1RWalFsRlRrNDNudGVQYjBNbXl1OVgweWZ5L3dDejNrWkZJVjVGemtlMmZXckQ2dFlYRnhieHpUdGFTaFBuQlhhQ1QyelYyMDhXMkZ4Y3VzTjY1WVkycXk4R3VZdnRVdU5RMU9PS1NPSmtiS3Q4blRQMDZVSzdidXVod1RsQ0VWRlZiNjJVV3YxUjF1bVhWcXQ1SmFMSTVYT1VmT1J6NlZZdTlMdTRZTGx6cURYQVVoZ2pmdzRyZ3pxMG1taDJoMHJQa25hclk2bXV0MG5YTEcvVzV0NzIxa2grMDdTTjJSK0FOT3p2NUd2TlNuSDJjcGF2bTVYcWttK2hzV1Vsa0RDN1JKSVdYSkNucDc1RmRLV2xNMFVpeEtMY3FSblBQTmNkSHBFMEVzNHNvb3BSdDJJTitTQjcwKzYwcldHc3RwbGpDSGtJT0R6MXBLM2MzVXEwWTJjSHBycDVlWjFselBKRWpSeGpkRzY5TTRQNFY1UkxEUG8rb3lUS1RLWmxKS1o2RDJyS3V0TzFhWHkvc3JHUW93QklmNWxQWHBYUjJta2ExSWtMeXlKSWhMSTVZNFlZN0Nta2wxTUoxS2xXU1NweVRUMGExU0pyTzdzNzJNUy9hSklIQis2QjIvd3FhNzhTMjBVMzJlU0Y1QVZHMDRPVDJyanpwV3RycWMwQ1BDcU9oQWJyanZYZWFQbyt0Mjl3aTNrOE05dXEvZXg4MU95dUttOFMwb3hYSzdwT1ZycCtvVzl6Y2ZaMUZxMGVHUGZxdjUxdkcrdmJLTW1TVVNFTDh4YmpIMHE5TWROUU8wRnFTV2JPUURqSTZIaXZFZFl0Sk5XMWFPM3VtbWdia0NSRDhyTDJ6U1IxU2JwMnZOdVRzbGE5a2Q3ZVN3YWt5S3FiUy9IbVo3aWtHZzJzY3l4TlA4NHhody9PSzU0MjJucUlMT0tVM1d5UUwxSVpmd3AybDN0aWwvTmJ5TTZMSDBhVHI5Q2FkckxRNU9hTXFxOW9vM2JTdmY4QURzZW9Xa3FSWEt4SnV5Z0I4eHNrSDhmV21uVUx4YmxncXErNG5CSTZlOWVXM0dvWEZsTk5iUVhFbHhITVRza0F5RS9HdTkwWk5ZZXpBWXhsMXpnbWsxWmVwMjA2cmNsRktYWGJaZmNkbExKSVlOa29Ua2RjNHdmb2E0aUtLVjVBTnhVRDdwUFN1UTFPWFVyMVZZUWxKb1pBb0hJRC9TdlROTVc1bjA0cE9JMGtVakF4elNhMFdwY1pxclZhMWZLdEgzOGpEdnJQV3lSdGxRZ1oyNTlLNWFHWHhBa3NoYWRDRUFYS2pnL1N2WlRIaEpvMitZNCtVWjVQK2ZTdVVXNmpza2tqV0VBT3g0STcrbi8xaFFwYVdzaFZhQ3VwT3BLUG5jOHMxbnhMcTdYVVVDN0pGYkhHT1RuME5kTExvbHRlMlpWYmlWR3dEdERjOEN1Z2xzckl2NTg4QUlYNWkzOTBtc3kwUzFlNG1uQ3VvTERZNDcwNzJSd1M1L2FXazFQbWVpYmVpN25IWFBoYldvaEViZlVaTWdEaCt4cjA3VFRlV1drU0hVSk43QWRnTVlxbEZjNmxQcU1rYnpMOW5DL0tSOTRrMUhQYU5MYXp4U1RzUVQ4cGJuTksvZG5SRGxqek9uQ1Y3Tks3MHVVN0M3c3BwRElzb2pWdU1uajhPZXRYWXROOE9wcWJmYUdielhYZEdXSkM4ZHgycmhicTMxTzBzbVM2aFJiY0g5MjR3RGsxMDFsNGFrbXRyZWE4dU00WDkydzdlbE8xdGJuRFNxMUhVNUhSVGxHMHZlV25uL3dEcXIrL3R0UGhqZHdwaVhxUnlmeXFGZkZQaDI3dDlpS3F5TndNakJQMHJqdjdBUzQ4eUs1dW5ZRGlQbi9QV3ZOTlIwK0t4MUswZFk1TXduT09oNis5U29ydWRWWEZWNFNVckpVM3BxcnU1OUFYT3JSMkN4dUV3cTREaFIwejJyVmoxYXptdERMQkdaQ2Vpa1lOZU5uVk5SdVRFeDBwd3JQdzJEdHdlSzlGZzFIVEpMaExhVUxISU1iR1hpcXRwc2IwY1RKMUhhYWpGcFd1cmF2c3pTdkxtYUl4eVJXZ0lWZHpMam5OTGJha2RSdGk1UlZPZHA3R3NKSTlWMFM0bGRtKzJ4U0hnQS9NdlA4QUt0eWFCWmJReVFOSEROSjh3VTRBSm9razErcHNwMUczZTZ0OFVQeXN6TnVkUjFHd2dtbk9sdEtzWitWbDdpcmR0cTB0M2JDVHlUR3pmY1VuYVFmUVZyYVpkYWdsdW9sMjRQRDU2SDM0cmxidlRmTTFBelJ6U0pzQTRDNEg0Wm9TUm5LZGFNSXVMbEpOMmNXa21yOVRwUzZJMzc4Z01SbmI2LzhBMTY1MjhndGJxYk5uZW1KMTVZRG9SM3ppb0xPemptdXQ4czhqbGM0QjZZOUs4Mm4xNnowN1ZIaVpHVm5MSGNNbjZmaDdVTGQ2bVZTcEp4aXBRWEszcTc2cExyZEh2RFJSdERieFhBVjFiN3g3VnpsdnBuaHBkUmthM3QxU1JQdWtqL1BOWnVtYW5jWFVTUjNFNmdoU3lFZ2ZONlpyTmc4T3ozVUxmNlpzbFdVc2pMM0h2U2F0cGMwbFZjbEJ3cEtWMTF0ZlRvZC9lUkMyVGZHQUdaaGxldWVQU3VDdU5aMWtYWGx4MnB3QjkvR09QWE5ZR29EeEJwazZQTk1aWWsrOGY4UlhlMjhzMDJabGRGUjB3QWVDS2V5WFU1NVZaMVpOTG5wdFd2SFFtczQ5V051Wkh1TnpIczNZSCtkWDdQeS9tV1lBN1JuY01FYytsZWV0Y2F4cCtwTEcxeXNrYzJNSFBIcld6ZjZwUEFGaGpqTE13QnlvR0QzcDIyOHpkVm9RcDNha3VYUnA2N25vOW5yZG1vS093QXlkdVRuTlkrbzJwdTlrc01xZ0RKYkJ4a2R4WFBKZTJFM2x4VDJ3VHAyT2Z3ckdnMW5Sek5MWklKVUs1SHJrZEtuVTZYV2cwbEtjYlBiV3p1Yjh5MnRpcXZ2MkkvM2oyNXJBbHZ0SnVvUTdYdXd4bklHN3JqaXR1Q1RUNXJFMjhhbWRlUWZVZTFlY3lhTjVFcWxiZjV0Mk1kY2pOVWxydWVkV3FOeFhMR01vdmRhNlA1SGRSWGRxRVM0V2ZhQ3VPdlhGZERBNnl4TGNSU3Z1Mm5IemMxeU9MY1FKYXZFWXlmbHdCMHpVOGhYUzVZa2xaakdxakd4UWZZRTRvME82RXVXTjNheVN2cnN3dTN2TGlkdzhURHFjNVBQdFZhK3M1YnUxU0tSY0JTQ1QzeDlSK2xkUGVhN0o5bGhlSzNNaWxzRTdjRUNyVnhkV3F4UnN3WlZjZlRIcURpalhzT2NhVStkT2QxWlg2S3pPSXV0QTA2OHQwV0p5d1FjaHNqdDM5NnI2TnA4TWM1Q2dJRkk0OXh4a211bGhzakRjaVMxbk8xMnlRelZaRXQxTmR0dXQ5cUE0eU1ZSjcwMjlMWE9WMG9YZytSSjN0b3JvZnF1bDJFclJrdVFRT01ISEIvOEExVVZpZjJkcmR4ZVRIT0l4OTBIaWlzcjI2bXJUbEp0WVo3Nzl6ZnZOTnY4QVRKYmFLMDBxenVFanhINWhjaVFEMDU2MXZIVklaYmlUVDdxemNTcUEyNVRnTXJjSGtkY1ZGTUgxTFRMK0dLWkZ1bVZ2Szh3a2hEMCt0YzVvSGhlOHNkRWtpbm5IOW9BdjUwaFlsU3ZYNWM5QlRTMDFldlk2WXdhWE5UdHl0NnhkdHUyeDZUcDl0b2x2Q0Zpa2QyMnNjS1NTdm9EWGw2dmVDVzdoc2Jjd3ZJY1RUT0J0SGZJejFKcmIwcS90cFp2TGpsTGtSc0hSQUFTd0hCM0N1WjFJYWM5cEZFOGNzVTJRZnZobUROMDNET1NNMDlVekdzMU9uVDVWR0tqZTF2dXNuclkzWmpkUkNJR0tPOGtqd3dtbFlBcVIyQ2l1aE92MlRReHVubG1SVCs5Q2s0NTQvS3VGMDN3YlpSU1JTcGNHUjl1NTFKSVhjZjVZcWRORDEyMlM0eTNtaVZ3Y2JRemJmVE5HajZtVVpZbUR1cWVrdlNWckxRMU5VZ3VidTVpanRyeU03Z1NTR3c4WHJVSTA0d2VTVnRoYy9QbVR6Q2QyVzRKQTZZcTNva3VwM2tjaXJwNldJSEFsa0dXYkhwbm1uNnVOY2d0bzFFVy9nK2RMR3dWbEhRWUI3bXFWOUJPTVpLVlRsazc2M3RkZks1d2ErSmt0TlJhM2V6bmEyVGNuN3RTcTViMEhYaXVvMU85Vlo0TGl4dEpYanVZc015S0RLcDdjTldMcWtseE5hNXVKVGJ5UENoYzcxT0ZCd2NCZStLNkxScGIyMmhReVBiY0RNQktzVzhvOGM1L2lvczB6R0RtNVNnMjdmRW5aSm8wcmJ3MWJ2RkpQR0hhVVpWbG1mSXlmN3dxSCt5WjNqREMydExLVlpBeHp5Ryt1MnRDZVN6dWszTkc3cEJJV0xLckVBL1FkVFdqQkFzOEIreXpBa3VIY1NEYng2RGR6VVhkenJkT2szeXFDMFhSNytaS3NJZHBiYVJiV01NY2tvQ20valBQMXJsRjFHYWJUcnV6ZlRaMmppWjErNzhyS09tV3ArdGFMclYzcWZ6VHJiMmlLTnV3Z096ZlU4MHVtMzhtblJQYXlReld6YlNQT3VHRHJ6M0JIclN2b0U1VGRUbGZOVGl1Wlh0ZTVoYVZkVFc5dTV0OU5OdElxQlZkbkRnOTYzN2REZVhFTTB1b0FOSG5lVXhzNTY1SEp6V0xyVUdvUnFZTEdLSnpLQUpMcEJ1VVpHU0dHZTlQdHZCK2dUSkZkemlhMk1YRGlKekdyTjAzZXVLYmFNNmNhamFoYTZqdnJ5clR0WXl0S0hob2F4OW4rMFhFZHcwck1qT0NuSTdEUGJ2WHF3ampnbExlUUhVQnR6Z2UyZUQ2MXhHcld0dkRiSHlySmJ1V0JrYU5sa3hKdEk2N2oxck4wUHhKRGV0SEVydXNoa1lOSHNiQ2dkQ3pkeWFmUzVWS1VhYzFDeVRidW1sOHJhbXhZcHBrQlp2N084L3pHWjFtaitZS0QxVTU5NnpiNi93QlZLb3RqcGdXVld6dVpBOGVQY2RRYTdiVXJMVEptOHFYS0VxWC9BSGNtdzVIWGpqaXIxcjluYUJMYUZ6R3UxWERPTUVzUDUxRE5IUmx6Y3FjVWxzNDJUdWVYUVhHdlhTSjlwMUtMVDVBekRJakNNUjBBd2UzcFR0WHRmRTMyZXoreDNTYlJneTNjc20wSEI2SDY5cXUzckltdHhpNnVyZDl5c1lJbUlVNEk1SnlPVFdrMmx5NnBwanBPbmxRQmwySkkyMHlZL2lWUlZ1MWtjOFl5bHp4Zk0zcmJYVjI2dmRJNTliVFh4YXVMdlVZbTNjdzNDTWNEZDYxWHUvQk04YnhYb3VwTGllSlZZQkd3c2c2NXpYVy84SXhxNlR4aUsvZFl3cVk1RXNiYmV4SFlWd090NjdyMWhmUldVbHlVbFZnd01jV2JkbFBjc3ZJcGROR2duQ01ZM3FVWjlrMjc2bmJYM2lpemJUQTgraDNKbFQvVk15RXJrZEFDYTR6VDQ5Y2E1RXQxcGNkMGQyNUVTWUl5Qmh3R3IwSFRMNjVrZ25PcUxHZHhVUncyN05JWXZRbjJPSzZPS094U05wclNTS1I4QjJESmwyeHdNZTlMWTZIQ1ZWeDVxbTNTeVQwNnRkVGlwTEMrbG1ieUxONEptQjJyNXY3c0EvM3VPYXVyYVdsMnN0dlBFV01lQzBDN2dBeS94QSs5WTEzcmFDNHZOTW0xV2VLNGFNdnRkTWJGUFlNS3JXdXI2YnBNU3pUNjBacldWQ3Nhc0NIM0RyZzR6ajYwSk8xelAzSE5LenMxNzNOeS9ranYwdk5Ga0wyU0ZFT3pEUnRKaG95ZnJYbmorSDdxRy9sdDVmdE4zRklCdGxlWGF5Z2Z3bjFGYXAvNFIvVUhTYUtGa01JWjE4ektlWUc1SUpBcTM0aDFhNzA2SzFsU3psdkk1RVBFUUxsQXd3QjcwSmFsdjJkVk55NWVXTFhLNDl0bW1qbmNlRXRQaG1XRzhpanVaWkFqaUtRa29QVTR6aXVpMDNUM2tqbWx0NXBVZU5kNVBDeGtIakpKL09vTkEwRHc4SVpKazB5TzJMRU92bUhFZ1k4ODU2WnJzNWRQdDMwNExjc0Zoa2tZK1dHK1hnY0xrZncwTzNkaXAwazlWR05yYUpYUjVUQmJSM045RTBPdGVkY0l4TFFxNE83SFhHSzllMVcyc2RZMHFlMm1zMlFaQTNTZko4dzU0WWYwcm1kVXR0RXRMTUxIYncycUFEYk5GRnVZQTl3QnlUbXVPcy9HeXdRUkM3bm11VWpkbEJhMVpTd0hRMGRMOWlxYnBVT2FtMzhXN3ZlL3JmVXhYdnRRMG03aVNUUlZ1TFo1UkdMd3RoVkk5NjlCT3VYTFBGRU5PL2RUWlg3U3ZSVDN4bXVUaCtJY0V6eld4MCtXYU1Ncm9JNCtjK2hCNkVWMG1qNjJiZ01wSG1FeUVORGNTREtodlJRS1Q5RGxWU21wd2hHbzBwZjNUdllMZU8yc3BJbmtGd0YzTWZNWExLdnRYbldvejNyeGI3QzRqaGlLQldqS1lBUHI3aW4zK21RM09vVENCU0kxR0dSYmdoQStPQXludFdmWitFN3FHNFdXNjFCMGM0eEZISDhoWDI3VXJyZS80RzlTVmFYdVJwMml2ZDVsSzIzbm9iRWNHdHkyVnBDdDdaemxsWXRGSkh1M3I2QTEwV2pXcFdCamMyQWhiQlVMR29BR1BjVjQvRFp6YWRmWFNXK3JHTmNreFF2RXpTaGllVkJQR0RYVzJPaCtLamN4WHo2cEpBb1VtYUdYRHF5K3ZIU21ucDBKcFZMMUZhRXBOSzIvTXRQTjlUTnZQRG5oeVhVSG1lTTNjaUFHVldrNUFBemdMMHhYU1hGMlcwcUtlemxTeGl0eDh5RlN4SUhCVTU3VkxQNGJ1NVUrMDZaZlJ4VE56NXBCS1Bqc2NqcFQwajhRMlZ0bTdtaG1tbFhBTERiRXg3QWpzUGVqVm1pak5jMTROSnA2eFh6VHZ1WUZ4cU5qcUVNa0gyNDIwb2RHVjFqWUJlZWV2VUd0dTUvdDVydi9BRVNPQzZ0WlhDeUtTUVU0KzhmclZTOWpudTdPYVhWVkZva2JwaHJYa1lIR1FlY2pOUzJON3Bkak8wZW4zN1hEYmYzaXlFNExkaWM0d2ZlbnN1NG96YWxlVHNuWlhYdXllOXRHYzEvd2pldFdndHBMcDdXR2Z6V3dCSHVJWFB5a2U5WG81YlBSeTh0M2ZwTEs3S1hlUWhXSWJqRzMwRmRwYU5xVXQyc2QxQ2hjYmlvV1FnS0QwSFBYRmNsYzJUemF4YlBQbzRtaGVRbzd6Z1NiQU9teloyK3RHN0ZLRVlSVW9LU3ZKZkVtN2RMazhmaVBUTCs2bnQ3Zk1pRnR1Mk5XeVJqQk9WNlVrL2hhem44bnk3YThMS3BBWHp5VVFyejgzY0dwNWJEVDQ1UmJwcDdSQnlTSm93eUVZT0FjaitScnFuMDdVTGQybEY1Sk1wVUF3cUFtVkg4WHFUVDAzTmFVSno1L2FSVTlkWEZiWDE2bkh3NjdwWnR5SjlQTVYxQ2pLeU44M21JT3BOYzNZNjU0U2VTU0NXOVMzV1RrRm8yQ0R0MjZHdTMxUzAwbHJjdGRwdFo0MnlOcmRPMmNkNjgvZGRFdnJXS0t6bjA5WWtHWHpHU3k3ZTVCNyt0SHV0ZFRucSswVW8zNUpXVzJ6ZjVIbyt5MHRiTHk3TzhrWlN1Mk9SQ3BCTGVoYnRXTnArbStMRGJtM24xU01CM3crRkRTTG5wZ2lxMXg0aDA3UzRJTGRyVnIxVGhSSGJSWUNBak9UNkNyMm8yWGlpWFM3ZDdhOE5wTTdjRlNHNGJzY2pxQlVwTTNhVW1uYWRrbW1vdDJSd0tRK0l0Syszd3h4elRLWlNxVFNPcUkrZXZYdlhKYXBvMmt5WDhvR2ozMXU4a0tzQjUyWXllNUdPdk5mU3NtazIwZHJDbDFxaVhQbDdXbWFaaHQzS092SFExZlhYdkRjbHF5eVQyOG9BSVVEQktnZGVsYWJ2WXhlR1VWSk9xb1gxU2JXbmtlY2FGZVh1bVQyaXRmVzdRdkVBRE93UXFPbnluMjc1cXJyc2gxUGJERGZTbFBNYkVsdEtQbFBiY0JYb010bG85L1kvYWJXM2duVmx3bkFZYmU0T2F0YUQ0VGhzeTBsclpRVzY3Y0dNTGtzYzVCQjlxZzZJVUs3akdDZDFkUFIzMC95TURSN2VhUzJoanViZVNTNmhqMnRjYlFXWmZRKzlkRlBiTUxhSHlGS1JLdzNaQUhBL3VqMEZiRjFvbDNkYnhKY1Myc3FEZnVnSUQ1OURuclhvZmhlMnU5RDhKNnBxZDNmdGR5WHdlMDArTXdBU0FNTVR5YmU1QU8wZldyalRjbnZaSmFucDRUQ1NuSnhtbkdLaTI1MldpWGwzUEdiQ3dqdjlSZ3NZYmVmVVo3bWNScXFxSTFMRTlUeUFBbzVKOUs5aDhSM09qN1lkSnQ3VHo5TnNXTEYrbm56a2JYbTU2cnhoUFJmcldGWmFMNGQ4SDZQUHFTUnpRWHV0aVMxdGxVc1dnaDZTeUlPY0Z2dUE5aG12TWRmdmJlRkxKWlhTV0E1UUY4cTJTT000UDg2MGZ1UlNXOHQvUTJsYkNVSlJ0RjFKcE9YbEY3SjMxMTNaZ1hPaWFCRHFBbDArNyt4em8rK1dOdVZVZSs2bmw5UVc0RTcrSW9Hc3dQOVdTZ0hIVTU1L0txa2swdDFaeVJMcFVUb3o3WlhNd3kyTzQ5UlZuUXZER2xwS1pyN1JMVWJRZG16TE13UGRnVGo4cXg5VHdsVFRxWGd1Vyt1bk5HTi95T2JzYmk0MVRVWmphZjZWRkhNWFNSdUVqNHhqSGNWM3VuYUpyY0RNN0d5bFYyenZVRmNGdXY0MTFZczlGc3JDU1Mzc1d0a0dXa0VaL3UrMWMwTmErMXhLdWx0RXpJcGNSeWpCSkh0VDkzc1hDalRwTmUwbTNOM2tsRjcraTZuUGVJWXZHVnRFa0Z2YjI4a0x0Z3pxMlBKRER1Q2FqOE53VzFsYVJ3M0dyeHozV0RnSVE1ejYxYjAzVTljdXBFR3BRQzNSOCtiRzdBcmpPTzNRVnJ4ZUdQRDloZFN2YTIwRURYRXBNY203T1diMDl2YWk2TkZUaTVxY2RiYWUrOVVoSkw3WFRjUnhRUnE5cmo1cDVlVklQVUFldGFNbHRackRJN3ZDZys3RzR6bGZ3cm81M1hUOU96STlzM2w3Z1FUMU9PT0QxcnlLeFh4UmNhblBKZDJpTGFsZk1VSndtUDRTS2F0WTBtM0JwY3Nxa3BQYTExRy82R2phNkxMYnl5bEZqdXBwVHlTV0JSVDZnOFZ2UWdXYVBMZENOMzZqT1dQSFFHcU9rdytHRE8xNExreVRTN2hJdm1iaVFPTVlYcFY2NTFyVDVMV2NvOWxHYlowRzJSbVVqbmdOOWFWMHpHRVlRaHpYakYyZktyMzIxKzhxMjkvWmFpUE5oalpTd1B5NE1ZR09DTUh0VElZNVk1M2dtdFZTM2RSNWNqUHdTZWNNUFNyNXZrdTl0eERQWnlxNVlKRUFGSVpmdk1HNzFtejZqclV1bnJMZmFSYW1NdHRmWko1bkhRY2NjMDdJMGJpbzh6ZDdhM1VkR3ZPMTlEblgrMzZmZFJueWJDWkpReTVpY0Q4RzlUVkcwdHJDMWwyM3Vtd3FzekV1dlRhZTJNOXExN2JTOUN0UkxQYTJzelNwbVIxYUptVlNPdkhwOUt6cGJ5MDFQVDIvZFIzTWhaaGhtTWJwbi9BSHY1VXQ5anpweFR0SnVLZXJqSFNTOCtoMGQxb2xvZE50MzArNWFaWTJJVlZPNEtDZWMrdFRXTjhMY3lSUlBESXo1SlFxVklJNHJsOU5zcjNTSlVadFNRTEltQUM0MmpIUkZIWDhhMDRXc05ZakptSiswUWo1V0NtTVpQQkI2WnFXbmJWNmR6U00xRnhhZ29WSHB5MzAwN2ZJN08xam5GZ1hrZU9PUkdKQ2lUSXoyNjF4K3BSU0pDbDFQSTY4SGVpeUhHTTljVmRzOU9raXZ4Rkw1eDJJcEtENWxJNmJpVFd6NGhzTGU5dHhHa3hVNEo4eitCY2RteDZldENzalNwenlvU2ZMNzBkRW05MmVjMlduUnZjQzR0dFNtZ0hJVUdVdUhKNmdxZWFvNjVxc3VrNlU1bWMzampKeENoQjNkZ2MrbGV5MmNWa2ROVVJ0Qk15SUNYaTVJeDNIdlhJM0M2bzg4WmsxTjBqWnhsUEpRRWo2OTZmWFVGVGRPbEI4dDIwdmgyL05JOEE4RStJcmZ4SEJlbTRudXJLNWdtSGxoV0kzNTZaQjlLK21wTkwxZVpsSG53WE1iaFF5OHE2cWU0STcrMVhZTGF5a0diU0ZJcFBNNVl4Y3NCMXpqdldCZEhUTERXb1lKdFNXR1dVWktsaU54enh6NlZjbW05RlpkanFuQ256eWtvV2kydHBmbmZjdkxxNmFkS291Tkhja1pYY0NHS3FPN0gwcExxK3NibTd0dDEzSUlteVY4bzVVK3h4Vi9WWkZpYTNrdHA3ZnlvNWdaaE1UbGxQWlNldE8xSzIzU0k4TjVGYnF5aGtWVURFSFBYanRVYUV5VlgzbzN1azFwWmZub1pBMUEyVnhOR2tFcGlZRmcrZHBKejBybXJlRldiVUd1M21ZUy82cUVFNFU1N1lydEk3eWE1dGJoWnRPY3lJU054QUFjRCtKY2V0Y0xjYS9mYVhISlBjYUxlSHlwQ0VBUUVGU1A2VXRUQ3BLTFVidHVMYnQ3cnNyNmFqNE5kMDFvcGJXVXNicUlGRVV0aVJ4L1d1Q2tnOFZ4Uk5ISmRRTkVXRHh5YnlyZ0E5R0FyczlKaDBMVjc2M3Z4YlNKZUtDNERjRUwvQUxYcm12V3hac3NpeGt4SXI0UEtidXZwVHVqS25SblhwNnkwUzVVMHZ6UEhienhIYkNMVDhrRWtZY1lPNVhIOTNOYjk1cmVsMkZ2SGNobldhWnR1ZHVkMlA3Mk85ZWlKcGc4NlFNWUFDL0Rzb2I4aDJybjUxTnRjU1J6NlRDOXZqTFNxMlJ4N1k0cVVidWpYaW01VFd1aWJpOUd1dWx6QTBuV3JxNFBucmFvcFo4S3prbEh4NlpxdDRpdUlDc1RsNG9ad2QyQWhiY080RlhidTFFbm1JMXZKSGJnZ2lNTWNrZjNsOUtqMHUrMFNlZUZMVytnY0lySXNMc0N6RWYzczg1cHEzWXl0VjVQWnVTL3hQVFcvUmFIVTJHczZiR0VaWXdRMkFwSFVINkd1SDhTZU9CcFdwMmtjOEptTTBiRlRHdUdYMEpyWDFhZG9wYmVHM2d0eGNramZHRDh3QjZFVnZSYVZCZDZTczB3UDJpTVlET28zSEI3VVdmYzdWN1NjWlFVdFk2M1NzdlE4eXRaYm0vaVozV2FhMm5PeHdWS3VwUGNWbzZUcHVyV053VXM3anpMVlZLN0pPR3dhMzExeS9odi9BQ3JlTlhVY0ZXR0crb0hjVnFUM1NMY1RKS1ljc29aZ0R0TFVub2VmVG9Va3IrMWszRnZYYjhUeUR4UjRYZ1pWdVlZMkY4NHlZZzRBT085WkdrNnRxdWhRNzU5TGtaVkpMRlczS3VleEZmUVZ0YzJNb2lsdXNRSXBPd0hseC84QVdyaXRka2lrdWdOS25hV1pteVluand1RzRKTlVtRlREd2orOWpKS1MrRkxmN21SNlRxYWExSERLOWhMYnMrU2txZXg2SE5VYjZQWEUxa084cVJRcHl4VThrZWpWMGswZXRDeTJDS015SUNDSVcyRWs5Z0t6b1BETncyTGk1VzRZWnlZaStEbnR3T29xVXhPblZrb3h0SnU5Mi9oKyt4aWk4ampMUkpkTGNTUGx5c2k3aG4wR0s5SDAyK2hualJtWlFWQUxFcndwSFk1ckVuMDlTalJ4d0NOamtxNVRrWjVKbzB2UjVMVlhTYTVNaGw1T09qWTZabzZHa0kxbzEvaHZGcjVMN3k0YjB4M2Q2NXVZUkZuYS9IZkhhcVNYZGxKL3Fsa0VTamhsT0NjOVJ6UmUzMEY5SU5OZTE4dmc1bVVZT0I3OXFmZXZZYVNrTWNDTTJXd0h5RGdkeWM5YUxmZU55VjVlOG5HTzdzNzNmUXhFdjdxT2Eya2psTFc3TzBaU1ZmbUh2VnU5bTFHVkdEMmtGd29HWW1VNUl4Nmp2VjZhOHRtWHpISk93SFl5NCtmUE9NZXRjRzNpYVdPY1FmMkpkQU55c3lxUVFBZlNxMzZHY3BXVFRxT3pYVFhwOHkxcThzY21qUkM2MDBSSnV3azJlRjl6NkNyR2o2ZGFTVytJM2tML0FIa0tIS211anVKOUZhUFpLOGJpYkg3dVZzRW4vR3V2MDY2MCtDRmR0aUl5RGhQTDVVRDNvdm9PRkNIdCthVTQ2UlN2MS9BNGE3MVBXTk0xR0sxSWtkREh2WmgySC8xcTYrTHhQRGRLcnhYRVR1RHRLRTRKSXJpUEUvaWJSSUxSM2tETk96YkN3UFJmL3JWeDJtK0gvRGw5NU10dGNFTVV5KzJUa25ybXB1dE9oTXE5V05Sd3B6VW92YTcyOHZVOUt2ZGN2WWRTWWl4akcrUGwvYzk4L3dBNnR4M3QzY0JpNWl5cVoyRHVheTRJZnNkbzBlODUrWmtXUTd0dyt2ZXFXbk15Nm5NUXF0RTBLc2R2VlRudmloSk1TcVZPZjNwTnFUMVg4djNGTFhiUFc1ekVJV1NOMkNIUFpRVFhMNjFhWDJtWGJTWEZpbHhESEVHSkE1UEhQU3V5ZlRZUmRQZGpVWmRzcllDSGxRUjJwZFN1ZkVONmtrYlFKR2lMaHBGYkpLL1QzcSsyeGhVcHBxYmNaOHphY2JXbGYxT2ExYVdEVXZEL0FQbytsM1cxb3dWQ2pCNTdERmVlYVA0ZXNwSXd0N0hleGV6bnFSMi9HdmI3Ylc3dnlCSGJYTEZBdTFuQzRISEhUMXFDVzkwYlZEOW5ra2FPNmlHQnV5Tng2NUgrTk5PM1ExbEdFNHhmdEU1V1dqU1Nma3JFOEdnNkkrbkNLS00yczJDUE1aUmtyNmcxYXN2Q2wxYVdNaFM5V1I4ZzdndVNSV1RxV242N2JHQ0ZTbHdoVEFqUERZOWMxbDZOOW1zUktrME42a2lNU2R6NUJ4NlVOTnE5eXJVL2FwU29PTFN0ZS9MK1YwUzNMNmdKakRIWmlZZHo5M0hldG1Ud3l0OXA4ZjJ1ZHNzMjdiME1aSGFxc2VwK0Y5VTFBQ3p2SFc3UUVzb1lnREhyNjF0Nm5kckhCQ2x4ZUlySEFERTVHUjF6VTMwTkl3Z3ZhT1h2cTJtdW1wVzBTd2hzYlc2aWpqS3lFTVVrSnlDQjByVTAyRy92STVCZFI3TWNBakI2ZXRTV091d1BKNVVheFRJRjI3Z08vc2EwbWx1bmpGd3FpS0V1RmZuRzNGSm1zWXc5bkRrazJvM1RpbCtaNXZKcHM5dnFRbWpkWVdqSjM3UmtQNlpGYUNBdzNrWWtiY0pHeUZIQUI5YXFlTElOYWx0R09sMzBJbjRPT29JOU0xeEdnWE92U2llSFdWallLQUN5REJCQnlEbXFTZHR6a25DTUwyZTg5TmRMMlBVTHJ3NGw0clNKY1BIT3JaR09nSS9wVnk0RUVzUnQybUtNY0JpT0R1NlpGY3hMT21vTkhiMnQzTmJOR3BMWjRKSDFxTzhleGlXMmdlS1dkNGcyNlVIbjZuM3BwTUkxS1Y1dFJWblpPVjdxWGthSG5SV0V5UmZiMjhwVndDMzhSNjR6VXQxbzB0elpJNjNmbE5HNWNZNXlEMnJ5dWJ4VlpXcEZ2YzI3TkU3bnkyWk9RUHFLOWZ0TDdSNTVJb2xEZ2phMG1UakdlaElwNm9VSlFuR3owVFZrbTJqTzBld2tsbGZ6YldOcFFjN2xIT1I2MUpkUzJVbHhOQkpiTDVoNDI0enV4NjFtM2x6ZjJpM1Jodkl3eXZ2VUVjN1ByM3JsVThjZUg0cjJHV2FGbWtJeTdnOUcvb0ttd296aW9LRm5lK3JhdmRmSTlGc2RIaW1nZU5yZVJGUE8wY0VFZEt6THZWWU5JUkJOYXlNWWY0aC9FRFduYStKSmJxL2pZTUlvV1FrSCs4UFVWbFg4VXIzQWxWUkxCeXJoczg1NUI1b1NmVTFjcWZzLzNWN3AydmI4Ykdub3ZpTFF0UnRyaG5RaFZmb2V1VDlLM1pMcUZidUpWaVlvL0c0ZGpYbjhkNXBTWERXMFZyOWxtYkJWOXVVYjM0clcwNFg5OUVrbm5qNUpjWlVZUEhIU2hwbFJ4RTdwV1VuM2l0N1BWTTE3bTF1SkRNc0Y2WTNQSWM5Z08yYXc3ZTloWEJlUlpEQzN6RTg1UDlLMzc4b3NNbnpjakpEKy9TdVgwSFNrTWR4dk1aTWhMRTV5VG5wVTlDcXJmdFlwTGU5OWRQTFEydGExS2FkbWhqRWZreXhESWJxRDJyTmlXYUswQ3F5dHNIQ1o1RlZ4WWFUR1UrMVhCVjR5V1ZnM0JGYlY5SGFOQXN1K0pZejl5UUhCSDVVZERuYW5PcE9kMXpXMnZzamxSZDJkdHFlK1F5N3RtZHZVWjZqcFhRM0dyeDNscWZKajNndGlUZ2piWEt4NlZjVzF3RDl0U1JIWENodWMrd3pYYUpwMTdiV2JTK1VxbHZsYkhBeDNxdFBVemdzUWxKVzVZM2JkbGQvZVpzOC9oL1V0TmEzdUx3SnRBNDNZd1J4elhRNlpHOEZ2Q3NkeWs5cXZUbkxmbFhFSHc5cEVsekkwVWJFdXBEcjA1UFUxalc5bmQrSGxhZU9RU1FJdy9kRW41YzlhYTdmbVAzMU5TbkZXajlxTjcyWGZ5Ty8xMnh1UHMwZHhwekJDaloyc09hRVNmVXJDUHo0d3M4YkFsMUk0cmRndTAxSFRtbjNwR2MvZEJ4amlrRU5oSlp5Q0taU1kxK2ZhUWVjZnpxbGExajBZMDRTZk1uN3NvcDIyVDg3RktXODB1eXhEOXNMczYvTGs1WFB0NlZVdXRBMDhwOXJ1QU96YmxQTllyV2RuTGJ4UlNXMi9jZXVlUjdtcys1dE5HTTV0bnVMcUlxbnlya2xUbWkzbWNzdmVqSzhJTkszS203YS9NemRXOFIyRnQ1WnNubGxja0J1Q2NDdWtXVzIxQzFYeklYK2NZOHdIYVZKOWNWcmFWcHRySEYvb2NhdElwdzI1ZVQrZjg2M1V0N3I3R3p0R2lsWHc2REhmalBGUjFXNU5PbFdsRjg3VFVsckZLOGRDMXA5bkZwOXBFaVhTM0dUMUpySmsxdTdoMUNkSjdhTVFZeGs4SC9QTk9HeUNZQmJmQTNBb1NTZXYwcGI2d2wxYVJyZTRzMlZFRzRTS2NkZTlYb2RzbEwyY1kwN3hjV2tvcE5wK1RadjNzaXgyRU55c1NyRXd5Q1IrdGNWZkxwMnEyb1ZJa015c051Ums4OTY2bnhLc00zaCszc0VTUW1DUGFoWHFjVjVOb055TlB1WUV2TFNhTGNDRmNnNE9PbWNVN0xXeHpZcXBKVjR3dXZadUtVcFcwVDZuYnRwaVMyNlJYRUkrUUJkeWdaeFRwTFVRVzBqeHlGU21NRHBuSHNhdjNXdFdkenM4bVlEYko4d0k1TlU3aDdTWUFyZEtqQTg1UHk1SFk1cUZxOWpTYWhLL0sxTFJLOXpvckdTMjFPelZuQ3RuSWRXNHp4WG05emI0VzdEU0NPUEdFR2NZSTlQZXVvdDlMV0M0ekZlZk8rWEREN3A3L1NzYlVVMDJSWGU0aVlzdjNqeWMvd0JLbTJwTlNWVDJTNW94VWxmVnZSL2NZdWltMGVFUVRxMG0wN3Q3SEpYUHZYV1FXQ3JOSktKVWtqejhvSEpGYy9iWG1tTkl5eHVVK1VBS2U1cmdyTFQ1TFc5dTVocU1pUkdUSVhQSFg5S3EycHl1dENFSU44c3Q5bmJiK3VwNlg0b1lQQWtrS2Z2b2dXWHZ3SzQ3U05WMU9UVkYrMWFVQkdZOE5KdDcrOWQ3SkZEUER1aHVOMDRVWS9IK2xRdGZSV3lSRzZQbDViSFRJcWI2YkdzcFhxYy9OYlp2dHAzTFZyY1dzUm1hMWdJSmJKVWNaSjlLNWZWOVQ4UVhEU20xaFFPRkI1OWFXTHhDeWF3MFZ0SkhLaEhJeG50WGQybHpZT2hkNHZLY3ZnbnBuNlZXMjVNSnFva28xZVZLVHVyV1Q5RHlXMTFHOXViYVFYdHZzbVVjdml1d2dXN2VPTm1hT1VKMUdNOWEzOVEwNGxKSlBMeWpOeVJ6d2ZldVBFeUIwaXMzYmg4TU1kUGFqZll1YWRPYTVtMnJkOVgvQUpuYnV6aUl0RkdNRmVVeDYvV3NlZVNBckJET3dHRG5wMHJucDlRYTN2ekg5cFRhUU1qa1l4MnJVaGxpdUhrUldFcEhPYzRJUDBGVHl0TTFsVjVyeFZyN1dlcS9BMkxlZTFTVm9JMERiaHdTTWNmV285ZTBxNXQ5Tjg0elBHR0k1ejJJL2xYVmFEYzZWWmlTUjdQeko4RVpJOU80ejBySjF1NGwxSzFVU09GWEdRcEdBT2VockpUazZsdVhUdXo2QjRQQnh5OXpuaUZLckpQa3B3WHcvd0NKc3pMUzhzNDdLM1dLOFNWZ2d5U2NuOGFLNUNTUFI3YVpjV3BYY2g1R1BYcFJXdkxIelBEalhxUlZueWFhYU5uV3RJb3ZRNlFTZWREdU9ZMFBROUNNOVJRMnVhak5lVHh6cklzUGxSNTh5THl5Y25ubjBJclhzdkV1bVhvdllZN3lTRmxLaGZQVUpuUDkwbnFLbHRMZlc1N200amtuTHdxbzh0eU1pWW5naGg3RG9Lb3hTbEp4Vk9iYWIxNVVyZk1xUjZqcHlYN0RTN2FBNVFCblJoKzdKNkVnZnJYbXVxZUc3Qyt2b2JpWFZvV3U0aTVab3lvS3YxQk9lU1BhdTMwdnd2WWFScTB6Mjl1VVdWZHpJUDd3N0hQOHFkcU9nK0ZiOVpwcnkxWlc4eFdDZVlJMkxON3IycFhaczA1YU5KYXU2MlM5TEVrQjFBV0VQa1RSTjhtR1ZoaG0vdmZVbW42UDQyc3JXN05sSmFQRkp0RFJGa1lid1RqZ1Z5dW5SZURrdURiMjczRnpMWmx0OHU4eUZHNlpBSFd1MDFxSFU3S2FLOXM3ZU81WEVjWjNKbVVLZXUzUFNpSzYySWk2a0Z6UmZ3Nk8zdmFEZFk4VmFiYm0zdWJ2ellWM05HVlViOTRidWZwVkdEV2IrK2pMMnl6WEVLRlZiSzdQbFBjNXJodkVOcHFTMjhNME9seFhrWloyUzNabUhsUG5vUUs2N1I3NjdlenRXTjFIYXIveThXOExxQWpqc1FlYURuOXBVbEswcE5YZXkzZXl2cjBPZ204UFF5M1AycUVUd01yWlR5MURSc1QzYlA4QUt1RnVmQ3V2NmhjRzRmWHJpUGJ3R1JCdHdEemdldGRWZDNlcFcxekZFSHVyYUtVdTZ5SVZkVVhHQ1dCNlo5YTVDNGcxK0MxTTlscU55Vkw0a2ltSTR3ZWZ3Tkd0dHgxYWxPN2ZzNU8xN3I5Yk03bU95dE5NWklaOVFubFZTV2VXVnZ2TzNBeGpyVmVieERlWEY0bjJkYk40b3lSaU45emtBZGNIcFhNWG5pZTB1N2FaYmtNd1JsS2lOZkw1ei9lYnI3MWV0NGRIMjI5eERjR2VGZ0E4VWNpb29MazVaeHhrR2pUZG94ZFZ5azFTa2xHNmJ0dit1aHB4Nm5MOWo4KzMxRzJNNWx4TERQOEFPTWVnd2VPS3M2bXNXcTZWT3gxS09PSmlSdGpLeVk1NVUrZ3AxalA0WnRJajVPbG1INVhPMXorN2ZuR0MzcjZWRkpvdWxOYktMVzJuc1E2SE1DeCtZSDkyejFCTlEzcWRLVXZaMlVsTDNkWXB0WDg5U0h3NzRhU3hpbVdUVVBNRE1DSEJDa0RIM1NEMVBwVHBwdE1oVXcyaFM0UUlWbUx0dktucU92VW1zdXkwbXl1cGJ5M0VpU1hISG5DWkhYYXlqZ3F1Y0FWUGErSHJEU1pnOC8yZUk5Uy9uRVJsaDZSOVNhZHJtY1hOUWlvd2pHS3ZlVjcyN296THlBUldOczAybjNGNHNTWm04dGh2WEhJR1BUNlZmbjhTYUhhYVRaWFRpZUl0SXpSTG5EUDZLUU8ySzZTK2U1TG9FWlk4ZytWTkdEa2J2WEZjbXIyOTJYajFYVHJOcElUaExnU2c3L1hCR01HaXo2amRvTnBPMmkxYVZycnozT3NsMWF5blZaL0pTUjJWV1pYamI1RVBVbnVhNk02bm9sOWJHUzJ1a1ZTQ2hZQWdvcEhJNS9uWEJ2RDhQSkpiZG81MTNzcFVza2o3Z2VtM0ZRMi9obU5rRHg2eklxdWRqYkNHQVQwQ2tkYUxLMjUweHExMDNiMmM3NzhyL1hRdFgxaGZBUlMyeHRMdDR4ODY1NUk2Y0U5RFVFT215MjlsUEZkYWJLZGlGa1R6dk1aUzM5MDlRT2E2QzNpaDA2MmtqbTFkWGttTzVSY0JJbXdEL0NSZ1ZVUnRPMVZIa1RVWWx1SXdWM1JQazhjWXgwSXErbGhTcHh1dWttdmh1ckdmNGEwalJ0THRaNWJhUjFrbWs0ODluazhzZ2NnNDdWSStxYVJESW9Fd1NZdHRZQ01sWDNkMXB5Mk43OXFoamdtdngrN3pKSUNGV1RBd2NrZzVyTWkvdFlmYWxYUzdxSlZZaUdTVjBsTzQ5R0kvdWpzS1FuT3B5L0JhejNzM2QrVml0YWVKdytycEYvWmswV1EwZm1DUk5rckFad2UvU3JkdEJyNzNBUzVodG10MWNsSkZab3lRZXpBOWNWbjI5cFlSL3dDa2F2QmJRdmJidjlJeHNSUzM4V0QzOTZ2eUhUcnUyYnlOY01xaGtDcTg2aFdIcHU3MHJhbWJsb20zcGQ5VkhYelROVTZucE5uZU03c3JpVkIvcEdQTkNFZE9lMzBwa3Qzb0dzWGtsdUpyUnhzUmh1UlJ1eWVnUHJXK2RLdDRZWW1uMUpKVWtmYnRqakFSUUI2ZHlLd05RMDd3YThDU1MybHFQcy95dExneGtFbklPQjYrdFdyTkkxdFVVWGQwMUc5K1Y2UDhHWlY4a09qM1VVMzlzSkZCS0JISkd5c3lLVDBLWXpnMTZMWTNpV0drTkxhZk1yWmwzSDVpL2ZnSG9EWEI2YnF0bEZhUmViYmkxamFRaU5WZFhTVk01M2ZNT3RkSi9iRjNmem16czN0L0xDRkhXVUtycVFjZzQ2a0dwVnJ1NFVwd2pLOFdrMnRFazIwMzZtQnJFOTNxTnZMSkRieVd0eXdRelF1QnRiSHA5Zld1MnQ3SzJheWd0cmovQUZrUVFpTTlQd3g2VnhGMUpxMEY3R2ttaXl4QkZJOHp6a0tIUHJnOERQclYrTFRYR3JXZHpKTzNubFJzTVl5aC9BZGg2MFdDSE9xc3ZkY20ybEs2NVY2NjlURnZubXQ3YTlNdDhsd0VjRmZNaUsrWG5sUUN2SkZhR2thbDRrdDFsSzJzRXlOQ054WGxpM29BZVJtdW5UVXJPN2tubit4M0Vaak95WGZGc0JkZjRsejYrdGFROHE3MG9MWkl5NzVTa3NqWUVpNFB6RUhwU1dpMk5JVVh6WGpWZWliU1c3Kys0K0s0RDJ5MjQwOVVMeEhkMExJM1hEVjRpV0VBdTdaN2RyaU5pWEpoQjNwZzUyc3k5SzlCbFlXRnl6bVI1WEF5c3o0VlFGNCtiYjNxRk5TbnZURkxEWXhQZFNSNGtiY1lsa0kvdURIUDQwbDk1TlJxWEttN09OMWExOU5yV1I1VjRLMUhWYmlKcHJtZEl4SEpLb1VZTXBEY0puUGNWMVdwNnZIWVQyclNhNWNtS01CcENQN3g3TWNZeDlLN1RUOUhpc2Q4VjFwcGhTV1F0REp2RGc0K25RbXVMazFMd2xiYXJjUW9ab3BaU0RJSlZQbEZsOU4zOUt0dUxrN3IwS3F6bktGTy9KVGFTVFN2RzF2TFFzYWQ0bXQ3aTFXYUM4aXU1cFR0Q1N5Yk43RTljbkdObzZWbzYvcEZ4ZUt0dzhTNmZNQ3FOTEhjbHcyT2NNb0hJcTlOYjZaZjI1dG4wZUVNNWJkUEcyM2FvSEJUanFhNTdUb1o0NGlOTzE5dHNjaFdYN1ZCdkxLdkcxU2NacWJMZEdTZzVlNUo4MFd0TnY4QTI3VnYwTjVyRFdSb3FrM2s5M2NSOHhySEtFVnlvNFVacnl5ZnhUYzN1b3hXR3NhVE5hRXg3Qm1SanZ5T003UjYxNkxvK2gzTnpjeVhrazk2cWw5d2cyZ1JTRHM2NHlRUHBYb2srazNkNm02Nm50d3R0dVZjSUFOcDlkM3BSM1docENoS2ROMmkxZEphdTkwdTVqdzZaWXhRUlJMRE5KR2tmSURGbkh2aXBXdDcxZFBlU1NkU205UkdKUW9iQjdISFUxeTk1b1lOdW8rMzNEeFJzdm1MYVRiWmRyZjNUM0dLMElkSDBlS0R5dE9ubVZpdTRDUmpJU3dQQWJkK3BvNWRDb3ZWcFJzMHJXdmJ5K1ozc1dqNnBIKzlsdjRKaGdlVXZsanZ4akpQV3VDZlc3bEw2YUc0dGJ5S09IS202amRRaHllT0s3a283cWlUcVhaY0VHTk1oV0hZNDZDc2EwOEVhVkhGSkpGSTRFakV1ajhna25Kd0NhT3pPbXJUcXR4OWxkZDd5djhBbVhibTUxYTV1WUhnc0ZtZ2hRN3cwbXdrNHhrWjcxaFMyR2xHNXQ1Mzh3eklHVmd6c3l1cDV3R0hwVy9kYUxwK3F3K1hKY3pLYllFcUluOHZjUFE3ZW9yQjBuUTFzYmlaWXJtNU5tUXBqaFZoMGJxUXhQTkZpWktUbkc2VWszdTJuWnJ5K1JuUUxwdHpLd2d1STQzV1p0Lzd6elFNZEZ3ZW4wRk5UUnRNa2xXTlBMaWtETUdrV0hBWWs1SndlSzZ5Qk5QbW11MXNiRjBtaFliOXllV1NmNzJlL3dCYXhiLzdWSHFjakdXNDhtU0pRNDh3eUtqZHp0QXlQclNTSWxHS3B4Y29xV3U2V24vQUpieTMwL1RibFdrdnNCVkJMbkNMNkFIdG5OWWwzZlhNOFROYmtwSXFFb3pZTVFJL2lKSHJWeGRTdHIydzhxNEVqeElWd3hqTHF4QjdER2E2NlN5R3BhZTR0TjBJd2NsSXdBd0hadzRvSlNWWG05bkxScTZpdmlQbHRkSThTTGYzRjAwcG1aMTJ5RmsvZEVIa2crb0ZlK2FmUFozbHExcEI5bjN0R0NKRWgyc3JkTTlPZnBWdnczcFd0WEY2TEczdXBKakxKaUJGWGFVWURrTjIyKy9wWDZaZUNQaHJwdWxQSGUzVWNjK29sTVBOc0cxTWprSUQwSHYxTmQxQ2pLcnNySmRUMWNueVN2aXFqZk0xRDdiYS9CVzZueVA0YzhBVDMwU1EzNWdqZ1FLVW1TSmk3UDhBN28yZ0FWOUo2ZDhML0Q2Q015WDVsQXdRcm95QWZRS2VLK3M0d29BWDA5cWxOdmJ2bmRDamZVQTFyVHdXTXB1WDc2akxzblNhdC81TWZ1T0Z5ekpLRUlKWVNia2trNXltcE4yOVluaGxuNEcwU0dUZERiMmtoNE9TRUxISCs4TTF0WG5oalRwNDRvN3JTNEhTRUVSRXhiU2dZNU8wb1JnVjZOTnBlbmZLZkt3U2VNRWdWK2R2eHMvYU5uOEw2aGRlSGZES3dpOHRseGRhak9QTWd0bjd4eHhnNWtjQTg5Z2VLOW5Dd3hkU1RqT2xTOG5GdC9lbXREMGFsSEJLUHVMVHFwUlMvTGMraFBFZncxMG5WcDRaNGIyNnRKSW9FaWpSR0VrSVNQZ0RZMkNPdVNRYStSZkVmZ1hWdEZsdVJmOEErbFdrZy9kekZRMGFucU53eGxUN25pdm1qUnZqNzhVSk5TaFkrT2JpNHlmbVM3MHkzZUQvQUhXVk5yQWZRNXI5T2ZodjhTTk84WlBjYU5xdHBEYWF0SGJlYzBVYkdhMXZJRHdaWUMvellCKzhqY2ozcnB4V1dOUjVwUlM4MDcvZWZNNHZKOEhpMUtVZmRuM1Y5ZlZkVWZuUkpjMk5qTnN1ckJudGhFU0pyU01Nb2IwSkJyZDBTNjAyKzFRU1EzWVJUQ3VZM1FLNFBYa2RxK3d2R253dGlzSXBMclM3V09TMFJta2xoakJMSnh5UW81eFh3cnFGbDRmdXI4WDl1bHNaSWVabGpuMnVRZWUzSnI1S3BEa2xyOG10bWZrdU55N0U0Q3B5MUl4ZG1tbHFycnlaMmt0M0YvYU54RmJ6UnlIKyt6QXJ1UEpVRDE5YTU2L3VwTGdDM2swZEd3UWZNaWJHN0F5T1FLNXp3OXEzZ08rMVZvN1ZJZnRLUDg4RXg1M0hqY0NPNXJ0ZFgvc25TOVR0TjF6REE1WnNJcFBROERBK3RaYWREekc1U3B1WFBGUjVsZlhvL1ZIUG8ycHhXVUQzVVFoRWpjcEorOXlvUEF5QjNyaUpyblJMelYvczAxOU9oUzRCU0h5c0JKTVlBVmlPbGUyZmFMaTlESkJjSklnUHpLT3FZN0hQcWE1YVpKRDlwT3lJU3d6QW9aRUozdGpyM3FFN1BVeW5SakpMM20wcmJyZTNvelp0N1BSTHFZUGNTTE8xckw4dk9kell3U3c2WXEzcTJpeFhNTWM2bUVwdDRYZXlBTG5rWVU4MWthZG8ycHhYY2wwMGx2REJJaFV4aGR1NXovRVdhc0M3amdqa2tzMzFXTU15Z3RFemhJejN5dmZtam90VFdYTDdPU25SV3JlOWxlMjI1a1NlRU5MdFdQOEFaT3IvQUdLNkViTThiS0pBVlBQT2E0MlhRTlYxSFU0SkwyOHR0alJLdHlnWGlWVjdnRHVUWG9PdFdGcGRXRU5wY3pScENxRGZMR3BWbFFqT0F3NmMrdkZjSG9TYUxwZDk1UnZGaGxnRzhPQzBna2pQVGZualAwcDNkdTU1OWFOTlRqSGtVWTgydXRrZHZaNlBiTHFWdGMySCtqVzBBOHQzWlFVUHJqUFN2UTVybHJ5MSt6d3Y1c1RIS3poUVFXOUFQU3VSbTBueEhQY1c5M1lhZ1ovbjNyRklnV0ZrWTg4TDFOZGRlMlVZdEh0SHRwUVNDNjdBWXh1N2hTT2xWdjFPK25DVVlUdEJ4VDE3SjM3V3ZZNHhYOFUyVWMwakcyOHlKZmtqRDRaMEo3OXNpdVhtdk5TbFMyYTY4dUI1SFZXWll0N2puUFh0OWE2aTd0NGJWZE5tL3NyekViY2pzMHVYUTllY25tc0xWVTFxV2FWckJKREdvTHBsUUkyUG9jOC9sVXByeVBPcVJxVytLYldudXB0NzYzMlIwU2VFTkx1THFHY3p1WmtjTUR0SEE5eDcxa2VKZFYwN1RyKzNXOFFORnVEbGl4Vnl3UFllbGREcEdwWHFhZTBONDlyRGRBY2NqRWlqMEhxSzRCN3VMVTlRanRwbVhVWGljdHZlSEN4QWpoUVR4VXAvZ2RGUjBvMFVvS3ptMDNwZlhzMHpkdk5UazFtOU0ybTZuQW9XSUNLRUVxNEE2Z2p1YXhyV3c4VTNWaktaYm04ODJXTWg0Wk1iQmpqa0RubW1wNGYwcUNkTHBKb1lwbzl4a1dLUlFxcjE2RG5JeDJxM2M2OWFwT2JneVMzY3NVSWNSSXhTUWoyN05UdWNxdTVOMUcwNVArZlIzOHZJMGZEZG05b3JXcnZhMjhpTUMwU3NjbjNiZGlyUGlPZlM5UWdramRDNGdZQnlvWlNDZjdwckQwYlVsMWlXVFVwZEJhQ1Y0ejluZTVjTnV6eDh5amtWWW10cmF5bWFlZTB1YmlWZ2dJU1lQR0Nlb0NEbjg2cTYzTjVKK3ljVWx5M2V1clZsc2M5SHFVV2x3RjdpNnZHVmx6RXk3ajdCVkE2a2U5ZExQZmpWSHRYL0FMS041QyszeTJrVEREMUpQYXRTMnROUit5cTdHT05GWU0wTU9HR08yTTkvV3VWMVhTZFdhMXZXdDNsamhMaDhTVEJTbzY4RHNLbTdaRWxValRzbEpxMTdKWDI5Ym5KYTVkNnBldlBIZmFTMzJHQno1SG1rcU54NDdkUUsxSU5Ya2kweG83ZUZJdkxqL2RNcHlrcTR5ZVQ2VnN0b1NhL1oyMGtHcVB2VUtzaW1Vbm9PZURYVUR3Ym9WdGJRV204SUhrTEtXWWtLUjEybnNUUTl6SDJPSms1VGpMUnJTVGExdnB1ZWE2RnFQaU1HMm1UVUxjV2s0YjVReC9kbGVvK2JvVFhyQmdtdkxIejViMmU2SHpGQ2pBS0Rqa2tEcUJVRm5vMWpLTlFzcnVVVFFnY1J1QkhnZGlDTVpyaDlMMDNUTkt2WGtnbVZQTGl4NVhuR1JBTTlTT3dxZjh6V0Y2Y0lxVGJqSldzM3MxK0JqM1drV2lYMXRkVzl3MGt5U3ArNWpsSElJNmZoNlZzWEdyK05SZTdKWWhDbS9JTWFlYWRvNkU5dUtxYXpxOTlaelFYRWZocU9kaWZrbXRlUTM1OUs5SzBYeERMcU1jbXkwaGptSVhNYlNZSTdIcFZQb1RTcDN2SDJqanpmRHkzVjBqa0RaWDEvZENaVGV0RXZ6TzR4RXJudUNLa1RVZFMwZTVXSHpaNVlwWTM4c01nZG96Mno2Z1YyWjFyVGxrZTNhK2lXYjdwaVNUblB0NjE1UnFkL2VXRjJrQzZQTGV6U1NEeTUxYi9sbjZuR2VhRTNxcmJHazF5OHJqVWZNOTVYMjh0RHFMWHhWSmVPZDFuY1R2Ym9TemVYdFZ3T2M0SEZGdm9PaXphc3Q5UGJwYitZZ0s0VGJzWnVjOGZ4Vm1hemZlSmJkb0ZNUzJGdVYyTTZuekhCeDZMM3Aranc2amNTZjZiYzNVb015dWtyTHQzanNNVlZ1cGtuSnlVSGVvN3I0bGI3NzZuYjJVSmtlYUNPV0dSWVZKRjA1MmxRUFVucWZwWGxWeHBQaXVDOERuVjVMeUZTellVQkVRbmtaUGZGZWg2L0JxRnFrZy90ZExlTmszSUpZUVF1ZXYxckg4TTZWcUZ4ZFQrZnFrbHhHVkJVbEFxZk4zeDNwWFIxemk3eHB4akpTMjNYL0JNalJMelc0eThyM3RuZFRCd3FCc0VqZDZrVkpkV0Z0STR1cmlDYU80TEViNDMzcUdIUFE5cTJMWFR2RHRycWs2VGFIdGxSbC9lcUNGem5oZ2MxMlRKS2sxMGJlejNENVNvTGc3elNkam5oUzVxZHBUdnExYXpkbXV1eHllbjJ6WGxvN3k2aGIrYmh0a3BYREtGN0VWSGVUdWZKTWVvcGhNNzVZeGpQcGc0L1NxMHMxd3N6TTFoYTJZSkltazNiK3ZmamdHdGUvbHRMYlNDbW5SUjNBNHo1YkFnc2U1b2ExRXBlNUpYMldyMXUva3pFdmRKMU9PS0w3SnJjVGdrU0NTUTRmQVBUUGNWc0h4ZnBXNVpJZFdpYTVRRUdNT01iaHdjMXhxMy9BSWdnMDd6RHBVYzRoVTVhVHVTZVF2dFNXOE9oM2NFeFMwaTArVjAzc1dqR040OUNPY1ZYTDNhK1JGT3F1UnVGNHVVZEZKdGFydGM3bWUyOFVYTnN0NVpYbUdkUDNzRXZJSlBkYTQyMzhTV0tTdmE2ak5MRGRqSS9kZ2hTUFd0VFFadFlLaTV1TGg1MlQ1VkVaMnBnZE9EaXQrNGkxS2E5ODFiQ0dSWkJqYWNGaG51RFVXTmI4M0xPTG5mYXpUa241MlBOTk9TenZiKzh0VnZwWkhkc2pZVGtMNkgzcld1QnBWdllKQnFTVE9VZklNbVNUNlkyL3dBcWIvYTkvb2VwRTMrZ3RiMnN3S3BPcWhteU9nWURvSzlOajFLS0t6a25FU1QvQUNiaHVBUHpEdDdVYStablNvUVVYYXlrOTd4NmI3R08xdm91czJNYXhXdU1NRkpEYmNqMzlEVWkyMGVtM1JlNXVaekRHcEVaTDdoakhJUHJXRm8zaVpwRXVwb3JSSW5KTytKbDJobXhuQU5aUGhiWC93QzA3cVZiclNwWW5rbGRveS96SmtkZG9QYkZHdXFTWjBSbFNseVNUWE03V2RySTdReTZGZkNOWTF0M0ROaEpHSGMvMXJmdDdpMDA4eVF2YnVzWVRDeUQ1bEo2VnlBZTZ1YnFiR2tDMFZUd1hLbEcraWpwbW92N0wxeDVvak1pMjBEdU1CWmQrZmJiNzBOQXBUdmZsVGxmUnFMMjh5YlVORTB1L2pFRjFCRWZteUhEWVB6ZlR2VnlEdy9wVnRDSTFpUkdpeVBNaVA4QUQ3MWMxYXdsa3NIRUJFVEhDSFBVNDZFZWhxRFNORWFLMVFHUmxJWERFa2tzM1VacWVtNWZJbFV0N0pQUzl6azlWMFRVblNKdEx2UFBXTGtySWQyYzlRRDJycGJTeWs4K1M4UkNKeEhzTVNFZ0hqbzJhNjNUL0VOaGFKZVdkdHBiTlBLMjJZaGVGd08xY3ZwbW9hdko0amtnazBlU0MwZUZqSk5ub1FPTWZXdDdhYUZRcFVPYUhLMDVTZG5aTzBXdk5sSzcxcTZGbzhZMFdSblArc0RZR01jNUdLb2FiYzJ1c1JTUFBhWEZvWEpSU3hJeTNzUlR0TnM0TGk5TTRtdmJRYldSbzVNbkxLZUc5cTZZV2xrbDZQdE1zdTlBdXc3dmtKOWNldEoyc1lSVldUdTV4YXZaWHRabkxMWnhpZUsxKzBsNU41WDVmbFlnYzgrcHJyck5OTU53Nm00WDdRaThLNEJmYUt1WHNWbzlzSkFnbEN2azRIempIWEJIZWkydDlQU3pGemJLakVBa0Z2dmV1MGs4MGxzYnhwdE8zdXZyOGpFdk5YdUJlc0hsM3hxQnRVTHRaUjlmU3JrbHRwc2l4eUtwSklMWlk1eVA2MXllb3RMY2laUEpURWlBN3kzYlBRNHE3ZFdxV05pR3Vab2xpRVdJSXhuSWIycFdNdWYrSTVheFd0MzArOFhTb3ZERm5lUGRHd1NLVnNJOG5RWVBGVDNYaGVPOTg4VHdvYlpwUXlzSC9Ldks5TXZZOVhTNXNyaVh6dm16dEh5TmdkQlhyK2x5TnArbkNLUjVwSWtBQ3JNT2crbzlLcTF1cEZMa21rcFJYS2xvMGt0Zk00blVkVTAzUm81b2JPQllncnFEMU9QV3R6UnZGVmxyRmxjVzhCODFsK1ZsWlNQcWVhM3JGdkRsOUhNOFBsYnQ1QlZoeUNQWFBhdUNmU2IzdzFDMTdhRkxnUElTeFFaWUE5dVBTblpOZVpGcXNFNTh5bEI3cUZySmVoNkRDa21sRTdiRkxpRHE0WDd5bjg2Zll6emFyOW9rZ3RFaWozRUE5U1Q3aXJtamFwWjZoQWp4aGtNcTVrREFxQTFMcDlwY0s4MEtNSW5SbWRtSFJpYWxwZk02WVUyL1o4c3IwOWRGYjhHYU1Oa2p4bVZyVXBJQVZMTWNidld1TU9teVduMmxwTFg1R09IWWNubm9SVzZibHBKSUxLZG1rOHd1VW1CNFYvUTF1MnNNOFFJa1VsaXUxQ1czWkErdE94MHlwUW55MlZtdXVtOXVwNDB2ZzVqWnpLTHNsR2JmR1dBYkE5czgxRHArcTZhMXpKRk5ESXJ4eGxQTUkyZ2xmcDlLNzIwZ3MvTnVrbXVJNDhIQzVmYmdtck1Pbld5eHlSUE5ITUpDV0RIREVmbFJyWTRWUlhNbkMwZTZldDdma1lzRTQxQ3llUTIyOE1NSzQ0SUgwcnliVS9EN0tibG80b0FrZ1BEam42ZzE3ZGJ5eFdEeWViQWtNYURha3BPRllEMk5JbXAyMTdkcVk3UVBDaUhFbkJVanVNK3RGN0xRbXBTaFVqQlNuNzIyMnA1Zm90NVlXbGtzZHZheHZPTUFaSkl6M0ZlbTMxdWwvWnF0eEFZSkdVQTdXNHlPM0ZSVzlwWXJOTElzYUlwQjh2YXZJNzlQV3NJdEcwTEJST1JJN0hQY0VlM3BVMzFJcHhjSVNqSnhrbXJjdGtscDErWll1aE9rTVFoc1JPSXhqZGtFZ0Q2MXpVRnhNYlJvN0w5eGNJNUR4Tnh3MWJkdmN5V2Q5Y1NrenFyS051VkpVWUdPZzcwU3cyNnZKZGVTWGFYQkRZdzJQVUNxdGJjeWxHVXBKcWRyWFRYWmQwMFpGMW9zRnJaeE01dUpMaVhod0czQWsveXFocE5uY1lrekcwT0J0YmNTY3FPaHJzcE5hMFMxbEN2Y0VPNkFKa0h2MnE5RnF1blNlWmJXaDIzUGw1UVNEQ3Q3QTBhMkpWQ2g3Vk5WSXF5dHlyZC84RXdiU3cwWVNYRUxOdjNwazd6a0ExalRhZHFiWHRzQmJSTmFveFYwVTV5dnI5YXhtMERVRExkeVBHcXpzUGwydUFwRlNhTHJjRnV5UXp4dGJ6ZzRKTGZLd0hwbXFzMXJ1WnhjRktLY1Bacld6MitXeDNpV2RuYU14bmcrUWN4aFR5bjBxR2VTOGt0Ym1PRFVIT3o1d080ejJ4VEgwRWF0SXMyWkk0MFZzWWY3NS9DdEpMSzcwVUIwdFBNUjEydDNJeDYrcHBIZTR5ZDN5Y3RPMjZ2ZlgwQzJhYlM3R0IybDh5Vm5CTy9nbFc3VmZMV2x4Y1RzYlJuTzBaVEh5aytwcm1yZWFiVWdiaVNQSUxGUkVlQ2dIZm4rbGQzcE53dGlqZWZJSDRZZ2tkaDZtazlHYVVwSnlpazdVK2pldnoxT0dHb3d1djJjMlNReXJ2SWl6dDNMMHlLckMzbVRTN21DRWZaV2tBTzVlZWU0ckwxSkxQWE5WamxTNGlpZUJqNWJxUUN3UGJuclhiV3RyQUFzQ3MwamtBY0RkZy9qUzBJWHZUbDd5YVh1cVdpdmYwT01zdk8wbUZqTmVOTEl5ZktHejArbGQ3WlNOY1dEdk41ZTRBQlRnY2YvQUs2dGF4WXd3TGJYTTBhK1dpWVlucUtXenRyY2ljMjkvRzhNcVpFWkhJUHJWU05xZE9VSnVLZWk2WDExNjZqb2tXd2dFeUFQSXdHN2J4WEdYVjdlVHl5cEpheUxzMmxUMk9lZTFkSStsYXA4Z2oyQ05PR2JxU0RUNUhSckYxaVpQTlUvT0NmVDZWSm5MbWxkV2NFdWx2aTBPZGZ4QkJDZ0RXOGhZRGpQUElyb0p0WnVocHorWkUwYjdTVnh6blBxYTRMV3JHWjBqbFM3alZWajVVbkFKRmFtaGF4ZlRhWExJMXFibmFOb1JlU2F0MnNySExUeEdJVmVVSlNhVFh1dExmdnNVZEk4WDNscmFoN25Nc2I1M01veVYrdkhXdGdlTDlEMU8xQ3hNd2tJS3J2UWpCNmNHdk1aZFAxMjRBYXpzamE1ZkVpT2VDRC9BSjVyMFNiVDc2ejB0VE5hd0s1ZFJ2VmNkZTlOclVtblV4TWFiVG5kSmJ0TjZHWkpwa2kyWmpoblVYQStZbC83cE5abW5TYW41VWlwWkpPVWJMTUc2MTIxM29pUTdwNU44eXlJQ3dVblBIcFZQVDlSdDdhSHk3V0ZvK2N0NW5BR2ZjK3RIUTVwVTNUcXhmTjdOSk5hYXRycG96c0xhOGlrMDZITnVJMlRKS0RrZ0hqRlZydVUzY3lsSThSOElSV2JtOVcxZVNXRkhjdGdsUDdwOUs1V3kxUzBTU2FHQzRsTWl5WjJPdVJ4L09rb3JVN1oxNU9NT2ZacFh2WlBRNjNVOU1lQyt0bmlXTUl3SmM0Nlo2R2xoMFl4MjdTRm81UnV5VkE1L0d1ZHZmR3B0dFVnZ2ZTbWNzbnpFYzRIclhRMkdzV2FYY3FvaUZIQUk1Nlo5cUxPMnByeTRaeXVubzM1Nk1MVVdDWFhueDQrWUJTdWVSdDlxa3ZZSTNrU09kRktuNWt4eU92ZjNybHRUbjBHM3VwSkxnVFJuY0dVb0RnbjhPS2l0dGNGckExMjBUVHdBNFRBNVVFOVRtaExxak5UcHhUaExsV3J2YlgxdWpyNXZDdW14U3BjeHcrVktXR0dHUnhqMHJBMUNLU2Rmczl5bUMyUWpwMUh2K1ZhdzhUVDM3ajdPTjBVWVVzTzQ3L25XWkw0b3NOMDRrQVdXQmdRRHllZmFzOWJtbFNXRmNXb3RKUFRiUmp0TG12TGFLV05uZVZWNFhlRGl0YjdVdHMzbi9abFZtWDhLMmJUVzlQdW92S2xLcDVnT2ZmTlZwUnA5M2ZOYXFqa0lnTEhQQkhUcjFxYjZsd2d2Wng1YWlrbG92STgzMWQ5Rm5SYmw3ZFNjL09RU2R2Yk5hK2wybWwybHlaWVoxeGNJQmdPTUExcU40VzhQK2E1UjVQS0NFU0lXT1AxcTNZNmI0YXRCYlJLU0FyRElOYU9TdFl4alNsejgwdlpxejBkL3dBVE4xVFVKcmFDSklVOCtSeVJqcGo2NHJpN21MVzdtN0VERXJBNlljQnNGRy9HdlpkU3NyVzczclp6S2hBREt5bkhJN1Zsd0dleXVaMm5ReVpqVTd6MHowcW9wRzA2VTVUdEp2azAxV3g1ZEI0Y1dPRlVFenRqbkpQVDIvOEFyMFY2UEpxbWp5d3JJWW1VNXh3cFA4cUtUNXJrcWpoVnZPSDNuRWFob21zM3Q3RGZ4V1VXWThIeVo4S3ZwbkErOFIxcnBiU1M3aURSeE8wTjJqTzI0TU5rbkdPaHpsZlQwcXBaYTdvd3NabnVadkxuYVVoYmNqNVZYb0ZVZFNLeDcyMDAzWFpiZEpMT1ZIdDEzRFk3RElVOG93NDVhbHJZNDRUcE5RY2FqYmw1Ni84QUFadko0cTF2VUw2U0Q3SE5ieEpBelBjU0o4aFljZjhBQXFnMFRUSmIrd3ZvZDlydmszQjlwS3NCMUJBUFQ2VnhsMXJVa0hucllhWnFDcGdSdWdETktvVWRQbXlCejBOYk9vMmx2UHAxdk5GS3NlM2EwalNOdGRXYy9OdUlQM2hTMjhpT2FjbmVWNThxZDliYzNUUzVjRmpOb3QyOTdaYVlXWjFDeWxPQzZqbk9PNVByV2hOcmNsNlkzYUM3TWNYRWJLd1ZTekRKV1FuMHJ6ZUhYZFZ0Tld1YloxdmhFa1J6UGhUOHVPQ0c1eUsyTkY4UzZmckZ1Tk9oKzNXaFNibWFhM0RJV2JuaGU1STZVSmxKMXBjeVVwUmlrbTA3V3ZwYjBPOGt1emMyTXhqdW80THhZeXBFaGFRUmp0dUM0NjlqVy9vVXRoTXRtTHFCWnBodzhzY2VGeTJCdUpQVUN2SlpyYlZkS2tsdHJ6VjRERzNLek5FZnVuZ0Evd0IzOGEyZ2RhYTlqaVMybHVMYUtNUEVzQnl1U2NjSGdkTzFLeUhDck9NMTd2TTR0S1dsOWJucWMrZ3JGZGFnYmE4eTBtMXZKZjV3VkI1eG5rQTlxd1k5TkVVTVNYaStSSThvL2ViczdpUmdFcWY0ZlVWeUduNnBwMDJvVHdYeTNGcElVTnZBa3BLTktCeUJ2SFRCNUZUd2VHTlNqdDVaTHJVRm1kMWRra2tPOTE0eW9VNTRQSEJvMi9BM255MlRoUnV2ZTB2b3J1L3lOYVN5c1ZqU0ZGaTFGR2tielROS0lSRzJNNVFOMjlxdFFlSGZEcngycjIxcmFvZ21CQ2tobTNwN29lbjFybjd5K20zcnBVbG9CY0cyODFwYmhQTVVqR09XWDFIV3VQdC9CWmh1QkpZRTJrNktzaUhZU2hBSnlvR1RqSjcwV0lWU0NqWlVyM3NyY3UyblcrcDZkcUd2Q2I3VEZiMjg5M0ZFNUhscEd1R1VkZW5UQjZHckduNnJLNzJDbTF1WUdrL2RJamt1eWpxUzNvUFRGY0JwbXBhczE5Tkg5anQ3ZHpIL0FLMGpseURrcmpwajByMHE2MWJURmloRHpDS1NTTUFzclpkWEhKRzFlbVBXaHBYc1JUcXVwcTZpVFQ2cTE5YjJNUFhiaVhTWVdsbWRycVJXVnhjS0NoWUhxcDdZRldMZTBzZGFpaHZQSWU2akF3Q3BJWWpxY0h1VnFUUzlldWRRa3ZZb0liZWRGVW84alhHL09PU1VUSEJIZXNneTZ0RlBNTk9hRlZFWkNzaWtTcy9ROEQ1ZnlvVmgyaHJKcHlnL3N0WDI5ZHpwTlIwNnhpampXQ1c2Z2R2M3FDUmlFY2ROc21mU3ZLcnJTTDJYU1Z2TE5iTkp5M3l5SXA4cmFUaGcrVGdPT29OZWd0ZHBxYzl3dDE5b3VoQkVFZG9tMmhHZmpnRVpCeitGY1dOUHM3T2VKUnFPcU5HOFpWMVczQlJ5ZjRkd1BQdnhUVEZQMlVuZFJoeTlFOU52VXEyUGlueE9pU1EvWVF3ajJnM01VQVliUWVjQSszZXV0c29ydFpHZS93Qk1uM0NkbWhtV1VjQThnN1I2VmEwTFFybTNWenAycVJ3V2x5VzJwSkh1QVBwbGprOUs5RWl0dzdxMDJwUk5OSEdVa0VEQWJGSHNjOG1qUkhSQ2xPYWk1U2s3Ykp0T1BycWJyNlRwT3EyUmE2YXpua3dDb2FJTmdEcGtNZVBldVd0OUF2VnQ3aTBqMVd4c2h1eVd0WUYrNzJBWWs0YXVhMHk2dWpjeXBIYXhSdHZ3NnlzR25lSVovaEpIMVBiRmREYVdkaFBZM01zMm5vV21tWUczd29YZ1lEQXAyUDhBT2g2SFpHckNvNHk1TmJTdTd0R3hwY3Q3RGRDMWhuVzVXTXNrbm12aHgvMXpIY2U5VDN2azJzRCtYNWp5aGk0QU9XMmpwdUhldU4wV0RTN1M2aWhTTTZmTkFwazJTSzBpYk04NGtidFhSbTIxRkwyNGVXNXQ1RWxHeUJ2TDJTTHVPUUF3UHpMejFxV2k2VTVPRnJkYkt6dlpmUFU1VFZHU08zeGNXVDNxRUNSNHZMSkRxZjRTR09NZzlLejlVME45VzBVZjJmWld0dWlLa290NW9GT3dyeWNoZWZ5cloxSzR2clNBdkl0dmNTVzRQbXBMS1dKNDVBNDQ0NlpxcWJLWk5NaHZ0TDA2MWd1dktYeThUY2gzUEFaVDF3S3BJeCtLY2x5eTVWcmEydC9VODYxR2JYTFdTMXQxWVNTTnRaREN2bDllb1pXSHAzcnNMaVcrbXU0Yk82MGFXQ1psR0xoMER4QUhrN3pubk5WZkVlaitNdGYwVWFmZlNSeEZpakxQQUNIVWQ4WUhXdFNId3N0bmEyc2NsM1B2U1BhbHhJN05JRDB5UWVEbXFhank3Nm1Ic3JSYmlwTzdYdXlYTFpMN3pMdWRVc3JhOHRyYTRQbXdDYytTZ2dBaGQreks0empGZHBjK0c5QTFDS0JydTFQbWJpUS9TVUVkZ1YrOEJXYlBxbW42RUVnbEV6Uk1VaWpjTXJEY1Y2N1FCdHlmV3FlbWFQSkJwOTQwV28zTW5tSzBxcStHM0ZXM2NGT2F6MXVieDZweFVuWjNYYjd5NkxDeGpQbVJ5Q0JITEtmTmJrcmo3dUR5T2FWdEdzVm10Ym1YVWJ1RXBFcUJVbVVJQWVBQ1J5TTlxNTIzZnc3NGhhZU5yYWFRNWpNNWljeGdPZU9DNXptc0tQUy9DdmgrYTd0WmJ1N3RtS0JsdUp4NXFNTWs3U2VoeFR2NWtMMmJnbW94YWIwN0hybXE2amRKQ2tGMjhjY1R0ajVwTnJPcThkL3ZWWXM1NytWcmlPM2dqbEVURlQ1ekdJQlNNanBuTmM3WWFqNFVrdExDVFZiMnd1cDF5YlF6UnVtMVc2WURjbjYxYXVMalJrdkl4S1lZVGwyY0t6YzhZR0ZIV2xZNnJ1eWw3UldkdXF1dlhkR1pkV045Y2k2dEprRmlGSUlLSGVraFk5Znk2MTArbVBwTWEyendUL3YxWHltTHY4ak1wNU9QWHRXayt0YWRwdHNKUmN4SWlJR21rNGpNakhnTHROZVRYbXVXbW9hZ2lXK2l5M2lobEpteUFxTU9wQjlQNTAydGpLVGhTNWJUaktUNlBmdXJXN0h0bDZzOGtOdzBGckd4VTdRSGZHMWp6d0Q5MEdzSFZMVFdMcU5YZXowMlRqYnNseTJkbk80RlIrbFoybnkzZHJwYm01czRKR2FWakVRVzJnRTRCZGprOCtsVlgxM3hOUEVWMHF6Z0loS3E4OGpncXZPR0toZVd6MHhTU09uMmtHdFhMM2w4S1YvMExlb0I0WnJhM2EyVW80aVp4RXJZWGQ5Zlg4NjVlQk5HdXI4UVBld1RYTmh2QUxia01hc2NnYlJ3eDdacjFCdGV2Yld4YVM2dUxXM09RQW81YkI3a2Rmd3JtMDhSUUZpODBRTUxBb1o5cURldU1oaTJCaGM4VVczTTV5b09lczlYOWxyWkdENGZ1dkV0bmNTZWRjUlNXc1RNUnVWa2tVbnBqc1Y1cnBScUdpWGtGMUdka1FJQmtEeWVZakozTHIycXBvbXBPK2t5UmZhbE01WUlVd0NZZ0R5cEl5R0dLNWkyMG03YWQ0cDNLUXk1VHpXUkRHRkhSY2Z3bkhlaTI1ajdTVUlVNHdUbXBYdW5yYnBiYzdMUmxzZklKdDVMTVJGTU41S25DYlNjYlNhdjJ0eHBTM1VLeGh3R1ppVUlibkhjWTdWVGVlenNKWWRQdEVralpvanNhTXJ0WEhJd01kNjVxTHhCcnRoZU9KbzVIdEVoU1FmS0JMbG13VkFVRU56Vks3TnVlRk5SdmIzWDd6U3VrMXF6MWlSTFJwWkowTzE5bTNHL3kvOEF2cXNYTTl4YkZVUVR4NUt6TUdPUU94R08rYW1uajFxZFd1Tk4reVRPV0c1WjEybFZKNUhHZm1IdldITnIxL2J6SkExakFnYVI5cnRjcWpiVDBiWngxb095YzQ3eTVrbTkxRzk3K2x4K2xhTnFOdmFsb1lycUViQ3Fid3ZPVDMvK3ZYTTMrdStLdE4rME1kQmE2Q1NCVE1yTGhWSCt5eEhUdGl1dDBDL3ViMFhqV2VvK2RIQTVWbFp0eUYrNm8vVGowcnJaN201QSthM2prVmRwSUJ3RjlkeFBwVDAzSWhTaW9RNWVhT2o4MTI2SEtRNjVCcnRoRVk1emF5MjdBU09RVGxzL2RJSHAzclVqc3RTczdxNHVXMUtlWkdBeW9oRDhkK1IwWDBGWnNsMVBCYU5HMWdMMW1uQkN3WTNMRzdaMmdkOGQ2NWFYeGZMSDRwT214V01sdXJ4QjJkNUFESXZRS2llMzZVblpta25CMmxPVDVrMXRkZmd0RDBOVWE1dTRYdDcxQUZVa3FZOHRrZlU4SG5tckY3ZUs4Q256QVYrYnpTSlFwQkhVRGpyV0xIcWx1bHJkU1c5NWFxNjVXVlRnc2hHVGdrMXRlRDd2UTllMUt3dHIyU045aGptbmpJMm93QndvVmlRRHViQTYxVk9FcHpqRks3YnNiVU9TcFVoU1ZSSjFIMzBaOW0vRFR3WW1sUUMrbUFhN3VsQkc0RW1LRWdFSUNlaFBVMTlRUWtqdFhrT2plSjlDbXQ3cVNKWkVXQk4waEtkUm5hTWNuSko2Q3UyLzRTRFNrdG9KcEp0aVQ3aEdXVWpKWHJ3TTR4WHRZZk1Ncm5oNFNvNHVqS255T1NrcHBweFQ1WEsvYStoL1FGTEtzVGhZUm9yRFZJdUxVYmNydnpOWCsrMnAxNzNDeHBra2NBa2tuQUFIZXJ0dlA1aWhncElQcDN4WEtRMyttWFgrcnU0bmJHTUJ4MCtocm9JOXl4Z0J1TzJSL2hYb3huVHFSNW9TVWwzVHVnbENVSGFVV24yYXNYUzRhYVBHZmxCSkdNZHhYOHBueHgvdEx3LzhTdkVsdGZFdEpCcVZ3V1UvSzdMTzVsamtHZnZLd1BXdjZxSTNjeXlaVUVBS09EK1BmNjE4Yi9IcjluZncvd0RFNjBodVV1anBtdDJxYmJlK0VlOVhRSElpblgrSk05RDFGZGxHczZmTloydjFNM0ZOV1orRHZ3MytJSGc5YnlIKzFHRU94aGxuNkVldWErdHZCM3hmOE5hdiswYjRGajBPM2tpczdlNmEyRW5tZjY3N1FwUWpwMDVQSGV2blR4Qit4bjhkTEM4bmppOE9RNmlyUDhsM1pYY2ZsWTc1allxUVByakZmb3QrekYreWRyL2hEeEVuaVh4SEhCYlN3cXYyVFRVbFc1Y1NnZjYyU1VBQVlKeUVYdjE2VjBUeGRXVWJTYXQxZmNVSWNyWGI1SDYxWG1rdzNLa2lSNHBVUHl5SWNISTcxK1h2eFQrRXVqYUZyZHhxazJtUVRXOS9MbHBFQWpaWlg2cm5qQUk1QXI5T2pxc0N5c2lXODhpUmpEeXhydVVFZGMrdGNwNHgwRFR2RlhoUzlzSlVqdUk3aUVQRWM4RjErYU5nUjB3Ulh5dFRMcURxdXJHTGpOclhsYlNsNnJadnozT1BOcUVzWmwwNkUxR1ZsZUhNaytWK1Q3UHNmaWJONFE4TTZkUFBkUklza1lUekREQjgwcWtkQnVIT1JYYWZhNGJxMldTNVJyZFRBclIvS0ROQmorTGNjbk9ldGREYjZlbGhheHh3Vzl0YnVXY3lRaGdDSkJuSUpQUEpydzcvQUlTdWVmVllMSXgzRW9XTnc1V01mdVc3cms4YmZyWGtYWi9QTlNNS01yV1NjdDRycTE1bnBEM2VqUTZpMGsrc2srWXBkbmtDaFFGSEI0eG4zckZ2cmkzMWI3SzF0cXUxQjgyK01BSEhUaGdlOWNUWXc2Tk5wOHJ5elhWMUk2a0R6TGNDU0VaT09NWUsvd0E2NWFIVFlJcmUydTR2RGx3N0dUWVkxK1JBQm5KS3FlQjlhblJuSDdhVFRpNFJ0SzcwYi9GcTU3cnAvaHU4a1M2aXZOYnU3K0I4Z1JLUXFZSFVGczlheE5iOEplSHRWc29ZbTA2VUVmSUczZnZrR2VOckFtcEd2TlNkZnM5enB0eGIyQzRacG9PVGpzckFaeVBwelRkSW44VFdsMUkybnppN3RXanpHa3JlVkpDdzQ0Vmh5UHJRbGRIZENkSnRKUWE4L3RMMFQxc1oybjZScE9nUVNDZGRRUkRKdGFhZFRPWkVYamI4bWNEMHpYYnlMb09wMndrdEREY3A1WkcxaHNiSG9RQjByekRROWIrSWsxM3FVZXF6RzJTWnpGRVlvUVFEMTNrK2dINjF0MldtVDIyanZCYzZoTzl5V3pGY0ZmS1pGQi9oMi9lSHNldEs5dEJPY0lxU1VWS1BXNjE3bXF5U3kzbHA5aXY1Yk9XSjJDcEd4TU1tQmdqbXZMOVk4VytON040STd1Yjl4Sk5JcHR3Q0ptalhxeWtaeDdWejAzZ0xWcmk0ZTZzL0V3dVJMR3pOQ2NJeEpPZUJucURYWjI5bGVhWlk2WExjMzF4NVlsSU16eEFzbm1IQlFubkFOVDFXcHdTbEpLNmwwMWNXN2EvY2pidXIzd3piV0VRbHU3d3JNcTduREZwSXllUmtmenJ6OWRhbWcwK2U0MHFLNTFNUXlTTDVFa244SFVISFVDdlo3clJwclcraXVFOGk3UlF3bGthUVoydDkzYUIzQXJsNVBzdW1hNGtVdGxacmIzWSsrWlR1NDVIQXhnbXFZT0RqTk9TakZSa2xzOVUvK0NjRStzK0g5VFF6M0dtWGNXb1FRaVR5UTVLcWU0QlgwcmY4SDY1YVg5Z2tUVFhObElwWXFzMjArY0NTYyt2RmQ5ZjNsblpUUkxGcDBOeEhNUUhFTWdVeCtyT0R5UldPbmgzUzdhNm1rc1piUklybk9XbURHVGUzVlVKNkQwRlNyZVpwS0VVM0tMaTViTkpXL3dBalNzdEp0cFpYbHVsc2x1V0x0RUlnQXhYM3pnRS9Tc2JWZkM2WE50Y1NpZVN4dW8wRC9LU1kzWHNUMXdmWDByV2cwTVBQYm0vdFlEYjJ3WUt3TGIwM2VvN1Z1V1ZqcEZtYmtySXlvN0FobzVtYktqcU1FbnAzcStvNmROdUtVcWNVdGRXOWI5N1cvRTRUUUxMVDlPYVo3aTllN3NwbzhCbEIyeEVqNWlTdlFWZXY5ZDBQUnByZU9Dd2hsamtieXdFa3k1NHlIOVNQV3NqVTlWMXEzMVcxZzBtSzN2clZsM2xWZFUyalBRanZYV3hRYXBQZHdYRTJsSmJ1aGRZM1FCeXFuc3dJcVdaUVhMRktGbFo2TlJ2Ym85ZGRDcnBHdjJWOFpMTllJN2Fiek1SaFViaFR6ODN2MnJibjFKUHRxV1JqdFdra1VxVlpzRWtjWXdmWHNheWJQVzdUN1pJaDFHTloxVXE2K1VWY2sveXhYU0I0WlovUGh0Uk0wTWUwZVc2aDJrSXljWjcrMVByc2ROTnpjVXZhcHRQdDA3V1Z6eCtTSjlEdUdlQzFudWk4aHkyNEw1QTdBQTlSbnZYYmFrYnlXQ2E1TnE4Y1RSQmxqTTRSWGZBNkhHUWM5NnM2NURycm0zTUpSdHJCNTR5Z0VwREQ3dk5YVEdsOWJXeG0wODcwNTJidHk4ZmoxeDJxNzNzekJVNHFVb0pOTGRLMWsvek9Ec05WZTNrTnZxT213d3lTb29qWVhIblBoKy9QNjEzT252WmFicFU3M2x2YXpSeHVjeVJSa002K3JIdmcxZytKZEIwenlVbWwwMjVsRWpnTEt1QVlmL3JWaFFhSHEwRFc2YVJxVTg0QWNORktvVkJrZGNuZy93QmFXdGc1YXRPcDhDZGs3SkxWWDh1cHA2aDhRUERaZ2xpaWhVd1J0aGdyNTdkY2ZwWElhTjRpOE1TNjFFMXZwMTNCSXNXMUhSY3dFbm5rK3YxcnAwOE82M2JSeHBCWTJrVnhNcER2NVFZY25sai9BSVYzbGxMUEhidmJQYlc1bGlVbktBUm1WaDZyMCtsU2tyZjhFMHBTcVNsZW9tbW43dnViZVNNZE5Xc29yaUozMHV6RXpTc0duWlFwY0grSUgzNzF5SDlvTmVhb2x6RTJwV0VKWXF5cVEwUmZQQnp6aFRXMWVXVGFocGJtSmJhU0tiOTk1VXdPK04xR0d4ZzFGNFl2Sm1zSVlwTlBkaUYzRmdwdzZub2ZUSHBRdTVoN1NvNmtWZjNXbkpPMytSMFdtYTdlK2RLa3p3M1JSd0NzU2dQRno4ckVkNjB2RTBsbDVVVFhUdEVaRnhJcFk0YjArNzBOZWZhbHBqVDNNNXR5MXA1cVlaMEdKQXk5Q1dCNUJyMVRSTk9zNXRIa2dsWnM1d1JPdTdsZStldk5TNWU4cmRlcDZOT0ZTcFJxcHpqcFpSakxXL1cvb1k4RjFCc2hhQ015aFFBUktmTUNxZTRKOUt3NS9GbWkzM2lGZEtEeVcxMmpEQVZOcXZub1BvYW8zSGhIUzlMdUkzaCsyeWIyek5IRytRY2ZOa1o2RDZWc3BKb3p6eHZLSXpMTWVKSnlGWURzQWVEeFRkdEdacWM0cFFkbHRmWFJrWjFIVUcxR1hUNW9FODZNYmlTZDJNSHVmZnRXN3FNeldObHVqaFpaQ0NRTjN5anVjVmgrS29MNktLUFpmS3BjQlpYSStZcTNUWVIxNHJ6WFF0Y2hzOVFpdDc3V1paSWxVaE42Rmh0Ym9PZWhIclRhV2pSak9xNFZIQnQzYnNwTzJpUFQ5RjFHUFVOQ2tTZTBqREY4TUZCYnFlK2E0T3d0aG9lcTdMbXdaNEhsWXBMR2dLOGROd1hwaXZUV3N6TE5iR2RGUzMrODBrRWdYSUhUT1BYdUs1KzZoTW1yQzUwdlRibElmdXpPa2dBY3FjZmRiK2RWZTZlb1ZJU1VhYnRlVUxKYWF2dTdXMk51VFdMTFVsVDdISE1nM0VCSkVLcEw2RUR0V2drZWx3VEk5eThFY3lLVjhzRlFHR2ZlcTl5dG8xak10eGNOYnlJUVlrOHdLNm5yejI1cnhmV3ZBTmhkM2NXbzNOeGR0S3hKWlRJTnFLbzl1dFNsZEhXcWpWM0pLV2wyMHRyZVhROWV2WnRKMVRVWklsdHR2bHJ3NE8wWmJzUFd1ZHZMTzFlRldnKzFyTkJMNVV5d25jZGg1enoxQXJJOE53NlNkT1h5WnJ1NGNTNzA4dzdTQ3ZCSUhwV2hkK0pOS3NZNXhlNmo1cW5jQy9sN0dUSjZBanJpbnFjRStTU1hNbzNuMVZ2NnVkWk9sMkxlVld2dHlzQ0dWZ0dPekgrMVhKM3k2eHBWa0Z0YktLNXRNS1dLakQvUDNPYTVQVXBOTHY0b1piVFZvWnJXZVJBRkRFU1pQOE83MHFoTHBPcjZTa0Z6YlgxemVpWWxXdHhKOXdEb2NIcUtTNmFrVkp0em5lTHZGYnFWejBHeXNyR2EyZTN1ZE9RWEJiSUN0d01qcVRYUU5IZVE2WmJtR3dqODFKQWh6Smc3UU9vUGF2UEVqMVpra3VMdktJbTExakdjcnoxT092MHJwWmJxVmhMRFpQYlhCa0NrcVo4TXdJNU9QV3FhWlZHVU9WWGp5dHEyeTVtdlMza1orckZMaVpFOHVlQzhaUU1TQWxGLzJnUndhdjIyajZsWTZYTmNUYWc5M01tTmlzU0J6NkdzaUcydGxjMjk1SFBDR2tBVjJtT0ZMZERrOXE2MTdXN2hzREhCbDRrak9SSTJmcVJqclJwWkJDR3RTZHRsMDBhZm1pcXQxWUhUcFlZNXY5SWt4dUc0bkRIbkdlMzFya2JyeEJyK2pxZ0ZtV2ltVUtoZDl4TGRNNTlLNmp3M3FIaDU0Smt0Y1J5Rm04eVNSZnZPbzZEUGFzTmJqVll3alNSSmRXNWszQll6a0FaNmpQU21rcm1jM05RakpTczdmWTFTOVRXMGp4QnFYMkpaSkJHcS9OenRMTnZKeGc0N1YyRjVya2VWUXpNa29RTjhveUN2b2ZmMHJGMVRWTkNNbG9qcExhRzRCVGVCeGpIT2NkNlZadEswNHRiaTU4N2FoWkhkZ2R3Nm5yelJwMk9pbktyQk9DclJsRkpLNzMrNDFOQXY1NEYzUElyU3psaVVsd0dVSGdIQXAycTY5QmJ3TEZkV1V5bmMyQ1k5M0E2SEk3VnprRnpCZTI4ejJNa1VzK01ZTFpDZWcrbjFxbmRYWGlOcGsrMkNQWkdkclJ4WllNcEg2VlYxcm9QMmtvVVl4amQvM3JYV3U5eS9CTzhNYzBpVFNmT202RWxmbEovdW1yOHB0eG83UjNrZ1ZweDkwZFFhZmFhanBIMlNXR3hna2pkTnBaV0JQSjRKNTlLelBFSVNVcmJ3UnNMdElnMjd5OGdnbkJQMXBKWHNTM0ZVSlNVb3lmTGEyNjE2RDlOMG1PUzJhd2piS0FobWs2TUFmUTFWdjlSaFMzK3d4bzVtamJhcnpESUlIWG4xcTFwdzFtSzQ4dGZuaFdKU0pKdUhMZDF4L0xOYzFyQ1hONm9sRndNd2xtWVJrS3h4MklQZWpycXpCODBhWHV4Y1pKTmFyN0s3SFcydW1hZmRlVkphcEhGSXF0NXBHQVdKNzF1YWRDYmJUYmlXOHVBNFp1ZDQ2Q3ZHdEc4VXlUN2t0TEdiemkreHBKU3FxTWRNbjNycXJyVnRRMCsyZTQxYUZHdGl5aDRveHZkTjNBSTlhTlhlNTB3cndUVDVHNWQwdmQxMDFOQ1RSWGhhUVdkN0U4Vnp5T0F4SGZqNjFxUlIzdHZhb2lvY3FjbFFRY24vQUJOWXQ3cFdtWDFyQUxXK2VJRmQ4UkM0YUxIcVBmTk90ZkQrdHlzRmttV1F4bmVzcWpESEhjNDcwTjM2L2dUR0VrN3hwdDNXbkxLNjFOVVIzMTZXSGwvWjR5SENvMzNndzdqSGFxR21UTm9zOGNGNWRrbC9tVndDYyt4elhhcEJwYjNFTU54S0k1V0IyeUZzZk1CMHA3eS92d2sxcWJueTFZOEFISS9HcHZyNU02dlkyNVpLWHZKNlBmMXVrWjgvMmU2eTBGMHJSNTh3ZXFrOTZXRzF1NTVvUkpPUDlIVWdET0MyYTR2VkxpRzh1TGVlS3pFTWtEb3V3dHQ3OUNCVkN4MTYrdWRZdTdXZlNXUkJJQ0pBY1l4L0VQVVZwMDBaSHRZTjY2NnBLemVvdXY4QWgxTG05aURhZGNUaFpBemJYMnFRYTZYVGRJOExyY3JIWnRJSndOa2tmbWJqR1NPK2E2aTMxcTB0cm9KTmVCbGt4NVlJNXJoOWFYU0xUV0V1YmVCL01tZkJlUDVTeHgyOWFtNy9BQU01eG94Ym5lTXJTVjFLM3UrbGpGMXJRbmlDUlhEVFhsczBtMW5NbURFYTRpVHd0clZxVmowL3hISEhFVHZXTW5EYy93QVB2WHBla3BCcmEzY005dzl2dEl6RkkyQzRIZm5wWFJMNGZ0N1NBRVJyUE5uOTFnWktqMXFrKzYxTVlVNU44MU9DNVgxYnZZcDZkWmF6Y1djWm1samVXSUZTVUdDYzk2enA1dGV0N2phSTB4NWUwTzQrNlIwT0s5UjBtWmJlMExYRUFpa1orU3d4a211WUl0Yi9BRkNVL3ZsSmJCSTRYZzlqVWFYT3VwU3RDbmFjbEtUNzZ2N3puTE81MWU1VllvOXNzaEdXSkd6SDRWemFhdWd4Y1MzRENhRm1TYU1wd296Z0VZN1ZyeW1EVE5SbU56ZXY4ckRiOHB6dFBiaXRXQ0xUTGlkMHRKU1pwUnVsUXAxQit0WG9jZnZ5U2lxbHBKdE9MZC9SMnZ1UVcxbnA5emRDOFJWbGpZYnZtWGpQVEkrdFptdExyMG1vd0d5dDdjdzhBaGdBeTQ2NG9BUnRRUmZQYUtVallrWTRCeDNJcnJMbDRaWXBJSWRUZ0xJd0xxekJYUTQ1QnFkamFDNW96VWx5NjlHbGRuRVRhTmZYRjJxckhKQ0dQenN4Skg0VnluaWJTNzYwbE4wTE9POVE0VXhLY01vOVFSWHNtbkpkQzRkbnVOOGJKdDNCdHdPTy93QmFxM0Y1WU5ZeUxGT3IrVXhKMmZlR2VNSHZWY3pKbFFwT0x1dGIzcy9MeU9IOE94em1HUEtYTm5DMk5xc3hiZys5ZFgvYUpqMUUyMzlwSXNLNExHVHEzMHJQbHZQdE9ubWF6bGtZNVVsQ3VUaFQ3MXpVWXROVHZyZWFPMVpnRlBtcEx3QStjYzBMVnN3aE53aEdNZGJ5Vm5mUnA5cmREc3JqK3l0UWlrYTF2UXJjaFhYZ0ZsN2NWeDRFMXlodEd0Wm1LNVJwUWNEa2Z5cDhjMnVXelMyNitIRk1DU0Z2TlJoeHoxRmRuRGJCd0dTOGFNU3I4M3FqRHFhVjBYS0RtMDluYjNrbGEvM25ray9nWmRQbnRwV2VRcThvQjJuR1BldmRqWlRlWEJOYTNMTHRZSzIwWkxBZGMxemY5dGhvUUJkd3o4NEJKenVJT08xVzIxZlVJUEtNVmxPdThsV1hxQWM0elMxRlRlSGhLZXNtclJ2YTdhK2FPUThaemVLRUF0a3Q0NUVrUHlrbitkVjdPd25oMDhyZXhORks0WElpUEs0NUZkcnI2UzNsbjV6dThjOFJEWUk0NE5LMm5YTFhxWEVFaXlSU3hEek1uR0dBeHdmU25mVGN1Vk5TclNkbTNaV3YyZW40SEQybmlHNzB5L2thYTRsa3RXWEt4c01zZTFiMDFyYVhkcjlxdHAyalp3WElCNisxVWJ1SzlpdW5YemttVjhiZHdHVUI3QTF2aWE1dGJlSXBwaHVQbSs4dnk0RlEycnJ1Y3E1N3poTy9MRys2YmFmbGE1NXRMY05jdjVjMW81UkJ5dU1mclhlNkc4R25SU0xieFN4S3YzbEk2N3FrWHhNcjNUUjNOZ0xaVVpXamRoZ3Q3VjErbWF2cHR3OTByTWg0eXVEMXpWUDBOY1BUaXFuTXE2Y3I3dU5takhsdWRVSlNONVlGaGtQeUZqaHlmZXV2YlIza3RObDFjaDl5OGM1L25YbVd0YWMrcW9peVdzcWlHVE1VaW5HYXQ2UHB0M2hSSmVUTXFPQ3F2eDlSelQ2YjJPeU5UOTQwNmNweGF0ZHUzNEQ3MWRTTENDSmdqRWZ1NUF4N2RjMXlsL3A5NUxaM2NUWFRBREc1OGRUOWE5SnZiN1VMVzl0UjluaWxpZkttUUhKWFBIVDByZml1TEZCTkc1RGJobFJqUFQzOWFHM29aT2pTbktTY24yMXVsdCtKNEpwVnpOWTZXc2NMeVM3d3l0SWM0QkZiMGxqcUgydExpMENNeFFaQjVERTExNzZFOE9IaXVsRWJNV0VlT09lYXBhbjRidXJhUzNtanYzTWNyZ2lNSHA5TTBQYzV2cTFSVTNkU2FqYlpwVzgwY0hxTnRyMTFjaTdndFVSb1VFYnFPK2V2SHBXdkY0VlczaGptZFRIS1NDY01jYzg5YTdLMGhXSzNuRWdmYVc1WUhrVnY2ZGMyVjVieW84MjllTURwd09PS0UzYXgwVThOU2svZWJjcEs2VDJ1ZVlhem9WOU5NdHhaM3ErUnR4SkU0eno2ak5iRnBvOGhzbzRra0J3cDh3WXdDU08zcFZvVzgxdGNHYTMvQUhvY2xTTTUyNDZWZWgxS2Z5Q0ZNY1VyL2VVRWRRYXBXc1dxZEgya200eVRhYXNydGZJODJ0cnU3MHlPOXQyaEVUYnZsa1BRbjN6NjF6dHpvODArcFJtNmlTTjVWQkxJT0R4M3IxV0RWV3VKSGp1dFBJSUkyeU5qR2Z5cjBSNHRIRzBNeUZ0djNqMnoyb2RrOWtjdExDeG5UYVZWdUsyVFZ1dlZIaWx0NGNPVEdia3lJbU5yTHhnRSszZW02aHFkb21zd1dVVjA2UEd2L2ZYdG12VUxHQkJkTWlLY0hJTGc1SEI2VXV1K0h0SWdrZ3ZZNFZrblFaYjFiNjFudWJyQ1dwU2NJcFdhNXRYcWtlUmF4L3drODZtUzFJU0pUKzhYMUhjODF4bHhaK0pYZFpWaExrOEtWUEF6WHMwTTEyMTZraklxMnJyaGtQTFZxeTNPbnd4TVlvNUN3SklUMytuZXE2ZERtZEJUMWRTU3MzbzlMK2FPSDB2VGRSc21oWEJ5M0VuT1J6MXJXMVRXbnRTaXk3NWhrS1ZBOVQwcXpkYTVjd3pLWUxRbmVWM2dudC9qVVUrbkxMYjdvSmlaOTRkd3g2QTlxVmxjMWtwK3phcHlkNDcrbmwzTTJmeEZwRms3SkxhTUNjRUtWOVJudlJXWnJWbll5eklicTdDc0J3UnhuUDFvclJKV1c1enp4R0pqSnBPbmJ6c2lwNGQwTFR3OGs2Mzg3eW9wRXlKQ1NRZjdxTWNGaVBhcjBYam5TcnlWTGJUTFM0dWJtSjJkc2s4TUIweWZUMHFscUVXcVBKR3VuWGJNVEp1ZVBkdVE0SDN3d3dRRDJxK3NGNWJ6dGVYZW5UUUxBV01rOEpDcW0zNWppTURjd1ByV0R2Y1ZPYVVYR01XbnMzYlQxMXVaMHR0QmNhaW1wWE41Y0xDa2dXN2hhZnl4Q0dHMWd3SE9jMVNtUXJDVzA2NnRUQTdTS1piZ0IyOHhmdTVkZVB6cm8xbTBiVUpybTZ2Wm8xc2J0UjVFVER5eVN2M2pJVDFiSFR0V0pkMkVDMnh0Tk90eDltRXdaSTVvMkNCMkdRY3B5ZjVVSzVVa2xaM1RkM2IrdXhwWDY2blBwMEVjMXNCZEZRMFd4eDVjcUx5d1U1NUhmRlE2ZG9ndlJOSE5mWFJsU1pXZFkxS0NNbGVtZStQWHBYVDJoOFFEUzd6eWRPUG4yNkVXOGM5d3F4OFlUQ0RHY2R4bXZQZEVIeE5nTXFqU2JLV1F2NWMxMjh1SEJ4bG1RaitBZFBlcVcyeHRIRFJtNDFHcnUyMG5aMlhiWTdQU3ZETmhhTFBPbC81MzJqSmtnbGRwRVplbVFPYWZxZXR5Mk52TENacFlITVJOdkdtQWlOd3BPNys3MngycVpMTzR1bHRKNG1nZ2tra1VLV2N4TXBCR1V5T0R2OTZmcVUrcDJVY3lYY01McE14ODBNTjZydEh5NUI1STdaNzBrdGRqbGNtNmJhNW9xM3hLN3ZvWTl4SjRwZTFodWJTNmg4OW9BTXNoa3hLZXhkaGprYzVyeW1lMThaVzJ0UXlib3IrUWhXbGlnWVl5Ui9IanBqMUZmUTkzOW9UVGZPekFzMXZDR2ppRzBKdHh6d1B1Z2UvTmNiYTZobzlzSTVyZFZ0citadkxrVlZNb2ozNCs2VjdlbEJxM3lPQ2JUdnI3MzZlWXFOcTJrNlBKZFhhM0JkUW93cmlSVkx2OTBENmV0YW1wK0xkYnQ3TzQxRzNranQ0dkxJaXRqSHZsV1JPUm5IVUgwckh1dGJzN2k5WXozV29GVUFETEdRdm1uK0lGU1Bhc21XTHd6YytVMGVwdGNMQnVKdG1CU1ZVWStxbmxpZU9lS2JYVm5QR3I3TnZrbjdxMzk1WFR1YUhoL3dBVTZyclVGcTExYWxIU1ErWVpZMmlVdXZKNUE2SE5hVjVvbDFjYWsrbzZZbGphWEtrYmxkbWRaVlU5c2phQ2FyMzNoM1hXdG5sMFdhWWtJQUdtdkVlTFl3Nkt2VU1PaE5kVlpOZFFXbHRGZXlPKzNhcktqWkNZKzl1SlB6Q2tyWDBPeDgvTzI3OHJsZGVWdk5uUFErSHIxYmVhV1MxL3MrWldWczJiQUNWVC9EZ1pJSHFhc1dYaWJUTFdFeHM3MnpndmplUG15cHhoY2prRFBXdTJlNnVyWm04a200allGcEZseEdZd296bkF6a0hwZ1ZrUlFXV295dzNyMnR5SVVBS2hoKzhMTU51MUIyakhjOTZvVlNObjdrbnpXYTE5ZDdvdjJGNWZ3Uy9ZcHJ1RXF5cXkzTE1xUGhqbjUxYitZcWxmMmlHYThhQ3lqa09DZ2FLVWgvVVlPZG9PS3U2N2EyVTBRbHZyYTBtamhKRzdBM1FJQndUeWNuanZXZGJRV3QxcDhVSnZ5OXBLKzVteW13QWZ3QmxxZXByS0xTNUwzdHRmZGR0Ny9lYXQyNEZoWjI4OWxkQUttVW1oeEkwZWV3eC9FS3hQQnJOTFBjeFRXYlF0NTdoMmVWUkxMdFBWbFlkR3lPbGRKL1oybldjZHp0dXB4QkdybENybGlyTHdwQU9EajByejJhWk5SUzNXYWE2dVpZNVR0amxWYmM1R0c0UEpMK3dxK2pGTnloS0U1UlRmUkxYYlQrdEQwVyswRFRmN1ZsZHhjbVhkbmVTVHRPQjBQK0ZZMnEzUTArVzJzMjFCWUd1T0YyV3JMdHo2Zm5YQUkydjN4TU56cjE5dWllVmtpV0ZWWW9PaTcvNHNaNjlSV2pJMnZ4U3lUVE5kc1lvMENlYmJoNDFIWnVPbWU1NjFLdUtkV2trM1RwMlRkMjFkZXQ5anJOQWZiSGM2ZDl0dXBkamZKUE1RU1EzWURCeXYxclp2N2FhQjFrdGc4OHNZSWVJU2dFQWZ4S25UUHI3VjVtZkhkck5ERGJmMkE2M011R1pFSmdLNDRKZCt3OXZTdGNMdnZiZVZHZ21ra1VnczEwQzBiWXp0RzBZSVBmTkNMbFV1b3h2ZDkxZFdWK2w3bmRSU3k2aGZUQVd3S2tONXNFNktTNUF4aEhCL1dxQ2FmbzJtVFNDYUs0czVKQVhTWkM3OEFmY09OdzRyRTFHNTFKNGxsMCsydHBaMGt6SjVQekJWMkFMdlBHWDNkRkhGRnJQYzZ6UGZhYmVXRjVhc3Nhc0doUm95UVI4M0pPTWs5S25VdjJrWlBsUzVwYzEwMnJwMy9KbmNXZDlyRnRwcXh3dXQra1pEK2FNaDFWdVFaRjVKOXNWeTE1NGoxU1RTekdMZVNLQnlZcmVXSkNyUnlBNStaRy9oSHJXam9maHROQW11SlkvN1Z1SGsyNVdkMXlnQVAzTUhuTlZMMENkN2YrenJ1MmdrbVFTZnZrVnNEK05YVWQvVDNvdTdhbTAzVWlvSjFHdExXOG4ydWIyanlhUnF2MmhvYmtYRHhFUjNjQUkrOG5mbmdmMXEvZWFmbzJsd3dHU1g3RUJNd2huaytaVko2QS83UHRYRXo2YkJhVHhyYjZuYlcxd1FKUExFUUVNN1ovdWc4NXg2NXFyWTNkdlBGRmJpRWlJN0drY1NsMURQd1FBMld3VDJwN29ybmdtb3VuSG1iMGQ3K2ZUWXk0Ym54QzhDWEgyclQ1SVppNFJZSURpUUE5dU8yT3RlbDJ0bFpOYnd1bDlEaHZ2Qm1WK293TnU3aml1ZWdudTRwSnJkdFZ0TDhMSVhqaEQrVThhcjEybnFNZW5lc3JWN253N0pheXZOYXZPcmJIV1h5eTZibU9EODZjNUh1S0xMc2M4VkdONU51V20wbnQ2TlhHNnJZTEpxOXM5eGJOY1JiTUNjQmZsS2ZkYkhvZlN0dTFoczVySjR6SmJ0dVYwYWRkMFcxbTVEQXRudCtkY1I0aWp0TG5UVDU4elc2eE5HMExobWk2SGhsSkhKQTZWcGVIOVpHb0UyUWdtdTRJeEU2eXRJa3FobDdrTGc0K3RIWWluT0txVFMrMWZmWGZvZGZxVDMxemJ3R1M0dGJ3eFNSSUFzYU9EeGc1ZHM4ZDZ6STlac2RRRFdzOHNDdkMvTDI2cnRqQ25vK094N0gxclAxdXh0b05idGhhM0thWk0zUGxRN1I1NXp4dURjSDJySHZ0ZmcwKzdpdDN2N2VLVU9CT2lRQldmZjNiSEhOVjh2bWF5cVNUazIzcHBMVzZmMzJOVzF1OWJTTzR1MjFtMkZxU2Q4RWJCMWRFT01Md09UbkRWMGVtYWhzMXFHMXNMdXdndDJnZmJhcEVUTVg3L09PQWM5dXRlVXA0ajE3U0xtN1E2TmIzMWxGSnRSMk1hZkszemJRQnp1ejB6MXJ1YlR4RHFoc0RLZkQ5NFpaQzhyZ1RKdFlnWUNsUnlvTkV1akhTYWlsKzg3TjN1MzhyYkhwTThTM0t3N2JlQm5rZmRJemd4bEZUdnVBT1I2Q3VHdloxMUJiNkd5czI4aU9VeHlsa1pZM0k1SUFQSkI5YWpUVVBFVDZaQnQwYzJib2hJUnB0NVRmd09WeWZ6cnoyUFVkV3QvRTF1VnZybTBGeXJnbVdRTkU3TGdjOWNld3hrMGwzTktzNDh1cWV1N1MvSzU3Q2o2WnBGZzZMcE1scmJHWkpQTlZXY3JJd3h1R01uQXhnOXEwVWhYVU5PTHhYdHRKRE16a1FsZHk3UURsUi9leWZ5clh1VHFiUncza1U5dGNJZHlzTjdoV1hqSUNqUFB0WEdSYW5wc3NkdTFwcDl5Zk5mRWdqVlE4RERKQVpSeXU0ZEQwTlV6b2s0eDBiVnJiYmFlVmk5cDA2eFNXdHdyeXdRd1c1RGdSQXJJZWdBQkpZRWUxYVJzOWVNOGMwZDVZR0JPZm5qdzRYcWVoRmVPNno4UjdEd3pQTHA4M2h5L2l0bi9BT1BlYU1GbUxuc3BPZTVydTR2RUZsY3BZU1dsNGx1MDVWWnZ0RVFhU1JSMVhibkNta3lieGpUanpTYVQxVm0xcXROQXNyQjc3eEFaeHJFTUx3dnZraXM0enNjZ1orZHlmdlk1eFdMcVZ0NFZ2TlhlN2x0cmE2ZWRIVVN6WEJCTHhkQWlqcVNlT0t6Sjd2UTJTL2gwN3c5cTFwZVhML004R0VWaU00NXpqNXEyTkMwU2NhWjlrbTBoWVdZcWN5a000Y0hsampqTkxwYzVsZHBRZ295dTIrYlZwdjVpNkhOcHNOcEdiRFJaNC9OSkRwRzNsQ09RRCs2L2ZQZXRDem04WDJjQ3BGYkpjSjkyVlpaZDBtNHR5b0lIUEhjMVJ2OEFTOVFzcmxydzZrekNJbmN4VXZKSHYvaGlFZkIralYxK2xRWEZ4YmZhck5tdURISGxsa2R0NWw2L09wSEdPd29UYVdtdHpXbXF2dE9XOGswbnRiNTZJeDlXMDZjd1JxWUk5UFZwVWVTZFozRGJ3TUtWOU1lOWNacVYxcldoeU5kczc2dEZDakx2RzJXU0lua25Bd2NjOGl2U3JxRytqMG0zODZGcnJlNEVrWmxHMWR6Wk9BUm41ZmVzYTl1dEFrTTF2OXBNTXNVRzk0U1RHV1AzZ3luak9QMXBkTENrbHpYdTQ3T3pmTDUyN0R0RDhSUTN0bGJSM2hWbW1Rc2pMQ0FHYnBqRGVnOWE5ZDhMNmZCYm00aHQ0clNGSTVFVU5MdEpZNDM1RzRIR004RWREWHo5cFBqSzN1VnVFaGpiVVk3RUNSbzRZZHNnMy9jMmRBUUQxQTdWOU0rRVBFT2hOTloyOXpicERjM205b3hORXlzeEErWlJuZ2JheXJZT25pYWM2RlN0V3BSbXJjMUtmSk5la2x0Yyt3NGJ4RU1ObXVIcVRoU25LSHdxckM2YmF0cmU5L0krZzlNdEF1Z3oyc2M4VFRTM0VUTjgyQjVjWElHVGpKM2NtdXgxblRydWROT2p0Z1pJcmExOHZLOVM1T1dPUHdyeHZXUEVlbzZkWVJ5V09rMlZ5NlRZbVdXZnl2M1EvaVVyd0hQWUhnK3RhbHQ4Uk5Da3ZyV3ptSDJTNXVnM2t3ek1ZV2NyOTRMa2tFajYxNGVLNFc0YXFaWFV5MVZNUlJwencxS2g3c2s1S0ZPVG5wZFBWdDY5eitsc1BudVpmV29ZaHhwemtxazZtcWFUbE5jdjRKYUc5YlhldDZaYzg2SDlyUjFJYnpNTHR3ZjRRMk0vWE5la1dONWNwcHVzWEFab3R4aWhpVU1RRWR6dWJIdUJ4bW1XK3J5S0JnektPbkRCaC9TdHByOUpZd2tvaWtVRUhhNjRHZW1lTzllSmt2Qk5IS3FFS2VEelZ1TktsWGpTVTRPTDU2cTBsTnA2MnZza2V2amMrbmlwWHJZSkp5blRjM0dWN3hnNzJTZmM5SDhNdk1ORnRua2RuYVhkSmxpU2NNZU92c0s2YWE2WlpGVUFjZ2tuMHhYbjlsckhseFJyNVlDSUFGQzhxQU9CaXVsVFVJSkQ5ME1leHpqOWEvWk1MaDNSd3RDbnp1ZkpUakhtYnUzeXExMmZuMWVwN1RFVlo4dkx6U2J0MnU5am9neXlScXdRZk1WeitkV0w2V1NLd3VXakh6TERJVkE3a0tTS3pCTEU3UkJlQURrK25UanBWOFNFNUFJUHRXOWpDK3grQ0g3UVB4dDhZNkQ4UWZDa0VHb1hsdFlEUTdXNVJJSE1heVNUSzI5enQ2a1NEQjlBSys4ZjJWUGlmcWZqZndacWN0MUJjcjlpdkkwamxuSUxUZWFtWldCQUFJRWdQU3VlK0ozd1U4UDZwZFFXK3QrRzcvVmRNZ3VKSnRPdWRPazJYZG1KbTN5V3ovM29TM0srbGZVbnc5OFBXZmh6UmtWZE9pMGkyZG9ZTE94M2JqQmJ3Z2xGZGllWkhMRm1QcWEzcVZVcVh2U2lvclc5clcrWjF6aTNlenVuOEtSK2NmeGcxQmZESGpyVm9WaWxqaG5uRXFTcEVyWWVVQitCMUlHZWE4TWc4ZFgzbVRiOU11Yml3RDdEY3d3N0E0a0dXTGdqSUNtdnFIOW9leDFkL0ZOOU5ZV1gyMlI3YTBVd1BNSTAyZ0hjVnovRWErZEpJNHJiVGhiUnpTMk05eW1ZMFkrYWlFZGR2VTRGZklWNEpWWjYvYVovT2VhUmxTekRFTlRVWTg4cksvVy8zV05XMDFtSnI3YkJhM0xvWXc2RmxVNEFQM2xPZTU3VjE4OTVxYXpKS2x0RTBnVGVpYmZMY2djRlNlblUxNVZIQjR5c0xWRGFYYlhNNnFQTFF4NzRwRmYrUFBwMk9PbGF0eGJhNWVSSUxsbHNFQ2xuV1BkSXJ5RTg4bmtLZlFWemRUeDZkYVhKSk9NK2EvUkpHbnFYaUsrc2lvbDArOVNNUitaNWx1d2ZucUR0T1J0SGZOVUpkWnVMUFVyT2RkT2t1MnVZVHV1VEY1UkM0TEVNbzcxbFdmaC94R2RXekxxK3F4cXpCVUsycW0zQ2daQU80bkk5NjNwOUQ4U3pLWTVmRTkrenJqNTRvbENOejkzMkJIUWloQ1NxdHQ4MHQ5UEovZ1diSFU3UFhMS003NWJTV1JjYlBNR2VEN2RPYXpVYS9XOWxXNmtGekdGUnZLd1ZhUEhjbk9SNjFrTm9saG9zMytpWGFSM1VhZlB1WW1URE54MTRBOWE5Q2x0UmVHUzhaMnRsakc2VzRsakd6NUJqdjI5NmZMWXh0VmxvMzc4Yk4yMmEvd0NBZWFlSU5ZaW5TQzcwL1FaYmlPTmxacmhMYzV5cCs0QURrL1d1ajFIeElaN0poQm9keXNjN3hoNDVpb2FKd01seXBQOEFPdHJUdmlONEx0M2VGYjVlY2lXUkYyeHFSMno3MDNTNzYxMU9XS1MzMUdlV3l1NG1ZSktxN3lWT0NoM2pKWEhOTmJhRy9zbHl5Y2FpY3B0S1ZrbFo3ZnFMWXBwb3Q0U05HdUxoOXgzQ1BHN0o1TEFnNDdWdFgybXphck9rN0JJNDFHRmptaUVoQUl3R0o2clYyMzhPNk9idVpJMVlnWXpGSE1WVlNSd0dWU01ISFR2VjJPM05oYnVMYlVCRXFNd2FDYVVNV1lkT1c2ZWxQUTNoUWxHbmFjVW85ZVcydHZranovVlBERjVZaExtMTFDRXRGRmxZbFE3bVlub0NleHJvZEZrbWt0eEZQQzBVWklZSzRCS2s5Y25xVFVJMHpWZFYzdjhBMmZ0T1FyWW5HQUNPUVBXbzEwZURUN21ZTFBPenFBVmlNVGJRTWNnc085WnU5a2MwYWFoVzU0VTVSaHRadHBQNU10YW5mRzBsRVNYZ0xTUHVZRmNrUjlPRkhVVTlyaTFqQmxpaHRTMnpiT3BBaUJ6M09lQlhIZllVazEwM0MzRnBLcm91K0xkaVZTT2dYT09BZWZXdFpQQ2xsSlB4cDZ6U1NCbmI3USt4U1I2WVB6RDBxOU5DNzE1VGxaSzNOWmEzdDZibStiTFNMclRuYTB0clNaQ21GRWJmY2JQUEs5QUs1aVRVOUlpMWVHTzQxUTIwRUVJeEVFMmpkL3RsdXZzYTJyNjBnMHlITU5pV2h5UE1XM2NJRmJHUURqdDJyTHQ3ZlJ0UXNiaDFpdUUzL3dDdGp4dmNBRGtZSis3NkNrbzNRNS9IeXBRVWxadFdhVFMxOGkzcU0ybVhNZHZQYjNNQWNTQVBPaWJzQTlBUmtBMWpUNlhxMXc4TUZ5OXVRMlN0emJ4bUlIMExZNzQ3MW42WG9jOXBCdVcxUGsrWVJKRGNNckFJdlJ0cDdtdlFaUHNxdkhITTdXOEppTGdiZ3BJUEcwQUhuSFhpaE93NGUvek9jZVc5dHJwTTR5NlRSOUtoa2x2UmU3R1pRMTByRnRvUTRYY005RDYxcHJyMm4zVms4MW04VHhBTVkvUFhHWk95NUZVb1l0SnVudTRMVi9NbGtaWWlPcUFLTWdqUEJIclhHNmhvTUVseGJSM0Z2ZFNSTTY3MGdZS0JnL2V3UFh2VmI2R0RseVI5eFJVVzdhYTllNTBGblA0ajFpMGFLV3dqczVZaUFra1U0a1JzZFNxbnY3R29OSkgyTzZ1NDlRdTcwektmdURuelBkQXZyVjYwOE8vMlZlRTI4a3pwZFBJNklSdVJGSFJXUDlhM0k3alU0WUQ1ZHZDWlE0QmFUa2tIb0J0NUdLVzNtUGxrMm5KTk9ONy9BR2s5RFNzNFhnaFc0aGFlQlVYRzJYNTlxdDFMRTl4V0xxMTVhWFVUdHFkNXAwME1ES1lwRkpWMUI3bkhXcThkeDR0ZHIrM2EyczNTSkN6U3JJeDJybk8zbitMRlZkT3ROQ3Y3azNnaENSRUVTeFBGdnoySXlPMzlhbExmVTBjMXl4cHBXdnVwYUovTHlNZEpOTXNwRGNtOVdleGtHeFVnaVkrV3hISG1FYzQ5YVpENHZzNVk0N1YvTVJVY2hqR3BJNFBZOWNWZDFlMDBlQ0s0WFRqOW44a2gvS0R0RXNnN0VPYzUrbFptaDZOcEZyYlQzK28zazl6Tkk0bFYyVXFJOW5JQTJqbkFyUlJWbXpLTUtxazR4bkNLdHIxVDlQOEFJa2pzb1NiaDdMY0d1QVpFeUdSbjU2YzlQYXVjc3IvNGxTWFMyVTlra0xTc05nTGpkNVk2TVQwNTdWN1JEcTJsM1VpVHd2TzlzSXY0bEtCUVJrc0NjSG52aXF4VzJhRkx1MEFFYUhlcnU3RmdlbVRucUt6ME5IVGc0dFJrdlBsYlduV3h4RTArczJOOHNrbVprZ1VpUmp5ZUR6dE5UNmY0MzhIWFdyQ3pUZGVTTEU4b0JpRW13RCtIbnY4QVNzY2E1cmNHcVhDWEt4dkdRRlNXUDVoOC93QXhMS09neDFxcEVOUHNOYXhhNmJISFBkUkFDYUdWVkxIcWV1Umc5cUZabk5UclFoS2Z2UzZXVDFzL3hQV0oyOFBYT25LR01xbzBlNHFBVktidVA0dWdGZWJQNGIwMnlsWjdLOGt1SU5yTXR2OEFJY24yWnVhNnl3dnREMUZybG83bWN2R28zb3czSmhlQ3VlNEZjcGYrR1lXMDJXSFRwVkRoak1YVmdIWkQxVWV3N1VsdmE5alNwTlRTZkxDVms5WXZXNjhpS3o4VGFWcDVrYTZzWllyOUZWVTNzQ0hEY1piSEdhclFtenZqRlBJLzc0RGN5Q1E4RW5veWc5NjV1ODhRWHNNUzJGMXBzcXl4bUl4TzhCZDVQWUhIU3ZaNE5RRDJSdUl0UHQvTmpRK1lxcUZaQ09mbXp5QlRlMmlPYUxjNUtMbFpLTjBuRHEvMVJjZ3RZcm0ydW9kVnNvWUlpdTBGanU4NHFNajVoeVBhdk5ySFRibTY4dGJDOWxoalhjVldaUkpHd3o5MVQxNjFVaHN2RkF1SXJ1S080OG00ZjU0MjI3RXoxWVp6VzUvd2tVK2o2YzdYOERUd3lNeVJ0Q0E3bC9UQ2RCNzFiYmEwTjQybjdQM1pyUjYyMWQ5dFZZdm53K3JUVzd0ZGlTNGxZTjhnS2hTcDUzWTRBUFN1dzFIUnRJRmxOSHFrTUpqa0hXVGtEZDZlbGVLMnVyMjk5cTltbHN0K1pkaGphM1ZTb1U0emtuajhhbHM5ZDhQNm5mRUVYa2w2SlNqeFN5RWhTaHdNajNxZmVZNFRqR01wS25xMnRXM2I1bDlwdkJHaHUxdGhSYkNNTTd4WXpodTRIYzB0aE40ZnRMd1gwVjdQSkRjY1FRekFiVngxSHFQeHFIN0daOVlKVFFZV3h3ZDBpN1ZPZXVPeHJkdS9GT2lhVmZKYTNJVkpBM01mbEJ3QWV1RzcwOUUrck1hWEs1U2sxRmU4N096MCs4NkMzdjc2YWR4RmNXMHR1b3pzaitaZ3hQcjZWbFIrSDdtMnZwYmlGSWZORXl5dEtZc2xmOWtZcW5GNHZzSGl1cExIVVdEckk3UnY5a3dnVCs2eEg4NjdnR1BVbzRacHJxMWdTWkJzZFpDQVdQdjY4MGtuZlE2TFVwdExtY3BSZDFydGY1NkhBYXJGWTZudmoxRXl3eU5LR1hkOHNiZGdGOXEzNC9EVC9hN085aTFxN2k4dHRrY08zY2piUnlQeTlhenRkdTlTdFJscmVDOVNETEw4eWtFRGo1ajFHSzdQU1BFbDB1aVFYRnhDaXlaSjhxM0piYVQ5MGZqM1BhbTdYUVV2WnVyVVUzWjJ2ZDcrdTVqM2RzSUpESkhMYlNTdXpCQXNaQjU5ZlErOWVWM1R0cDkxTll0cDE5R3BjeVIzTUs3bEpIOEpBN1YydHI0clM1MW9DOHRKYmE2M05HTGNxWkJJM2JKQXdQcld6UFA0a1c2amUzczJGdXhPOXQrVlhCeHR3YWVwblVWT1NrMG03TnBXVGI4MlltbzZwZnk2YmJ6aHBJMUlSVkJpQ3VKUFVaN0dqVU5jZVNmUzQ3ZlFJYm00bDJocDJBK1QxeVRqbkZjMXFYaTZZM2x4QkZhR0dTS1F1WkQ4Nmpid1Rqa0FZcnJMTFVFMXg0OS83eTNpUU1KSU1FcktQNUNuYXlXaGxUcWMxV2NWVWNtMGxaclMvbGZZWllhTGV6M3Q3T2s4Vm9CbEhnaEk1STZON1pyYVRWSk5OVmxZaDNZRkNrdnl0ais5bnBYQjZoNE1JdXBOVVM4dXBKSGtWeWhieXc0SDhPTzllbDJodko0NW11MGpnTGtsU0J1RzBER01ab2JPaEp3bnl4aktNclg1dDFyK0J4SytKdEt0SmhOY3FJSmNxamNxVDY1SHFLNyt5OFRvMHQ1TGJRdGNpRmt5KzNnaHVldmV2TnIzdzdiUVhxUzM2MmQya3NteU9SbDh2YUNNL1ExNkJGRk5ZckhIWUlKNDFJMmdPQmtIdGlwME02VTYwVzFmbHMzZlM3djBlaGF1YnExdVltdlpFR1FTakt3OHR1ZWdHYTRPVHdFbDdNMHd2N2hMYmFYOG9nRWcvd0M4S3lkZDhVMzF0cWYyQytzNGlyWlFJY3NGQjc1N21ybHZZeDJhSmNlZGNKRGxTd0c5bC9BZWxEVmhTcXduSzA0YzNMdmYzWGRkZlFwVDZacG1tUW1HR3lCdHlWYmVTek93OWNEME5laTJOM2IzdGxCTEhMR2tvWGxaVitSZ0QzckIxUFVyMnlNZjltMmtkMmdYR1JJTndKNTZHc2k2dXJRNmRMYlNTaUNaZjlaREt1MGd0emdFZHZlbXBYU001V3B6azd4MVR1dGxmZlJtbHEvaVd4c2IxdnRHbnVKRVFNV2pVc2h6MEFyWThPYXRwR3BRVHNkVWFLY25Lb1RzWlRuK3RWN1crdTROTWhpZUNOWWtWVlZqbVZpZnk0OXFvM2VnYVJyNjNFbG5ackhjeHFXTWdZb3JGZWNIM3BxMnFPbU5TVmswMUtXcjVHck4rbHQyZWl6emFCY3pReDNGeEcwa0xiZ1c0SWI2anJVc2Y5bXkzTVFTNFpnVHUrUW5hUWV0ZU02bm8zaUo0Slp0S1dKYmhVWGNyc0hJeHdjRS9yVWQxcFdyUTJscmMzRXR6SGRMR0J1aXdGTEhqRlQxc0oxcTNLNU9pclh1M3F0RjVubzg0aEdxWEZ0WStSSTZBTS9uZzg1NEFGWlkxMkQ3YTFwZDJNa2IrVVVieXh1VG5xd0k3Vm1lRzcyUzV0SjdXNkRTU00yMEJzTE54L2V4VlpnbWs2aEdqMmQ1THVmQ1NGdHlBTjF5UGFucDFNZmF6YWhPRFNqeldscG92SzF2MU9pMCt3MFdMejU0WWZuakJUY2VkdWVSak5McG1vMjkvSXhtc3BWbWljY01OZ3d2OFNpcStyWGZpT0IyYXkweTFhQmxMYjVId005aWF4NUp2RWQydGpjMzFqQ3ZrZ2Y4ZThtZHBQOEFlQTZpalZ2YzZaKzRrb3hkazlZcUdqOHpycjJ6c3RieUkzaURSbHNkbUI5Q2F5VTFPWFJyVkV2NEpralViRWxqTzRFbm9Eam11WnNOYjB5U1VRcTBVTzBzckpuRzRrL2V6N1YyTU4xWVRMdFZ2M2I5WEpKWEk2SDYwOVVyR1ZPVk9iOW9wcFRhczMwZnFqbkc4WlFOc010eE84Yk44c2JSbm5IWWU5YU5oNHh0dFh1SkxXT3prZ0h6WTh6NUN1UFN1Y3VSNG1zYjIxU0xVTGVlMkQ4VFNvQ1J6ejJyMFMvMEt5dlpFdWpDWkpGaisrbkJ6MTR4UmFKcEY0aVNhVW56UmF1bXQxK0p5OXROUFlOSWx4RkpjckpMbkxZWUFOMHhYVFFYOXN0M2NzcXgrY0UyeElUdEpiMFB0VnVhelo5TjVQbE03WVVTY09vOWNlMVFhWHFQaE9HUzR0cEpFZThqQVVuR2R4eDF6N1ZOMnlxY0pRbEZjNlViM1RsK1hxWUM2ZmE2cE5IUHFPanZEY0tSekhJVGozNHJrcjN3MTRRT3JYRnhpNDgxbCtkUUR3UnprbjNyMm0vdHRVaTJ2RktIVGFOcEhVRTlNMTVIRmVhdExyNFUycko5bVB6dnpza1BvZnBWSzczNkR4RUZGSmN0M0tTVGJqdW42V0UwdXgwK3lWekVabTh3NVZReDJncjdHbjNHaVdqWGdsajg1WlprM095a0JjSGl2WjdDOHRyMVpJNGJQYTZxTXNjRGFSMVAwcnpsYmJTeGV5bThuZmRLdXh0emJRRkp4bFJUTTVVSXhoR3pqS0xlK3lSaXc2YmE2UGRXMEoxUzVLU2JnckVaWEo2RElyWnV0TzhSd1Rzb01EUlNQdU11TUVkK2ExRDROMHZUTEpvNGJpNGVKMlVxeGZjRndjNUh0VEw3VUh0dE9tRHpJMXV4TEY4NUs0K25haSt4VTZQSXBxU2NWdXVXWDRQeU1vM0dwTGQzR0pSSkdvd1ZCeUMvMTlLcnBwOG9hMmR4R3NjckhjcGM0R2V0U2FUZGFYZTIwUXQ1NHlKQ1dDb2Nic2RheEwrMDhkd3p6ZVhIYU5hakpqVW5uOFRSZXoyTWtycm10S1Z1aTE2bVQ0ZzhLM0VTUVc5ZzhFSURGdHdiT1NlUnpXelk2MXI5cnB2MmZVYjZCWEF5SmwrWSs0T1Bhc2JTdFNHcE1ZNTdWcldaRHRkVkJJT2VNMWp5ZUJ6YTNTQ1c0dTdtQ1Z5V1FZd3BZY0hORjlVbVlKUzVxa3FkMHIyMGZ5czdhblgrSS9Fcld0cll5eHNYVm5WSkJqZHVCNmZTbVgyaTZteXhLdXBTcmJYTXFNVVRqYm5xdnRYRFcyaGF6Yk9Qc2Nrc3R1MkF3WVpJSVBYbnZYc3QzUGNMYTJzSHlsNXBjTTRHU2c5VGpwVTYzSmpKelZSelVsWksyOXRkUHhPQXV2Q0JrdW5XSzVrdDRpcXFyRnM4bnZVR2tlSC9BQm5heHlXLzlvQ1dCU1MyRGhseFR0WTA2YU9lMW1YVXBzU1RZZEdmQlVEdmpQU3ZackM1c1pMVmJnM1FBanlYQzhnZ0RGRDNUYk5LTk9sT3BPUEx5TzkyMUpiTTU2VFI0N3ExYVM0azh3bGNiRzlPbFo4ZHVsaENGdG9ZMW4yRWdOMElIT1RYWldrV2szYnhYRU0rV1ZoZ0J1UWhyQ3ZOVDBTeTFOeFBFN1M0WUtjWlBYZ1ZTVHRZNnB3cHdYTzVSamZUbnY4QWljTkY0eTFnd0ZyMjIyaUU3WGFJWno2Q3A5SzhlcmNTWE5ySnA4NWRHL2RBcnlWcVVYdWwyMnNmWmdEaWROemhobjV1b0JxN2ZzOHNiZlo0NVZ1Z2NDV05lUUQyTk95N0huS3RXVVp0MVcybTFiZCtoV3VMMit2cndSSlpTMnF4NVlzZTRJNkd0eXpHdGtHS05vR1JsUDNqOHd6MEFxbVlkUmpsdDRyalZIY2xTdUNuSko5L2FyN2VURGZRUnZHMGJlV1NqWnlEanMzcG1pMmh0R0x2ZVRtdFVucWx2MDB1V29yMmUxdDBodVl5N0U0SVFaeG4wclZnbGU4aG1DYjNrZ3p0QjQyNEh2WEl4NnhwbHBmZVVsNEdsZVFzMlRrS1QyelhibVJtanhDbStWeWZuVGpPZlgxb3NkdE9kOU9lNldqUzFmMzl6a3JmWHBKTHJ5WlU2Sjg0UEpKOXFxeDJkcEI4d1Y5a2tnQ3FEZzgxenZpQ0RVYmkyWklyQVc5Mkc0ZFc2NDlQd3JtZFA4SzYvZUNPUzV2NUxkbzhaTEU4a1UzcSt4elRuUG1VZVZ6ZlJ2b2VueDJIMlc0a09aRitiZVNXeUdYM3hTeDZUWU1HbWlETk11V0lKNmlxNzMwbWlwRE5JNHVZM1h5NVZ3YytnTmRkWjZwcDExR3pwRUluRzBnZE1aNHhVdTV0RlVlWlIwVFd2SzkxNkdjbDVNOXdJcFlva2laQnpuRERQVDFyelo5V2xlOG1zdnNvak1aRExJNXlHWE5kTHJ0aERjeWgwQnlHRzhCdXc2VjU3ZTZWcU4yU3FTRkpGVUFidjRscWJhYXM1YTlTcmZsU2IxMzh1eDZIcVF2NExlVHliZzI3Zkt3SUc0ZTFWcjI3dUpMT0pacmh0eng1M0tEeWM0T1Bhc0hUWi9GMEFNTjBnWkFqRWJseUNGcWYrMi90c01jY0xScGNScWZsSTZFbmtjMDFIYllhcXEwdFpSYmo4TDYyN0UwTjRnbHpiVGxwb3NMNWJqakhxTTExQ3NzMStxdGN4cTZuRWd6aklOVjdhYUszdlZoYTFFZ2JKTWc0UFRQTkxyZmhyVHBKYmEvbHQzVThiakdTU2MrdEk2Rkdjb3lhYWJUVjFxckQ1OU1kRnVCYnpwSVRsaStlVlB0N1Z3bGo0cnZMV1dSYm5TMk1ia0I1RnovRDlLNjl0SUwvQURSdnNqZFNya25rWjR6ejNIZXByTHd6Y2FiYWkzanVWdUZjNU83bkFKL2xUVnJha3VsVnNuQ0xqYnp1amxqUDRXbG1lVmlyYmljb1RuYWFLM2RZOExyTGNGTFJFaWY1V2NFZTJPOUZVcEx1emxuQ3RHYlNvVTM1OHR6bFBEV2thSGE2c2tObmQyc25tSS9uc0ZrQThwajJKSkdQU3ZTSlpyWFFJYnZOdGFSMnJ3NFVTWEJjdnpnZzV6Zzg5RFhLNnJicGF1dHBCY2VSQ0d6ZFN0SVlYQ2pHQW9IYkhXdXkwdXgwaTBzN2UyMDh3K1FqTk0wOGorY1N6RGtFbkdSMzlxeTJmcWROS2ZOelhjVk9MdHZmeXRxZVlhaW5obFVnaXRaUHRpQWVZWlk3WlpZVk9jRU5sczU5SzZNK0ovRGx4cE1FcHNubDhzL0pIeEFRUWZsR0VPU3YxNzFrUXJwa21vTExiejNObjlwWUJVc29Wa2p1Q3BPUVFjLzRVelU5TDA2emY3VWw3bTVlUUlpTkZtUU1TZmxKUVlISEpYRk5KcDduUE9UakdUcDhpVnR0N1c4bWRiL3dqMXhyZHZOZVIzMGtSYVFQR2hSWkI1ZWN0R2NZeitQTmNKNXd0dGFhd1g3VmFFUnRKNWtZVklTRDh4M1p6Z0hHT3VhNVN4OGFhcnBlcG0wMUhVYktLRnd3aGh0MUlmYXEvTGtxRHlTZU0xMlVzTFg4akMveGZRK1d1MEl6SzZCbHhsMVhrZGM1L0dxMXR1VldVRjdLOFczSlhjdWtqWHRicGJHQ09FYWNzOFVyRjN1YmVVczRrWWJrMmJ1UWZYMHJZMXJXYmZVTGRiSzdzTDY0Z3hsbWFBdTRIKzgyQ01lb3JoZEg4TkxZM2x4YlhWaExhK2Q1ZStOWi9Oakk1SWxEOVF4QTQ5SzFZdE5YVDlVdHd2OEFvMFZvWGRUY1R5TnVIWGpuNWp6MDZWRytwTGNxYTVVMmxkUnRidDNOL1NiK1c0ZEZYVDBhd2tVZ01aQXBERDd4WVBqSTRyVml1THkyYVpCY1J4eFdRTFJlWEVjb09XREFkd1R4anBXMFpiWFU0bGhXNmh0MGFRcXNpeEVuZjJPR0JISHRYbVNhWnJVTjdOWnphNWEzU0kvbUw1a0htQXJrajUyR091T2dIRkRkalZSYXBxMHJ0ZFZwdjAwNkhvRjU1Vi9aZWZmdEE4Y3NhdkpBcmJ5cHpqNUd3TUFqOHE0UnRPMHR0S3VwbzlOc29YaklSN25MSkpFZzZOa2pMUDNIYXJOaGU2Z3BkUEw4cGJZWit6V3RzSlNXeGpjeFBBOXF2VzFuWnpYWWxXeHdSdVpwWG5ERldBeTI3NXVuYkdPS1ZtWjgvTzExNWswN3JWdnFjMzRmOFJhYTFzeldHcUxIUHZDdGJYUkJVUUkyQ3gyWTJFbm52WHFVOFdqeDJzMTVkYWxhM3FRa3VFaWhCYnBnQThuUFhyV0plYUVkUWdlQVd0aEZEY0t6VHlMSDh6RWtEYVNWQjlUa2RheEpOSTByVExlU0ZOV1czWjlvUjFYS0x5QWl1d0JJeVJnNXF2bWFTZkxibHBYamJSdDJWL205VFAxWHhESnAwVnJKSzlrdHBQS290N2lLRjUvS1BWaFBua0QxcTU5bm5WbTFDMmUxdmd4VlZXM1ptaTJ1TWJjbHZsQUo2WXJuOUZqdWRRdEpyTFZTTGhZdk1FS3d5cUNNRTVYZ2duMXgzcnBvOUF0b2JZUnJwdXhiYllxWEVTRHk0OXczQnBFQkc3QkhYbW4xc0ZsT0Nzcnk5ZEUwdlE0RnJUVDdXK2l0NTlYdDRFbS80K284dXcycWZ1ZzlHNTdIcFhyOXRlNlJIQkRHa05wUEVxdmxJSmhrZ0VZWFlPRzNlbFlFTjFyYTNpSkxKcE4wK1YyeVRXNVRZMGhCQVVLR0JCSHZ3ZXRTbXdXZlZKYlovRHR2bVFTUkdTT1VwSXNhL01HRVhHUU94RkRiNmtVNmFnbnlOWGJ0cXIvTHFWYm54ZnFaMUc3czdHd21ZRGFJNDVJUkc2bmpvekRCWHQ3VmRlNThLM2wxcC8yeTJtdXRRQ3JHQ3FNRVhQWE9BQTJ6UExDdWd1Yk93R213V2R6TVFBeW9FZDNoZmQvQ3VQbXlTSzUvVFpkZVZMdUpXZUszaWRRSE1xK2FZdjhBZ2ZBeDBJSE5JMjkrTXRaY3lhMmZ2VzhyYkhva2x2WVdxZVRzUVhMRUttWm5qaVpjY2tubm5GYzVKL2FRMUtaNEpwTGVINVl2SVloMVhkenZUcnVIWWc0NHF3a2RqQkxiWFVwYWVOZ05zc1FNNEViWVVsMlgzNzR3SzE3NTdlT2Z5VWsreWx5MHU5bUJWbzFPQWMrdWV0UTlqb2Q5NzhxVDBTZXZsYzh2bTBTK09wendOb3dram1kUklZZHlyODNkdDNPUHBYVHczbWlXRnk2RzNtUzVFQjNSUUtXTWFJTWJpdkI2KzFkSXNOanBsMU84Nm9BY0t4REJmTkorN2g4a2tWblErSXRHdTcrV1N5bmllUjR3c3J5TWVDdjhLT2NaYnZqMHEraGdxYWcwK1pLU2V6VjdMeTJQQ3Y4QWhMWjMxeFJZRzd2YkJsVXQrNVlQSElTY2pCd3VlT3RlbDZkSk04OTR0N2RYU3BjRlVVM01xS3Zsa2NsY2RNOUs4NzhYNkhaNjFkTFBwa2x6ZXlPKzAzTnZKdWhSejAzSWNZNDRKSEZlbmFKbzNpR3h0TE8zMUt5dExxQ09BeHl4TWhBVU1mbGNPZXBPZU1Db3RjZkxhU2FUdGZYZHBhK1JxMlZub1ZxMGV3Ukh5SXc2TGFTbDNieTIycUNlY2s5eG1zaWEza3VKYjFSbzl6RWJuYXNqZVlBVTNjc3hHZjRUMzcwbWxYaTJFRnhEYXBGWnlSenM2UlNNUUdaZVJHaFVFamN2STlhMGRHMDdYaERhekc4YVEzYkdQY1lzcEd6L0FEQmM5Y1o2NTVOVkhWUFVuOTNVc2xDL1YyU3V1blV4OU44S1FXdHJISjlvaXZaSUN4bEVjUVloVHdBTnpjazl1OWR1bmgreWpOdmRhVGN5V3hSTnM2YkNYZnR0S2c3Y0Q4NjZONGJob2xnR2o4S0FKSGhjUUVNRHlWM2M0NzU3ZEs0TnRWMHJRYkc4dVZ0bGE1RHMwc1htdktHR1FNbGlCaFFPOVU3MjNPbFVhVUZyRlJWcjMxVFRYWmo3dlNOZHViazNOdGNXMXRFcDJySVlURzdCdURsK2NIMHhVSDlqM2x4cENUYVpxaXh5Rmo1Y2lqZXh3TVprWWQ4OXEyYjNWNDdxME54RkRLVm5ZSkx0RHVzVWFqT1VWZU1FZCt0ZVpXUGkvd0FIUzM5MUNsL3A5cVdLSUlraVp3UnUybnpBZG8zTjZqcFU5TmlYQ0Ric25MVFhWNmRuNUd2YTJuaXlHZUtTL3Y3VzVNaU9KMmxUYVU0eHRYcnhubXBkUjhPWGRnSTcyMVZ2SmVOa2FPRXNzYU1jQU11UDR1ZnpwTHZUcktXQ1greTlaV05tVmxXSXh1NkFxTTg3eVNGOThWejNodTE4WHBjUVBlc05xa3NQTGtmNWdlZWNjYlRRbjEvQTVwY3QydVZPK3pVazdOOWREZXROTHQ3eU1McVZzc0tRNVlUWEV1NlZNSElKYkl3cFBZMWs2dEpkV2hmVkxUUTdTUzNpaUNwY1J6QmtkRjRMTXJaK2I4SzJOVlJHMU8zaXVvNXA0YjlueEJKWm1YQWpPU3FGTzR4M3JXMitIb2RCbk5uZDNPa3hQS21ETEY1UGxGZjlsaHpudjJORnk0VWRPMW51N1g4ckZYVDlSOEVlSzlKVkpJYkh6NWs4ekRibC9mS2R1U1JnajZpdGUxMGJ3aTZwSkpwaXdYRWJwQ1E4N3FyS280SzdpT1Jqak5NdHZEUGhlNGFTT2RudVNMY1RDYkFqamxCYk9WOHNnRmg2R3N5d3RCSkpGQzV1ZFJ0eTVjQ1Q5K2tMUmpJR0NBQWNlOVgwTjN6TGxUakJyVkxhWDMrZm1XOWFzcGRSMU54Ylg5M2FUeUVSeGlKdzhlQU01SkdjZnlxYlFqNGgweTh1VGV4L2JaWW0yUklJa1V1QjNCNkRyWFdXMXBMTEJjUFlSaTF5RjJLMGUxVUM4TXFsVzVKOUtxYVZmNjVieFJSM0U5cGNvTjZReUxISm5lcHh0WVlBeVFlZTFTYVFqN3luSnROdHRTV3FJNHJYUmRQdHJwN2RMcUtlOW5WbXRXbVprU1E4TUFNWUFyaTlZajAvVDVZWjVkT1o3a29WUXdzVUQ4NUl5cDVZZGVhOVZuODhGSjRReXlzUkc1RFpWbEE1MnJ6OVJYS040Y3VrMU41VHFGN0JiU0NIOXg1cU9HQk9EdzZuQjRvM0xxMDNLRGpaYWJhYWVwZWdta24wNk9SN2dDMkVnTFJYRHBLWUNPTVpISXJiVFNyYVJaWllFU1FDVlpqNVpUTEFESkpEZGZZMXgxMWRXV2o2dkRIYy9hWnpLeGpoalpVQzdtNkFyZ2JoanVQcFdyUFlXenBMY0g3UmIrUU9MbTBoQ09vQnlRQnlXQnhqcFRkOUJVdHJPTjJ0SGQ2NmRmUTJib1dpM1VFOG1ZV2ZHRU1nM0VqMnlBZndyTTFiUnkra01MU1NXY0x2RWthUytWS0dKemdzM1JCNlZoNnJZYUpMZXJjblZDaGd3RVJsQ1NvWHdTU2NrZysyS20xRFhyalRyT2E1dU5YdGJpUFp2YTVFS2dKR3h3QXdCSmJkMDZWTHVVNXJucVJsVDAyVGkwM3IxTnJRanBHbVFSeFRXdHhickpFLzcyVzV6RWR3NDV5TXNUMHFucUN6V1N4R0RWVzA0b1F4bWtZM0FaUU9ONU9PUm5nSG10dXgxRFRiMkxUN2laUXNtMExIRXpMdENua0V4OUQvQUxKN1ZMTEFidEptVjdJV2pEeTl3TEVsaHdSbHVPUGFuY3ZsYXBwUmEwMWpaV2UxOWJXTVhVclhYMnViYVdQVi90VVcwYmR0dmxaTSsyN09jZXRZMXY0djBqVXBHVnJKM2VPVjRwR2xDamE0WXFCa2pJQkh0WFlXOW9pb0k3ZWVaQ0NqZnVwK00rckE0emtmL1hyV3RkQzhYMzJ1UjJ0allXVWl0NWhrQ29kNTdvOGpkTjJmNHM4VTQrOVpXdXpXRktyTis1elhrMWRhenY2WE9ObDhMeVhyWE05dEtJcFpGQzJzNktGTVdCejE2NXJWMHEwT21CcmRaMnU1R2dkM2xtbENPSDduYjJPZjd0ZmNuaHI0UVRNSVpkV1pBNVlNME51N0ZSdEhHNW02KytCaXZlNVBoOW9QMkl4MjluQkMrVllPSXdXSlhzU2VjVjFWY0xpVlFxU2hGU21vdHdnM2JtZHRGZnBjKzV5L2hpcFVxMG5WcSt4aTVYbEszTkpKdlYyUHhDK0lkanF0ekRmemFmcXM3WFUxckZCY1J4aVdSV1NNbGxBT092OEFlSEl5Qml2anpYdkVIeEYxM1Q5SGptc251alpadUlaWm85a3FoZnZqY01ISEFPZnhyK2lmVVBDSGtUdGlGUWNuY29HQ2M5NjQrUHcxWVcxMmx3bGhiK1lxaFNKSWc2c3VjN1dCN2ZxSy9tUEUrSmVLeTNPM1N6VEo2bEdoenFMcXBPVGdyYXRycjhqK2xvY0cwSlphbmhNMGRTcnk2YzZYTEx5ZkswZmtKNGUrTlh4UzhMTEJxV3U2ZGV6YWZPcGlpaGFQNW5kUVNyN2xVQUQ2OGtkSytzZkJuN1duZ0xXM21pMVc2R2lTYng1WG5ocFl5RC9DV1VjSFBjMStpdm4rSFUwNUxaZEVpSTZtT1hEUmcrb3lEbnJ4N1Y0bnFmd3c4TGVJTHB3L2czUXBoSW9FaS9ZbFVzdnV5bFNENkd2MDFlSUhCMDhiaHNMaDhmUEVWYTF1V0ZDak9lL3kvd0NDZVRnK0hzNnBVS2pxUnB3U3UzS3BVdDkyclBWZkRmaXZ3anJjWU9sNnJaWGJFQWtXOXdyTU53eUNWemtacjBEWWg2dHNPY0RlQ1AxRmZuZDRnL1l3K0gxNWNHZlJOVHVkS3ZEZ3RDdHk1VldIWkplQ2NlOWVSNmo4TS8ybnZBa1RmMkw0MHZMdUJPUmIzbUowWURzREp1R01lOWZ1RktEVUl2eTlIOXpQbEpjemxLN1g1bjZzTnJEVzk5RmJrVGt5S1NraXFXUUVkaXc2SDYxMDBlbzNnUHlTS1NPekRINUd2eUMwL3dEYVcrTFdoQ09QeFI0Q1M1K1lLMDFtN1FzdzlRdktrL2xYc3Z3cC9hVHNmRkdvNnBwbDlMYldFeG5DMkRUYi9OMnN4K1c1VWdCWFVkRDBQZW9kWnA3L0FIb3hhU1RjdEQ5RXIvWEovc2x4RmMyN3hlYkc2ZWFvM0tOd3htdVUxQ1JidlI5TnRMUi9QOHNrU0Zja2c5QndlUU9ha3R0ZTBXOWdlU3h2NDUxVXNHZEQ4dnluSFBZZjE3VjVqcm5pSFE3V1krZXdnbEJ5czhSMk1EMnlPTWl2amVJY3B3R2E0UEVVSzFTcFNkYWw3RnpnNys0NUtUVm5wcmF6OGoxOEZqNnVDbENyRndsQ25QbnRMVFd6Vy96UGxyNGsyMDJvNi9xVTBkOFlaZDVpdDlzaEdWaUdCa2RNanRYaFMyK3BOcDBWanF2a1hrdm1zQTZTTkhMNU9Na2wxSFhKNUZlajNiaTZ1TDI0OHBKVE96ZVlSSzJKTnh6bmpKQjc4Q3ZMN2EzdGx1NU5PT2xwYnpSdHZobWt1UE9KSjVZQlZJNDdjMTBSVmtsZlkvbVBNcTN0c2RXcXhzdmFUazdPOW5kNmRMSEg2VkQ0aDBaVlVOSE5aQnlEYjI3TTl4R3JISEhvQWZ6cjAreTFhM0szTFd5VFNSeHliVkRneWxHUVlPYzhnbXVGZXlzTEhVTGdHRzBUellTUWtjVWpTN1hiN3dLa2dIamp2VTh2Z0paSm81WWpkaTNETm1kYmg0MzNIa01Bb0ozSDB4UzA5RHlJZTA1bGJwdjFhNkhZeEw0cGxJdWRObmlaRmpEZlpuUXBrNTU1SnlPRGttdGVmV0UreFJOUGNXWm5rZG85cU9KQ0NldzJjam44cThTMVh3L2QyTTlvYmVUWFpKcG1VYnZNSkNnZFFYSUFBWWYzdWxMNG84SlhWMWFycWtlbVN2ZE9xR1JCOHdaQWVSdVFnRStocGE2R2w2aTVrbE85dGJ0dGVwOUNReFFyNWJDNS9mUnhqZDVpZzVUT1NDVzVJcWhOcURYS3M4RWJ5cElEa2lQeklUL3ZBa1lHSzhVOEgyWVRWWk4yaDNjQldGRmxWNW1mRzc1eUVCUENuSFgxcjNyVm9EY2FjdHZaWEV0dXJQaHhHZ2Q4S3VjTVZQQXlQbTcxUzMxWjJ3azVRYld5NkxkL2VlZVhZMGVQUmJkWDB6VHBKQ1EzbHh1aHhrOE9BUmdnVXVtM1Y4bWt1OGNVVnRjSSt5SkhYNWRwNUl5T25GVUw2d2h1OUptaGdzcDdRS3lzODdvMXVrbVR5ZHh5TWM5S1N6MEdldzBxWTdYdUdad2RtUmlRTnh1VnVRY0NxNmZNODV1cXF5YVduczNlMmx2UGJjMTduUzlWdlloY1RhZGE3SkZ6dVM1YUkrWXZLczVUSGZvZTFaRnQvd0FJdEZkVzkyMWpORHFhS0ZaWEpraVpzWU94bUpCUGZPTTFyMm1uMzhFYkJ0R3VHdFJiUmtPckl4VWorRFlXNVB2Vlo1UHRGemkvV0VXc1daREJNRlNTVEhSdHluUEhjVTl5NUpwUjZPWFdTdnIzdlpFN2F4Y1drdy9zclM1NW9KanVOeEN4SzdpTU1wRERxTzRyMHEwMU5ieUkrVTAzbXhNZDZzRGdoZnZBanZnVnlGaHEybTNOcVVpOHVBcmxUYlFrWkFKd1NlVGd0NjF5bXA2SmI0c0lvM24wbTRrM3NzcXJ1VjBVOVhjY1pQcDNxV3RYdWJ3bEtDdkdTbEZyVkxSTDAvNEoyVng0ZDhMNmhPc3RwcHJSWFN5QStaNVRSOSt2UEJyeDY2MER4YSt0d1cxeWJhNmhlZVZvMUVyeHVHQXh0SDkwQWM3UlhaNnRwdC9jWDBCMC9VOTl6R0dLbWFWNDBKQjVMSUIwN0N0eXowM1V0UTA2ME9xWFpOL0dadm1oSHlGZjRXd01IUFlucVJRdDkwS1ZOVmViM0ZkTmFyUk10eGFWck9sM3dtamRaSVhRcXlsL00zakhjSEh6ZS9TczZDMHVySytOOVlRcFpveUZaek1WVVN2L0FBcVRuNWNldmVxbW9hajR0MGV6M05KYmtScEhHRjhsbWpWVTZzQW9PQ2M5K2xhbjl0SlpXNXRwd2YzbHUxd0lsaERNeWc0S0RPUVZ6MDcwMiszVWlQc1UycjFJV2ZOWjlINU1mZTZmcU9vU21HWFJFa1dRcWJoMHVnNklRZjhBbG9vSVBOVW9ZVXR0VUZxYlJab2cyeFZpQVpNRVpKWW5uSDBOWHJWOUkwdEx1N2lzSlpVdTFReVI4Ty9Jd0ZLb2NnYzg1cnBVUzBzck1RMm1tRm1HSCt6UkZJMnlUenc1R2NWR2hyN09NMm5kY3lkMjJydTNUWkxjc3ZjNlZiV3l4SlovWnlXYmEwYWNBZzlNZXRaVjNxR3UyNElEVzg5bXdETzdEYkpHb0dSaFI5NG11SmtqMUtHUVRMZjNrTVR5aVZiYjdGdUlVbmtNd3o4MzQ5S2xiVWJiN1pmVzFyZUxNODg4Ynh4M1VUNWpBSHpMZzQ5ZUtldHlKVitYKzYxb2ttbDA3ZFJaUEdsMFJOTEZGUFBaUk1oaWEwWGV6ZjNsa0J6MDlhODlqc3ZEMTVxMGw2THZVSTJreTJKSW1YYWM5T092dFhvdGxiMjc2bzFyYk85ckl5a3lRUnFpQlIxRG4xRGR2U3V4WFR0YXRMYTNIMmhwR2pkOWpLeTd6aGVGY2tmTjdVMGtaY3Rhc3J0U2tveTEwdXZSV2FLOW5MRm8xZ0JKZmlKbUdGV1JsR1I2Z0d1YVM5dDd1QnphNmhhWEpoeHUrWVlIUEpDcjBQdFhQM2lQcW1uUEg0aDBxNTh4Z1ZTUllzcUdQQU81Y2xmb2E1dlIvQmVsMkdvU1hGckJkMnp6d2pNS3NBSkNCZ25EOVQzSHZTYVpmdEU0cUtUMFh1eHRyOHlLMjFkVXVUYno2amVUUXJjcnRVUUt2VTlCdTdldGRWRmQ2b2wzTWwydHkxcnZkb3liWEJXTnhqNXNIT0I5SzRyVk5MMFN4bjAvKzBvNzZhTnlXTW5tY2h1VGx3Y01Qd3J0ZFdPcWFURGJ6NlE5eFBiaUlNN0pKdUdPcHlYeWM4OU8xYWFKN0hEU2xWaHp1VXIyYTkxTzd0Nk43RlZkUVo3MXRMc0xoZktFQUN1b1lPblk1RGRPS2p1UEEvaUt4OGk0MCs3KzBPcm5mREtRcWJNZndqUGYwcnE0bnN0Um0reTNhdmIzNWpEcE1COGpZNXp1QTQ5ODExSnRMazJteUxVNXpLVkRTUHRWaUd6Mkk0d1BTb2V4MEtuR1VwT1VYSjY4cmk3VzhyUHFmUEQ2anBTVG1YVTlJdkZjTmlWNG8vbGJCeG41ZjRSaXJXaUMwbHZyZlVOTjFMeTRvNXNDT2FIY3FidVd5VzVISFN1M3U5VnRyYjkxcTJvcGJzNnNxS2hPeHM4WkJDNHozTmVYZUxOYThTNmFIaGowT1dlM09BWlJoUXdZY01EM05KYm1DcGF3YWluTGZtYlVYZnpmUTd3YURwZXN0Y3k2VGR5UlhDeXZ1bWpZaEdZOWVPMVpiK0JuZTdNOC9pWWk0VlVZYk1vd1JCOHhkUm5KSHJXUmIzTHRvZHRQcHJMRGQzRGlPNVpqdUtnOEZTcTlTUFdyS2VHcGRLdTdWdnRWdE9QS0R5UWhtRGtkeVNlY0hyVldYY2ptVjIxU2pKdTNOWjZLL3dDcDFGbHEwOGl1OXJyMXZlcEVkcWVZQ1dHT25hcitxcENkSnZsdXBqRkpLRHZZNHdPK01nNStsV3RNdHRTRmpKTGJpejAyU1ZzUmpBbDNqcUNBY1lCOWFaZTZWYVQ2Zkl1cE5iWER5aG1hUzNqd1N3OUFNOGlvdnFhdUUxQnUrK3VyZGtuNnU1NUxhMkdsSk1xMkY5cThNVXFLRW1TVnBFemprRkR6anIwcjJnUE9JVWhzdzBnZ2ZIM1BMSVRHU3hQYy9oWE82ZmMyM25MS2x2T3N5eHNxVCtWamNxWVhuZDNGZEJxR20zRjVwMXFxenpSWGZtZk5lUXFJNU1LT1J6MnF0QzZicVRVcnY1cmUzYTVrWDNoMXJ5K1c3dW9aRWRSc1dXM20yWlh2dUI1L3JYSHRQUGF6UzI4TVVzRjJrZ1FYSGtlWjhuWEpmSE9mV3ZXWXRHamUxbjg4dmRzVUpUekpBY2xCZ0U3ZWhQZXZLdGJpc211bGp1dGFleWhaUUlmS25ZRTdlU3JnNTZVWDBzS2ROOGtXN3E3ZlhYNTdIUlFwUGY4QW5GRmVPWk1zSkZYWWp5Z1l6Zzg1cmdkWHQ3KzFzNFp0Um5qV1FTZ3F3ajh3cGcvTU1rWUFOZEhacnFsNHJ3V3NFcm9nV1Q3V3l0azdqZ1k1K1lkeVJVbHBxdW8yMTQ5anJtbnVFakRDS2VOUzBFMlRublBmMm9zN25QR2x6UTFUWDk1dlRVNGExMURXNTlYOC9UVVRVSTQ0Y01rU2VYa0hzdzRCcnFQRDlzTHFOR3V2RDVqak1wYkhtNENIUFVxYzk2OUYwNiswR01Ya1MzTGJzNENKRHN3RHljN2VUeFhJUmVMTENLNlJvTlB1WHR3NFdhZnlHalpsOXdjNUE3ZDZvcjJVZVdNbTF1NzlmTHpPNmFHRTMvbHpYaVJ5Uy9mU2VNQU9lbzJNRGlxMTlyZGxZM052YW03VkhMRnZMQ05zNUhDbmFPbGN6ZTJHaitKTGhyaTJ2cDJXRGFSYlNvVVFjZFJuQkRWMU5qWnJjSzF4ZFhDb0pJbzRvbWpVQmxWUi9FRHdjK3REU3NkRDVuSnFtbGR0KzllNnN2bVkwbHhmM1dtcElFaGU0RTRrUlVrSUpYcGxjODhlbFZJRjFjNnpOL3hNTHBsaldOcFBPWUJNTjFBN0VWWTFYV2RKME14UVFXOGtzVC9PWkNtUVEzVUE5bXJOMHEwMWU0MUtWL05XNXRIQmVLT1FjWVBLaHlPNFA0VTlQa2NjMUxtakhtazVhWDVYbzJqZjFHT08vc0E5bkpBclJ5dDV3aVVNSEFIM1dJNlZ3VTUxdlNKRjhqVFl2c2JSQWw0Y1prSjlRT2MxMmR0ZXdhTGR1a051RmU0a1kzRVlKS2htR0R5T24wcnlyWGZFTjlaU2tSWGdSWmlTa0tSN2xUbkdBUjZkNmgzK1JVcFF1M2Q4OXJOUjZXUFJQN1UwMjZzSjRMbVM2Z1Zvd1ZYQkxKdFBWUU85VUo1cksxVzNlejArVzVpak83em1KeVNSendlcHJOc0xmeFBCNXQwK28yc0xGeEdKV1hobHhqY3VlcHJzdkQwdXZpOHZrbG1rdTBpZmFrb1ZVTG5IcDJIUFdqV3pJamVUaXBmRmV5ZkxkMjNPY1M2bjEyd1VTYVpiR0hjQnNrbE1icjJZZ0RwajFydjRmRG1qTlpyNUprdHBva0NsUk5uSXozUHJWRjdmVFpiKy9lLzBLWkdZRU02UDhzbnVDdlk0cmw0dEMwZWRWdTdCN3FNYnlzc0ozRjBIcHoxRkd0dEhZMWFXdk1vMUhybzN5dlQxU09xbXRidHJtTzRlUkd0NDhrb3k3dm1YcVNUNlZvMit0Vzh0dFA1VWl0R3UxZ0VjRjlwUHpFRHNCWEwyL2lHNUZ5MWcranlpQnBDSlp0MlFxS09jRDFOZWU2SjRpMExUdGVab2RGbHRrbGlhTVR5c1FBaE9mbTZpalcycG9xa0UwNDFMWHZ6ZDEwKzQ5bWcwaXhFSCtpWE1oZWQyYU9TUmdXajU1cHVvK0U0YnllRnpmZWZORGo1MnhsdlFISEJGY0RQNHZza3R4REVHbGhrSXhLaWZNdUQyeFZuUlBFY04zWTMxczErSTBGeG1JZ0hjRlh0OWFXdlFQYllhU1VlWHBicWxkZEQwQi90K255cWozc01pRWp6STVCaGxHT01BZnpyTmx0THVTMGFleGhnZ2trYmF6QzRZQTQ2bXJGcEZaWGlMcUVOdjlwSlBsTzY1RFlUcnVCcUs1U3pheG1TR0M1bitZeStXUmdKMjJDbmN1Y1U0NnYzZFhIVzc5VTJqajdxM2t0ZFZ0THQ1cmsvTnRtamlmS3NRTytLNnk2VzZ2clR5NVlBMEVpbVEyNmJoSUNwK1g1dWh6WEw2WjRsTXNiVzZhYTZ5UnFjYjFJYmNlTWZXdE82OFNPTFlKTlpod2gyTklzdU52Y3FjZDZldW1oeWMxS0tsZXMxRnJhenRmczJabW5mWUpOY21FbW1YMW5OSzN5UGpjdVVHRHlPZ3IybEdnbHhHcmdQRWNzTThzQ09oelhLMlBpQy9OcmJwRlpURzNrVWtNSEJlRWRPZnJXUmFSM01jZHlrc3YvSDBXMkxnRmczWGpIZWt6MEtQSkNQdTZwdlY4dHVsMGQrcGdmVDdsSVNKSHdVOHM4Z0QzQnI1VzFDOTFUKzFWdE5MRjVaVFJ6S1hQay91bUFHRHlhK2hySFVaSW5hMGtKaWZ5eTNtU1JaWEM4RUVqMTdHaTJ2NTVwemt4UGJnK1hJZ3ljZzlENjVwSTNjb1RWUDN1V1dxV216UjVGZStHdFlhM0xiclZvcFhCa2I1Vkk5OCt1ZTFkZEJwZW8ySWl0WTRFSzcxSWN0bFhYcWNlaEZhT3RhRnBWaTZpMHZmc3lUQUEyOG1DdkhPNWQxZDFhWGxuYjJXeTZuVjBYQ293eDh4Nlk0cW5QVG9jbExDeGpVa3RZditibVRYY3c3dS90YjJ3OHNTV3l6bktuZGdqajJGY2sxMWR5Vzd3Qy84cDFoQjh1SWNzd1BPMzNyb3JpeTAyS1MyenBjVC9QZ3VEbllEMk9PbGNmY1BwTXV0eVJXYzBUU1F0dlhHTTg4ZDZGNURyZTB1MjVLK2tiSnRYS1ZocVU1ZDdhUlpXa3p2UnJoY2xpZXdQVDYxc1R4YWJGSXJHMGVDWS9OSVlrM1pJNUlCOTZ1M2VuVHBwNFZwamNEY0R0VlJ2QlBmSTdWbVRwY1dkcE5Jc2s4U0IxS2dEa0QwNTlhcE81ek9GU0VGZFg2M2FXaU8zMDd4QmNYVm5MRkNURzI0L3U1azV3T2h5T21heVc4VVcrbndyTE1nMlNGZ1NxN3lYNzlPMWNGWkw0bzFPNGx1WUxtRldNYTc4RVlJWG9QcjYxZUZwclUwa2xzNldqeHM1TWpLMjFrejdlMUt5dVJIRTRpVVl0S1R0ZFJkdEdQVFgyeEpkMnJPWEFBS1l3Q3A2WXpVRDM5dnFxdzNzVG43Ukd5SlBiU2pjbTBIcVBldHQ1alplWWx3TjZqNVlTRTllUjA2MDZLRFZ2c3F5MmRwRzhjaTdaU3lBRmZSdmVta2xzUS9hU2ZJNU5xemJpbGRwOXp1TlFlMkVsdTdYUStVRkJFamNNRzl1OWNYcGwvNGN1STc2RzdrZ2pVRGE3S2NnODhEbnY2MWR0Tkcvd0NKYUlyMW9YbWpKa2laQ1FjbnB6NjF4MnA2VGZvenZaUjJVb0Nxa2luQmJjZWVhbEwvQUljN3FrNmxveTVGZC9aMzNWbWFNbmh2VGJPT0Nld1pabFIyYUFCc1lKOXgycm9MQmRSVkV1SmszSytRWWNuQko3ak5lZDZaNGhPZ1FNMTNwbHdtM2NVTEw4bUNjRUQ2ZHE5RjByeGxvZDBxM0V6TkZzQjJxZW5QU20wNzdHTkowWEpOejltMzA2SitwMkNsVmhYN1pBa1prSkt2R3ZBVWRNbjFxdmVRdEphbnljc0NoVUlEaHNZNmowTloycVhqMjFwTTl6cUMvWllrVmlBbno1Ym9LNXEyMWczSUMyRzBzUjNiQkE3OEdvZTUyVHF4VXVWM2QxLzI4L3VMR2xKZHpYUGtwRlBhcEhHdURJd1BtTjNKOTZ5TjkvRHFkeGJ3MjR5VUpmZTNjOUNDZldsdXROOFpGa2FLT0hZaUZoSXpZQVBiclYrd24xUzdsU0src0RETW9DeXlyeU9Sd2Z4b3N6Z2syNHdnMVVnK2JkcTEvSmRqeWpVZkpzWHQ1dFVhNDN5b3lsVlhmdEpQZkZkVDRjdE5PMHpVaGRTYWdYdHBZZHlvL0EybnZWSkx6eFJvdXFYSU5qRmUydm1zOEpIek8yUjBPZTRxanFuaXo3YVlWdnZEZHdxU3FGVXFPaHoyeFZQeklqUWhDTjQyNTR0T3p1L1BjOU4rMzZURHF3bTB0RWxXNFVrQUhBVWoyN1Y1dS9oL3hMUHFVbDB0MnJBRm1KQjNiUVR6V3Q0ZlN5dmJscE5Pd2tjVWVDSlk4RWV1RFhyMFZqdEt5UnY1REZRT21Bdzc1K3RWc2J3b3pyT1RrckpTYlNqb3ZrZVpXbWxYOTNEdnVaSS9NamZBK1RERWRpZnJYbytrZUd4QmN5M1ZyZE95bENDck1jQmozNTdWdytwYWxxdHZhUmxyZFRJakVCd2VNZWhxMzRYa2U1dldsYlZDTjBZRFc0WUZRUU04ZTlQVzNrS2pUdzZyUjl5VG03TzdkbitKcDJNdC9aWGx3dXBMdXd3MlNBNTY5eFhQZUp0VjBsTGZ6WTczejlnMnZHb3lSMnJvdFpTSFVaQTg4Y2x1TFpnNWNuQVpRTWMxNHlsdFkzT29SVDZOSnRpRW9TY3lES3VBZmVwNmlyYzBZeWlyT0QyYitJdno2SDRZOCtHWlpudDdpVkkzdy8zVCtOZSs2YTg4ZHVnZlpJcWdnR000T1BYaXVIdTdYUzdxWjBua2hsYUloZG5UYVRYT1QzT2pXbDNCT2J1UkVWOE1FSkM1NllJOUtGclljWk9sUFRsNkphOXREbzliMCtIVkxLSzNpdkhnbVdmY3NvUE9LczJta1RRbU5JOVZrdUhoKytwT2MvVVZkYVBSNXJwZk1ra2pMUkZ3UU9Eayt0VWROMHkwczU0N3V5eWpDVWg5N0U3K3g2K2xGckxjMmNYenB1TVhycTFMVzNvYnQvSVh1b28zalJFa1VEZmpvZlFqM3F2cU9rc2p6SnNWZ3BWZzZqRzRZNEFOY1Rya3VzcmVYRHNNTHMzUnR1K1VNcDRQcnowcmN2dFl1MTB5MlhkdmVTSGMyd0VoY2RzMGFxd09jRzZsNHZ1ci9kWWwwK2V5UzVuU2E0OGp5MkcvY01ubitZcWZXTk1zb2JyN2JGY3lBUkl3T3psV0k1QnJuRXViKysweHdMYUl6NUIzTU1aSG9hZlBiYXJickZQNWpRRmljd0ViZzNHQ09mV3JlNWtwcDAydlozV2tsS3pWdFRTKzNheHFsdENrRWlST3JBZ2xSa293N1Z5dXJlSDVMVFZMU1hadUcwbG1RWWJlT3VhMTdkNzZPOVc3Z0tlUWpCbXp3VndPUldCNHIxN1Y1SWdZNFZYekpQM0xlcXIxTlRyZEpXTTV5cE9nK2R6Y3JxemUxbDE5Q2pyODkxSmFUUnhNMGNrTGlReTR4d1IwclkwelU5YmwwbU56cWtVekJjS3B4MUFxWFRkSm11MHVFMUc4REM3UkR0WGhoZ2NZcnpxUHc1cW1tWDhOaWlOUFpNNU1jbytVZ25zMzBxZE5qT1NxSzgxZmZaT3p0OGowcUl2cmRzMWxmckxDNVFNem9lUGw0NHhXbkpiMjlqSkM2YXBMRkF5cEVVWWJ1bkFOY2pOZjZuWXl2RkZsWmtHMlVrYmhnY2o4NlMrdmwxclNtZ1J2TGszSnlWeGtuMDlxcnNSR3VwWFR1NTMwYjBlblRROXZ0NDlTVzNRWFRpZnJza2orVWxlMmNVVjRKNGV0L0VtbFBjUlQzNW1UY2ZLRzdnS0QyelJXYjBaNzBLc1ZGSnA2ZlA4QU1aZGVFdGMvczV6ZFBaUE9zdy8wcVV2OHFuSDhJUFgxN1ZhMDd3amZlYkRJdXRtMEc5VHZnVVRLU3g3cXc0eU9CMkZUSllQcWQ5OW91UHQ5eE1VQmtlNmg4dTNLSzNQM09BZTNmMnJwNTlWdDlOanRsZ3VyT0lDVWdRb1djN0crWUsyZVF2djFxK2g0bnVScUthanBIVlhXOXpQTDJXbjZxOXJOcUVyR1ZnWTVpVlNTS1ZUeEd1MFlYSS9PcWVwNjVkUjZqYnRONFoxbVpVZFBObmdJY1NqT011RnhqSjZIdlhZTnFHclcxMWZRcmIyZDJHUm5lT0ZsamZjU1B2RitRVkhRbkdSMHJtcmJ4VnA4REd3ZTVzN2RaZUZqODc5NXhncnZkTW4vQUJxYitadlQ1Rko4MU51N2QxYlR5SnRWbjhPZWZjdFBOZk5keGhQM2NzWWlXSXVQa1Fxbkl4K1ZRdjRkaWt2SUk1WVljZWFpeW9ON05IbGVCdUpYSVBjRHBXZGMyWGhSWlo5VWx0b2RSMUMzWmk3UXY1cWhjL0x1d1Z5UjJyVTBhRHdycThjczFvc25uaU1TSktZNUVraU9lSXljZ0Z3YVBSbWJqelNpMGxkVzhyUGUxOVQwSlpyMW9iQ0RTcmVGdHh3L25SU1IvS2M0Q2wvWWRQU3M2U0RXYmczTXQ5Wld5RkMyenl3emJ2NGNaWUJlTzFRMjdXZGhJSXRRbml1bmtkY01rSWQybnh3cnFySEQ5UUNjVmVhNW5uMUszdDdTMGkydkhJSlhuZGwyeG9kb1RDWkJ5ZTlKSnBIVmJtaXVadGU5YmxUMFZ0Rm9lUDM5enB4L2Rha3M0YVhZV1NMT0pGVnNLTUsyMWZjZGVhNjdUOUJTeWtqZGJlNlMxK2NOR3pqUHpIQ0JFQUpBQlBPZURWbTVGaXQ2SXY3Smx2WGFNcUdpWlpFV1FGamh0d0dRS29hblByVmpjQ1FYOTFiSkpNa1lEN1pJdklSY0hidEh5blBBeWNtcTM2SERHTVZHVGN0RStuZnp1ZWpwYVgxbmRXNzJwUm90eFYzbG5YWUFPQUdDOTJ6d0t2NnpvN3g2ZWpQZHgrYzhzZ1V3b3Jzb1k0QnlvNXgzejJyZ0ZXenZiWTNWa2JtV0Vxd2xFTVlqRW9QTEZvZ2R6WTZacHMycnViQ1Zab3JtYTFKUldNK0lsaDNEaGlWd1FDY0E4WkZKSFVweDVKUmNIcW5iM3RGOXhZaFBpblREQ1pOVFdSQ01XN0xHTjV4d1FPZnlGTHJkbTk1QVFZRGJySVZra2xTY3E3Z2ZlRHJuanJuUFN0cXcwRzNuVXkzRFc4SStRUmJXYWVSZXdLazRBUEhZVmQxTHd4cHNzN0t6ekZueG1JczBaMjV5eEFYZ0tldTMxcExZVXFOU1VOTlZiUk9YK1o1WHA4bHpCcUpnbnZJYmdJcE1CblpaSkkzZjd1SFJTRGtmamlzdTh1SnZ0a2IzSGlPNHNyYUlsZnMxdmFsbllEa3M1R0R0UGJpdlJKdEYxTDdVVXQ1TFo0a0RNVHZaZk1SaHRBWmw3TGpyMXFqcmNiNmZwdm55NkhIT0ZLRHlBZDBpbFJrdEV5bkp6ak9LdFdNNHhxd3Mya2xxbmRYMzlESGk4UjZMOWt0SUpQRnNjTVR1eGcyMjdKdHh5eXZ5Y2NkUGV1dGg4UmVEUE1lT2U4V1Y1Q1JHMkczNFlEQUc3QjJranFLeHJIV3RMdW80VWxndDBrVkZaTFdWbFNWek55VlpTQUdIb1FhcGEzWlcwK29RaUczcy9OYVJsUnJoZk5sTElQbVpXVHFCMEF4aW8wYkx2R0tUaWszNTNrbjIwZlE3TFR0WGpYeW80R1R5b3RqbUdhNUVoanljQXIxT0RuaXNMeEtBYlM5bG5sTXJ3QXNJb21XUUw1bytVTmdEWmc5K2NpaU5kSGdSSnRmZXlsa3QxTHhNa0lpbFVBYlVaUm5BeWVCbXVMdjdEU3RkMDY2MjZuSFpUd01yRm1tUmh1YmtJKzBET1IyT1RtcVRSRlJjMUpRYlRUdmRQb2wxc2p0Tk1GNXB0dGJ0ZTJuMmUwRUlFcUNQekJ1a1BKeXJEQVBVY1Y1UmZQcWtMejN0bHFkMk4rN1pac293MGFPTndKYzhFREJZbnBXcDRTZDBnU081MVNTZEhaNUVVUnJNWVRHYzczQis4dkhHTzFmUlpsMGpXclVRQzJqdU5zYmx0MFJVTXU3RFpQUlNTZVZ6bWwwMUhSaENiMGtueXIzVTlYNW5uZGhiMjEwWGtFOFRUeXhHUjdZaEgzSzNCSWJISkhUSHBXSmQyTERWclJyZTcwODI5dTZLMExyNWJoang1WndNRWdEcnh6VnFId3BvVm5KYnVOSVNHUkNWVlZ1M1l3eHRrdEl1RHpqcmp0WE5XbWpRYlZhNG50WUlKSi90TnZJNnRMTXhKQkN5S1J1eXc2THhpaEozM0U0d2phS2pmWFZ1NisrNTdkY1cybHRBTFMwdUJISXdsWmNSRUt6Z0VsbWFNOUFTT2VsY0xhYTllNmZiUXh6NmxjMzc0QVNZeDdJeklUdEVZM2NzUitncmg5WnY5WGl1ck1pODh1eVZIRDNDUnNqQUkyU3V3ODc4OEVIakZXWXROczcrTkxuVGZFY3EzRVJMVHhUZnZCSXZUQ3NNYkNUeFUyTDlzNVQ5Mk1ZdExvN2JmZWVtNlZCSmJ6VFQ2cjVNVWQzSXk3SkhJVENMMFE0RFp6M3JzeFlXYVNRSkdxd1BOQTBrYndLenhTTW5HUXg0eW85ZWZTdm1ieExxR2wzOGNHaHRIcXpTeEhkOXVBQUNsLzhBV1JqUDVFL2pYcDFwcEl1ZkRac1hGMXBNVUxva3J5M0lrRFJvUVN5blBCR09TYUVkbE95U1NpcExScFBmWFhjNmxiZngxcG5tTkRhblU3ZGdpcUk3aU5Db0lPNEFTRGo2OXpYT1dQaW04dDlTZURWbnNiZkVXN1pLcGVjamtiV3dBdTNIVWpyVVZ6NGVpbXRveEQ0bW1salZWbFFwSU42S3hJOHg5dU1wbjE3MTR6QkI0aXZMbERKS3BqOHc0a2ZiSUdSQjBZRWIxejJPS3JvekNyVWxCUmpGTlBkYzA3bzladS9HOXJZcGRTUnp3dnBxK1k3U3d4dHhnYlZWZ1BYc2E0YlR2RW5nVkpvYmlXR0Y3N3pJMldTQ0VGbFhyOHdJeWM5Zld2UUxId0pIRGN2Y1JtWkxtUTcvQUxPN0g3bVA3cmNFZW94eldOWmVCN0M5djVMaTdoMDJGM2pkV2FKOEY0MFBYQ2tBSHVmWFBOUjAzSEgydjJ1WnQzNWRGYlcybXZZNjI3a2RUQTEwRUZuT0M3eVJFdjVaSjNCeXgrNnJBOXZwVlNMVVgweTIxRjU3NnprdDRZRjJ6Umw5M2x1MjNwanJ5TTR6VjYyVFE5S3RXdExhV0dWWGpXTmxDTkp1Yk9BWTA1eU96VnoxbHBPbVEybHJMYjdUZVdoZU5ZeXpReCtSSmxpRzgvSVUrbjVVZHV3cksrOTNxM1ozZm9qU3U1dkQxMElMZURXbzN1Yk03M1NlZG1VTkxsaEhrYlFISkgzZXdyMG1hMW56YnJkei9hYmFSeW13d2lWU3pnNXh0NllBeGs4VjV2b1BpTFI1b0xxUzd0ckNFTE41MXh1WE81dVZRRElJQjU1YnFlMWM3b3ZoMWRPOFR6M2NXcnpoWlhKdXJkbnhHeEpJS3hyeGpBNFhIRkZrYjBwVXBlOUZyM2tySlhXMm1wMk5tMTFEZDZsQTlzc1VLU0lMZFRhbmEwZTBCeGdkVDZkdTFhZG5McVVXcXNzRnpkN0pVWkk0cGJRYkk5cTdnMkZJSUp6MXg3Vnk5eGVhSWtGdzF0ZlNHVzJ1VTNSbmV4amQrUExreGs3ZVB3cXRIcU9zelNGMDFLTjVYVWgzdHdHaWtkT1ZVN3pnSEg4WEJ5S0w2bVRxS0Z0WDhTczAralo2RmQybXZhZWlYRFM2ZmJyZHdzMGhiY202YUxDbmR1NDVCemtmU3VYMUswMTZhYTFqaWFPU0dPNURLOFVpeHlvdkRjcm5CWE9lRHpYQko0N3VydXhaTlFtdnJ5QlhjVExOQXJ0RXpaMmxXVTRDNTRJL0d1dTA3WDdHT3lNbjltVEVJeG1iTVNpVmhnWWRmTEo0SEhCNjFiYXZvaXBUb3lkbEtjWWFieTE4KytqTTFyN3h2YnRmNUVmMlBFaXFGakhBWTREdVQ5MDg4ZTllaytGOU51WU5HV1IzblNCZDhwbVM1ODh2dUh6TmpIQUhRWTVyUGkxYlZ4dHV4cE4zdXVWL2QyM2tyNW5tSG5jV0J3RngyTmN4cDFuNGhpbmxONXAxeER1aklpemZlV0l1YzhvZUQ4M3B4VFcyaUtpMUNwelBua2tudXRGOTE5eE5TdXBaUHRNOWpyWXVya3VySmJYUU1iN1lSMGlKNDh3a2daeHlhdTZMNG4xZWUrK3lYaVd0c0hsWU5FNnltUW9vRFp5bzJodmJ0VVdvNmZkM3QzQXMraFd6RGNjU1hDQkpGay9pQ3NtVHU3KzlPMVMyOFRra1JlSVE3d3VKWVJraDlwUS91NUJrQW5QVFBXbG9FWnRLNlVsWjY2Tlg2OVdkYUp2RGVtUGR6U2FsSTBjbnpaRUNrTzVJd0MyRG5IcFRyKzAvdEZZNWZ0YktnK1JVVHl3U3A2TDkza0QwUEdUV0RidmR5MjBFTjZzYWVjc2JzMXVpbHZOQnpsd0Fjb2M4K2xOczlhMUVBeFROZDJ1MjRBVVEycWt2R3VRVnhuOG1INVVGdWROcFJla1gwU2ExMzF1elB0dE1OdHJDeFhWMUI1VVoydzJseEJBSkkxSFFySXB5Qm5vZWxlelI2ZHBzMWxjUXhocDQ1TmpLalNibC93Q2VaTzA5TWR5T3ZXdVQxVFVMZTRHbkQ3Q3NyT0NyQzV0eUNRbzVHVnlGWW5zZURYMWQ4T2ZBSzZ2RmI2aGV3R0syTENTS0Jma0VyTGtCbUg5MzJyU2xTblVrbEg3ejJNRGhLbUl4RHBRaXBKclZ0Yko5enpUNGYvQ3p4QnEyb1RUM1V4dHRLQTh1TkZWV2Rpdkh5TXd5UjdtdjBnMExRTk0wbXpTRzB0eEdnSFBVbGo2c1QxTlNRMkZ1WjRtQ01DaWxRb0pDNHhqT0J4eDJycVVhTkJ5d1g2bkg4NitrcFVZVWxwdjFaK3Y1YmxlSHdjTFJqZVhXVDMvNENJamNvc3ZsS3VYd0NRT01DdDFSeDdWUlJnZVZJTldRY0wwQTRyYzkvd0NSRmMyZHRjb0ZsVElBNDU1SDBOZWJYMmdUcVMwSk1pY24vYUg0ZDY5TkRHVHB3djZuL3dDdFZzWTlQcFh6R2JaRGxtWjArWEVVYnl0WlRqcEpmUHQ1TTliQjVqaXNMTDkzUFRyRjZvK2JaYk9KV2JkRnpqQjdmcFd0cGQ3TllCbGkydEcvM28yR1FmeDZpdmI3cXh0YmdZbGpCUDhBZTZFZmpYbjkzNFdjWmFCOTNYNVc0UDVpdndMRmVIK2JaVGpmcm1VVGk1eFRWNEpVNTJmUnJhU1B1Nk9mWUxGVXZaWW1MaW5hNmw3MFgva1puMm5TYm9NcmJyVnlNWkkzcms5d2UxU0phYXBhd3Mxdklabzl2Q3FmT1ErbkJ6aXVhbnRMdTNiRXNaWG5qY01mcjBxZUNhYUZneUZrUHFEaitWZXhsL2lCbkdGcXFobW1BYmt0T2FNWFRuODR2Ui9LeHoxOGl3dFNQUGg2cVNmUy9OSDc5eWhxdWwrRjc2TXJlNk5ISVNjTVl2M2JjK3ExNFpxM3dkK0UvaUhDeVdrMXRjZ2xiVy9CQW1peWVFTGdaSy83TFp4Mk5mVWFhcE0vRTBjY3d4L0dvei8zMEtiTmJhVk1tVXRCRSs3SjJ0dzJhKy9xOFZZSEY0T1VzSldoN1dObTZOWk9LbXVzYjYyZlk4YUdWVklWT1N2Q1VvUFJUaEsvSytqc3o4NnZFM2hmeC80SnRacklhck1Jcmc0Z3Y0NHYzV2M0MnNjTVkzSXI1OTFhNVRUV2hlNXU1WjdObWJ6a25UN1MrOERqYVJ5UUQrTmZzODc2ZFBZVFdHcDI2M0Z0SWhVaDEzcVY3cTQ5UFExK1ovai9BTUthdm9lb0Y5RThsTEZwV1NFUEdmM0tzcHdyRlRnODlDZTN2V3l6aktlWENwWWlFWjFueXdwU2t1Zm10ZTJwK1JjVGNQWnZCVmEwRlVxMEtWcFNTdTFGWDNTN2R6eXExdUxXU1VYZGxwbDRVSVFwSTlxdHNGQTV3Q3h5UWZTcnQ0OENzOXlkSmptbDNwdWxqbVVTT0dHTnhRRHFPbU90ZlA4QVBvK3VycVVEWE9yUzNjbzNob3JRbFZKYitIZklSOVFCWHNPZzJPc1ROYmZhRmprdHJlRm9wSXVWYmN2TzdiME9laEdmZXZYNm40cjdTY3B1S2hiWG9ycFA1bzRmVjlNbTIzdDVERnFVY1VpbDVUSTVkbzBBMmpDTUIzOVByWG1GdHEwbW1TVHRGZTNUczRWWXJrd3VZMllmd3VEa0RiNml2ZjhBVnJ6dzdiV0MzaXl1YnE0Mkg3UENYVm04cHVBRlBSbDZHc0t4MVNhNTFPZUFQY1cwc3F0UEN0NUNQTE8zcW9Ra2tudjh2MXFUbm5TYm12ZTFzdmhmZmJzWTR2Ym5VYkN4bFl5UnpBc3lvWlZNY2l1TUhjckVOajJ4WFJXbDNhYWFzZHZCSkRiM2JRa0pGTGNIQkpKNFZWUEk5eGlxNFc2MVZvSjdxNGhiWTVLTEJBVlo4Zk51YlBVRHJYRTY1ZmE1cHVxUlg3YVF0M2FySTJWaWcvMG1IakJjTTVPQWV1T2hxdWlSVk9EZFZTdTIybHl5ZHY2UjI5dllOcE9wTGR2cGtIMmk2VGE1Tjh4R0QyaXpuSno2MTZiSk5ZeDJNazBGODhSTEJ2bE85R3poVGpaempQV3ZKTkM4VGFUZTJxenJlM1VjOHM4a2kyalJqZkdBTUxGSXk4QldQemV0WVV1b2Exb1dyTktZTlF1SWlGTHgyeW55RjgzbHVNTVQ2OG1rZEVadVB1cThyNmQ3UDVXUFo5WWl2YmFhZVZyaDJQbHFJWXdna1FzeEF5U09TRG5vUnhWK08zdDdpTTJodDdxRjBCWlZWU2thZkx3Um5oaGs5cTRPZSt2OVFOcExiWHUyT1p2M2tGekVxeWxUL3dBODhnRTVxYTkxUyswT1JybHRQMUtaWkNnV1MxbExvNUgrd3hPUGNVOURXOGVlVWttNHUxNzY3bEw3RjRrdExDN050cUJ1N2dPanhtWXBrb2VOcmhjNDlBYWswbHRiMU5ibzZyYVJrU0psTmtZVWhWT05tVDE2ZmU3MWYweSswcWVYWlphWExaVzdzcjNabVZGWmgwWldRc1R0T2VXSGVwNUVuc0VrV0M5dG4zYnRsdkdkemM4aGNNU2Nld3E5RjJ1WXVQd3ZtdWszZEozVCtUS2IrSDlOTjFORGJpNnRKSFRjMHBRTjh4NkhJemtEMHJxVEJxczJtU0NYVjBtbnR6dzhVWmFQKzdsMFBISGNWeGVtWHZpb1hVSGx4MllUN09xSy9uQWVVekg1anR5UVZIYnZYVXl2cU52RjVGMnhTUjVBVGRRYlVZZ25nNXhnazQrYmlwdTdCVDVZcHYyY2ttbmV5c3ZJMFU4UTZXWkZzNTlYUVhVU25KU0xDazU0QXozNDZBMWp6MnVoWHVxaTdpMXBnSW1iTWFNd085Z0Z4eHo3NEZOdlk3SllIUzlhQXdKTUdoYVZkcFV4bkdBd3huZG5vYThmdlY4QzZSYlhrc1VwdWd6eCtaQ3JTU2JOeCtZUmhTQ1B6cDZQMU5uT1RWbkdEMTB1M2ZUVHpQWjd6UUpMUzhpdTR0VTFCN2NBb1k0UDNtR1BHNGpyanNRUlRMN3cxRmVTZmE1cFpaWTRWVmtTWGNGR2VEZ2dEQXlPUWE0alMvRW1qVzFySE90bGQyVnNubU10N0pJeFhjMzNzTGtzZjZWNnVOVHM3ZUszZGI5N2tURXVxUGtpVmNaM0xuazR6M3BhcXdsN0NVWGVLdGRONjZYK2RqeFRQeENhWnBkTjA3VDVBODIxWkVkbzNWUWVkMmVwTmVzeHZjNmxlUEFZR0Y0YmNicGtYTVMrbTR5RGsrMWMxZTZuY3ZleG1DM3VaSjVwZjlXZ0tJRWJqbnNQWE5aV21tOXNybTVuaXRKYkJpMjRTWEpPeVNRZFJnbkdUNmlta3VwaEdhVTBrNU5YOTVycjErODlHWHd2YVcwOTdlekxxRE56SVZTWnM1N2hVemdmVEZlVytKN0NIVWJXT1czanVyYTVaMlo3aFMzbXR4anloa2l2V0Z2OVExU0tBVzF2YkNlVmQzNzJSZ1ZMY2t1eTU2NCtXdktiZSsxRkxtUzNudUxXK3Vkd0xRZWI1b1NRRWxTc0lBNUg5N05LeHRYY0drb1I5MTZ0OHZWRVVkNWNXK21XbHVpS3R3MEtzOTVjUUU3Z1RqWWVlVGtkNjZEVEx5TyszUjZqWWJGa1RZenBHNk14eUNTb1U4QWlwMjErOGE1Z3RYMGVkbU9QbkNMNVRuT0RnRWxnUlZZNmxxVnJLMWpQdWFhT1IvS2haQWp0SEp5TnNoR0NGNzBKeU1McUU0KzgrVlcwNWJyMFp1MkdoYWZkV3MzMlY1N1ZXZHRnU1IxT0VPQnVTUThrOTgxd211Ni9KYXJOczAyVzdOdFBFWGlueEhLbkdDVVE4N2llL1N2VUpHbHViVnZNc0pCRklDUXhjcmtnY2drQThWNVZlZUdGR25UWGMxMWVQT3FrRDdMTjVranhBWkFZUDFBb2J2dmNkVk5PUEpEemswckxUcFl1RHhmQmZ4VENld3Z4Q01LclR3YlZRK3J1dk9QZXVtMDNRNUlicTNKYnlFY014anQ1UE1VcTJNbjV3T005cTh3c2RVaHQ3S2FXTzV2TDlHMmw0cFJzbGtqWWZlSXh0eG52WFcydW9pK0NtT1M5c29Za1dVd2gwallaR0FWNmtnZW1LRll3NTR5bnpTOTVyWkxmZnYyUFNOWTBUU2I3eVZtdWpCdVlST1Z5ck1GUEE0emtFY0d1ZG0wK0syMVNPQzF1SUk0SXNpU0tOeVpTMzhPN2J6eUJYTnA5cHZOUURSZjJoY1J3UkVocEZSRnVGWEpHSDRJYjByZE52ck4xcDh4MCsybXNwMkNzNGRFSWZJR1R2SFVxS0U5TEczUEdiY28wZGJwM2pxMmwwTk9hejBlMlYzZlRMeVkrVTNscnRNeFZuR1NRRzR4NmVocm1MeU9DZDlOdkV0ZFJsRFJnR0c0SGw0SStYek5yY0ZnT29GYlVWdnFWamUyOXBiWFYwNVZFV1JKOXN3Wmp6dkRBakFGVTVKOVppbWx1Yi9WNEdnM2xZMDJPeXF5NXp0R004OURUUlY0dU1sS0xWbXVpc3JFOXJwdW5lWXM4WXRudHQ0eElXTVJYSndSaW9yNjB0cnF6dW9XMCtTU1dSbWRETEtxYmRuUlZaVHVDa2M0cmhKTHUyZ3Y0N2k3ME41bzdoTnErVFBpQkZ6dC9lS2NiVHoxTmVnVzFwYVd1YnROTWp0SXQ0Ym5FbjdzY0U3OTNmSDBGQ1ZoSnBxeWlyUGV5MlQ2Nm93MHRmRDE5QTAwdGpieVNRRUFFczJRNEErUlNEeVBTc2JVTEVQY3JiR2VheENsUnVXMFp5NnNPZm5HTUd1bGx2OU9OdlBKWmVSc2x1VU1NVVk4dGt4d3hZZ0hkL2hYZU5OcUduV1NlVWlUVFNMa3hqSkRFY2pCYk9DZTJhbllpTk9NNHRXamFPc21vMytXbGppZElzZkZkbmNCUmUvYm9wRVhKVUtraWdIR0R1Qnp4MVBXdWhoMTIvRjdkbTZ0UkdOekw1VHgvdkVCR003eGxXVTQ2MVZ0TGw3aWEzWnJDU3p1SElaMklJQmMvS1ZZS2Z2RHJrOFY1L0hyOEUrcFgyblQ2bExIdFdWNHhLMGNiYmgvQUFUeURWVzdtdnRGQkxsbExWNkxwdDVtM2Z4YW5xYVNpQ0s0UjJjWm0zQUlvQXhnRk9kM3JWUFRkQXQ3cTJFV29BUzZoQk1Sa3lCakdPdllEUEhXdWE4SFNRUVF2Y2YyektHazNwUENZdzRqY2YzU0NkMkJ6NzE2eG9WeGJnWEhrRHpXZkRwY0tvRWJjY2hjODU5YzBXc2pscHhoVWNYSjZ5dmRjMTlQVHVjOWNTYWxwK2xHNWVaTXJLU0JLY2ZJcDVHVUhIRllrM2ltOXRuaGpNSzNpWEMvTkZFdVVjNTZxVzZFVnJhdnI5cUk0a24xMGdUWlF1a1NFS1dIUXJ6engrTllXbCtIOVF1dEx1Ylp0Zmx2NG1rSGwrZmJtTUlWKzZBUjBIcUtMVzFzRWxLMW9WSG9sWk5wdDllK3gyT29hZUxtT2VTRHk3SHpJVVZYWnpBeGtIVUVuZ25GYzVvVm5DbDY5cWRXdko1UXNjaFV5SzBMRmVNQURrMGZZcDlOeGIzd2l2UktjdkVRU2k3UjFKY25Ib1Awcmpmc0dvV04vbzdDeGdpdDdva1JzSW1TVlhKNUhIUWp0bmpGRnVoRTZyVWsvWnU2K0pkbGZ5OVQyTFU3TkN0d2doK1k4aGw2TXg1SVBQUTE1MW9LYXhhWDV0WkxRS3M1ZC92WldOUndxblBINEN0L1U1dFRCa3QybG04d09odHA3Y3E3ODl5cmRjRHJXM3BtclFYQ1R4WHlmdmJkd0drZENtU2NqSnp4elI5bXh0eXdkYTkrVnB1ejI5VWFGMVpSdGF1OW85czRBMktqS1Nxc09PbzYxNHhvbDFlNmRORWw3cXdpdDVWTzd6WXZLeGdrWVBIR0s3aXl1ZkR0eDV0bnA5NDBVOEUzeldqc1VZNE8vNVNmdkxWZnhMNGdHbFFYVDNtaWZhYmU3WU1BekFobEgxL1FVcmRMWEZPTXBPRW0rWGx0dHF0ZnlPVDFPdzhNNm1NV1dxUS9hQVdXT2NUZVdIT2NndDdtdlRJZkFsdGU2SUV2NG94SXE3ZzhiL01HK282ZzE1Q2svZzNWOU9pdmJQU3JpSzV0WlN1eEl3L0w5aDI0cnA3U2Z4dGF3UXdpVzJnMnlob21tRzBzaDdPY241ajZDcTFTM0ZHTkpUZk5UdlpXOTNwY3FONGIxNjF1STFlZk5va3l0RUh4SS93QXZCQjlBYTlBT21NbDJtb0k4MGUrSm8zaFFaMzUvaUdNOUs0ZUY3MTlWa2tOMUJFeUhmUEFaWHhoZVdBM0RuUHBYZExxMTlxU29tbUNCMmlYSmVTUmtlRmh4amFCejlLYlR0dVkwbFQ1NmxrOTF5cmR0cnNZTWxuNHpVR1RTV1c1U05obGJsaGxSakpIMUhwVUdrWE9wVzJueXJxOHplYThwZENveHVCUDNDdzRIU3RmUXIrT3hnWmRRVnJKZ1hMeUFzOGJzM2Z2d2V2TmEyb1M2UGN0YnpXM2xYeTNLaFpRck41UWJvSDI5QUIzcWQzc1drdlk4eW5aNjNpM2ZmVGJjMElwN1MwdVdqbWljeFNNY0VJU296emxlcHg2bXNmVTdXMnNybTRqTUwzTnBjZk1GTUtoSXlBTWtkNmRxVmtndElHRjAwYlFRYlJMQytQTENudm5nZ1ZXbDEyYXlqRnk4c2VwVzl3b0N0c0RGT3hKMjlRYUxHc3VXelRYTGF6VXJYc252OGluck5uTHBjQ1Q2ZVBObUNZV0pJRkpFUjZ0dEhXc3pRcks3YWZ6cm1XRXd1VUlDd29yRmllNFhvZld1cmkxNnkrd3dUMjhzUzNNa2JxRDl3T0FleFBUMHF4YVBvZW96T3N0bEhHempJbFIvbVFqRzVmcjN6UzdtdFNOUG5pNFZGZDJ0Ry91dlQ1bWxkWGxqcHpyYnkvSTB6a0JFQno4M1J1TzlaVjNPMXRJOXhjeEw5bk9FREJ0cmRlU2ZRZXRYYnk4dFVXQ1d6VzN1a2lrZFk5K1NVYkdQdkhtdm56VURjeDY3S0pOQk54RXdEektMaG1VcklleE9BQm1oWFlxbFI3WGphK2x0bDgrcDZUQnIzaE5MdmJIY08rUms3ZWNrOU1HdHUra2oweS9zL0wweUdWSm56bnpBTXlIK0lnL25YbjhXcFdxNnZIWkxvVnhCWnhyOHMwWUJUZDF5VDYrOVg0L0U4V3JUVHhLZ2d1TGVYRVBuSUdEQ1BqR1BVMDdMdDZuSk9UNVc1U2luZE9MUy93QXpvcjFyOWIxNEowaWUwdVBrMnIrN0s3dWNqMnBZRGVXanoyLzJNUEFvS0J4SU1nbjVjZ0huSTcweVd3bXVaMmZWREFVaGpENzBSaGh3ZU9SMnJhaTFQUWIxcG9GZTJsWjR3d0N2bGhqN3dKN0hOU3JscUs1bTFOcDM5MjdWL1Ryb1piYW5mU2FoSmEyNWhlQ0dGUjgwb0V4Sy9lM1ovblhKNkhZWDF4ZTN0NUVaVkozbFZKRHhnZ2NjanFLMmRZdFBBMGx6QkhkQ1NDWllTQTRmWXhCSHpBdC9FRFM2R0xiUVBza050ZE5jUVhjY2dWeU1iTWRGYjF6UmJUUVU0WHEwNVNrbW92V3oydnNjWEdMN1Z0UEVXdFNOaUtZZFZ3VlhQQlFqbkI3MXJ4TkNzZjJLM25rbWszbFZab01yR282dG4rdGVrM1ZucGFlVExOY01qQ0lDVWhNb2ZwbjNyajdtNFcwMUZsUzF1eENXQk54RklHVWp0bGZhalJvVW9XVjVTWG0yMjNaOVBJMDlNdTc4K1VrbGlHamFKMGtuVWZlSzhidVA2MXpjOW5vUm51Yks2bWhrZVZEdFliVWNMMkJZZC9TdWwwZlhyaXpndW5qaUZ4YXVxK1M2SVF6dmtnN3ZRVjV0cVBobWU1OFNOZVhVdW1wR2hMb09RekE4RUVEcVIyb1YraE11UjA0MmsyMHJ1NjBWK256TlcwOEt2cGZoNit2VTFhV09OTStRWnBNN08yQ2Y0bHJYdHZHRjVQNFI4d3oyMDEzRmo3c1IyU0VIZ0hQNTBoT2xTV1J0VXVyUzVjT3VJM1k1WlJrNFVkbTdWeU1VdXB5ZVRkUVdmMkdOWkRGNVJHQVF2TzRodVBhdGxaclZrT3RPRUUwbW0xNzluelhmZlN4MzJsaUhVTFM3Q1hFVVZ4TXdLbUtNZ0RBNUh2elZnMnVxNmI1bDNkMjF2THZURnU1eUc0R1R2eDJOY3ZkV2w5TEFMKzMxSnJSemdTWXd5ZGVNQWRDVFhYdkplelRXQ3BmM01rZzI0WForN2N0d3hZSHRVT1Zsc1hTVVpMVlBtV3FhNjNlN1RPazBlNnNMbU1sN1ZFSVFBR0dUekZEWXpubXVHWHhyb3VsVFEyczkvd0NYTkZHd3dvTFpZOC9OVUZ2QkN0MUphM1N2SElrdS9NYUVBa0hQR09vcm5OUTB5R3lqdXJtMnRyZG5pa01pcElOMGpCdlRQZWwxWmFxdHhqTFM4YnAyZG1uNXI1SExONGl2Ym1lU1FUdGRKSTN5eUtDcGlaZWNNSzlVMHlMVDlSMDRtU3dFYnN3THVqNHpKNjhkTTF6dW1haHA5enBNY3oyZ1dOVHZsalJCdmt4eGduMUZkUHArbFF4YWxQTkVJeWpxcFdKWCtZWjZrKzlXNUhud3AxRlZUVFVrMVpwNnYxMU1XWFV0WXNvcGJhZU9Nd2lYYVJJZk95cmVuY1YxSDJQQ3FwMDJDV0pZOXloQmhpQnlDZmF1ZXZ2RDJveFNYRnhiejRhUmgrN2tHN096c1QycmI4cldaTlB0cGJtVkptallDU09GZHN1M1ByNmVvcVhyWm05cHFUVTFONmU2blo2SmtxYVA1eUJjTW5tbjdzcEw5T1FQd3pWVFQ5S3RJNzFmdFRXOGs4Yk1TaUhCMm52eDM5cW50YnZWYmk5YU9PS2VGSW0rVVNBRWNuZ0w5YTNwZEt0Rk1qcFpxck1oM3lnNUpKLyt2UnIzTjR0U2Q0d3Z5dmQ3TXY2anFJdDdlRzFlenVMbmZJV1Zkd0FBSitYNml1TWVYV0xhOFEyd2xsU1E0YmY5NGM1MmoxQXFZMkZ4cUdvUm03aW5qa2lpQUVxT0FwQ2R4bjE5SzZSdFB0Mlh5cExrdWtlMG95dmd0MzV4M0ZWZEkwbEdyV2NwYXhVV2xGcDJlbmZReTd1M2lFOXZjM0Vjc0RoczdzNEhUdUI2OTY3RFQ1WkFrTWtMUWVhckhNYk55VlAxNzF5T3VhcGJ6NmY5a2dXWjJrak8yU0k1WVk2NXowRmVjMmVneHRGNTJIZWVLVldjR1FndHRHU0Q5S0xYV3BxNSt6cU4wNGMxOVcxcHIrclBSbHU5Vmsxblpid1FSV1F6SmNuYmh3QU9vN0VlbGM1YitJaGNTU1R5UEpGYk03UnEyTWc1NEJIcFhwY09uV05wSmJ6VHh6K1pmUTdrWGQ5eU5Pbkg0MXdFdWpvenp5Tll4K1JGTjhpcStHZFR5U1I2MGFhcGpyUnJ4dHJyZHUydnFyMjZIZUt0byttc2traGtUQ3B2SzRZZ2pyaXNXNTBXeHRQc3FKcDBaSzhzKzdZNHdPT25lc081c0pvZEd1WllvTWtzalJNMHU3T0RuRlhadFRsa3RaWnJrZ1NORjhzaW41a1BxUjZBVktKbk9uOE00V2FpbW5hK2wvUDBNK1c0MVNhNGRwckIvSThraElYYmhpUnlUbXFnZzB5eHQ4aTZXT0lrbVMyOHZjY1l4dFUrdWF6YnV6bnV6cDl5aUc2VXhyRzIrWFp3djhZK3ZldSt0b0xXTnJwYmRMZUprY1ArOE9SZ0RuSGVtN2R6bFNsSnZycmRPVDdxK2xySEdIUmZEZXMya3AwNkM0dDVRMkRJd0laU0J6bjFybWJQdzlxU1QyNlhFRzh4cTdjRFBtYlQzOU0xN1ZwMHVzcks3elBiZk14WWlJZFZIVE9ldWFvUy9iYmd6S2J3b0RFVWJZQUdWaWVNZTJLU2JOM2g2VGhGOGxuNUpSdVlqdnJEV1JqbXRVZzJFZVZzTzdDMW9YVjgwZHA1VWNaMlhDQVJTcU56TEowT1Iycm5McXp1ZExEU1c4ckFTZ1k4NXR5N2gxQkhVR3VmbjFYVkxEN0VMcTZqWGNXWXRFaGRRTWRNbnZUME1aUzVGSlM1azBrbnM3TDhDVFZiWFRQN0VtRW5uM0Z6Ykx1Zk9SeU8zME5abHZyR3BEVGJXV09LRkJLcElpZGdDbzlDSzZDVzV1eFpHNWsxUWVUS003MmpDc1FUMzZWREpwdmg2SkxHZFJIS3N5NVYyeXVEMno5YWwzZHRibVZwdUxjVW9xeTk2NlduVGE5ek5pdTdFM1BtM09xSkU1eTRqQjR6NkN1cXM3aHRWbVdVWHl6cXFBb3VQdWtIdUs1ZVh3LzRiUWtlUkk3UXNYWVB5U3ZjZzl4VlNieDM0VzA5amF4V2JoWlVLcThTNEs1SGJIclRsYm95YWNIemN2TW5xM0pKdDNzZW82dEVGOHUzYUZrV2NzV25VWkdjZHg2ZWxlS0xZYWxmcXpYU1NUUnhNOGNSaWJCQVh1UWU1cnNwdkUxdGQ2RElJSmpCS0I1VVR5azU0NHo5YTU3UjcvV3JLS0ZyeVczRnQ1cGZjT0djKzNyVXhUdUt0S001L0Y3dHRiZFBVMGJuVU5FbmdoV3ltbVM5OHZ5MVYxS2dNQmdmalc5WWExR2JHU3p1N2xWdlZiYVN3MmcvUW1ybXBhOTRjZGJhVUVSUnlNRDVtM0IzWndQenJuTllzYkh4QWwzSkpDRVdOZjhBWHh2a3IrQTdtbWtyUFJuUytWVFZweGQ5TkZvOU5YdWE4TTJyeGJra2hTWVMvTEhQR1F4RzdqNXZwVnNzZGlxMGFJOFdGWm1HQTVVOG42NHJrdE4welE3S05mc1dxVHM2UmhYQ2tzZHpmeFk3VnZ3NnY0Zmh2NWJPN3VuV09RZ0h6Rk9mTTZaejZVOUxHY1pSVlJMbTNkaytaTmEraHorczZkNGZ1MyswSnFySWhjaFZSdW03azU2MFVtbGFaNGJ2MnVFc1dLUEZJVmZ1Q0FldEZLM3FRNDRpVGJqVGpiMVBVaHJOdXRwZlJ3U1dyeGpBV0dOQ0dpSzRVWlhjQ0YzVnpOckIvYlY1ZE5lZUhvVXQ0OEtra3VWZG1VY1ozY043YzFsNlN1amFHOXUxdnBsN1pTRmxZcW9HMlZnY0ZXQjZrbmtIT0swMzFEeEpOZlR6eVh6UjJyRURmY3lJZ2pEY3FHallCU3d4Z2tIcFRSMTg2azdOdDJlaVMrZnlOM1VmRG1qUGJXbDdkMjhNeUNFSkkwc0lqVmlDY083RGtrRGpHY1Z5OHNWMXBMV0RhVXVoUUxoMjg2UkVVcmc1S3JrNTQ5RFZMVGJMeEEwODB5K0xZRVpzU3RiWE9KWW9nd3lDZ2Y4QU1ZNEFyUU9tK0RycVdXNG5iUnJ5YVFyaFZpSlpNWTNNQUMyNGs5OFZNcldOb3VENVhHWEt0TnVqODdtUW5pUytndkl2N2EwNjJtZFFaSWZzd1JTdys5NWpCUVJqSFRQRmRkTmQrSGJ5MXRPTHVSN2pmSmJNMkltakNrakxHTTRDTG5BSjYxeU56ZStIZFJtU0tMU2JpWUo1a2FRUm9yYk5yYlR0VnRwS2tjZ1o1cmMxRFc5TjBsclM0dk5FMUoxUkZTQXgyaklpSU9mblJjRE9mZkZOZm9ja0ZLVW12ZGxkMnZhK3ZWM1BTTlAwSUhUYjZNYWNyUlN3cjhrV0hWUjB3UWNIZWV1NEhGY3ZvdmcrQ05iU1c1TTZHSkpDcVJ6THVBWnZsV1RHQ1dHZXVLOHUxTHhwcmw0azhsdjRXMUJyVGFrQ1d6eStVN05Oa2VaaEdHNWY1SG9hdWFNa2x2cGFUMk9vM3Rrckg1TEs0WHp3ZG4zeUdZaG1IVTdlbExWNkhRNFVZcUxtcnFOK3FkN2E5UFU5b204Tm5WNVl2S3VibTB0b0VJTTBUSkZKSVEyQnRJNHh4eVQxSFNzSi9EVnRmU1hzR3BIN1ZiZ2phWHVGR0k4NDRXTURhM3JuclhLa2VJdFNsV0MyOHFRT3p1OXk4elJNb0hCUkkwd0ZIY0Uxd2tPbjZqQkFUZFcycHl3bzBseGlLWldET1RnQlFDV2N0Z0hCNlVkR0VaeGZJNHdmZE8ramY2SHI5aEI0UjAyd21hQk5QdFZnS2hrall5TjVuUWJ2NGd4eHl2NTBsOXF2aHE0U2FLVDdLNW1SUE5jeHNZMkRkQzZubmVEejZWNXRiNnhiWHEzRTB2aDNWcldYYVhtbmtpWGNJOERjR01lMzZqdlhwOFBpaU96MGFDZGRUZnpKNEZaRE5iZk1RellVYmVNWngwSjU2MFd0MEhVVTFLU2NvcTI3dHpYZjNyVThzMTdSdkYxOWFYVjNZbTRzbWlpOHRDNVVlYkdHNkl1U0ZKQjROV05FaHZwOU11bVc3MWdYTmxBMFVRTG9GSTZrdHV6bjMvdTlLajAvWGJxOXY3bTVndExjUTVaQzczRFR4S1c1VW1PSU53Y2NjOFZwYWZlSFVicDRyU3lXMHVWZDkxeGJidzArQjg1RFB3ZXYzTzRvZG1qbmNra28yVzc4MjI5T25ic2J0Z05SdEVqa2t2Sjd0STRnWmpITEdxeFN6cnNER01LdnlLVHpuZzlhMUUwdldQN1hNTjk0bnM0eTBMT3FnanpETElNSzRBeDA2ZTllRjNPazIralJ5SnFNbDJ0M2NBU0laRmVOU3JuWUVCR1J1eHlld3J1N1R3bnBqVzNtU1hkeXd1b1hoVzVmTWhFUnd3RzhEQWNIcDJvVHNTcGU5YVVYMGZaYS9jZXdXV25lSlJJNzNVTnZld1FBWmxhM0FsWVlLN2NrNDJqc2U5ZWNlSTRMVkw0NlpMRnFWbkROR0hNdHNyT1VKTzVWaGJHQW5ZbnJuaXN1MmgwelNJcDJzSDFXOFBtWWFPUzVqK1oxK1VMaGlEakhjZGE5RDBPNDFjNmZaTlBwUmhoanlGODI2eTBLam41MTVadW5UdFNsZTJ4MkwyZGs0U2J0Szk5OWZQVFk1NmJ4Rm9VRm45bnVKUmQzS3VtOHRzR1ZVQUR6QWMvdkIwT2U5V0xHTFNMNmQ3Q0MxVzVlTlhrZEpTa2NxampDNXgxd2ZscXhhMmx6Y1JHZWV4MHFhem0zSHowZ2ZJais4WXdyQU51UFpxNFBYL0JrUm5zNysybnZFRndYVVJncStGSStVbFFGSVgwT2VPOUpISmFmTTNlTGlsdGJXMzQzdjNFMUh3enBPajZ1UHNGMWN4NUtDV0Y3ZVZnQUczRWVaa0tPT0QxcnNkWmcxTzF1N1c0OHBMclQ0bE1iTWhLVHFwSkxNd0hIeUE4dDZWekdwMmVwNkpwYXhUNm5MY0IxM0ZKcEhta2haVG5hdXdlV052YzExR2llTDlLdTRMYUpyK2J6cEZ5WGNNNVhPVk8vWUFDckQvNjFWb3JHamNIV2xGeDVkRlo5TDl0UmRTc05MdVpidThoMUtTNE54Q3NJdHhLVit6bE9CSUZUSlpRT1c3NHFPeit6WHVnTDlrMWlHV1l1NitjWVhKY3dETzBiZ0N3L3ZFampwWEdKWTNkcHEwbW9RUVdjVThNNWlqaWhWMldaSlI4c2pIK0hJeWM4NUhGTXZyTHhuTHJGamVxNTArR1l0REd0cVJMdlZtM3J5UUZYSjU3Y1V1dW00SzBwU2JVVTdXYlY3ZmgxTysxZldkRHNUWnZxVVVSbHcwaGlWbTVJSVVlZ3lQZnBYbUxmOEk5TkJDOGRwSzAwbDNKUGJ5eXlIa1NTWUt0dDJnTGpHTzFidW42d0JJTEs4c0w1ZzBjMzcyVmZOamN4c04walI0VTdjbkt1T0s3dDlYazBpNm1odW9vbmd0b3ZOTXFEQ3JLU0FwWmVpOFl4MnBMYlZDYWJlc3VUbXNtK1hYWFRYcVF3NnBkNmphdmM2ZmJ3bVd6alEzRVJrK1ZyWmMvZERkR1BRNUgxcmd2RUd0V1YzWkJYYVNlVzRRUnhXYlppZUxmNnJoUzRKd1I2MDY4RWpYa2w5b0tjNmhDcVRTTVFyUkRkdFk1QjVMZGVPbFNhZGU2M0xhV2sycFdVY2QzcDdTRnJ5WnR6S3ZtRWpEWXpuYWVvb1NXOWlaU1NwdTg3MjAwWHhQZTZTS2R2NC90ZE11UDdIbDhQdXFSSWJlNWtRR1ZTU04vR2NZQlBidFc3ZDZyNHptaG1lMHVyU2FXUWdEeTJWSHRRdkJKRW5MRDJycnJ5ZlJJOVZ0cHJoN2pmdElWa2J6a0xIcVRzSFhCSEpybUREZmFicjF3YlZJNytDVjVFbnQxZ2NURGN1ZjNib0RsaG5KR2FtMnZYME5PZjM0V2E1VjdyMTh0UCtHTDBjNzNEUXZlYW85K2tOdUMwdTlVaG1tenpERWtZM0hnZmRIVTgxdTZqZldsdFBiVHBCOW5Na0RRM0Z4S25rcGJxM1hKSXp2SEE5NjR4OVRzOUgwUHpyU3draWNDUGNra1c2NGpLdnNSOGpIUWNIb1RuQnF2RnJFZmlMVElBQWJuVVFXYTB0bmJ5NDNiZGhpeThnNDdaNHpUMmVwVm9YbDFsS3p2NTlybkZhWHJ0ajRhMGFTNFc3dkxpeWFjaUpaVVZOMjg1THFldUFSMXJxaGUrQ0xtem0xSkxlNG1UY3pUSWt4S3h2anFlYzVCUFN2TWRlc05VMG0xaXRab2hjbWNiMmlMTHRoVXR1SWJid1Z6a3FLK3ZiS3kwMncwOHJwdWlRUXRIY0w1djdzUkloSURsaTJTTUFjbjNxbkhabWtZS1VaOHoxNW05YlMwOU81d3VsNlZwcytqekcyZ1I3YVFHWXgzUlpSZ0FoRkd6QkxFOXp6WG9MYURaWE1hMjkzSkpMY2JDUkpHMjBLL2JaazhmL1dyeUhTdFh1NzI1MUNLZXpaYldJaVNNczVhTE1XWFFCMEhVa0VzUjlLNERYZGMxL1dyRlN1blBDSnBZNUxhWlhZcXFNNUJFb1RMOCt1T2xPMXpPaTRjcWp5SjZKYTZMWHFmUldsNlY0bXM1WmRTVFZJTHRtaWtqbWlqUll4SVV5RkxIT1NlY1o2MUZxbzhMUUJuMVcxRnRMY3BHWmlrYkQ1MTUzWkE1WWV2VTF4M2h6N05CYnFaN3FOYnFJUlFtR01uWTJEa1lWODdtN3RuazE2UkhySmhkM2ZVVEl5eXI1cVMyM21yeXZaY2JsSHVNZ1ZEM09pRTR1bXVhMnU2ZHBMMTF0dVZJeHBzOW5MTEJJbDBxWmUzV2VFbU1ZNHl5cHlTTytLeUxiVE5YMUJKMlM5c0pnc3FySS8yWnJZdzRIQWlYak9Ed0FUeldycUdvZUtkTXZ4RmE2TE5MYmtMS2txT29WR1k4dHlQdTU1SUF6aXFDWEVOMFpMMExMZTNFVGxuVzNseEp0a0FPZktjS29EY0VFajNvVDFFNHdrNFJhNzNXcUc2dHA5NWIzVnBkdjRoRVNFc1dhTVlja0VZRzBsbEpPTWNkRFZyV1pOU2tna25zcHROSkNscFh1dDI5RUk1MkltN2NvSGF2UDlPOFRMUGZMQkpwZDNCYjh4Q2E3Szd5UVFXMkxnSHA2RDhhczZ5a0U2cXNlcTJrY3dsTXR1cC9lRkJ1TERPM3FjOVQrQnBKOURLVldNVk95MGIydjF0dnFleVhjV3NMcGx1c0VTNmcyeFE3R1ZZOXhBM01jZWpaNmRhNEszY1JvMnl3dTdTOVVGcGJSZ0NOcDVMbGdDUGx5TUNxZW5TNjFERExMUExCZlFtT0lBUktJM1pXNFlCU2NBK29yY3N0UzArUFZybU8yZTVXV2FHYVYwZEdDeTcvQU4zMklVTmtjVlZsWXZuak54Zk0xZlJYczdMdWpyZE0xYiswNHA0aVBzMTNIS0UvMWdBa0NZTzVDTUFxZStPSzh0MWMrTDlFMVNMVVYwT1crZ1FzRnQ3ZVFNMjBqQjNEQUlKUHBWKzg4TFdtcFd0amI2dEpkUW1OdzBNbHZseGJxZ3dRTUFoVklISWJpc21lYlY1ZGJzN2JUZFF1UUdSbzRvdnM0WnNEaE1NVGdndGpKeG1xaXJyL0FJQjA4MmxMblRjdVpXMTFiODBlOGVDOUxmWHIvUjU0dE5qdHBKM2FPV0x6V2VXM1g3M1liUVNDVDdEclg2VjZocldtYUpiSkdmbmsycjVjUzRCMmdZQmJzcTE0emJiL0FBcG9GZ0pwb3A5VmRBSlpCR0ZWM0l3N0JSMFVFWUE3NHJ6dUs0dWJ5VnA1SkF4YVFrdS96Ym05aDNQNkN2eS9pN2pQK3daVHdlRHRXeDFTS2xMbTFwNGVIZVNXNzdJL3J6Z3poQ0dJd2RPdFdwS25TVzdTdEt0TDlFajJPZnhQcWwyUnZsTVNIblpHZGdBOTJQSnJuV3V5eGJlaUVjbmtrbjZrbXJtamFHMnB6WFJaZ2l4cXJNN3RrZk5uQXgrRmJnOE1KTmNMRkRmRGVWM3FyeE9na0EvdXNldGZrdFRJL0VmTzhKaHNaUnhUcTA1M2svYVZ1UnlTZjJZeGRsdDVINnU4YnczZ0swNkRqR25LTnI4c0c3ZXJNdXlubGpJWkpYalljNVJpdUs3L0FFN3hYZXh5aExrK2RDRDFBQWtIdWNjTVAxcnp1ODA3VU5PbEMzRVJVTWVHQnlyZlFqdldiSElRMmY2MStYLzY0Y2RjSzVqVHBZcDFxY3VkeW5SclhsQ1VmN3JkOVBOSGZXeTNLc3lvdWNWVG5GcjNad3RkUDFSOWtXbDNiM01DeXhTQjBZWkRBOWEwQ3d3T29yNWMwUFhuMCs3M0FueVg1bFRIYisrUGNkL1VWOUlRM2tjc2F2RWQ2a1pEQWpCQjlEWDkyOEo4VTRIaUhLNFltaDdzbFpWS2IzaEwvSjlHZmh1YjVUV3kvRWNrdFlTMWhMdXY4eDBXb1F5eUJWR2NramNPeEhZMXM1OWF5b1JDU3hWQUd6aHVNSE5hUFgvNjFmY25ndXc5a1Ixd3lnZzlRZWE1eTQwS3drSktxMFIvMkR4bjZHdWtQMXAvVCtsY21Jd3VHeEVPU3RTaFVqMmxGUDhBTTJwVnExSjNoT1VYNU94NWpjK0hMbGNOR3lQL0FPT0Uvd0JLeG50YjZKY0dOMTljcnVINlY3U0tRRWRPOWZFWW5nM0o2cmxLbXFsRnYrU1duM081NzFMUE1aRkpUNVpwZDFyK0I0b0hKSE9NanRYbmV0NlpHd2VNd2g0cFZPVlBJSTlLK3FYdGJkODdva1Bya0N1ZWswUFNuQlI3WkRnOURtdmljNjhPbmpzUENNTWJHRlduTlNwVlhCM2kvaytwN2VHNGlwUWI1OE8zR1NhbEc5MDAvVS9HUHh4WStKdEkxYVdHT0pQc0VqWmltSkM3VkdCdCtWU1N3SjVyaHJQeFE5dGJ3eTMrblRMTkpLWVJLa1RHTEg4SlpuNXdmZXYyRCtJSGdxMDFmd3pMQmIya1gyaTIzVFdha0FMNWdIM1Qxd0hIQjk2L0xxNXU1cDlRVnJ4alp3dEZqeXBtVTVsVGtjNTdFZlN2MG1sZzYrR3cxQ25WcmUxbkduRlNxVzVlZVNWbTdlWi9MM0VtQ3A0ZkhWWjBMd3AxWk4wb3ZWUnU5cnZvakJ2M2phNUJqODJhY3VXeEVHVmpGM3kzUWZTc3UvMUdQU2xzNUpMcTl2amhwSXpGWkxKSkVEd1M3QWNBZE9PYXBhWnJGaWxoYjNOelpwYzNNSlpYZTFsOHh3T1NDeFRuSGJrY1ZzMitwNlhmTmRTcllUUXZFaGVScEZhRjJLREpXWERGZ09mclRWcldQaW9WSTM1dWVLY3JOSzdPVWl0ZEsxeG11L3NVY0xvemxabVZTeEM0UHpESUNnKy9Xc25WYm5UNEFONzNkN2N6UEtrVHh5YjR3cDVHMERoZG8vSEhTdW9zcElyaUNTNWttZ204NVNaWXJiNTJWU2R1QTNEWVQxeFdHbC9wVmhMZlROWUswaU5oNTFqZVNRN2V5R01GU2UyRGloV2JPZDJhU2JWMnRaV3YrQ09PMEt4MFdHVDdSSkxhNUNiMWp0cFNoM2J2K1dqdGdGdlFHdXJ1ZkVtb1dZYkdxckJMTHpheFREYzRRRERCdTRIRzBFY1pycU5JMUx3OWQyQ2lPeWlqbXVZMnVvb0dQbCtlMmVDdS9xM0hTbkxhdkZwMHQ2OGwwSTVTQko1K1draGlQYUVBRW9jako5YXZxRktqTkpjcytsOUxyWGJVODZ2Tld2OEF4SllyYi84QUNPelR4K2RuemxtTVUwUllZNEl3UUFLMWpiM0dpWENNZFYvdEcxWmlqVzhyb0dWd01qT01aOXoycjFTNDEyMmdzSG5tbVZyUkloS2x5RUorVmp0K2NFY0UrM05jcGMyR2t0WXlOSHA2K2U1eDV3ZzgwaG5PUTI5ejh4OU9NMFAwT21WK1g0N3lXdDl0dnpPSzBsNzNVN1c3a3hiSkZJbmwrY2tRYVdKVHhzT0NDd0dldlRpckhpSHc0K282ZmJ6U2FVc2hoU0dNN2JqN096TkhuNXd4WTgrM0pycTlFdHIreW14TVNFaWxKZWNCRUlPMDg3QWNzcDZuTldaN3FDZlNtVWFuSElKMGRqT1pQTGlXUmVjNEl6Z2NDa3ptb3hUVVpTNWxLejMwZDF0Yjd6amREWHcxWnVsNS9hdjJaREo1WlJwZzhXNGY3V1FvSittYTdmeEZyMGhqUzYwNjIvdEZFVGZOSkZkeHVrVzNxTmpFL1UxNVZvZWphbWh2WU5Xc29XaWxsRGJGSWZ6U09WMzU0VkJuNWE3ZVJudDlXdHBJOVBhSzVhSXhvWXdGdDEybjd6a2NnN2VCd1FhYjlUYUU1Um84clN2ZlUzcm5VSlBFVmtZbWxRUlRjUlNXa28zQlV3UWpuKzk2Z1Z4TjYwTm5iL1pyalRMb09VTGI1WW1lSlZHUVRJNmtZSi9TclMzbHBlcUxhN2phMmdtVjVZekJJR1RIS2tTR0lEWmdqajlhMnJqdzM0Ymd0Wm5pQXZYaXQwTXdtdURJQXNnd0NRQ0Z5UjNQNDBXRnJVaTVjMTdKcTczKzQwZFBnVzdXMnVJTHhJYmJ5dHF4RlZraFlIS2pHY0hJUFU5Nng0L0JPck5GZHh5M3R6dFp5dVhLQ0lLRG45M3RJWmVPT0s1dS9oczdIVGtqaXQ3eGJWVlJGdVFpTjVUTHlOcmJpZndBNlYzdW0yZHdVbWx1dFFFKy93QXNRTTBaUmlldks1SUxaNXdBTVVNVVpRcVM1SlFiZHIzNXJHTEJwbHYvQUdiYnRMckU0UzB1UE1tSW5PNWdDTVI4RWx1UndNMXI2ejRGMHpXeDVra3Q0NWxLdGdUdXVkdktnRHNQWTFTMUxTNUZ2V2F5aFQ3VDUrOXZQWHlveUFOcEtaSERIUFROVWJlNzhVVzhVbjI2eE5sTnVLQVFTTXl5eVp4bjVjN1NjOEhwVFRORk5Vaythbm9tdFUrM1U1ZSt1N3F4aHQ0Sm9kUXQ4N29QdENTQldVZjMySXlNYlRXSnB0dEJaM2NkcG9sdTl4ZHpTN1BPa1V0dllISmRwVnhoUVBhdTRuWFdvb0NiN1M3aS9oU1FEeXByd0tGT2NZT1VHU2UyYXBRYWxjZUg0N2FDNjBlNmY3UzN5SmF4Z3l4amRnQXRIL0VLU3Nja1lYbXQxSDAxVnUvcWUrVzhFODhjaTNCTnBLdU43eGs3UUJ3UnZZY2crdmF1TzFxUFhvYlJGdFB0TXNxdTVqbUtCaHRiQklMOThqb2E1KzY4ZmVEYk5iaTNtbXZCTE1OZ2htaVpHRHV1Y0ZlZHhOYWFmRUxUNFdqK3p4M0NLSTNqY09oeUpJZ1B1S1RqMklBb1d2M25wVHFVVlQ5NnB5M1Z1WmF2Y29vK3N5M1NyY1J6b3JLUWtFa3drVUhIRWloZWhJNmpOWnFXR3N4YWk5OHlUMmpURTdHZ2RSR2NIYU40Y25qdlhmd2YyYmVDVzd0a0NUQmxaSlpBd2JKNlpBUGJwenhWZVk2bFBKYlhGOXB0czZ3UnlKOXBEbGlQN3VVd0FvUGZQU2hibVhzK2FLdk50M3VtdFYyMXNqbnI5UEZxek0wT3BDSUpLc2hMMnlOSGlQZ0RQM3NuM3E5SGFRM1U4MXl3aTh3UnFIUDJjWjNxZHhLc1R3RDZWaXZwZmhWUEVKdUZGejlzMmtpUlp6anpBQmtiTy9YakhGWjJwWFZ4YnUyN1dENXV3QjRKNFh1UWlrODc5Z0FCNTRKb3MxcVo2SjZ1NlRkN3l2Yjc3SFI2dTkvZm90blBCWlNXcnNvZVczdXpESXJaeUYyOFlJcmg1ZmhiZExBcVdXb1hVYUdUemlHSlpTQjFWdWZ1NDdEclcrMmtyNVU4cnh3eVR3RkN0eEFQTFpzam9WZklDOXZldFNLeDFhQzNjM0Y4czBNeEpSRUlRcGhjbkxnNExldzRwSjdHbk56T1hQQnkwNzlOdFJ5V1VzVjNaV2dVR1prMkdVdXFZUTg0MkFuYm5QeW1yR25lRzRJcitTVzJoMnREY3RuemJoNUZZWUdHUUhQNjFMcHpXeWFVbDBFWkVqakcyTVJLK1FPT2k1SllIM3FlMnZwamNsSmJLTm96S3g4MjEzbk9CbjUxT09jZW5RMFBxVlNoUjBiUzFkMHV5L3JxY3pxR3VXRnRkM0ZsTHBGMDBFcXB2dUlsVXhCejJYcng3bXZPZGJuc2JIVHJrYWU4MGN5b1pvWkFwbGoybGdDR0dOcEFQYXZVYjNWTkdoVXRLNnN1Y2o3SkhoNGxjbmF6aHM4anZYRnhhemF2ZVd4anY3bTdqa2pkR2psaUNib3huT3hWR0ZPUms1NHBwTTVLczFKM2NvUG90RmRhbC9TNy9XYnkyU1A3U3JYMEVQbXpMREY1RVpCNk52NUdmUTExTGFOcVV0czAxN2ZTM1VjbTNkQU1JSThjZ0h5L21ZQ3VJbDhPZUZyNW9wdFAvdEJabWlZTXR2THNEdEcyU3JoL2w0Nlk5YTZwWmI5TlVsVi9FTjlGQVJFa0VGeGJwc1NROERNcTQzRDZVMGxiUTNwOGpVbk9WN3BXczlHL25vWVBoSzl0SmJ1KzhwNzJSa2xES2tVVGhRRHdlSCtZZ2ZXcjJ2d2FWcUVqcmE2Wlp6dlpLUVl5aStmbmR1ZkRNZW9IVDNyZnVycTVodTRKSmRURVl0bEtYSkdmTlVsK2VBQjE5YXp0VnViVHp4Szl2RE5OTEFxaEFYV1NYYjJmQUkrYjFxdE92VXo5eUZKd1Vra25yZmQzOUxsMktQUmY3R3VHdFlKOXBRbDQ5bzgwN2h3T09jZ1ZvK0hJMmFHMFdCREdwZ3g1RG9TcDNjWmtMYzVOZVhlWHJ1bFRSM3NWcWtVYjRqblV5QXFBeCtYQmxHNDR6Z2p0VXNKdjdjcEhjWFhuRlRJcVcwVTRKY3VlckZ5RjRIOE5HalJuR29vK3pjcWRuRlcwMDZuck9zNlRwMzJyekxtMkx5eGdNa1ppQkRIdUEyRGlzcUxTMFd5azN1cXptWGNROGdNWTNIY1FRaEdTUFdvTlQ4S3hYTm5BWTcrL3Q1RmlJVmJhWVNPNi93QjFzNTcxeGVsUWVPTGVWb050dEx0a1FtZTRuQ1A4M2JDTGpPUFdsc2RMaGVxcFNwL0ZmYlg3L002RysxSmRQc0k5VG0wKzExSkNyUitmRXVXQ0RKRzdrZ2ppdVdzdGRzZFVzWTcrVFNkUWtSSHhGR3FsMVVzT0RzQkFIMXJ1bzllOExPOTVZTkRMcDVqSGxtU1dJUnF6dWVTcWdIS2crdkJyQXRaTGZUbmVPSFVXbGFML0FGa2pSaTNPd2NnS280WWU0b1duUXhxUlVaSzg0eVgybHB2ODlXYXNsMWV4U2hZckNjNWpJV1JvZ0V6MUE2Zy9oVnorMzVadFBpbi9BTFBjcjg0bkhsRnNvbk9DRHlEbnBtc3EyMUR3dnJ0bTgzOW95UnhSU2d5R1FIWno4dUFlM0pyaUw1N21MVTc2M3R0YmhEUVcyeHpJN2JzWjRLZ1lERWV0Q3NFNmtvUWJVL2RmWnIrdWhaMWE5MGk0aGE2VFNIaWtjall3VW5Pd2NaQXhnRUhyV3pwK3N3YWxaUTI2V2sxdnNReEo1bHZ1SmNjNFZteUJYVUY5ZHVJSUlsdUxZU3lScnZ2SkZWb1dVam5DZzREZXhyaUo3SzUwMWxqMURVcFpDODVjM0Z0bFFPTWRFeUJqdURTM2ZVNXAwNXdibW03TnBOOHZMcHYwSmRNMDI4c1B0OTQxMG1YSWFTMGQ5b1RKeDVoNlpQMCtsZWlhMWE2SGQyZHREcUt3QklTSkhMTXdUZXdPMXV4NUg0VnhlcjJkOWNuN1BCcGx6ZHhxUUZ1aGNLckhkME9HUE9BTSs5WG9STEt0eGIzck5lS2hSQXlxc3hQSFBEQUVIbnRTdXR6V25LZE9MaHkzVnJYZmZjV1Z0S2ppSVJsamdFV0ZsUndDQVFCdkliTzVjOGUxY0tmSEJzN3d3MnlvcjI3TXMzeVlFN05qYXdLakRjYzE3SEhIb0Z2Sjlra2tqa3dHTVpLRWJTVnljZFFNZWhyaTRwdE9XYUYya1V5ZVVxd1N1bjd1WGduT1FBcTR4aWkybHpLVk95VFZXTVh0N3IyYUN3MW0wMUo1TGxKWXBKUzI3WXFsTitUZ3F3UFhHZWxhUU9wS3pSNmNzS3ZESXpNR2tWWTlySEJ3QjNxbFphUmRhMGpSWG1rV3FSQm1sdDVvWmd4R2VDSEtIb2ZTdWIxdnd2OEEyTHFVTjNiM2V4NGtWWkJodHE1eWVxOVRnOTZjWTNIS05aVTFKMzVVOVpMUi9pZFhiblVyc05ISmNSMjhyNWptRUpEUmIxT0IxNlovaXJUOHI3RkJkaTN0NHAzZ0lZckV1RWxEZFFGUGV2Slk3cXgxSzVtL3NqVlVtdTRTSlhNaTdJaXIvZVE0eDgzNFY3RGVTNnpZNlZaK2JJb1pBSG5TQlFYQ1o1SVBwOWFWcnRiR3NZeWlwOHlscHFwYm5rOTFvOHQ4RVNSN0FGaDhrSnRtUjRCbjdoVUVCdXZXdW84UGVENVliVVFpR0ZpNGRHa0xPcmdML0d2SjZIdFcvYTZoSmN4eHk2aEVZeEhJeElLcnhHZnVuY09oL3JYT1hVZXVhWHFCdWRKMWVHZTNaUE04dTR5MkZQellCOXoxTk96dUpRcCs3TnB0SzE5cjdiMlpycmV6V1dveldDYW5aM0NRcmt3eUppYmMvb2VoSU5hMXZwMmxYMXZITExFenpxaEJJWTg1UEt0NzF6bXA2N3FWdE1aTGpUTFVNNkxNSjJLK1hBMlA0V09NNS9PdXMwVXRxZWxndXBZeUJaQVk1UjhyTnlEbGNmS1Qwb2Q5RFdtNHlxT0dza3IyVFRzdm15YVBSb2ROaGdqZFhGcW9mZEV2OEhjSEpQTmNCUG9uZ2s2a3MxaGJ2TklRREkzemJkNkhQelk3K29ycEwzU2I2QkxpMm5odXJtMmI5NG1mM2lqQnlWOWMxaTZscm5oNnp0cktXMGprbGhaV2pDUm9VV0dVbm56TzRiUHJUYXQ4eFZXMm5IMmNJcFd2emF2MFhrZEZwZXRvMGQrSnRNWkNoS3lQc0tJUWVtM2QxQnJuTHpUcmlHTklOTFMwdG5tUWxwWlNWa0c0NStVNDYrMVpiWGwxcWVtb2x5QmFmdlVoUlkzRHlBODQzbHVPblUxMW1oV05tdWhYRVdvdE1pMjhiaVNacFJJNmM0RGhld1BZMU52a1JCeW5GUnVuN3J0SjZldXZRNHZUTHJWVFBGYmF2cDFqZU5ISTBhc2NLNUlPZU05Uldmcm1uK0pKV1dmVE5Na0daVCs2ZGxZSytlb1BZZWxVMHNQQ3NGekY1dDc5cWthUlZpUnR5TW82aHMrL1UxMVgyNnd0clNHV3pjUkdhNU1ja2Nqa0V5RTQzS3h6OHRQb2NYTmY0NUpwYTJUVGVubWthVXQ5ZlRhYkZiNjlwN1J0Sy9DeEtYQ2tmM3l2cldYSm9LMmJ5VFcwUXlVZnpHV1k1S1l5cWdOM05kN3JOMWRXdGhCQzRsZUtWaEZJVWxCWWJ4eTJSenhXYmIzR2t5bUxUSTdxTmJtTk5xcVFTV1ZSd0NmWDBOUzdwZk03cDA0U2xyTDNsYTE5R3I5UE04MnQvRWR6cDhTU1IyOXhMRXpiSGdhTUI0cytucUJWNjV2Vmt0eGR6YVRMSS9uYlM0S25yamc0NmNDck9zdDRrdGI5YlNUVDVYZ3Vvc1F5UVlWa2tUdXpIb09lYTR1Q3l2N3U2MUhUdFJpa2hTM1pYTnpFNE1ibkdUa0RyUXQ3N0hKVmhWc28yYlhWT3lTZlRjMlo3dndsTHF0M0FWdTdhZUlyTEhJNmJSR1QyQjdpdHlTWFZiTWVWZDdkUXNuTzZOc2ZPZ2JwdTl1YWltZlQzMDJTT0xVYldmYVZFalpJY1JMOHVNWTV4V2pwT24zVTd5UnBLQXMrNUhaSEpNYXA5MDdUMU5VL2hNMDVPbzRwSk9TK3pycjU5R1lWejRWMUtlN1ZQdGNzVUxvb2FORkFVRkRrSDYrOU1zWkwrMGtFbjlxdGRSeEt4RGhnTVlPQXBIcm52V25KNFk4ZHhYTXp2ZlJYMEczYVVMaUpRU2NjZ2Q2c1dtbmVITkVqUDJlV0pXTWJOUER5KzdubkJPZUFlbEIwT2s0UzBVb2ViMHYrUjFOOXE4czFodEZ5eW01UllvSll2bmZjVHlYOVBhdUcxM3dqYkxjMlp1THVKb1k0d1RLOHpDYmNPVHVJNDY5QlhRVDNmaGZXTEo3TmI3N0tZNWNwTEcyd05qbk9SMjlxV2J3czgybHNrVjVOS3lST1lMZy9NZzNjSElQWHArRkx0ZGZnRGNxamR1V2VtOTlyYnBsR0tLSm1FQmlXUStVU0p3cEJBWWNZeDNyRVJFaVlUeDJQMmRpV01sd3hZbHNFY0FjWUo2MDlZTlcwcTJNOGR4RExONXFyYnd5TmhwUWNESUdlbnRWaXc4ZDIxMWNwcDJyV2IyODAyNVdpMkZsRGRzSCs3eFR0Wjl6S2l1ZUtianl5WFJwUDAxMytaMmVvYXZIcG1vck0wTFhGdmNSS3JsWk54M3AzQys5YzhtcjZMZHlDOXRsZTNSaXlPc2dhTTd1bTc2RVZyUlBvMW5ZYW5MWm1ZUlJvd0h6Q1JDM0dTcWRlUFdzOTlDdXIzUTB1clM5ZTRqYUVNWVpSZ0Z4NlovV2xaWE9pY3F2SytXMG5ySkpXZHRlK2x6cEw3ekNiVkxlNmUyTGZPWnl1UVVIRzBaNzFMcVIxS0tHM1MyZU9SblVFVERuNXh6OHkrbGNWTHF2aXVDMUVkMW8wTjFHQ0FyS2VNNDZBVXlHS3lsamgxSnRQdXJkMG1LbUV5WTMvQU82TzNORnlIT0xVa3JxVFM3eHN2eE4vUnA3aG9MYzMwcS9hSE1nQktuREVIb0NmU3RKTktiVkpMdUc3dFBLVlNIamRIS2xXVVl6eDYxeDk1YzZvK3JXZHV2bUxGSmlSWVprNFRnNUc0ZENhNkhSL0VVc3VwTERjYWRkeE50Ry95L21WUjJKSHYzcDI2aXBWSXQ4a3VaeFVyYXJmVHJ1UzJQaDYwdEpvTG1QekdrUWJmbFloWDdmTm11SzhRYTdyVUYxRi9aK2hLWjdabUU0Wjg3MGJqaXZZdFR2Tk9zd1VqdU43RUJ6R2M0Q3NlVzZZeG11UmJ4M3B0eFlsMnNycU9RT0VNL2xERGdEQklOTlhiT3VYc0tTNWVlTWJhdFd1bmI4amwvN1k4VnpXc1Z4UHBxSTBVZUl6dU9GR2NoZnBYWStFbE54SDVWN2JDS1NlUnBNR1RKT082K2kxUzB5VFU3cnpyZTVXUVcwaUF4NzRpT0hIQUo3WXJ6NjcwcnhEcDJweDNVUVQ3SkNQTDgwbmM2SEdNbFQyb1c5cm1DbE9MVlQzcHBOM1VyZk05aDFxN2UybW4yN1Z0cmVIQ29JOC9NZW1LNGl4bjBXNWtsbGE1V1ZHa0NsQU1NdS9nQWcrdGRscDEzZHBHdVM5dzAyQ0N5Z2JBT0NNSHNheDlVOE53YWcxemNXY0VjRTZzR2xUbFE3SjBQdCtGTld2Mjh5cWlsTmM4VnpQVnFEWDlJNGZWUEEwUTFSWnJLK3VZMFRMQkFTeXFSMkE5S3BYSGhUWHJuVUxlZVdjWVVxb0NBanpWemtodlRGZGg0ZHZmRUN4UEsrbUJzU0ZDVmtIUGJnbjByVjFEeEJkaUdUellYVHlnU1lsSXprbnJuMHBXZDdtYmpoM0ZUa3BSWFpKMnQ4em5wdFAxR3p2Ym05dVp6NWNXUDNjWnhoU1BUdUs1L1Z0VHV0UVNKdFB0eEc4bzJ0THUyc0FwNGJGUDAyM0xUdGRXMTVMSUNGM284bVVETWZ1bjM5cTZpNTAxLzdVTTBkb1lzSXFsdk5VS00rZy9uVFp6cU1tbTRKMms3dFd2ZS9XNTU2bmhEWGJzdk5McWZueU1jcVBONEJVNTZkaWEyOUsxMzdSYmZZWkVXM25qSk9DdTdPM3VmU3RIWHRTMHlPRXlJd3RyM0lqM1FqZWhLSEdlS2lJbmp0Ykowdlk1ak51ODF6SHRaaDFJNmNIMHFyZTdkL0lwcFFxTnhuZDJYTlpyVmJkYldPVTFMUmZFSjB6YTBKdllpNGJ5bVlmSytlb0E2TFdQWjZaRnFXcFQ2YzBOemEzQVVlYU01UlVYMEI2SFBTdmRJN1l6K1pKQnR0NVM1TzRzU0F1TURnOVNhNDI3dUx5eXVDMDF3WnBuRzBUUXArODI5eGp2aXM3bFZFazR1emNlOTdyOGRTbGVSV2VtMlJ0NytPZVZZeXUyNFhxd0krNlFLcjJOL3BzSnMvSXNIaldUL2xwTEZrWVkrL1N0dlh2RTkzWldpRmJBeUswZVpHdUUybmdmTCtkYzlwR28vYW9pdW96YkxhNDJ3TGpJRzcyL3dCb2V0Rm5ZNTVLRWFxNUhhVDBWNHJUcnF6MTIzUzJpampRMnNVdVN3M09vNElPYy9Tc3pWRWhNNlBlSmJwRmJ0aVBwaFdjWUI0Nml1UnQ5UjA2M1o0TGp6MklmeXcrUXc0T1FSanNhcytJdFZoczdHZUtPeFNhYmNyTkFYeUNDTy9weFNWNzJPNzJ5bEJxOFZhMmwvd1paMUN4MVNKVkgyVkx0UEtZUmpZQ0QzM2Y0VnoraitIMjBxSTNVMXo5ak0wMkp3M3pBaHVjWTdWNmY0WjE2eG4wdUtPQ0JyR01KZ0xJMmRqL0FJODR6V0ZxR3BwTDVkbGR0SExDeU51bk9BaFlEdG5vUlVYS2xUcEpLYW0zZGFLK2wvUHFhdDNwVU1GZ1pyYU5Ia0trK2F1QnYvRDZWdytyeTZWcWVub0dTRzJ1d053WjhaQkhBSnpXOWIzdHRGSEJEWnFzc1VhQUJ2TXlTeDZqSHBXQmVhUnAwMm9Jazl0YlBkeUx0YUl1ZmxCK1lIQTc0Rk16cThzb3F6U1RWcEsxMWZ5Wmk2VTMvQ01Sdk1ZV3VmdEJBYnlsQjJzZVQrRkZlaVE2ZExiVE9naUN3TXFsRUk0QkhwK2RGTzY2blJUVldFRkdMYVhtcmxMVUxMWkJaUGVSWGwwakZ2bGhrZnl3akhCTTJja0JjOER2Vk9XOTBKdE1TQzQwKzRlM3VwUXlRT0ZrTHhxVHlpRmlSeUFDcE9UV0RmZUY5ZHVMT0NlZS93QXhxOFNTR01TS1pnU1AzcGREampyakhOZEhhMnR6YkpQY1FRd1MyN3ZLanpHNnhzVUxocEF5L2M2WnhqSm92dWN1cWtyUjZiMjJSdDJ0aG9zTFNtQzEwc1JxVk1ySkljb200akRLb2JPMzB6VXlRdXNnRU9uNldMU1dVSkVmTXc4bUYrWDVsSEpBSEk5cTRpRyt0WmdrR242MVl3dkhtVjB0b0VuYVFiUnVmemVOeE9NZk55SzM3elVOTDF4YmVEVHIyT1dNSUZ1TFdORmhsZVlzWEpLNXdqSGo1aHdhanNybE5xMHJMVkpYVmtudmJyME96MFR3N0xiUGRYMTVxbGs5eEl6Qkk0WTNUWU8zTEVuUEdPQlhDcnBQa2VVdHpEZmFnc2hTUVRPWE1jY3BKNVJTZDJUMDlPOVk5OTRLc29MbUZiZWZWYmFLWlBMaGRaZHFiU3A0K2RpU1NTYzVIWDJyVzBObXNWdGJHRmJ5ZTVEUGJOTk93aFdLT1VCZ2pLRGhpQU01RlhxYTNwM2FVSXgzWHEzMXNkUllLbHBhS0xlQVA1aDhxS1NZcGNCUUd6c2NyeW1EeGpuRlM2bkZjTWpRbXowd3JBa3ZsaU5Ia1FqTzF6bE51eGgwQXJCMWZ3MVlDK2ludExoN2ErRzBSdGF6UGJxNWZBM01HR3dGczRZL3JXRHArazYzcGpYVFMzbXJTcGIzRWtVMEJsalpIdUdHZUpkblFjWko0b1Z3Mmc0M2FTVnRGcCtCUDRkYlJCUElzRjVpZVZaV0ZoRXBhSUU4WkdDQ2R5ampPQUQ3MHI2emFYdXVyYkpwMXhFdmt4Sis4TXJGbVVrNVhzU0J6dVA0MTF6YTlhV3RsYXp5K0hKWXdBZDA3UUV5UnlJTWtrcG5QekhnampOYzhsejRmdVM5OU5mWFRiL0wrZkUwRndtM0xMR2taR05qazh0akZGMDlTWEcxTmU5QjJ0ZHRXWDRuSGF1L2lTNTEyNUZqcUNhZGF3TkFHa1dFRjNHM2FGMnVjc1NSOHg2VjNWNk5TdTF0aXRwZFRnTHVlVVJDR1BPY25lcDNEY01aeU1tdEsxMGpUOVYwSnhkNlMwVThwQVpMeFNYUkFlV0Q3UUhKOWM1QTVyakJvV3lkbHNrYTdlRzZFU3h6U1RHTzEzSmtFSGNCdEdPRGpOUy9pSEp5bHlwN1MvbHNKWTJOeGFpNHV0SnNJYnlaWXdJN1dSMXR0N3I4M21najd3N0U4QTFEcnVsNjlxbmhreTZ5MEdqZVNyK1pDbHl5SVE1KzhOdWQyN3Jqak5ieDAvV0xleWVOcnVkWUh0dy9teHFpR0p1ai9NeFBIT1FPdU85Wmx0ZTZSZTZkTU5Ydm1sYUw1Rjgwc3JnTHh1amo1em5HY2tVN2F2MUlqSlFoR255KzlmbXZmbCtWekt0UEVXbTJzVmpaeDYwOXg1VWIrWkkxcjVrZUY2Ym1mK0lBWU8zclhYSkhZWDBsdkZlWGx1eXFVOGxiY0JJdm41OHVRRTVCQi9oOUs4VDFqeGdOUG16TjRjdVdrYzdMZHJoQytOd3d3S3FBT1R5QWE5RFZyRFh0SHQ3aVMwajB1UkFVRXJ6RzJaVENOZ0cwL0tmVUE0T2FOaHloVTltcFNncmRFMjJuWXpOVDBuVExXU0tEL1FVV1dWUmMyTEJubUs1SldTUENrakl5U3FrZ1Z4ZW16MkxOYjJ6Mk44WTRkcVJ5U3lzaXVnR1J2QTJqRGtkL3hOZTltV3gwaXdpdUpMdldKQWptTGJQQXNqdks1KzhyakFYcmtqcGlwN2lab2RUa2FlL2pqbGpmZXhsaVpjUkFaK1FuN3pzcDV3TUVpbGREbkJKMnZaWFZ2OC9tWldvK0psdGJGL3RTekJJSWxabmlCV1VCc0ZUM0pRQThzT00xNFVQRStsNnRxRUZzQmNlVnlpYWtMZ1JiUm41bGxWVkFaaDJ6ejYxOUM2cnBrMnF5MzEzcCtxN0xveFJoSTU0OWtiUk5neW92Y2lRQVo3ZHFaWlgwMDZ5NmRjckdKQzA2VFc2Z1NGa1FoVk8zYXVGTzdJUFhwVHRjMWpUalo4emNuWnBPK3kyKzg1bHRXMW5USnJtQ0Y3aldCREdrMHR1WThTTEZIeDh4ZGdDeHpuNVFjMVYwclZyWFc5cHR2RE43WWhKOTNtV2lGQ1JqSjNGK0N1ZU9uQjZWYnZiZzNOMWMyOTBKN0M1dFdqK3lHM1ppaklTQUVJWUV1QXB5Y1l3YXZhVjQxdFRyOXhwODhaaEVySXd0N2k1S1BHVVlqZkVyYnZtN2xhZlczWHlISGxmdU4zZDIrOWwrbXhOcW1nenBLK3I2SHFFMFJOdE5ETERjWmZ6R2I1VndXSUlZWjRQUVZ1M2Nuait3UlpJcktDWldpVkpvbG1CZFdWVG55OTN5R01kQ1QzclZ1SWRWdUNubFh5enh6WFB6UnlJWVhTTmVBeFZCbkFJNjk2NTY1MTNRYkVRd1hCbEszZTZOYm9UR1REcWRyWmpJSEF6ako2bWg5YmpjdVYzNUd0Tk5iZmxmY3h0V2o4UzNzMXRPSmRPZ1dSQzVrbWRsa1hLamFyTkdmb0N1UVBXdlBiN1ZmR2VtM2Q5YlQya09vd2c3TjhSMzdrWTVDQ0hqa0h1MzRHdTV2ZEw4a1hWNXFHMk8zZUY0M21NL2x4elJzZHlOc3prVEE0SVVlbk5YaEhlUGVHM2puMDFWbXQyUm5qR1h1ekprYmd4QUtnOEhrOWVLbExvUktUYWs1UXRkZFc3M1o1US8yZnovQU8wTGxKRXRmTUVza0lCWklnRkdRclpHM0pQUWQrcHIwT1B4dDRWbnNieC90Zm1vWUJuVC9KTHVHVmVNbE9SdTZIMnJoTEx3dmUyT3VtM2w4VjJFZHdKbFVRdzJ6U0JNa3NCbGpnT3c1SXJyTk44UCtJZEwxSzlaL0Q4ZDNtUTR1MFR5b3BRZWdNYS9lSUI2SE5UcGM1MVJxMHVhNlUzZFhhNmVxc2ErbDJ1Z1hQMmZVclMydGtuY0F0YlBjc0dEWnlSZ25HVG5vYTJ0THROVCsyVDN5V2t0cWZQWU9UTnZkUmdra1JLTURkZ0RGSmN6V2R2Y1FqL2hIc3l3NGpuVzJUZTZKTXBMT2k3ZVNjWTlTYTVlRXlTUVNQRnE3dGJobE52YXoyc2lYS2dFTnNMbmJsbFBYQnpWQ1NqRlgwZHRYYlRWZXAxOG12V3Q5cUU2UlJTK2RkV3lQQXQxYnlMc0trbFJMZ1pHRHhqMXJoTkV1STIxU0s3dDlKaVRVSTNtRDI4VXpTUmhueURJVU9HQTU2WXIxVFNZOVJ0STdLNHVidHBKMHlXbjJ0bmF2R05tN0pWczU5dXRaYzF6b0tlSWo1K29SUGN5SXNubWVXRkcwc01OdjR5YzhCYzFVZGpxcVJjb3JaUG11dHI2Nm15dHovYUZoY1FRM3l3b0xkVmtpTUpWMWJPVDVlRGtnRVk5cTUzdzkvYnNER0g3ZXN5VE82enRMRnVhTFA4QUVVeVY2ZXZmdFhUV2tSZ3VGYVBYRW1ScG1keGNHUENSSEJWQWhVRUJld3pubk5RMk55TlZ1R2E0c3lzc2NxR0ZaWmlpT1dYRGJOakxuZy9LcEgxcEx5NkczSzA0TnkxVjlyN2VSaVNXT3JiTDBuVTdTS3lXUjNlSVpWbFVrTUEyTThnZE52ZXQrMnQ5UjAyOE0zMkpab0pGWXJNa09DZ1liOXJyOTRoczlhODR0dFAwemJKUEZIZlRUUEhNWllsbWtKOGx6c1BsNUcwRlJXeG9WM0hZWFpTMnU1cHB4czgyeWxaVWsyamhaVjNBRUVEL0FJQ2FIdXpraDdOMUZKWHVrbmZzZGRxMzI1a2RqZVJXWWJBZ2htU05ta2ZhRCs3azZyNkRPVFhGUytIdkVGN0JOSERiYWxhZVNoSmN1Q2Jna1pWeExJMmZsSEJBNjE2SGVhM1lTd0xkWEdwTGF3cXpHQzRtc2xiaFZ3M21OeUF2VDBOZVhYVVd1ZUp0TXNyY2VJN1hUb1hrY0FXNk9RZkpCS2hOd0d3c0Nldlh0VTMxT3hRZzZrWHpPMHIyMVgvQnNaUGgrKzhjd1hGMzVsNGs2VFJpS0tkcmo3UkpibGN0aDBUak9PRDFJcXJxdXAvTkQ5b3VYaG1sZ1BtWEZuR1dMcWVGUXhqSllFWngzSFd1cTBYd2hhYUc5dkttcHpMRzJNM0ViUndGd3g1SkFMQnM0d2NjMTAyc3kyL2g1N2dXTWtKdFlQM2s2QTc1VkxyODJ6SjVKSFRQU2lTVE9LY1pPU2ZNMUJTczRycjVyMTduZ2orSnRTMGE5c3BOTjBXNDFPeTg3RUxUd01IWGVQNEQyd0FlZTlkaGM2MW9VRnF0dkRvLzlueUdSMmt1bmdlQlZSbEtsQTRKN0hnNHhYYlhQamp3WmIrSDd1enV0U3VXaWlqeklzeGtNai9LT3BVSEFCT093elhHYURxdncvMU9hTzRzcHJwbzFkTnIzT0ZpdHl5N1dBM25Dazk5MmFkdkpuUktMVkNMakZjbXpsYnEraDNPZzYxNGZudElsdTRsRWdoQ3lUUlNtUXNzWFFrcmpxTVk3bXNZNnJkWE4vQkVrTnhKYlhQM0hBamtRQU1WRHVHSTZnWkhHYXUydmhPZXd2SnRSaXZtbWU0WStRRWxRcEtBZmxWQ0J0M2NaRlkwM2luVVZ2clVQcEVOc0ROY0xKSkxKNWhVNFB6ZklEa0VqZ0ROR3ZZd2xCOHNWSkpmS3phK1IzWGgvV3BZTGlXRXhYa1M3bkRSWE1hd2JObys5RVcrK25IVHRYMEQ4SWRJdTdqVkxyVk5YZXpsajA3OTdIT2xxSWl1VitWTTVKTzNHYy9TdmlMVWRhMWlQVVk1SDFkYnljUWtOYnBLWTBWbWJDeGlFamZKMTR5RG12dUx3OU5jYVY4TDlIamY3UXN1b3RMTk1seVFKaEdqZktINEhPUUJqMHJnekRNS2VYWmRpOFpPTjFoNlRtby96UzJpdm0yZm9QQjJXVHpMUGNOaGszN05TdjNTWGY1Ym5vZm0zdmlQeEF4T0FIUEs1LzFjWUhIMHdPLzFycGRjdXRNczB0amJodktqUmszRTRWOFl3Vkg4SVA4QUt2TWsxU0RSN1Mwc2xrVTN1cUJacGxHZDNrRi9MQUgrOHc1LzJSWHVtaTZacGVyRzJnbmszQlZhUmRyQWJ2WWRjKzlmbitSOEJSeDNDK1lWOGMxUEhackZWS2xTV2pqRnRUakZkcjlUK3ZjZnhESEM1cmhxVkpPT0Z3aTVJeGo5cXk1Vy9QeU91OEgzZDArbWt3bFltdUptQTNxVzNHT01IYU1FY25QRmJ2aFhTemIzY29hUzVNd2tTYVpKRndFZmFSMUJJWWtucU1jZFJXVytzMkZ0ZVRXS2FlajZkYlJrdHRHNDcxNjdSMXp1T0I2K3RkRkRyOWxjYVlyNlVpdENIeEtJMExTUlpIVXhqQlBQWG5PSy9ic295eFpkbE9Ed2tkVlFwUmhkZVNQem5INHlXSnhlSXFxUEtxczc2OU8xeG1yYWZyTitYdk5LMU5aVmxSVmV4dWhtM2tDOFlIQUtONzF3T3JhTGRhWkpINW1Da3FnZ2draFdBK1pNbnJqc2U0cjNleW5naXNsbm1jS0F2TFNIYnRBNHhnOVBwWG1YaWZ4TFpYMW0xdkJHV0JZTjVqREdOdlRhT3Y0bXZ5bnhQd1BEZUw0YnJ3ekxFMGFGUlJjc05VbS9lVlJiY3FXclQ2cEgwM0RHSXpLR1BoR2hTbE9rMmxVU1duTDNiN3JvZWJCMlVxd1BVZ0graHhYdlhnZlV0OE1sazNXSUJvdit1YkhHUCtBbXZubU53NkFub3cvblhYK0hiOTROVHNaU2NBeWVXLzBrK1huOFFLL2tId3B6NnRsM0ZHR3B6bTFUeEQrclZWMGJmOE4rcWF0Nkg2cnhMbDhjVGxkYjNmZXBybmkvUStxeDhrNE9NQi9sUDFIU3RJSHRnMWh5T3JCVjNETzhFRE9lYzFyQnNIakdLLzBrUDVyN0ZuSjlha0JKUDlLcUtSeHpVNE9QYkZJUlpDay9VMW52YnkvYVZjTmpCNStoN1ZkVnVNNW9lWlFPVDlhVEtSS2VsVjI0a1h0a1kvRWRLNUs4OFRhWGJqbVlNZDJNSU4zUDRkSzVLVHh4YjVqL0FOR2x3WEJ6Z2ZkNzk2K2N4bkVHUllLcDdQRTVuaGFNMWIzYWxXTVhyNU5ucVVjdHg5YVBOVHcxU1M3cUxzZW1YVGxJbWNBSGJ5UjdkNi9LVDQwK0dYMDN4Yk5jWE55cTZWZHZGY1FxcXh4dkc1NGtCZHVXWGQ4d0E5YS9UeXcxL1RMOHNzVXZ6ak81R0dHL0k5cStYZjJpZkRVT3BlREk3NFI1bjB5NFdXSmhGNXBRU2ZJVzI5d01nOFY2YzUwY1JodWVuT000MnZHVVhkUDBhUGlPSThES2VYMTRUcHRUcHJtczFaNkg1bjJIaGV5MHk3aWwwL0NoNDJobFppc0UwY2Jrc1pnK1FDT3k4Yzl6V2g0dXVkYzB1enRMM1R0RiszU0pNVmxJaldlUUlPZ0hJWW5IZmtBVnhFUGhpMzF4NTdqVmpiM2tma3hwQmR4eWJvNUhYS2tuWmhvMko2cDB6VHRQc2ZGZW1TMnJhZmN4VFJNakpGdW5LbFZ6OG9iZmtOamFSemcxNG5vZmhsK1JmdzVhdStqV3k2cS9jNkh3bjQwbTFNenZxZmgxOVBXRWt4c2tiRkZQUlM2eFpJejMrbGRoRzFyYTIxemIycldkd1ZienJpMmlkWUpwWlhPTXN1Rng3RHZVVm5IcU4vRzczTnZiSmRtUGNKZk5TUlBNWHF5SURrRVpBOUt3THZWcExXOEwzR216M2tzNWlTMG5qaGlaQzBnSUlMS2NoZlk1cHV4U3FTYTFqYTk3TzNSK3BrVDZ0OWhzWTVKTkJqTnV0eXlyYW05WXpCandTZ1VFWXoyQjRyT21IaUM3MDYza3NMd1d6eWVhc2xwY3NTVk9kd2VOdU04OVEyT09sZFRxdHRhU2FaYTNjZWkyb3ZrWlYrMHo1V05HazVrSkNrNEk3ZTlhVTF0OFVEY1MyMXcrbVMyL2xGZ1VZQTRZWkFkSkFUZ2ovd0N0VTlDWVFhVHZxbEhhTWUvZlloc3pxVStud25XWk5OZGQ1YUtSWW1IZkJ6dUkyc1Q5YXVqVHZFa09wUXlXOXdqVzhUSzV0VmpqVXU2a2pJMzVKVWV2V3VHbnRMNkMybXRwUEtIMmp5cC9MdC85SVZnR3d5c3BJYkI3bjBycmJZMzlqYjJzZm1KZlJUYjJTVm9zUERFdjhRZjd4WWYzVDJwTjdFUnF1VDk2TW90SlhrbnJlOXZ1SmIyeHRMbU9LMXVOTXZVazh6ejQwV1dLSjVuWmNGTjJlUnowTlhOSlNKclVORnBUVzgwS3NDa2lxNVhldklZaklJT1BwWGxseHIrcjI4dHpCTjVNc2l6TEhaczVVejdNN2h1UWdiaXc0SkJGWitwM211NnRORy8ydTlnalJvUHRVdGhpSGQ4eERBaHM3aU1kUmdEMHExZGtxclNqTFYzdHBleTIrUjZ3bW02TlBlZVlscWd1WGliS1RvZXJuRFp5QmdZKzc2MVIxSFN0YWxnbWtzSllycDFPNjN0WGo4dU5WUnNiUStRZDNyN1Y1WHIydTNPbjNxMmNsOWZTdkZkUm43UTBMU2wxQUkyTmxmdmdZOXZldEN6MWJWdFdTVGRPa2JSeUxFdm5LWTFpYlA4QUVPTVA3VU43RSsxaEZ0T2k5Vzl0RXhMcnc3QXQ4OTdCb1Z6QnR0V2U1QUFaWGY4QXVLUzJDeDZqaXVrOFB3YXQrN1MzaFZCdE1jNG1nWlRzTFpVc21BbThkTWppdFVXbDMvWlVyLzJUcWJUdDVoSG55YkErOGxqdDVIeTl4N1Z6Ri9ybW8zRVlqdWJhYXpuaUFWMWxkWjBsQk9GTVpqTy9QYkk2ZDZiZXhueTJmTzdwMldsN2ZMeU80MUMzdUhWTittR1dSWklsWnhFQXFxR08wcWluR1JuclhEMnRucmVuWEN4cmFhdExEQXJ0R25seHN2elorU1Brdmc4NTZudFZMVzROWWU5dFh0Tkxsbll4Q1Z3bHhzbGFWVTJCd0h3ZHlnWXh6Vnp3dGVlTFk1amUzdW5YTWNFY1g3NDNMc1pFUkZ5Q3ZPTUhHQ2VLVjNZRXBTbGZsbnJLMTA5cmEzN25wT25hdzl4WnJMZFc4bHBIRklTQmRLVktzM0c0N2w0eG5IV3JNT3V3YWZleVFUdkhOY05Lc2Fvc2l5ck9WRzQ3U01sY25ybnZYSHA0dTBXKzFWUkJaWGl0T2hqaGxKOHNiWEc4czZ1Y0ZDUVJrVlQwZSs4TXZkWFZ0TFlXNk1abUl1WUl5VUpYT1M3SEhYMDZWS2E3SFI3WnB4dFVqZm1hVGZVOU5ra3VJVU1VWWppdDNOek1ybDFJUjR4amErU1NUM3lhNU94dVpZTk11Ym1HYTV1V2JNa3VKTnFNMk9TaE9NWkhPYzF6M2lEVEY4aGJ5MXZyYTZkSVY4eXlMbDRyaU4zMjcxQzVLbjFxemJIdzlZYWJiWFFudkRBcGtobUVTNzNRSXVXR1RnbllUaFc3ZEtmbVc1T1VvdHBSNVZwN3kwVDdHMGsraDZqcDhOdzg3bWNiUEx1b0VFcnhtSWhpYzQrOXpqbkc2cFRiYXdkVXMvczB0dmN2SzVYenhieFJZeU1xV0pQQjl1TTF4K2w2eDRlaHRMcjdGNThFT1kzU2FkWHR0cGR1akEvZVZtNkd2Ui9LMU5UcDE1QmIyYzd5c0VsbkVHeVFNM0FmZEdTTUhPRG5rVTlFRGpLVDFUdXJYY2JwNk04eThTeFgxOUNzV3NhbERwZ2trV1F5Q0poNW5UNVluVGdQbmdtcThFMnVXTnpMSGFXc2w5SFpybmRMY01TZDR3TUFuTEhCOUtWOWQxSFROVy9zQzUwQmJ0UE4rMFhMbVVTUlI3K1J5d1B6REdSMHJ1eWRHdllYczdvUVdadUdrRUs3eGttUDVnNDh2QXczZkJ4VDJ1WVdtMGxkcVN1OWQ3OW0vVTIwMGJ3K0xPV2VhTm81RWpqbGtqQjh0b3lQbXl1N25KOXpnbW9SWmZhWUdtdDcyM2UzdURzWkNvbGR3T29jZ2Z3anQwcnh4clBWYmgxc0pOWXVvbGp1RHV0NW9kd2srVUJZMlpjNFUrbjRpdTAwdnhEZitIOVJrdE5aRm5iVzBrQmUxRm1yQ1A4QXU3bVVqT0JqQklOTDFaMFVwVW1ydUtqRzFuMGQvTTduVUl3c0RYWWdFVFNOSEJFMGFiOTRVNUFJQjY5aFhuMHVqYU9rYlROTGQyMGtWdzUyTnVHSTkrZHFLUUJoajE2MTJFT3E2ZUxObzdPQnBJQkc4cXpSdmxWWVB5ZHpjaHVjajBGWk1XdGFqYXpsN09TR1UzRzFtVzdaNGdjZjh0WTNiZGtEKzdnWm9UczdFejluS2FUa3JOYXZlejdyWVpwRnlZVG1NZVhhbVpJemNvLzdzRmlNUmxaTUhPZlN2UkRjU3kzYkxhM1ZzR0RNaUszeXN4QnhsZ3VTT1I2VnpGN2ZtVnpIZVhpeHhTSUZobGltWU1DMzNpUWNCVHh4aXJOb3RsYlFlWnA2UlhoSytabGQ3dVl5UU9XSExFSDFwblJCK3pqWlMwV3I2TmVpUnE2bEZkcHFjOXhHc0VrV0JHSk1lYjhoR1hCeDFadXhyZ3RRdVp0U2xlT3d1NWRLbFdIUGx5N1JGTHRPTnB6bmFUN2ZXdTVlMjFtNThpYUVMYkNWY2t0RTM3c2pzc1p3UVIrUnJHYlU5T2toaGE4MUZIbWt0NUNNV2dEU05DU0drUkFEdUdQWHJSOGhWTFNiK0pLVjVYZGtuNmFuSlMzY043YlEyVnpjdHBWMURocmlGbVhFbUNDY04wd2M1eU90WGRWOEY2ZnFLb1UxZTlRU2ZNMGtVaXVwMnJnTHRiSUhUdHpXay9nelROYnRiV0M1dmJlZDdhSldnMmdySUZJM0Rqb1B3RmVkSjRUMENEVlRKTGFYa0xOdE1vbHZaSTBLZDNSc2dnZy9wUXZ5TTR3NVdwVGd0YkpQZlk3ancvNGUwU3lpaFFhcE5kendFUnNKcEF1ZU4zbHRuZ252bnJUTDRmRUZaNTQ0ck9GNG1RUGJYYThOR1A4QW5uTEd4QnlQVWRhM1lkSXNMSy9MS2tseEhJa1pGeE5Ja3lNZ2JnREE2cUIxNjExRnhlV050Y3U1dUpMWVhXQjVhdWRzaHp0UXBqUERaN2NHazdHOFlMbGFsYUd1clR0djExUEs0b2sxN1JMUVgwNGE2aWwrZllUSExBeWtna0Y4WkI5RFdScmJlSDlBRnZiM09tUlBETXJiTHU0WmZtZkF5N0JBemJqMHlPdFdMZndvazAxNDgwbW9GeXpGaC9ySTVXWGxXS2dCamp0NjB5Ty9XUyt0TGJiY3orUVdNaXJhYkZYQTZFUGs3ZWVvNzFkdDlkRGhYODBvcm1hdGZkdFh0c3p1OUh1TEM0TVVsbHFNVG9JOXRyRWlnbHQ0T2NFOGtEOUswSXJhV1RMZjJoTkx1U1RFYnhGUU5od1IzSXdSd2E0ZVhYTkdpK1g3WGM2Vk9BclJFeEo1VEtPTnd5T0Q2MTB6YTdkM2Qyc3R2cVVFK25yWk14bThobUxTN3NIb01rQVVtbXpwcHpwdU9zcjJlbG4zK1p6ZDVGNG51NHA1RTFWTk9tamJMSlBiYjRuVlNCdVZzQmlwNjhWME5sWTZ6UFp5UjMxeXQxT0VCWkZpd3JyN0hydGIwcmtMdi9oSzJUN1RIcTFtMWxNUUFIak9JM3p0QUhIM1c5KzlkUHBONW8xMUJjeVdGNUhNWVpNWEt3aGc3TmpheEdEOG9IWDZVdEVoSjgwMG1tMGxmVjczL015OUp1ZE10YnQ3VzIwMk9OV2lqamtWV1ZBc2g1SUlQM2o3ZmhYVHphVUk3cWRaTEczdW8zRXpSQStXR0E0eXVEenlmU3VSdnpjTllSMzlvemZaek1GbmVhSHpGUWNLR0tnYmpnL2pWaEl0UjFKb252TFcxbE1PNVk1STl6TzZkY28yQXluMUI2aW41bWNKKzd5eWp6UGRXU1NhWjE0MC9TWXJDS1o5UFN4ZFlsVDdPWmcwT1R6eW9HTi8rMVQ3N1J0Q3V5UWtLeFNpRWJsUmlvYkg4UTllVDNGWTh0L2EyRnRIdHU3Y05DaUF4elJ1QkxFMmNxU2VBUWVCWElyNGxzQlpSUXhUUlcxeXpENUxsM0tuSkliWTc4Z1pHT2VLTHM2SlZhQ1ZuR0RYTGRyUytucDFNRzl1SXBacjI0T29TYWF5ekxDRE5BSFI1SWh0VjNBSTJGZ2VLOWYwK3h1MzBxeW12ZFFqZUJsZFo0NDAyQjNBQVhiZ25IdlhONnJwVXNnZGpxMEgra0tDdzJvNVpRTXFnSSs4Z1BjODFUdi9BQS9KTk1rRnZmckxKRkVIalJtOHJjcFhEY0E0REQrRTBYVE9kYzFPYzdVdWE3NzJ1Mjc5enROVTFsdEptdDRQc0Q3R1RCbGVNYlNjY2ZNcDZnZGMxWm44VTJVbWp5WGw5WldpMnNFYW9RenBJRkJHRjlnU1QwcndlODhKK0pwTG00bG4xWGRaVFJLQmEzckJnekJjWTNvZVJ4MXJOc05GdjRKcG9McTEwaXlWaHNaUTRHL2NTUGwzRWpqcUtUaytocEt0aUlxVFM5MXJTTmxwNjNSNm1ESnAybldsem84dGo1VjB3OHRjK1M1QXlTVWZvU2VPRFZ3R2JVYmQzWFVvNFptQ2t3dktIUU5nN2xPT1FwUDYxeU5ycGR6WUd4dGJqVEd1WFIyaVdaMjRKSXl4UWRGUURqTlN4V09yUTNVdHdrbHU2WFdHaWdFQVdSV0pJdzdMbm9PVFN2dGRuSHpTYXMwMUZMV04zbyt2NW1MZTZOZXRQSmEzRHBaK2FvS1hNS2pLQWRVZHdCd1NlQ2UxVUo5QnM3SjdTMG5rbnU1bVIyVzdhYksrVURubmIxWHZtczY3MUR4T2tOc3Q5ZVdjdHM4cXA1a0lQVEpVaGxmR2UrUWE5UHNkUjArVmJqVG9OUGpTMHRvMVVKbGk3aVlaSjNNTWJlT2c2VVBjdzl5VGxHOStWcXprcjM4dlR6T2R1SmZGY3VrRlA3R2kremdzaTJoYmMwMGJIbDBZZGVPYXNpeEgyY1NSMjE1YVFLaXhyYkxnN0FnNURLTS9MNzFQQ25pVFROUzMrZkNzQmtZQkpBekVBZmRWU1Q4b0k5T3RYYldOOVNXYWRMbTV0b3huTWtzdi9MVDBkVjRHT1B3bzErUVhVMDR1TXVaL1pmbCtob3duKzE3UzhodkxTM0VMd2hnaTd0Z3gzZmQweitsYzhmQjJqUnpKYzJjZC9Bd2hUeklMZWN1SDJucUFEeml0TzZqK0lqV2xsSnN0Sm5pV1JKZGo3VUlZY0VEcWZland6Y1hzRTdUYXJaMjl2ZVhIeU1ZWE1ydnRHY1lVZktNZXRPK21oNk5PS3R5MUZMVjI1NUpMZlVuamE0ZkVBanVsUlg0bGtrZUZzazlDckRrajJyajExU093dm1rc3REMUNlR1ZwRnVIOHZjbStQbzVZNHptdXN1UEQ5MDJzL2JFdnN6dDh6SzZFL0llaWZNM0RmaFhxVWNNaVdtellENWhBOHAzOHZJVVl4ZysvNDAyL21LRUpTYnZIbDViOHJzbjZiSGkzMnZTMG51cmhyUmxpVjFhUVJoblE3K2cyalBKUGNWMWNtcXZBODY2ZDRYU2VTU05QTkFZUmx3QnUrZmQyWHZXR05TMVdHeUVBdHJlMVhld051SEFHNUd5RjNIK2RkWkJQTVVsdUJiQ1A1akhJR2tEYnR3d1NDdk5Gcm1OSjJra3RPcjl6N3poOUtzcmpWTEl0cTJtV3NMUDA4aklLSUNBY3MzVTlpUldqOXA4TFdqZlo1NDdiekk1UExWWlVNUXdxNUdEM1BQWHZXU2JqUXJHNWUxVzZ2Ylh5R2pkbmJkSkV3ZnF1NCt2Y1ZsYTdlVDN0eEdKSWplUk52WkFxTG5hQm5kRWM1bzYyTTZrNHh2YUVITzZXMTkvME4yR3dqdWJ5UzlGNFpiY3hFc3JBNGlqUWNoU09vOTZ4MWJWYjFZcHJHQ1M0dHBwTnlTZVJzSzdWeGdIZ2s5eFVrV3JhM1p5STBlcURZMXVValdTRUl4UG9SNjQ5SzlFMC93QVF4eldOdVpyeHJhUUl4RWJMdE9UMEs1d0NwSFNwZDl4eFZHb3VUbWxGdFhiVmxyOTU1STJtejNWNDloTHFVOGtJaExnTkxsdDJjWjU1SG9SWFJXOTNiVzFrMWpCRzhGektQTEJDRWdTRWNGeno5YXpoTjRlYVJMejdTclhNQ2JHTHJsczVZYm1DK2g2bXR6VlBFR2pRR3hhNEJkM1VGWkJKNWNZSEFKT2NmTFZidlU1b3BSdStkSjMzYnU3UFE3VjlDMDJEVFM3bU5MaFl3clRCUXh5dzZrRGs4MTV2ZWExcFF0WmJjWEVrRHhtTlh1UXJJcmJ6am5Qcmp0Vysrb2F4Ymt5YWVMZTd0V1FzcFB6SHJuYmxNakdLNEs2dlBFT3BwNVgraFFxZHhMeXk0a1FLYzQybmduMG9zYTFuRFJSaGE4V3R0N2VaMlgyaTIvc3VBK2FpdWtnMytaSVFyS1RncngxUHZXQWROUjVtT2h6V3NUUXFWT0dEN2l4enNKYk9LZERwY09zMjlxa2w4em1PVXE3SnRIbWJjNUtqMUh0V0ZwMXpkV2wvTmIydWxham56U1BPa2pWRUI2Qmp0R1dIY21wVjEva1pKVGJUNWZkU1ZwTFI2ZGpjc3JHZHJJMnVwM2xzM21TTWtYK2pmY2tZY2dFREdSVW5oM1dMM1NrbER6U1NvakxERGJiUXhJZm8zSFQ2VnpwVHhScHR2QTk0MElLM0JlSWJ6c2VYa2pZZStSNjFxV2wvNHllYTF1WmJHMG50ejgwZ2pLbVlFdDN4NmVsVmF5NzNLMTU5RktNb2RiZFB2SDNYaWp3ckpxOXFtb28vMnhaQ1UzUjdXanczQlRCNjVxVjU1YnlXTkl3Wmx0N3dzM25yNWNoM1orNHc2cmc4MWJ1WTU3eEl0VGdTekxXY3I3bmFNTkt1RDB4L0trRWRzaGFhNFZVZG8ybWpNeDRtTzBFNEE1WGs0NG9hMDBKbTVXVnJyUzdrOUxydmYvTW9pd05vaVJSYm80QnVrVjBYNTgveFJnbjE2VjFHak1yVzhMUkc0TVpQeXE3Z2tQMHhqKzZQVVZ4a2Q1WmFuTDVNc0UzbVcyTjBaRFlCZms3Y2RlS3J6WFZzTlRUem9JSUZFak9ydTdSaHlvR1NpL3cvUTFMVDVUbWpKUXFYVFZ1bDMzK1dpUFE1NzNVWnRTaWhXNGF4dTQ3Y0x4R0psREVrL01PM0ZWZFgxdTAwalJvLzdWbmVXVHp3b2tXMitWV1laTGoycmo5VzhQNnpmVzkxZWFUcTUyek95WEJpVWx5TWNBTnlmbFBXcWVtLzJxa0ZuRGZhbnFOMmtjWk9HdDk2WTdxZU1uMlBhb2QydEQwWFZTVnB5ZDVQVFY2cmE5OWp2dEs4Ung2ckpJaXh5dkVGQ2VhUUZRODlSNm1yY2xscHpUM2tGeGZ1NnlObmRFL2x1Rkl3RkpIdjBGWUptMFMya2lNdDVBcTdQOVd5RkcrWThJRitocXhaYVJvRFgwaWlLVlNuM0hYZ0tQdkFrNU9hZDBqSzlSOHZ3VGQrc3Y4QUk3Qm9yYXd0TGZUeXR3a1RxVUU1d2ZNUURveDdIUE5jR05IUTZoWnErczNDTEFkZ0FVYlpCbmRuMHJvWU5TZExWemI2eEhJKzVuVkdDeUJ1U0N1VDB4NjF6V242MXJ5MjBzTnpjV2RtNmpFVTRHOEVOMjJudWFjWHVhdWNIS0hNckphVzZKZHRHZFpMWlBxNjMxdVBFRXUrUmdxcWloTUxqb1BjZW9yblk3YlR0Q2hndFh1V2FhNFlaa2NzMjhJTWtkK2F0YWJaNnpiaVEzVjFiM1ljN2taUGtlSmlNNUIvdW1yMnFhcHJ1bFNXV3paZE1ZaVJGNUlJM0hnZ3YwQnhWYnMxbEtMVGxLTWsxOXJlMTM1czFkVXRIdjBzSlh1bDNSdEd5SWpoUXlqNXNObnVLNCs0MWxZN2lTNW1hYU8yTGxGS25lT3ZVZ2M0clkxM1VibjdQYnpOQmJ4eE5HdTVVNWNPM2NldUswZEswZXdleng1a2JsbzhyTVNBekJ2NHR2UWdIdFQwU001UmxPcStSNjZOdDlleHp5Mml6QmlMbDVKTitTc2NiSXJFRElKRkxKYzZaREN6ejNNY08xZDVEOEZRZUJ1QjZDdVV2dFQ4UjJVMnk5dUk0bVlzc2NxUDhoSzljZWhyYXY4QVQ5R3ZiQWVYY0pxRWwzSCs4d1F5Z3B5RWR2VE5QWkVSZXNrbzJ0dmZyNmFuVFd0cFkzVmhJTEs2aFNGNUJqWUZZR1VkRzRyRDFPMmd1cG5pdlk1R1FmdXlJOGd1U001OXZZMWk2RDRiZ2pzNUkzdEdzM0RxSFVTRUt1MDVETDlPbGEydVByVnBJazl0cm9lMVlBYkhVYml3N0J2UWRxQWN2M2ZNNFdTK2Q3ZVRJZE50ckswZEliY2VaREZHN2ZNdVdKYis4UjNwdHJxZXZSWHpOOW1oTWNVakRNdUFUdTRBWFBwVkxUNXRYdkdrMlhjY1FMSTVIa2dTdG52bnBnMXpIaVdDMkd2TFBjd1hrd0d6SVIva1poeHRLOXFMTy9mUXlsclN2R1Vvcm8vUDhUcUxMeFpaTnJyUTZuWnlSc2paVEM1VmRwKzh4RmRWYzYzcEM2bkZHU2lBcExMRzVYNURrZE4zcldEcE04ZDlOTzhPak5BK0hTUGVmOVl3R2NNVDJxZTNubHY0NTdEVU5KU0ZJOXU1Y2dLQ1R6dFlkaGptbFl1aktvb3JXTDk3ZXoxYTdzeTlRazhRYWhGTUlBaFZJRkF5NEt1WDZkZTRySHRmRWVnV2R6SGEzMm0zYVhjRVN2c0s1aExkQXd6eG10ZlZQQkZ2WXVEcE54Rk1KQ0RtZVZsQzVPNEttT0NCMnJvTDY5dG9EYm0rdGlyU1JDTjJkd1lpUWNFRFBPYWEydHVhU2pLRTV1ZnhXMGJ0SlgrU2V4eWMwQ2FwRVRZNXRaQStZMjIvSVQvdEd1djB5NGtzNXJnYXJOYkpjTWtZRXBIREFmS0FUNzE1UHE5OTlsdjkxbGJuRTJSSzZzU2tMY0VrRDJvdi9GR3A3WGhtdC90RWZsbFVtYU1OdUo5ZllVTldPU05TTUpLVjF6ZVd6NmFvNitieGxaUzY3RFkzRnFxeXgvSzhtejVVVW41WEh0WFdYbHQ0YTFUVHJxMm1qUkFYekZMdTI3eXh3eFg4cTgxaDE3UWRRdGxrdko0TGJVUEw4bVNTTVlEUll3QmcxbjJPazM0dGI2MVdLMnVvNVdJaWZ6TjdSdURrWVAwck4ydDVtOHB5NWswbEpTWFZhblIzdWxRYVZlQzRWSTdhMmlBWGVwTGxnQmpkZ2Q2NmZTYnl5MUhVSmRzOEN6amI1VXdHSEVmVWhzOVRYQy92YmF3OGg3eVdONUFyeG1SUVFBRGdnQTlxeVYwRzZ2WjdreVhrVWhSd3krU1FqQlFjWUpIQTRwdGVad1JtK2Rjc2Z0WGNEM08raDhXM0tLTFcvZ2xSR0lDdU5wVUhwOWFLNXJUSUxPM3pGT05RQ0JRVklKSXo3RmFLV25mOEQyYWRTTTQzazJuMVRuL3dDeHArdWVYWjNMNnJaUTJZamhqZ2pUekdkMlpodDVqeVFUeUIzUHJWN1JwcHRXZ0tRTDlpdG9YVTNGdExGdlozVlRrN1NCZ0hIT2UvU3VRdVpkQXM0WW1OamVKZHVGWlhoYk1xYjBPUXpBSFpuT0NLMGJuVTlTdXRRdDNzbjFlQ2VaY004c0c5SW5qQUNsQkhsY0hHVHo3MG5wMU1ISmU0cGEyM1MzMTA5UmJqVDlBMVE2amFKRGRUS0ZWb0ZhUHlJWW1ZN2VXVWJ1TThBNXJsTlFoMGZTb0o3Q08vdnJBN3NLc2NVVHdNekFLVUtvVmtaU2Vjbm5GZWhyYzZsZXlheGFYRTdYOEN4aTJqOHBURVhKSVlxKzdLK2FvSEIvV3ZNN3JSOVVTNnNKdk52N1NKSFpMZHA3QXpFS0d4NWNzZ1U3UjZNUlIwdUVYTnRLUHZiMzAwL0M1dmFSNHZ2b283cTRGN2N6UTIwU0NSSkVSdHpGdUdVRWdLaEs5Y25IU3VvdFBHTXV1UW85M3BSUUNVK2JLMDY0Q0lSSVhUeThncmtES2pwd2E4bjhUelJhaGJTVFRKT3dUYW5tMnJHU1Bhb3hrSUJ0S0hPQzNCQnJjMFI5TTBDTkF0L1licmtQSERNZzN5Z1o2QUJRcW92OFlPQ1IwbzZYTTZWU2FYS3BOcDY2cHQvam9kbnAzanZSN0t5bGFEVjFtWnBVd3Q1QTRrMlpKa01ibm1RQTlNZ1lyY2Z4OTRkdWIwTmFYQ1MzU3lSVzBETEt4M0dVRU0zbDVHZWMrM2VzRFF0WThQWGxwdlNUUVRhcHhEQk1uazdIQnk1eVEyVUo2RG5yWGNUYWRvRjlGY0JiR3llU0VNRldQRGVYSTJHRVVMTHR6dXdjYnNFVWxmdWRiYzNHU1VyVzBTYjF1dlc1VXZaWGZURGEzSk1OdnZLd3oyNGxZcStBVU1wUW5rZHgwTlUzMVMxMGFFMk1zc3U2QmhFSEZ0SXpQdkFZS3BBT2R4UEk3VmpRWFVDekJKdEJrdUx1MllDQ01UeHJKSUJ3Zk4yN0ZJVWNiaUR4M3JyTHpVN0ZiU0MydG1XMGxrVGZkS3JzMHNVTHRuNUhPUXhIUmVPZldyZmI3am5pb3RjemtrMXBmVlAwN0dEckZ6cjlwZDI4dGxxTTk1R1dMSmFRNGcrVjF3ck51YjU5dUR1WHI2MTU2dmlYeHFMNlNPNHRvRnVudWR2K2pLVWJhT0ViSHpad1QwQVBwWHBOeHBqUVdyYk5ZZUZCSUlrV1pmTWplUjIrVUJIQTQ1NUk0RmVhM2ZpTHc3Y0NDeTFQV1pMeDBlUkdtaUJoTUc1ZmxLdXZ6YmZUSEZLelJuT1UybGE2MWplMnR2eHYxTjNUcEwrWFVGMjNWekxxRHF3VGZBcVFFWSs0U04yY1orY0VjWnpYVmF0cUEwNmV6dVUwUFVIa09FbG1palZTREdBQjVoQSthSnV1ZTNhdVg4TDJpNnhwc2RucDJvM1U0akVua3JNekl6QThnTzZubk9jSDJyS2cwVHhaYTZYZldOenFscllpVmhPR1Y5N2xtVVpVRHVvSjZZeFJwcHFpNmFrcWNwOHN1VzluSnJUbU50dkVHczNseGJYRXR2R0JDeXBFNkJqY3RFeHpKSDVibkNGU01aYnAxQnJ6bnhOb2VuZUloYzNzY3R6WlR1V1BrWE51WDNrc2NzbUFSazlpS2ZaK0cvRnRyWlJ2RDRvODdMTnc5bzB6QjJJTzFTY1pVa1pHMnZYNFNaWVBQZlVYa3VKa1FPM2xNNlpUcTBhcU1na2c5TThVM0hUb1ZLYnAxRnkxWXllbHQrMit0angrR3hndGpMYVcrdGF0YndiWGU0RWdpQmttR0NyZ3VSdFQyNzRyMVhTYkRWcDlFaGUxK3lhak41UWNTU2xvUUJ5TUsrVHprWTJuclhOUmFoZDJOM2I2bGU2WmJOSkxNeU41TnJJN3pSTjBaM2tYSUJ6d01aNHIxalVqZjN0bXRyWmxsaWh4TzZ3WENSeVNSTUMyNGtxUUNQVHI2Y1ZEV3BTZk5KKzA5NXh1bGFPcjlMWHVlUldtcDI4OTFPRkQ2ZGNSUWpaNWdaOTNtRVlSZU1ncVZ3VkhRVjNVNitLdFF2cGIyenVMSzFKdGNocG8yeXhHQWNZR1NoQzRZWjdnMTZBSko3U08ybHM3aEk1M2pDR2FSUFBSa09GWm1jNGJkZzhEUEo1cnkvV3J2UTlRalNhVFZHa2doTWhrd0RGRktzYmxmbUs0YkpQSHA2MGFNRlNkTDN1ZTkybnlyVDVtRHIrajNkMnNVOS9jNlpaUW9JaEV6T3psMUJCZGx5Y2duN29KeU1kSzlJaXVsZTBVYUxiMkYxTThwV080Q0xNZGlMdFhETnlDN0huMEFybXIvVHBmdEhseFc4OXpES1k3aFJEY1JLeTRYQVJmTVVrcU9pOGozb3NrdURwVVFnaXZiS0c0M1lhSzdoTVkzbnpOcE9NaG5JNDJuMkJGV2xydmNwV1ZrcnB5dXI2Mys4WmFhbUlMbU5yeVVXV29TUDVkeGJySElzVEZBRVhBUEJ3bzQrdWE3TnJPeGt0NzJLNXZUZVI3WkVpbVZSSmN4aVFZR3gxNStVOUNCeGpuTmVYM1BpRzgxSFRZMXUvRGx6UEVqckVkMHBpdU1nNERMR3BPT21NbmcxWTB1eTBxNTFDMXRibDdxeWtpaWxWWXhGOG4yWm1MR1B6SXlRdlBCNnNLaDJ1S202a1cwclN2MWZmejZGVzg4TzYxcCtsUnlCSUxnMko4eXpudjQzM3FFNUprTEgwNTZZR0s3YlM5U3ViaXl0Ymk0L3MrNGh1NEZaeDVUdUFzUU9XVXljQWpvTVl4MzYxd3R5eDArRzExTzV1b0xzVzZtSmR1K1JqRE14UWJtL2lDNTU2ZWxhY09wWE42eENhbmFySHRkMGdhM0NZWTRYQXlEdEI2bXFJbFZ0bzFadmJXK3BuYW40dDhIM01VYzJqVGVWUDVHZDBVQm5nVVNIYis5QklHZTNYTlIrSDlmOGRMT3R0ZVhsaUdjdThjS281SkdkdUg5VkJYNVdHY2l0RzQxbnc5cEdtWExXdHVyeW8wY2x4Q3R1VmpNbWNGaWhBRGU1SGVzWk5YZlZaMHNkUVZkTThveXZETEVTK0NuR0hqVDdxNElPQlJmUmY1R3NzUjd0UlJWbTdXMlg0cTNRN1FlTzd0VGF5YXBiQXhYVTVVU1djY2lNeXFuSUxPZHZHY1lITmM3cStxNnl0akQ5bDBCVTN1QWI2NWFRdGE1TzFYOW1JL1hyUU5JdDlJRXRsYXJleUxJMGNqanpVOHVUeTEzRmtKUElHTTlpT2xhL2g3eE5kejMxeGJSMzRXNmRjeEpPKzdkNXZDTXhBMjdRZWM1NHdhZjJmekloVWxPZkxKTnRiKzdmVm16TDRaVFZoQmV0ZnozRXBHeDl4YUJKMlE3V01rUXh0UEhPT3RVTCt6aXQ3K0VMWVlnaWlGejkzTUx5bys3SXlTVkJ6eGpqTmV0Nk5hNmxOcDBZa3ZaRVkzV1dtamRiVnAvS1BNckE5QklSdHpub2ErZnJxQTNGeGNQRnExL0hQZVRGZjNtd3ZEOW5ibFVVbmE0OUFhYWR1aHZXaEdNSTYyYzdhdGFHeGIyZmdPYS9qdTFkRExISWdpV2FJQmR3SHpFakF5M1k4ZWxlbGlLTnQwbitpQjBabWdsZUxES3A1T0c1T2Uzb0srWGRYOE1wcDA2NnJjYWhmSW9sUldtVU1JRmxsTEJtSXlUR01LQVIwejdWY3V2RStwK0hab3BieVdTK2d1akgrOGpnS2pEZ0hjTUE1Y3JnMUcrd2tuekpSZzJuYlpXMWZidWUrd1hiYWRxdW8zalhWeGNSTEJFU1pYRWNFR1ZDc1hLWkJLOWR3NTVybmJIV0lkVHUydTBtZGpMTTBVVTZ4a3BJYmZsVlV1ZVZHYzhnWk9NMXd6ZUlKTC9TWld0TkhMcjVMd2pueWszU3NSbCtRYzhrbjNyUnVaYlpHZ3RGZWEza21pTGlLUzVhUXJORndRSHdRUG1BT0FlbExUUTU1Vkl5V2pzazcyMis5RzdQSkZaYnJhS0MzOHErRENWSjI4aVlQem1RcUJzT1FDRGprbmswbXAyWGl1V1NQVVBEbC9hdkU4TFEzQWtlTkZkbWoyaG5JSERvZWhHUWE4ODBmVi9GbXZyYldWL05KWm94bUVqeURjU3VSa0t4d0JrWnhWdUx3bDRmMFpvSmIyOWpsbnVwVkZtdHBJeXJ0QkNoeXJzdzNESEo5RFJydWRGSjI1NWFOUlRTMVQvSFh2dVVkRjhSWGVuVHZaM2w1Wi8yZ2x6NWNzMzJlVzZqS0o4b0NqQ2dlaWowTmZSRnVsdmZ4V2Q1cHJRejNOd2NGMFJNS0ZBVWZ1aWM4a2JjRTE0NXJlazY1ZTN0dGRhWmJiR3RtMkZXakpWekVReEtINVJranYxSXJZa3NyblM3bS92cDRiWVEzQzdWdElTVTN0TDh3M0VuSTM0NDIwMzFzVDdTTVZyRFJ0OTlQTkcvSEpGYjZuZTI5MEpyNTVrazg2SzRWQjVieUhpRUJsR1Rqbmc0QXhYSWYyWmNTVzgxb0xtM2d3eVNXME4xYkltOTFZWUh5RUlWUEk1NXJmTURXczVGcFp1clJUU0NXMSsyc1E1WkR6eG5JRGRUNlZ6amFOcUY5cS9uVDZ3bW4zMkVqTnBKRDV6QmNnZ3U1eXB5QndlcHBxK2x5SDd6MDBWMytKNnBvYTJsdjVwdnBDcnhQTEx1amRHdG90d0dRaWovQUZiRHFjRHZ3YXhOUWk4SFdPcFNDN2tObEZOSXlLQXpBeVBGajd4NUtIbm5ISnJvdEhtdWtzcFB0c00xNzVlWTMzUEdyTVYrNlVLa2JoM0dlaHFmVWRhc3JVNmhEcVphYUIweXNJUTc5Z3d1ME94eTdBbitHbGZ6Nm5Tb1UxUmp6VzA2eVg1djVHVDRlRi9EYnZKWURUWi9MbFh5WUF6UEk4TDVHNUpIWVA4QUwyVThqdFgwZDRzVVM2M3AybVJZVkxlQzBnVkFjZ0U0WWpuM0lyNDA4TzZWNGIxcHRJdWJPMjFHQnJXL0x4enVESTdSaVE0ekllTUhHTTV6WDBINHoxYWUxOGIzOXpGdDh5Q2R6SHVHUXJMc1FFK3c2MThGeGpCVnNzd3VHdTFIRTQraFRsL2gxbCthUDZCOExLZnM4WGo2KzdvNGFiVjNmWGI1YmxDZlVocVhqZS9tdHBuZU9IOTNHTS9LaVFBMjZxbzkrcFBxYStqL0FBeGIzOXZZRjRwRmFDT1JISFZYM2tFS3VlK1R6N0N2bGJ3dGF6U2VYOW1pYno1SnR3UkJreU1Wd2VPL0hOZTlhMXpwM2h6UVJjeXJjelNMZFN0djJTcHVPMUMyTVlLb0NhL2Y2VVZDbWtrcmRFajAvclB0WlhiZlp0K1I2Mi9rZlkxU1JzaVFoMllFZzRYN2h5T25PV3JqcjQzYVNSR0I1c3h0dWFhS1RaT0hQUTQ0Vjlvd0NEeWVhZStxeDNFc2g4cmJHQ1dWZjloQmhSK1FBL0dyK2xYY0N6eVhVNTNSMmFHZVRqTzVnZmxHQjF5eDZWdTFwc1hDc3I3OTlEc1BITGEzYmFScEp1Wm1rYllSTXdRaGZNSnp6dHpoaU9NK3RjMXBFR3FYRnRINVZsZHpuQitZUk1CK2I0eldmNGsrSXQ2TFdIeWlidEpId2pSa3hxMk1ieklVUFJkd0FQVEo5YTVtK3Y1NXJVdXJQRkt5REdYTEZHNDV5VDJKcjhMNG04Tjhwei9IeXhHTHhOZFJiaStTRFMxaXVYZHA2ZVIraVpWeExpc0Znb1VJVWFkMDVlODc5WGZaV08vaE1zVHlSU3h0RTZTTUNqWUxEdnppajdRcXgzV0NEdFlOalBwaHY2VnoxdHFON2VYMnBQY3VyekxjbU4zVmRvY3hxRjNBZHMwbHlKMVM2WlNoUjQrUWM1R0JnNHhYOENabmhxZVZjYVl1amhtMUhENDlLbmQzZjd1b3JhOXo5NHc2ZUp5eWxVcVc1cWxGU2xiYTdWM1kvUUcyTVhsSXlxQUNBZU9CenpWL2R6M3pYTjJEZjZKYmpIU05CejlLTHZWWUxhV09OaUM3S1dBSjdEci9BQ3IvQUZVVnJKbjhndUxjMmxycWRVRDBIZk9mclVvUGZGWTl2Y0pMRWpqSURLQ1B4NXJOMWZXYlBUTEY3aWQ4S09BTzdNZUFGSHFUVXpuQ0VIS1Vrb3BYYmVpU1FRaE9VMUdNVzVOMlNXOXpTMURWcmV4Z0x5TWVlRlVjbGoyQUhjMTRkcjJyWEYzRnNsa1pWYzhRcWNkUDd4SFg2ZEs0K1hWNWJ1N2E0dWlTK0NFUWZkakhvUGYxTlowMXlKSHlSaXY0ZjhRZkZsVjhQaWNIbE5mbGkyNE90RnRTa3VyaTFzdXgrMjVMd3dxRGhWeEVPYXB2YnBIeTlTNEp5SUZqSDNReGJBOTZoTGRxTktzdFExYnpEWklyUnhzVmVaemhBUjFBeHl4K2xlZno2aGVvRkkzbm5yZ0FjL2dmNTErTVpSNFg4YjU1aDRZcFVGVHB6Z3VTZUlueXVjZWxscTdlYlBxTVJtMldZYXJLbktzdWVMOTZNVmV6OHp0dlBsV1pHVnRtM2FRd09HQlBjR3ZVOVN2RTE3d1pyRm5PZ2xtTnBMRzZkQStWSlZ1ZW1TUHdOZU82ZGIzbHpwMGw1NVJhR0NVUnV5bmtZQWJjdzdyejE3VjFtaTNBajFTQUU1U1VOQzNwaVFZL25YNlh3Wml1SStEZU1hR1ZaalRuRENZK3B5S0xmTlRjcE8wYWtIdHZvL0xjK2N6N0RZRE5zb3JWYU1veW5TZzNkYjZLN2kva2ZtQlkzZWs2dFp6NmV1bDNsdGEya3NKZFk5cTdIWUhuOXlmbTVHT21CVHJ2d3hyTWVwQ05KWjU0NXdXZWVhSWhSSHd3akJqMjhvUmtidndOZUc2aExyT24rTE5VZ090MmVscEd4alR5NDNSUWpua3FpOGJoMU9UMTVyM1cvZSt0TGNEdy93Q0lXdkxkQkZ2aXZIQklpSzhUQ1FBNTZkT2xmMmh6ZXU1L243T05PVGtwL1pmTHBaUDAxS1VkcDRmV080anVOYW5XNXQ0RTg4eG5ZUW9PNWlTNDJqUGNaNXJHZzhMNmJZaVEyM2lxOG1qaEF1MHQ0VkREWk14SWZENVhyMDU1clloTjUvWTF6YTN0aFp1OFViVFNDWnZNaGxaenZEamJzQ29UN2ZKMnFPNHRYYldyS1RXTkFpdFlvVVF3bTFrZVMzazI4Y2JRUjgyNzdwNjlhZXQ5R2N5VU9SKzdGZE9xdDZuWFFXMTlQcGFMcWt0aFBNRVlURjhZbEROa0ZodC91OGpCNmpGZWQzOGRuWnpuV0xyeEJHRVYyVkJBQ2htSmJQbE1WTGJTQndBT09hczZYcHVrSnFNbHZmUTZmQzl4SnNqQ3JJR2pNb1B5TXFQOHAvMnVtYW96ZUdMSFJoTk1saERHbHZPaklYYnpET3pNQTRiekR1Ump0K1gzNjBsNjJKbTR1TjJrN1B2ZmJxenJaL0dHaVhjRWNiV1dwMjBzbTNZWW8wRHJ2WWJTaFlZejZpdDJ4dUxtNFh6NXJPYUVQdkJZeWdRbGtCeDVpZ2RXSHpZNkN2R0xQVXZGR20yd2swdXhhZXphZDRTa2JCNUlKSlgzeHR0WTR4amhzODU0cnJiUkwrNjFTWEVua1JxaEFrTVp0M1ZzZ2xmTEdWY09mbExBOFpQTksxbU9NcXJkUG1kMitpU1hscVlMV3ZqdWU5VjVMM1NKTFo1STQvSnVvVWVhVU14Q3NOdk8wZTU0RmNOcUhoL3hFMnFQcDF5dW4ybHFaRlpaZk9kRUNvYzhwakJKendhOVh0bjBsOVd2bnZOSmZ6NERLRExMTmlKbGljREVHd2daSFRqdFhPbHpxeldjc2R3SnlKSmVSY1NwTEZDclpmaks3c2NZSFUrbFZmeSs0eG0xekpOSnlXaTc3OWR0VE5WanB2MlN6YnhIQmN2c0ttRnJzYjNSd0N1MHV1Vlpld3p5S3JYRmxmUTZ4ZFBCcTgwbm1mSWZNajJSUEdGQVV2THg4M0JVNEg0MTZMcXgxSzdqdU44MXBKYkxBVExiM2tZMk1qbFNIUnlONDI5ZWVCbmcxejZXdmhPNWp1b2JkVXM1TFNSUk0wekNhSWc0L3dDV2N2QTY1WDFOU205U2FzWEt5akp0eTNYWDVHenB0dHI4TU1sdTF5WkpRd1pVbURlWElqbkNCWEJIM2ZYR2ExdGMwZXdpdm9oTGZtem1raVhhc01nSkRaK2R3Q2VnUFgxTmVhMzJuK0RmdHl4WCtsUmw3Y1IzRVU5ckVZZDBiNUg3eFM0VnVleThWMHV0YUpwR29XTnZlejMxNWF3cGJveUNlRkhqaUlQbGgxY2ZOdk9jbFNmZWxyb1VvMHVXU1VydTIwdWhuMk12aUs4MUc3dEpKZk5JZmxUQThVaGpqNUVpTXZ5aDI5TzU3VnUyVjc0bnVkYjArMlF5UnlJSmR4RnE3aDQvWElJQk9Pb0l4NlZRT21hSGJKOWt1TldlRzR1WVQ1TjJKSFdVc2dBQjM1d1NmY2NHdDVOSzFIeXlJOWUxQmJpNGlWWVlzR2FOSkZPVEk1Skc0NEdPTWMwVzdCQ0s5MXVvOS9ldExwMFJnemZaNy9VTGl6dW85UHZHczlwRnhjQmpJNlB6KzdqaUs0R2VNZGE2L1RIdnB3WXJ5MVdOU2pMSExiMis2Sm8xQXdaVWZMTExqZ0VqTmVZM05oNHVIaWhyZWF6aXVYUzBsa1M3VlZYT01aRzdqREhxQWE2UFE5RWxuaisxQzF1N0M3aU1qdzJ4dURKSyszS0ZDcjhjOFlPY0VIbWgyU0xUcXluYmtkcjllcHhkL3Exb0xqT2xXc05ocUdjQWh0c2FvaEpiN3U3YklUMUhXdTB1OVQxR0V2YlRXTU1icTI5bXZVTWtEeXR5d2ptWDdvSTV5d3htc3pYOUN2dFcrd3pRdGVTU1JOSWsxbVpZNHBua1pjYjFLODVEY3QxM1lwdW51OS9vQzZWZTIycVNFU1NyNWpXeTNLbzhZd1V4bGZUT1QwcDNKdFo2djRydGFXKy9ZOU8xWTIybzJMNlpKRmFYalc3eGcyb21NYkJBZk1DYm1YYVNQVEdLbHRyZUxSQXJXR2szWGtYS1prRm8yNUlQTDZiMVpnRG5QVVY1VHFXbTJrQ3JQWlhOMHkzVVAzSXJyN1BJRmp3cXl0SE1DU1IvZUhwWFlYK282WmJheFl5M2wxZHFzVmxGSEcwRTJZUVV6KzhrVS9mWWpCSUkrbFVybS90TE84cEtOclcxMEdhcDR0MHkwRUs2aE5mMjBaVGZsYlptRVFrRzBPNVF0dVRuQkJ6elc3ZDZ0b1M2Tk45Z3ZyZVlUeEJZVE94bFZrenR4R0k4N1FUMUo1QnF5UnFjU090cTZKQmNSbWJ6NDdRaEdSL3VxY2svTjF5MWM5bzBMLzI0OHNmaEdPSWxRc2VvUElJRE81WVpCQ0VsU1I5Mys5M28wdnVWRG1rbXJQbTF2SjZyWG9peEhKNDRsanRvNXRLdjdPRlhDM0Jodkl1UUZBQmp6a3NwQXlUMXFqZmFqb1YxY1gya0crZTlOcnZXNFNhRm5rRWZETCs5YmpPVCtJcFN1cDZocXR6Wk5KZVdSa2NFdjVTeVFGbEh6aFJKa1pKQXdPYzExOFZzMDdQYjZmSkVra1VLSThySVZsM2dZWU9pZ0s2YmVoSFR0VTdpak5UNXRIdlpKdlgwU1BQSTdQUTlMZ3RCWlFYWmd2SlFMbWNBM0FpV0k0RVkzRWRmWVYyWDl2Nk9nbVdhU0c0Q3pNR2tNR0pJdWY0NHh6dEhRc0s1T0c3OE9OYzN1bTI4RnFrMFpmSUZ5Q1hDcUZRUmw5Mnh3VzROV0xINFUrSDVMOVMxdnFGc2JhQUlpdFB2Q01BUVcyZ1p6bmtrOWF1MStvVTd5aytWcStpK0YyZjMyT3oxTzMxUzYwNmN3UWFmY3lNdnl3eEtIaDR5ZVFUdUFIWWl1Um5OcHFFR3lDekgyeUJHMzI2cTl1VktBWlFOSDAzZS9Ccmo3andab3R0cU5wZDNXb2Y2V2lzWEVsMDFySE0zUU9vR0FQY2V0Wmt1algxcnFIMnpUUEVGMGJoV2o4NkVUSVJLZDNHNDhqR09Tdk9hUkZSd2M0cDdOZTlmWDd2TTc3Uk5YaGhLS2d1YmFTT01yUERJczBnQkIzRGF6Z0RjUGV0bTg4WTZMZWFsYTIwK2kzclN6S3pXOTQwU2lKVkE1d1ZZY0FkTy90WFBhYnFYeEtpU09hYWVIVUZqamtJalpmSmVTRTQ1dy9Lc0RuR1J5SzlKc0kxdVNsNUpheDhBK2NUaEpWQkdBTUtDQjdldFVidzA1b3FTa210bkhUMU1pZGRPU05EYTMxckhMSW1YKzB0amNHWCtFcWNrSEk3MXB5NlhGQlp4M0psbXVYYTFTT1dLR1VOQVRqRzdhU2Z6elhubXJhdGFiVXRIdExxZUtRbGtTV3psTGVVcEdDamJUd29IT2VUWFZBUGM2V2t0bnBVcGt0bzk5dUhpOHVOKy9WdG95MmZ5cGRmVXcvbVNncjh1bHYwS1dzL0VIU05MdHRMdFpyR2FFZ2hXbU1XREVTQmlRakJ4K2ZTdFhVYlZia1FJZFdXUkZuTXFwYlFlWXh3Unp4bmFjakphb3Rlc29ielR2TXZMZExLN2pYZkZFMHlHQ2FVNFVSeWdFNVVudjZWeUduK0lKdEV0QkZjYVpGWXFxdUVhR05udGd6ZFRKSUR1VlIrbFZkSXVUZktvMUh6SjI3cjVXVmpxazhQTmMzc1dvVGlGSm8wVFpMRkswUWtVRWtLUXg0NDV6M3JnTmF2anFGN0RQYTIyb1RlVkd4M0NWWThNRHQvZWduNWhua0hyWFkyVTBGclpMSkxwbHZjUkdlSVFUd1N2Y0lTMmNFYmlOb1grdGFmaWVaTGZTbW5pbXQ0Zk5sODY0WXhDY2VXaTdXNFR0bmpQWEZTbVJ5T1VKYTJkcnkzYmZSYjJNaTd0TDJQVElVL3RLU0tTY0o1dm1JczBmWE9RV0Iycnh5Ulc5WjZtMXZCY1RTYWxjWFVjYXNUdGpqWUtWN2dweUFPNE5lUmFmcmRxTlJndUxQVkkyZyt4YkdXUzRFZHMzellCTVpESFBROFUrYXp2ZkViSmVXcHR0T2tBQ1F6dzNCbVYrZm1VeElxcWNZNzlha2lGN3B3bloyU3MyOUNXNThXWFMrSmJPM2xONUphM1JRT2p4aGxaZXpZVWRCM3hYcEs2eWl6WEVkaGF4eHpTSSsyU0pTanU0R2M1d0J1SG9lYTVtNTBteHRkTmxtMUcvdXJhMUFCUTI0RVVTWUpPYzhZWTU1SFExakRUcjZTQjc3U2RZbGppWlJjL1o1WXZNbGRsT0FZMys2ZDJmdkVjVVdKaTY2U2ZOWnU3ZDNyWmRqUW0rSmZpM1JMK0dDNTBtV2FDU1VadVhmeTVIVDZsZHAyOS9hdEM0K0lIaGlXU0thT1I0ak5DN2lJUk9RY2ZLcFl4KzQ0WVZZc05ZaGxudkV2SnZMVUtvOHhwc2dEKzZzTGNLU2VHQjY5cTFJdEhsdU5Va0tTV2lSaUVFTEV3UnR6TVZETXEvTGpISS9XaDZHdnQ1eXB3VUh6cnpldnFRNk5xR2l0YVd6UTNVbDFjSURKSmJQTGxsa0F3TUNRTGhlK1RYV1hLK2JQZWZhYmU2VlZBM2VhcVNReUlmNFVjRGtEcjZpdktwcmo3VnFsMUZQSGFDNmhrZFptaGFaTjBjWUF3U1FBemM4RHBYWFJlVGFhWEVrR3BYTWhqQ2JKUmRLY0V0dEFreVNDdVB4cTd2c1p3bmFNMUphUnR0MTlSTHUxOEx6V2oyOG1vVzluRWthZ1JKUGlXTlI4eEJMZDhqUDBybnRSdVBDc3VrM0wzRjNLa1d3MnNkNWp6bXl5NXlkb3lwUFNzKzdzZkR0L3FUV0Y1NFdLM1N3dkpGY2VhTjB6SjgrQXlubkhZR3VjOE02TkxaeVhOKzBOeEZjM2tZbmdzbG0yeHFSa2JOekRHY0R1T3RMbzJhdHdVb3pYSytrbGJyMitScmFIWWY2SkJOWlhEYWc4ZkN0d2ovSmpLcVdQVDJJcnNQRWk2ekpmUnp3YU5ieE15eG95ejdKVlhkODNPT1VZNHhucFhrRnJCcmR0ZXlYZDFyczBEU3pCVlJyVDU0bVlFZ1pHQS9IVWpyWG9NT3FNSXdMUnBOWW1NYURlWE1jYXVNbkRLeHlBYzVwdStuYzUwNFdjVksxMm03UHI2TlhQUUUxbTlpMFo1OVVralNGWTVKTnZROEhCQXoyQS9PdkdmRC9qSHdwbzF5cXkzMGpiNUQ1Sml0bmVKSTJPTnhBejgyTythOUQwKy9uaWh0ZFB1UExGeGFrbG9YUXlxM0c0eDVKeVg5TVo0cnQ1Q3NGcXNVTTMyWWJtTzUxWEFabURaUWtZOWlLbHBJNktMalBrbEp5YnBycnZmMU9adDlTOE9hdjUxeWsxcGNsRklET0dURVNrNTNLM2JCN2NWekYzckdqUGUyMGtGeGZpQUp0WDdKSm0zSUhJMkFqMjV6MG8xalNydWVDT0dIV1pIaEQvUEpiV3F5RjB6d0g2QXJ1T08yQlZuU1BDc05tMEVlQzh3aUpCV0lReEt4UDNwQUNmbTdlaG90MmVoblU5czBveFVidHE3NjYvbWFXbytJSkx4TGQ0OVFzSHRIdUZpWHp5R1loRHVMSmpxd2JqMEk2VTdWdEEweVRTUWZ0VUZ0Y1hNcWpLU0haSUY1Q0VFNDNIRlVaTkgwdTZ0N3Jhb3Q1b25ReVN3c0V6dFBEcUIweC9jckt0ZEcwQzVieUp0WU4zY0l3Wnc0OHRncmZLTXJqOWVvcXI2SWwrOXpPU2pQbTI1cGVmbVowL2h6eEJEZGlXelZvSVhRdDVMU255NHhHT0FPY2xpZXA2WXJxYlNHMnVOUmpraVZFdlFxQzVXS1lTRUovSHdUay9Xc1M5MUo3YUtXMWExR1J0Q0xKY0o1VHhxZnVyR3gzSGNvNHJqOUs4TVdVbW8zZDcvQUdWZTI4NTNQSEdpaUlwRWVPVHV3UUIyelJLOXRHWVdncEt5azI3ZE5tdTJpc2VtWEY0WHVKcmFLOWxNc0NlYnU4dkkrVCtER1J6MjVyenFQUzcxYmxIMWkrdUw3bG5pakc1dDBlY2trQTR5bTRkNjlDMU8vd0JPUzVoamgxQ0swdVV4RzBEZ1JHUXN1TTdseVRqc1IxcXZhZUlyK0s0Z3RibTZSbGtZbUx5b0dpRERrYldaem5JNzRvWFRRMWtvV2FuTFJTMGExL1UzN2ZUUERzK25mNk9XV0NlTldEaGRzb2FQa0ZpZWhHZUt6VXNkV3RMbUY0VUZ5b2pWd3JSbG54bkdZeU1aUFBRMW42M2U2bElubWFicUVGeGRoTXdXMGtwMms1d3pFOGV2SVBGWWRoZitLNTdxZU84dmRNTWdFWUxScVZlSkR3NFUrK01udlR1N2xTOWpaTkt6VHRIbDB2MU8rTjVlSTAwZHhwTjM1UmRUODZLY1NLVHpoaWY4SzVZNmEyb3VMVTNKMlBHNEt6cWltUGQySlRrRFBRQ3RkWXJQUkwrTjdUVGpNaFZtbWtacEdLRE9HUHpBNUpCNE5jeHJscDRkTnpiM0FXNmxhZFNWU0M2MnFwTFliSTZjNXpROXRCVGxHSzk2Znd2Vlg2ZmNTd2ZEMjFTMWE0czcwTk9zY2tXOWdaQWR4NmprWVllb3JOdWROdWRDVzBmVnRSaWt0bktZWmtlUXh5TDl6SFVCUmpyVmFQd2pkMmVxVFBENGt2UHNabGFTR3p0L21kRzJodG9kaitIdlhWYVhkK0tiaVpWVlhiZE1xc1ova0FHZVFSakRGTzVGUzIvTFlWU05GVGdsQ1VtN0pPRjJ2bmMwN2V6dmJ6ek5RdHBiZWQ0b3N4aHdGV1FrbGxMS1FPTTF5ZCtsaFBwa3FYQTArV1JSS0pGSDc4UkVqbGx4MkJQU3ZVRXZka0dvTmI2S2Z0Y2V4R1dYRVlmakhCYlAxOXE4YW4xdTJzbGl1N3p3MkxPOFJIaVdPT0FNczNHM0NsZVBtN2swcnF4dktLNUl0U1c3dTlkNy9tZFZwVjdmSkRwVnJhemFaQkhLeXhaZ3psd2dBeW9IUWs5UWF3OVU4UDZOcW1xd3pEU0oyWlhSSnBOelJRRmdTR2NleC9uWG9senNpdEk3M1M3QzJnVy9YNVlrVUpLMmVGYzdzWXdjNTlxOG8xQy84WjJHb3ZCRExKSnZaUTluTEtqSUdIQkFZakcxeHpWTHV2bVkxSk9HanFONnJXMm11MXI5enBCNGVsa2hnamlrRU5sdWxraFdDTWcvN3U3a2duMTc5cTVaVEhOT0pJYmpXYklHTnNoMUlPOU9uSjY4YzEwcTZuckZsYldrVnBiWEVrY2Z6UElwU1pZU2Nzd1pSZzRYOHE5YXU3NmJVdkQ4UVc0anQ1WjRrQ1NQRU4vemM3dGhKQTNEdFMyWHpzVFNoQ2V0MnBwSjNlcWZrdFR6cXo4UjJjOEVLaG1sa2JKUzZ1R0dBNmpBSmpQUVlIVVZ0V045NGZtdWRMdUpMZU5MNVZkcGpDKzBZNkE0Nk4vc2l2TS83TDhSVzBWeEpOcXR0ZEltMUlnTFlZZ0krY0tWVUVnRWRhMnRSMGk0dmRGVlA3U0VraXVqeENIYkNmbUlMS3ZicDB6VHZaZW9uVXF4cXlWNHl0WjZydCtwMlU5bnA4bm1QOXRqc0V1SlBOWXd2c0pJNEliNit0UVdaaXVpSTRyWmx0bEpDeXNWYmVNNHgzT0d4V0ExNTRjczVETHFWekRGNW9aUkpHTnJGazRFWkhPVHh6V2RkYXZvVmpLTCt5c3JxUnBVTzRRT0JHa2d3Zm16MUhjOFVhRlNrcGNyZkxGUHoxWlMxMkRVWVJQRHA5MHZua21STWpJSlRCd0c2OGREbnBXZmEzMnUzWVQrMGJXQ2FPNFI5eTdnNVRqYVYzRDZackh1L0hkbmUyRjNKQkQ1RFFTaDdoZ2dqWkMzOEJZZGpqUDg2MzViWk5YaWhuMHJVcmEya1lySklzWTNzTndJRzRqQTU2ZldpNnVqa2xHU25LS1RTdW5kM1cvVFVwV2R4YjJGdkRjUTNWemJ4SUpmTWhKSjMraFhIcFdoWWZFelNKRExHbHdmUEJBaU1tWXdkL3lqUHQ2MXZUYWZQWTZSOXExR2EwdHAyalZVdUdPNUh3ZUFWL3ZZNjF1V0Z0cHVvVFNMdDAyYUlrYmRwSG16YlYrNm8vaEdlYWxtdE9Nb3BKeWNaTkxsdHB2M1RNaUcrMVdPRWZiTEtHOUU4MHBiYmdxZ1ViVlBJKzdXYm8zaGlTNjFDU2FEVVdTMGJDR0hhejR5ZnZBbkdQclducWwxcFdtMkVDaTF1WXR6dWJaWjJ3cWx4dEs1em11dVMvZ1RUdEpsdDlXc3JlVmtNYUs1UGxudXkrNXpUdlpLeEZPTjV1TTVjNmpHN1hYWHpkaGJuU1BEdmh5R1ZZN1pITFFsbE83Tzl4L0NEemdIcWE0bncxNHc4TFg2dkJjUnhsekNUSis2eVVrVHF1NDlRT29xM3JOMldHNFQybHVHQlVSU052UUVIaGdWem5OWmR0cHRsYzJ0Mm1ud08zbENSbVdBQkFHN2xHT09XUGFtMW9qV2RhS3FMMmNGL2RqcHIzOHpvcFhNU3BlMnVxa1c2S1F5eVI3dk1WaHdBZldyK29hcnFjbWoya1YwaGlSY1MzRndzUVVCZlg2MXdkaGFORVpwSnJ5V01yRDkwU2lRcW9Jd05yRHJ4V2ZENG5nUy9tMDI5dm11SnpCdWlnRVlCa3l3S2dnakdjVUlVSnlkMHVhTVhIVkxiNTlrYWVyMytuWEY4ajZkUGF5MjRoM051azh0b2NZQ2taNEl6eWE4dFZmRUp2NWJ5WFZSRE1ESEJFUGxRRU0zQXdPTVlIV3ZVTDYwOE1YOWhHbHpvOHRwTk1vQVZTR0RLTWdNTnZRY1ZUamJ3amJTMnFIelZobUJlT080QWJlVStUSVBYcU9LYTIxUW0zSnUwb3ErOXVubnFjN05vVnBQUGR3WE4wbDFDWW5JUkR2a0Q1eWNZN21zaUxTNzVVdGx0b2phMjdGVXpHbmxTQWdkU1A1MTAxL2IrRnpyVnRjMjg1UnpjRjNNTGxkb0F3Rlk0N211cGJ4UXJTM1UxdERHUTdxNythT0ZJR0Q4L1EwMDI5emlrNFFkblZzbEw0VXJvb1h6Mzl2YVMzODE3Y0tZVzhveGtCakxrWkpBOUsyYkRUOUdTd1I1cnE0ZUs2VkdNREhjUnVCT09PbWNVYWRyZCswM2wzK25RbTVra2FTR1pTWGp3Ni9LdzZqQjZWeVN6dFpha0lQdEVjTnc4YXNrRXJDU04rY25rSDVlbEs5MTJOK2FFWkswZWZWcVRkOURxUEREYU5aNlZlMm9ta0FtWUlIbnlRb0k0Q0gycmo3S0N4RnhkdEZyNi9aN21mQUUzeXlxOFEzSDczWTlxMlo5QjFxNEJ1WlBNdEdHQ2tFVWdraWNnRTdnRDA1ckFheGt1SlpJYis1dDRwRU1RUlRHcEJMYzdHWWNqTk5PeWVwY3FrMG9xVUU5TEtXcTg3WE16UXJEUWhxcG5YVU5WVGV4Mkp1eXJQajVncDdpdlJwN1czczdOVDVNazRQbUtpRnlDZTdPZlU4MXdNd1hTN2p5WTdGTGllS1ZpaVF6RTREbis2ZXhycWRKOFJhUEM4a1JsdWtlRlZNMHJxUjgwaE9WVUgrNlB6cE82MU1ZeW5KUzVtbGJSeWZTMWxyY3YrSC9BQkhwQzJ6Um1WWklZMkdXbGI1MUsrZzcxMTJ1NjVvc05qQkhmc3JxY3NyN01nSE9RMmZXdU0xUFM3SzdkSnJLSzNqdTVIQVNUeXdWZER6azQ0Qk5aV3A2aEg5bS9zNDZpdHdpSFpoa1hJMjhNRDN4emtVYnM2MVduVGpKTnB4U3QwMThqZGgxSFM3MldNd3JGSkZPdWNCOWpoczhranIwcld2QmF6M045YTIvbTJjc1NMTmJTTW8ydGtmTUFUMnJ4ZS84SjZiWlc4VTVrQzNEU1NydlNUYnQ3TGdIMUhOZXBXTHoydWgyMW1idEx0MTNBckl3SlE5ZVc2NHBOUDFJOXBDODAxZDJUMVM2OUVjWlk2ZExJWVpMNWJLZXpZTThwRVdXQnh5QVY5Y2ZuVjZlNHNOT3RaUHNiTENrNTh5TnlTUnU1WlI3Tmp0NjEwZWw2bHBzMmx0YnZORmEzYXM0TWF2M09jWXpYSkpydWgyV29xYm1IZmJYSGxlWXVQM2taUTdTKzM2OVBhbDMwMlpqeS93NDg2MVY5TjE5eFBmUzZaZWFZYnVhWm4zckVrUUtsVzU2a1o0NUlxMzRmdnZDOTFwZW9MWTIwN1hhL3ZERkx3TWc0QXlPTWUxZHhMcjNoZGhMYlBNbjJObDNpZDF3RWs2Z2YvV3Jnci9TYnBicTl2dEMxZU9SRWpTYVNQR3dIcGxRTzlEVGZTeHFxY0lPNjVaM3VyM3ZidjN1YmNQaXpWOUoweUtMN0JKYjNNa2hkeXFlZEVVUFRiMXdhS2hhZTEwZTJXU1c5ZTBrdVNybG9uOHhEa0U0RzdwMTVvcHBMeU4wNmlTWHRwd3N2aFRXbjRvOWV0ZE0waTV0WUk3eldMaG96T3RyQkxKQmxXa2tBVlU4czdDMlA3d1BGZVB6Mld0NmFtcUpZWGxwSll0NTBETkU3UmlLWjIyck1pb3VjZ0hPT21LOVhrWHhqSkJQY0RYWkZVS0dWSVlVRXFEQlJuUm5jN1I2OXdjRVZRdHRWOFcyOEU5dkpxem5LN3lWdEZaeVZ3eDNqY0N3eHhnRGQzcDh5YVhWbmJOVWs0KzdaMmV0cjN2b3QyWVBoZ1hjT21TdGQ2eGJTVFdpN2JxNEt5UktvSjJnU2Jpb1ptQ2c1cllhWHhmZFgxcmVXbXMyTnhZelJzMzJWb21qMnAvc2hTUXlnREdSam10WFZmRDlycWtJT3EzeTNNSmltbVdBV3JMNVRLd09WM1pKRVorNlc1SE5jM0g0WUxSUTI4MTZ6UGJKQy9ucmxCSXNub3crYU1nY2tBa05TU1NST3FUc3Qrbk12WFN4MTJzeVJRV0R4QmJGVXVGWEtMSUZRR1Fnc1ZDZzUrWWRSK05lUjI3WGVqMzh0dkpielN3U1JaVjFraVdNc3d4dEc4SGNRZXZVMTZuL0FNSkhvd0R4eFhUUUpHTm0yYlRISVJrT05vazJuZHZJNmdkSzE3ZWUyMUxSSUhodDlqd3pRYmZMVUlBVlB6T25uRGFVeDY5YWF0WkV5cEtkUzZrcnBhZGJlbGp4TlBGc3VuUE5CWWFRMGlGSkpwNUo0MTNET0VKalJWeDNETG5pc2h2QTF6cTl4OXFta1Z5QkN0ekF6dkRIdkhQblJSd3RoWlNQNzNHZWxkTGRTMzArb1RmYk5mZ3RrU1J2S251b1JIZUFZK1FLRWJaa1p3VGpHSzdhd1BpTFRMU1NXVFVKYjNmdWRwSmdWTVlJd29RS0d5NFBVOUtoNk1JdVZPUy9lT3k1bGVPOWlMU05SOFFTMnRyWWFobzVTNHMxdDFlNkd3S0FDZkwycTN6S1FPdU9NOTZpOFN6K0x0UGxNbWxhYnBGdk5KdVNTV1lpTnBZM1BEeGNrNHlPNTYxdzM5dGE3RFBQYjNjSW1hNmpRSTBXQWtQejhOMzY0emtldGRWYzZ4RUk3clRZOUxlS1NaVEZjeFQ3L2xrQnp2R3c4aHM4N2ZyUmZ1cm1jTVUyNU9ObHZ2OEFjbG9jY1BFZXFpNHRwZFcwdUIwVVJ0QThiaGk3cG5lbTh2a0twQXkzUUROTDRnMGk1OFR4clBKYVcwTUhscUV1NG84bFdIWnBJaXdLZHVSMDcxNkJZWEZ2YnZITGN4Umkzazh0b0kxWDVGbFhQN29vNDRBenVCUEo5SzJMMldQN1M4bHVrTFRQQzZ4V2FHU0Y3b3FNc05nK1J1RDY4aW5kV1JIdlNzNHk1WlhWNHJWN2JzK2E3RHdsZjZVMWxQUHEwTTd3TTd5Uld5TUkzQ3FBUXpSbklJeDk0ZFJYbzkybjJEVUJlWGRyYnFTNUVjYnRISTVIOTBsZCsxZ1RrTXh5YTlKMG5WYmUxZ3NrL3N1MjAvN083QXcvWmp1RzRaMmc0QkN0NmpJejFxZlVyenczdGhtOHEya04yWlhra2gyRno1T2RwMi84dEY1ejE0cVhmN3lhMEl6aktYT2xKTzZTamJmMDlUelNDVFQ1TEFyRnFVa2x0SERLSmdwZHZJa0xEN3hLZ2xPZUN1T090WDdlNGtXM2doaDgxYnN5b2tja0x5UlJNeEkyeU9Ob0NiaCtkZGhZNldiUzZ1b2Y3YnNvcExtSldDSWloOHV1Y3VnWWtvYzVJeHlLNXJWcmk1dTcwUVhHbDNNQWxoVUpld3U2Ym1QeXFYQ2h0cmZOa1o0Rkd5QlllbzdPVm8rN1pxMTNiNzJjWHIvaXlWZFJ0cmZVNXBCSE1qMmtrbHRJWkV5eE9EdEMvUDVlTWJ1SzByYlN0UlhRaTlxVk1OMU1NTXBhRi9sSjJzaFppQklHL3dDQTdjaXNPem5zZEZNRnVMZThZZVl3bEZ2amVHY2JEdmM1R3dmVHVEWHBGdm9GN2U2TEpjSnF0eEd5enF5UlNQR3o1VlNxcXl4NHdSbmRpalJlaHJDOG5GMnZwTHIwL3dDR01tOW5oOEphS0pidFo1akhPa3NETWhhTWtBZ1J0SVB1b3A1WGQ5S3dOT204TGE1ZVRYWG1YcjNNaUdNb3JSdWlSdjhBTVlnd0h5cjZOaklycHJ2VFduU01HNVM2Z0YzKytnaWxNd1FZd0FHWWh0M0I0elhtYzk3L0FHYkxaeTJ2aDY2RjVjR01KR2pHMkxvRDhvbGNMeWMvZDlRS0d2OEFLeU9mM25LTUZHMTc3dFdaMkZyb2NsckEwbHJldmJHMVpzVzBzcXlMNWJuYWNuNVNIWGpIOHF1V3VyNlpvbXFOWjNNOFQyazZTQ0pZRVhIbW9DU3pnWUlPNG5JSFUxUXZ2N0dVUTNXcjZaSEhKUElHbmtsbElseVhYNWdwK1ZnR0hJRldXMGZSTDJhL2wxRFRyQjRFRysydVczZjZVSkNBeUp0NmJXNUdPZ05DWFlkT0tmSzlWYlZ2ejlPbzNVcnpSZkR1cWFaTlpSeEY3bTBLcmRHSXErNW1ENzMzSEJYSHlqdUs3S0hVclpkRlc5dUZzaHV1V0o4dHZQZ1J2dkZSakczZHdUNzF5OS9wRFdrVWRyYWxJb1BMWll6Y01wVzNVa01VRE9DY0VBbkJ6NjE1MVo2ZnJGdGN0YzM4OWpZMmlTeXdiVXQ5eVNxUjBZUnRqRER2MFBhcGQ0cE0wY3AyazR1M0xvazlqcmZHQlpyUTNHbTZ1ME1raWdZUW9nUkMyNDdDZVZBNlpBSjY1cks4TnpXOCtrM0VWM2RXNnl3eEZvemF4NW5BSHpNQXo4OEg3elB3SzIvRW1vNkJOWTJxVzBoTjV0RGxCQWdtQ2QzRzRBc0FQNFFjWXJ6L0FFTFE5WWk4U3hhclk2alBjaHJkbDJSV2hlUEdEdVhBWmRvQUlKM0RrMVc4VloyQnRWSnBOd1N0ZE8xK1p0Ykt4NmJBMnMya0YzSkZkeHpSeXpDZmJKZVJ5dVNGSHlSdXc3RWZOeG1zQ3g4VFgwMGRzWTdxS0Y1WTVKakFaUkl6bGZ2bGxVYnNnRGtrZ1ZINGg4T1J5ckxGTTg5bmM3WXo1d2pWUVF3UHl5STdiaHVCNXp6M3JsWi9EaGJTL3RxbGx2YmE2OHFDTlltUlNzSVZIR0UrL25qQTZBMU4yM2E1ejhtamNwUFM2c3BXcytueWJQYWYrRWZzTDZDSy90SGxpVXpSWGo0bmNTT2hHOWtZQWNnay9LdmJyWE9hcC9aR3BRU1FXZW94UjNRWkg4eUoxSGtsUG1VSkcvREt1Zm1HZm9hcXRiWDk1RVJLa2toQ3NobGVjZ3RsVC95ekpVWTQydDM3VjU5TG9NT3MydWtXc09sblRDc1BtUGNsd3FJeDNiVUpCUFgwd1NLY3QxYjVuV3FzWjhsbW8zYVYybDFQWTU1OVR0TFdWZFF0N20rdC9MUm1aNFd5aktSdFlTTnd5NEJQSFExSSt1UWF2Wlg5cGRYa051VlhNVHhNWkdqaWI1Z0pOeWdBbnNNWkk0cnl2UTI4V2VIbW0vdGE3SVFrcVVKKzB5WEVhb0F5SmpJQUo3amcrbGRYWTZQNGRrMSsxdkVXZTBZeGw0N1M0VHlrbUE0L2VZNUp5YzhIbW5acjVGY2pnMnVkVzIxMXU5elQzM25oL1RieElyNTd0N2pkNXNCa1Jpd0hMU0tyakRObnF2VURwUzMzaS9TNy9TYmEwMURSVm51VkN4Z044bXlaY0hEYmNLRVBPZS9vSzVXN20wT1N4dUlZOU9sTjM1TFF4eHlRc1k4eGdLVkxwaG8rZXU3bXJHa2VGdFlzaXIzWlcwamxqUXlKQisrQlZoamNJeUR6dXgzelJyMk1GTEVjdWtWeTl1bG50dnNWYmZXM2tuMVczaTArZTNNRUpadktSV2lWWXlBaUtnKzhYM1l4MTlhOUp1clY1ZEFXUy9TUWhWVnBSQkFDNFovbUlSY1pWL1p1TzlSYWJxOHNNY2RwWlgwb3RGbEx1d0FDM0FCS2s3eWNydUlQQTVOV2IvWE5YaTFXY1EvMmxkMjcyYzNsUUtnZDkzVGY1aElQT2VBTStsRm4wTGhHZzVkYjJzNzZwdmM4Zmp2TmFaNUh0SnZJdW9JVm5sVzVnbGtFVVVoQVhDWXlKT2ZtQTZWMHVsYTVMZHpMTE1iaU11MHNhaUsxVHlaR2l4KzgyeXBnREdOemUrYXZ6K0tybTV1SlRkYWRQRUpFUkoyY3lDUjB5Rlpsd3hJVURyeG50V3hvbmlMVEwyNXQ0TGVieVlVYVZGWmxaeUMvSmFJcG5Da2NBTWVPOU5KaEdqVFdtcXRLOGU5MzMyTkkyUGlMVnJPNGxONUhhekJVV0VTN2dqYnZtSmtXSW5hUmtjZzlxNWFQUU5Vc0NxM3VwMnozQlVUSmRrU3NIbjZydENiOElBZm15Qm5pdHpWUEIrbVhzVnpjUVhWeFpUZ01MZ2JpVW5EZy9kREVnTi90WXo2VjVuSnF6YVBwY0NXV2g2bGNNSkZUYzA3UXk1eC9yREhrTm5IVFBGRmxjNnBRdW9KV2NyNnVYNVhaNnRkV1UxeFp3U1NycCtvV3NjckVTVzl3OExvWFhjemJYQkMvTmpHU0szWHVwRHBzRU53TGhabzVmSlpJM0Q3QUNjWjZBWng5N2tBMTVqRHJIaUxWRGUzY0tHMDg4SzNrd1F1elBIdDJOdVZjaHVldmF1d3NiNjh1SkZ0b29Oa2tDdjhBWi9NajN4WEJJNFVFRTRqVGJuZDNwMmFXcGxkZTBra3ROdlU1Mkh4bG9XbjZnOW8rKzMxRklWWXRkeDVVNSs2cEtuTEhweGpPSzlJdFo3S1hSck9lOGd0RWdNbm15S2pMSWhrYzVjb3JaQlVkU2E4NW4xeWROWjg2WHdmcU56Y3lxWVZ1akZGS3lzQUJ6SW9PWWllUXhJWURnVmE4UWFEcFR6Mmw1SERISGVnZ1JyTGRNR2ZlMkdNZThNRXgyNEJGR2x0RHBuRlFob3JXV3phMVp2NlY5c3ZmRTBjK25lSTRuZ3RiNkZtczF0c3FrYk5od3hjZzVPVGpHY1Y2SjR2dkx5MzhiNm1ZNG8yUDJtVTdKQVRHZHdCK2JIYkJyd0sxOFdONGFTM2Uvc3ZLbkQ3Qzl0SXR3cGJQU2NoVGlUMU9lUWVsZTdmRTZWN2Z4QWJsSEFqdTdTQ1hjZVJnRFkyUGZpdmd1TUtkZDVQVHEwcmM5REZVNXA5dEdrL2syaitnZkNxckg2OWlxTlZXVlNsS0xWcko3T3lmWFJHZjhQc2FGOFFkS1VTeVN0SnNqZG5KKzVLZGpCUWM0QS9PdTV1L0ZhWHZpZStZS1Z1RXVKaVZZZk9pTm1MSVBZWTR4MUZkQjRDMFMzdXRHdTljdUpkand4elJXN0ZkNGpkUnRNcEFCSlBQQS9HcDlWOFAyOTM0VnY3MmVCNS9MK3pzMDF1Rmp1WUxaQWR6SzJNeStYOTdhM1VkSyswNEtwWnJUeWFGWEcxNVZLbGVYdFZ6UG10RnBXKy9leDlseE84RFZ6Q2NNTENOTlVWeWFLMTNmL2dsaTF2YzI3RS84dEdDZ1o3Sjh4L1VqOHEzcnpYVjBuUkxOakRMSTEzSzBybU1iaXFSL3U0cytnWnNtdUUxbnc5NGcwaTQwdUNDUCswcmFTM1FDNWhQejdtUE1oakhJUWxoeU9LOUY4YzNQaEtDMHM0SWI2TTN0cVlZSFdOeVZLUmc4T09odzNweUsvUTZ1SXAwMHVlYWpkcFJ1N1hmWkh3OUNsaVh6dFU1UGxqZTZWOU9yMFBCOWExbUtXOGRaTnFKcEVKbmtrQno1cEorYVB5L3VrTStNRTFUK0dNdDlydmlTSzNmVTQzVTNFUnVvVjNNU1dMUE1KTjNBWEF3cFd2UGJ1SFVydXd1NEVLU3ptOGhsdklneWhtV0lmdzRDZ2xuL0hIV3ZjZmh2cDF2cEhoeS93QldFQ3czMTZHczAyeG1MZk9lSlpBcEp3RVgzNjVyanhlTXdHR3dXTHhHSWxPS3BVM1VUVFhLdVhWODN5MlBid0x4ZUl4RkNqUTVKYzgrU1NkM0xWYU9OdlBjOXlqdUlacmk3bWpYWWsxeEs2S09BRjNZR1B3RlhuL2ZJa1E1TXNzY2VQOEFlWUN1U3RpcVF4b2grVlFxajZDdTM4TmVUYytLTk9oWjFHd3ZPVkpBenNHRkEvRTEvbC9sT0ZxNTV4dGhtNDY0bkgrMW11MGVibmwrQi9YdVBuREFaTFZkOUtORGxYcWxaSDI5QnRDQURzQVByU1QydHBPeUdXSkhLOHFjY2pOVlVZY1p4VnBYSHJYK29OdEQrT09aM3ZjMFM4YUxuZ0FmZ01WOGdhM3JqYTVxN1RLeE5uYXV5VzY5bmNjTkwvUmZ6cjBMNGxhL0xhNlZGWXdUYkxtL1l4cXc2b21NdS80RDlhK2ROUE1uMlVTeFNCSVFNUlJzUGw4dEJnRTl3VDF6WDhvK00zRk5URDRHR1U0ZXB5enhFVkt2SlBhbTNaUjAvbXRyNUkvYWVCOG1WUnp4dFNPa1h5MGsrL1YvSTlBRWlxaEpPQU81OXF5SXJuN1ZNVllNa1lVTWlzcFh6UWY0K2VxMWE4T1c4ZXY2akJDK1V0a1ZKTGdNY2JpM0tSRDFMWXlSNlYwY3o2elBxZjhBWWVwd2czd01zMmwzY2NlSTJSUmt4c1IwVEF4ejBQQnI4VjRYOEo4ZG0zRFdMeDhxanBWNUovVTZidGFmTHU1WDI1dGw5NTlobVhFbUZ3V1pVOFB5cVNXdFdWL2d2dGIwNm5vZmdEVWtqdjdxeEpHSlFKazltWDVXSDVZTmZPbDc0VzA5dkZDNnNacnI3UkhHMFN4Q2QvSXdjamNZaDhwWTU2MTZONEM4TDYxSDRpVzdtU1NLT0FrdnZVcVNjRUZlZnZIbms5TVZpWExzWkdZZ25KUE9PT3RmMkQ0YllmTTZmQ2VDdytPcFZJMUtGNFE5cEhsazRMNGRIcXJYdDhqOGw0bHhHSHBadlhuaHEwV3FzSTg3aTdxNzBhK2U1N2Y4TmpHTlAxTUg3b3V4dTNkT1U1ejdWNUMxNHNOMFpJeGhGdWhKRUQyajM3bEg0QVZyMnVxUFllQ05ZbGpHR211UkNDTzJVNS9UcFhBWG91bHNZTHA0d3FUMnplVXVjWktrQW42Wk9BYS9MUEZ5cmk2K1B5YkM0ZkQ4L3dCVXJReFZhcmJXRjVxbkJYODJ6M09GWVU0WVRHNGlyTkpWWXVuR045K1dMay93UGkzVC93Q3locUIrMGFqOXBlU1p3cXp3aFpVQWtZcmpaOHpIMGJvUnhVMHNVS1c2MmRwcFZsZDJiM0JaMi9lOVFjREVjWUd4d3hKNjQ2MXorN1hXRnZLMzJhWVIzVXNNcldyakt1RzJzVlp3UzVHUmtjYy9TdVZrOEFTNlBQcU9vUHI3c1hrTE82RVFvVlB5NExFRUFuZ2tIcWEvZWI2cy9oZVVwdHpmSmF6dmRyZSsrOXpqTHJWUllhdk1vOEZ5M05vYk4xODFyVW9mazUyNExCWFZpdlUxVDhPZVBmRUhpQXlXbDNwMG1rVzdScXRwL283SmdBY0FramFFSTQrbGVpNkdkVDh1YmMwdC9iS3ltRklKR2tXTlV4OHZPRlhIVWtIa2RLMEliVzZHclNXQ1F5eHZid08xczZxWmxNaDRPOVdZNUxMMHlRU09sVlpKUHZ1U3FxOWk0UnBYNXJKUzVtdlh5T0FiUXBiZUMzdGJYV1lvVHVtV2U0Mkh6UFhhck1TV0hHUjY0NHIwYXhlU2VmeUlSQmRXek90dkhKSmJySWhLTGxtbDNGR0hya2MxenR0RjR2YlV5bXBlTGtlMmNzRjJvSTlyNHdxcUF4dy9QUVl4aXV3bThMNjFQcGwxWVRhajlxWkZMeFNUU0VYRWljNVFDSWdkQmpISnozcU5kRGpWS1NsTGw5NVgzWFgxYlBQcDliOGZYYmdmOEkrc2RuR3hrTjNCT2ZNSlFGZjNjWC9QUnNjS3d3YXpiR1A0c21DWi9QaTArMk1KY1JxLzJpVlZIQTN4K3BBNkRqMnJZbXY5UDBtNmEwR3FDMWNCSGVDOWxHUTNWQW8rY0xudjcxMCtxeEcva1c3Z251STU3TVJ5eGxHYVd5a3c1M0g1UnVianQxRk5xOTF1em9WWG1YdlVWRnBXVWxmcHU5V1NhRGRhVnFxWXVydGZOUUxnMzltc2NUdEdjRjBRdDhqWjZpcWx6cVZqb3VweHlLMGNNRFROc2FPeGFRTzM4U2J2UTR5TnB5SzhoOGYrRDROWjFHWXBxc3NFeWxmTWhaSkdpZnpNYlNza25VZ25rZzlPMVAwM1RicUcvTm0zaUo3aVdIZGtYVVN4QlVWTm1WNURiRHdCanQycUdyTGNKUmdxY1dwcjJpYmZMWjNTNmE3SHRKbG1Ob3B0TmF0dk5aM21pam5oQ1FOa0JGVk4zekpqb2VvcmpicnhOcVUxazE1cVZ2cGxzdTZTM0s3Uk0xeXNCMmxYY0hDcm5CR1JrRG1xbDFvMmdrUnBxdGpvcitSUDViaFoyaVZGNDRJNEc3SjV6eldCb1duNkpjWGx3bW5SR0cxUU9NU05ISUduQktxNk5odW1QbTI4bW1rKzN6TTVTWHN1dDl0bm8vdk9zMVE2UHJscE82aTN1Q2lxSVVpakpOdktXK1VsaVFER0Q5NFpJOUJXM2NQcjl2cG15eDFyVDQ5aXhTeXd6MisrSlFvMm5KK2JjT3g0ejZWeDJwZURmRmlJTGVTOGp0b2ZQUEN5TkdweWM3Z29BQjlsUFN1NWkwMjZudDdOUThNOXZBa2p4U1BkUjJ6aHVtNTFrVnNGZlVaNHFveDBNVjdSU2I1WGRkSDAxL0lzM1dqMytvYWVzOW5IcHBlNWVOU3dpY29pTXZ6R0l0eUNPK01WbVd0dDRoazBTVXQ0ZU1zeklRcUdNeGh6R05xbmRrRXFPT0RodTljWjRqdFlML1VFdVp0WXY3TTJiUXRkZlo3ajVXTDRHRlViU3FnODd4K1ZicDhQMnVwNnRibTE4WHRKWTRlR1hUemNNelNEZ2JZR0h6RnU1QkhKcWZtYnhwMDNacVN1MDdwNmZMNW0zcDNpRzNsamdpMWFTd2h1b1pIREs3ajdUa3FNaUVMbkFCNlpOZHpwK2xXalhSdjlObk8xMWtSSkpwMXpKSVFCdkROdnprOEVER085Y3lzRnRMZlJSUjZJdXBXQWlrVGRiSUduZ2tRNDh0bUxqa0tjSE9LTEt4MG0xQWdYd3pOQ2txS2hoajNiRmpMWUljSytBK2Y0cXV6N20vSWtvODdWN3Excjdyek14TGVDV1pyS2U2aWVSTFoxVzRsc2d0eDg0WUZWZU1xT0JrZ3RnNDVyY2U4amtzcmEwdTlYaGV4YTNKYWVWZ0RiaE9FRzRuTWhJNzllYzFtMkM2YkpkU0lOTzFLekZvQW9hOVoxWVpVOHJ3Y28zdTJmd3A5czhFbWtYU2FkRkhkK1ZHOXV3dTQvTUNTQWJnVWpLN0d5TzZtaEk1bXFpbTFKM1d0N1hmYlN4eW1vSnFIaDY1dUpZZE1iVW9KQXN4bXRnNjNESzMzVkxTbGlmVEhicmlwOUk4UmZEcTdTUzR1ZEx1Tk9lR1ZRWUpweEw4OFpMWmtWVG5JKzluMEhOUTIrcGVGWkNKclBVcmFhOWpFY1F0R2g4c2VlUnViR2NoV0E0QU9NZGE5S3RiQ1JyUDdQYTJlbjJVaU9yd3lHM0Q3V2xBenMzRmk3L3dDMTB4VlhWdGpwU3RKcHdqemZFbnU5ZWhxNlo5bXRMUzBUU0ozZUNScEpUYk1SSnVXNDVVQjNKS3FtTTR6elZXQmZGU1hFc3FKSk96N3d0cmNReCtVWXg5d2JsWTdHeDBibXVFMDN3ejhRbzd0dzJ1dDVMU2I5bGxDSVgyaFNQbjh3RUtTUU9sZDlENGxXRlBzendFbUdIZXN0MU1GRHlKbmNwTVhHNy9aL0NwdXREV2JqRnB6bTQyN1hTdVpPbCtFcmU2dVk3dHRNdjdEVURLQ0RMT0hMNUJMYmhGa1k1NmtWZ1dYaERXYmVWamJlTGJtV0V6RkpJNTRESHlmZFNDd0dPMWREWjYxNEhlYUM2MUNXMmE4VVlFMXUwajdTRGhRQVFQbFBwMk5XdENrK3p2Q2xyZHp5MklLeVN4VFd1RVJ0eEEyTUNycUNUa2pCcFgwdVpmdTI0dEtPdlhkcjc5dk00SFZZL0JHblhJa2RyQkdrWkJPOXhDNlNJOFRITG9yWUtISitZak9hNnExZzhJYXpZU1EvMndMaG5kbWpnQVlTeFJqQnp3MlNUMzI5cWJxOCtzUGRocmpRYkc1dVN6Q0ltVkpWWk04RkdiRExrRG9NNE5jYnExd3JXcTJtbjNsNWEzUG5BQ1ZuWGZHOHBKVlZabEJ3T25vZWFPYVRzak9jb3hsZHBhYWJOVys0OVgxdlE5TTBtMWlNT2x3M2NOc3VMVzI4b1NoVlhMTkorODVCQlBJQnFiVEZudHRManY4QXpiWklwb0VhT1VRSklxU3NjTHUycUNjbmpIVUd2Q2ZCdW1XR2x4VERXL0U5NWVYVjRzZ2Uza204cUZTQmx3ZWVlT0FlbWVLN0c3dWZBOXU0ZzA3VUxpRloxZDFHblROSWdLa0J0MFEzSDM5Q1JtcXV6YW80dXM1eG5GeFM5MjBudSt1eDJFK2lhUGQ2bWl0cGJUUEhEaVc0YWJhc2VRRGhqSWVSL2R4MDZWd1dzZUg3YlQ3L0FPMldWNURCSkxJcjR1SXlBR0hCQlpTZHc1emtqakFybzVyUFNkUTAwQnRXdUx5eUxrUytiS0lDSUpDT0dVZFN1TWdrMUhwZmcvUzlJczRybXludUhZcStMbVNSRmlsV1UvS01qa0VmZDRIVHJTdTduTktONmNyS045M3Rvdmx1ZGhydHRyT3FoN09KWVdNVFJOOW9qbGJZeWtibWl3cEJjNEF5ZWxZUGlCdFVsK3l6V21waXpqVlNIRGZPMnhlcDhwODdkbU1ranJYTk5GZEpwOEdvZlp6YTNYMnR2M2IzeDJMZ1lKV1JXK1pUeGhjVjZOZDMrbXBlMmp5UjJpWGNpU01KRWJhMDRBSmRSdTVQMEZEdDJOVytaelVwY3NuYnJmVG9jUmRRWDgvOW55U1dscnJNakIyRnlVVXJFRkhIbHFOb2JQVTg3cTJEckN5aVh6dEltRXFKSWp3VDdZb21VL0tTRndTMFo2Y2NWbjNPcWVJcnpUclc3MDY2anNJSjlwVkpZcEp5cHlRenVvNGovRG51YXdOUTFMVUl5WW51b1d5QXNYbXl5eEk2azhzZ0trYlc2NEJPUlM2R0ZTcHl4NWxOM3N0N05hYlBVaWx0TFBVN0syc0liWDdIY3JQSkphd2ZaeEhHV09Wd2dPQVZHY2tIdFhyZWxXTUVhVzYydjJZUkswaGFOQ0dCZkcxbmlVSDVRTUhKNlZ4czNpQmIxdE9XN3RKcFdqODdJU0JwRkJiNVdLdnh4dE9CajZWek12aHVVNnJiM2VucVlTZ2tDN2tEZVQxK1FET0FEbmtBVUozUVFsRlNqSlhudHJhei9ydVhwN08ydDdYVTd4bmg4cTd1Q3F4eXVXaUs1Kzh5N2NvVDB3S3piUFZ0ZE5vVmZSN1cyMC9FbTY4T01saVBsS2JjakFQcjFydFU4S0srbDJkNGxzMEY2ekpKTUxqZE11UndyRUFnQSs0NXJ6L1dkTXV5MDlqcSt0ckZjbnlqSHBsazVpQlJ2NG1kbEpCd005Qm1oclhmUXRVcHhUazN5M2o4dGRiL0FQQU5pTFF2SzBTOVJOUnY1NUxtN1dRdXNSbEVaQzdVUlZJT1VCT2YxcnFydHRadG9wRFBjN3ZJdHc0SmJhcWdEamNwVUJReDc5ajByUnROQSt5UnRhMmQyeWhWSlJ2TUc0cklBUHU1Qk9jZGZXczdVOVU4UXh5elc5dnJjS0dOZ0pra3N2M3BST3JnN3NNTTRDaW1yUHpObEJxSHZ0eDkxTFR5NmJubHlmRXZ3THFpdEhkYVhkQzlkR1V0SEQ1dVZ4bGp1WEhib2ExN0t5MTFZN3FlTm1mVGp0WVBIRmh0cE8wb0FRTUVEcWVjVmR0MDBtK2tXNGcxQzF2WjRaQTMyZDRQc3pQSTUydXZtTU1INVQ5ejByTWJSL0VVZW95bUxTUllSb2gzNG5ka1pXUEFpMmtqYmtna2dVV1Y3SEhYVGs0dFFsZEozczczOVhGRldCMEV0KzEzcU9wWEVNUzdSYTNJQkpFbzRCVmNZUFBIUWU5WFBEK2d3MjBLQ3ppWUpzeVlXd0pRUURrTEV2UTRQZm5GYmtIaHp4ZzhkMFpMbTFNa2xxNEppaER5QmdNQlR0R1Q5RHhqbXVSdE5YMGEzMW1PRzNjUzZzTFpYZnlybDBSbVFZYnpTUUZVcnpnVmV5VmlYU201TG1pN2ZGcW5mOExuUCtLNytSbHNIbjhNU1p0UVVNa055eXpXemxkeElPVGtnZW82MTIwTjhadFUwK0dlN3U3UjN0Z2ZNbFZDWE1uQVl0MksrdkdUV2xyR3Qyc01zN3ZxWmdBeEhGREhFbHpPeXZnWVhlQmdna2s5ZUs2WnJLNHRvNFpUYVROQkhiL1BETEdFeXk1WVNIQXlBU2VGSFQwcE1xbzVPTWJOTlIvSy9rWFA3TWluc0lvTCs3bm1GdklYRXJMc2QxQUpWZHd5QnowSTVOY3ZZWHRnalN4WFUycGVlR1FTeHlMNWJKdDRKM0Q1VGtkVG11elBoM1NMdlF5YnUybGhtbjhxVDVHZmNzaUVrUGhUZ2dEcDZFMTQ3cjhkeHBsM0ZESllQck9uM0FhUjR2bWxXSHpHeHlTUGt5UHY1eVRRdGpvbEZwMDVjcXM0NzN2WmVkK3gxV2xOL2FmaUc2YmJiTk41S2xNYmlHWEJHV2tJR3htSFhIYXRUeEhvdWh6UEExeGR4V1JtV0lCV2QyaWxYQnhIR2QzM3ZYanJWT0xWTloxUFRXaEVEV2NzZmxSd0ZUc2FOby9uS3hqQndOblFrbjBwbDNyWGhCWUx5OXZMcDU3eDlxRkhLU1N4S2pEY0VVREF5ZWZXanJjeGo3S1VaUnNwSis5ZHF5LzRjcTZWZWFmWmFoZTZaWjZMZENGZm0rMEtVQ3NDTWhZczdpMmZTcTl6NGgxT3h1a3VIOFBHY1lEVE00eE1zUlhLc1ZIWEhROERGWDlIMUh3WHFHbHN1a1hjaXd4U0NlUjFCamtoVmdWZnl4aGo4eEF5QjByMEt6aTFPN2pzWnJTZEpVd0VMczUzckd3ejgyUURrOUQ2Vk4xdWJQMmwwdXNkb3hWN2RObWNwWlhENndZOVZ0MVMwbWpVNHRZN2dyNXdUNXRyY0RCUHIwckxsZVNhUDdUTFpOSE81SlVrbVdTTkhHRG1TTWNld3JxZFV1ZFNGMmx5Z25ReHUwWXRmSkZ3TjVBTzdjUG1DOXM5NjgydnRZdWJiVjRibEVuV3pNN3RjV3FzWW8xYmpHOUdHODdpYzVCNW91dXFNYWpWbW52M3RiNWpmRUdseENPSzZsMGVQVUo3ZVZFZVJtK1lzb0JWd3luN21PcE5kVnBsemZoTGZVTDRSU2dQNVJndDF5R3lQbU1qTU1LcStvelJva3VsMzdYZWpiTHZUNzI0VHpzRU5JRVYyMi9LM3lqR08zYk5kWWk2WEZhV2Rta3daVWN4aFZZYml3emtzVjZxMURaVVkxYlI5NVd0cC9pdm9WWTFzN3Mya2srbFF5RkdsaVlGUE9lRS9lKzhnQkE0NmltYXkyaVhkaDVja2YyUXhocEk1R1ZWUmRuRGNaNWR1bzcxeFYzbzNpeUdXRzdWbit5eVNFM05vcGFPZmE0S3FlQ1ZYZ2R1SzVXM04zYlQydHM5M2ZNcmVXWGd1TUxJaGx5UkhodDJDT3g5QlZhMlE2bFJ4cDJuRFJwSjNYZlR5T3Z2aGM2VG9GMXFWbHByWERvWGQ5aXRnS3h6dXd4NEJQVURpc1BUMW4xQ0N4MWlleGhXUzdZcUVkUEpQeVpBSUFHU3k1L0t1OTByWHZFTVMrVE5aQzNRbGxqbUVnQVpsNXdGN25BeVQwckJzTmIxYisxWkl0UVNJeFJRaHhjd016NEFKL2g3Q29UWVM5Z29RM1czb241a3V1MkdxV3VpUnJCZFhkNi9tSzBqV3NtWm9sQXlTeW5rb09oNzRyaHJaZkNzVmlQczZ5V2NxdUc4dVoxa2NjNGtrT2VEeU9oOWE5YzhRYWJlWGVtV29pdWJkL09rakpDTVZlTUtOek1qQW5KSS9oNjgxeTJwYW5vT3B5U1dsMXA4OEtvMFo4MkdJRXVrZy9kbzdZeU81SXFrek9xazI0MlMwVmxMVy9wMnNXYjZIUzdpd2o4dTdRdjVBM2VXNGhXVEJ3Z3huajA0cDNpTFN0VC9BTEpXMHR0UWsrMXhoZ2lzcXVGTW5LdGtjNDQ1eFZSL0N1aTJzaWZaTFdPK3VZV2U0YWE0Y0ZZbUJ5dTFGSTNLT3ZIUTF6K2pXM2kxNG52Ym01dGtYRGJkc0pWNHc1REJUako2RThkalN2YlV5YWlwZkN1WjJUaXIyc3RmbVd0Q2sxV3loaGZWOVdobG1uWmtqbWpoSVFGZjRESWVkMVZkTzhSNkZjYXJEYlEyazBwWDdTOFRTU0VZYjd4NDlTUmoyckp2dkZPbjNOcUxEVHRNWHpSY1l2SVpNbEdWK1JJY0hLdTJCMzRyQnQvQ1ZqRkpCZFEzTnhaWEJOeVcyaHR3WU1ReDNIT1FmZWkxMTJDVTR1Vm5aMnRKKzdwZCt1eHFYbmozd3lOUWl0dFFTU0VzQXB6OTdLblBRay9LZTVGZHJlM0dpNnlpNmNOUWhNSmdPWTFRR1FsVnlqS1R5VC9LdVZXeDBSN3krSnNJSmpERWpyY1I0a24yampCTDhFZzgvaFZTNWlDMk1kN0dYdlVpSWZmNWF3U0l4NEJZanFCMDQ0cHM1dWVIdXVPcnRlZXZaOUxXME90RVdteGVIcjY5c283OWc3QWxVRGlSaGtLSHgxR0NPZ3JqWnZGZmlXUFUwYzZldmxKNWFLWmh0R1R3TUJzSFBiMnJyYkg0aGFzdW54UVhtbW9idVJvMGdXVmdxazV5Y3VPZ0FOWW1zYTFlNnF6UEI0YUU2U1NibGpsazNGQ29Ba2ZxZUNlZ0hXaFhhMU9pZkpLRWZaeXM3ZkR0ODlEYXNrdkJkbDlNdURieW91KzRoM2IwZGljRlJrL00xYmwwK3AyMzluVDI5b25tejd3NTh3S3VVQitkZ2VQeFBTc25TcjIyZTFqdDlTZ2JTRk9aSS9KeXJsTThydTR6bHVRTWNWMVEwUzlkNFRkWGNrc0M3a2tXWTUzeHV2VlNCamNPdFNtcnNLVk84WHkzYlRXelh1dSs5amo3aVc3UzBoT3NXOW1za2c4NHZDb1loMjdNcEJ5TnZKSXJWakhpR0NmVEpMVzZTR0NSU3JsVVJnb1lmZStiK1Zjbi9Zc1ZqcUhuV2w0TGk0dHpKQ0dsZDEzeDdmbFU1QjNGUjFBcmVzWlpJNXJTNHZiNndoWlVFS0xFemJUdTVJQTZCaDJ6VFEzSiswV2pWbWxvN1c2N3BrRS9oZytmSUo3eTJoZFRJa3NoUVA1elNaS0dSUU1GdWVLNGExOEtQcDJxM054YjZ5OEVoTVBtNGh6R1ZQUmUyUGZGZXdRMit2eVhTUGJHd1dDU1ZDa3lxUzUyRElmSnlEMXdjMXgycHV0amV6SFVycmljZjZ2ZVZpYkRjcUNNa0g2OWVsSnZ1UlVjNHB1TVhadXpiMmFOM1JkSnVXMDY3YS8xR0c5WnBTazF1d3pFTU5oUUJ5Y212TWRNOElhMWJhdGN0YnJIQk1Xa2tIa1RLNFJTZnVzckVZUDA2VStLejFlQVhRdGRYdExTWVpmeTRGREx1WWpFY25mcDZjNXJXdFlQR1VrTWtjYyttUEtBZDVqeWtwTzRNd0xIdUIxb2pLMit6Q1h2d1M2MzFTZXJzWGJ2VGZFb2d0aHFNQnVvMmY3Z1FUYlFmbUljazhZeHdlMVpkcGRhZGVDT0wremJxM2k4ODdKRVhlc0xMeGpERGhUM3hVMEdzd1htcHZvTWx2SUpXWmkwNG5PUUZHUXlFZGVUWFZ6YXA0ZzBiVFVHb2FqRVlKbDh0Q1l5eUt5NDNibkhjanBtbW10VjVtY0tTMGZ2MmF2cXIrVnVoenVrVzBVV2t5UmFqWWk1MUUvSkhOQUNteFZZbkp6am1yNzI5ckpjR0tTL3Y0WTlSZ0hrcVFPV0RZZjd2cDJxL2Y2NUZxaXMybUxOY3lxbTFEdVZXQy85TTgxUG8rdlhCVjdWSVloREJCaU5USUZ4NWh5TU4vZUhlcXVRM1RkVzJqV3lhajI5REowNnhsdERxbGpkd1A4QVk0VUVOdmNoOThqc0czWlp2VTlzZEs4dHRKYlg3WmFTUXptNGtpdUdqTnhPbjc2Tm1HREV4R0RoZXhyMTNWTEt4c1pOT3ZBczBVbm1DRVJCdzhlK1UvNnhRT3BPT3RaTVZqcStqMzk1SmFDR1VKSVpIVzRaRk0vdWU1UHJUNkcxVG1VYmNyVDVsckhvbjNPcjB1MUYxcHNzOWxjMmtzdTdiS0dMSXl4b0R0RWZjSE5ZdDdxRmxMaUs4bXRDNStTMVpZeTgwYmZ4TVJqSTYxVWdPdHpQYm9tbXJDVElKV2xWRkRDTnhueTg4Y2c5RFdwZmVIOUJ1VEVGd2JobS9leWlVaVJEM0c3M3p6bWpSRVUvZXBKSk5hYTN2WnN5YjI2ZXdndTd0TlNpbFViWW83VUFGbFlNQVhZWTZFMTNzRnhaTlpXRWttbE41ZHd3Q2hVRFJ4dWVkeEhjOXE0Nlh3ZEJvZUpZb1VrTWgyeXlPeFpYVWdrREl6Z2xqd2F4YkR4SkhieTIrbkY3aG5pWDc4Nmp5Y25JNWZqdmpCcDZXME5ZM2hVZDQ2S0t1clhPcjFvNitrcnJwMXZhd1FTSVkzS241bGtERmh0QjRHUjFybnJiUnJhZldvWnJtengrNUtUTkpoUXhLNURxUnpuTmREcUhpNnkwaXh0WWJ6VUkzbGtsQ3pyRzZ2c0J5cEFJN0ROWE5POFVlSHBwZnMxdHF4ZVpFQncrQ09uZlBHUlJkcm9hdW1tMDNkV2ltMDByZDdGVFFOTVczdkpZYnFhV1dHTTQyK2FEc0dBd0lBNkRGZWRYdnc5azFYWGhlNmVMaUpqY1JsV0Q4YmVydjgzWEhUQXIwTFV0S2hpdXJhZGRTdDRaN2h2a2NGZ0dSanlHWHZYS1dzL2lXSHpJb0pKRyt6THZsamZLaGdlUXFIdUtmUXhoVWRKcUNUdHJlelYybjBmbFk3TVdsbGJRNmpHTFdTU1dLUGNKWmlFbGJIOGFFKzllYytKYm00dWJIVFhzckx6NVNHWnd2VU5CMmt6OWE3SFZQRUY3QnBrTU9wQkpQdE51OHlqZnVhTGFjaFMyTytlYTRxejFmVzBtTFdmaDZPNWl1U0VXU0NZT0JrNXdWeitacE5OOXpUbDV2ZGpGT050VTFiejZibTFwdC9GTEJFa0V3MCs1Mk84a1d6Y0RLZWg2OEFWMnVuK0daVENTczFuTE1qcUJKY1JqaDNHVGc5eDZaNlZ6R29hamZPSUxHWHc5OW5sRzFUTyswaGQ0SVluSFlqdlhmZUU0b3RPc1dqbHQwZFkzS3NDeEliM0RIMjZVKzVsUmhGVll4azcrYXVyZVhxY2ZOTHE5anJOM2EzbHRIS3BDbUp0dTRaQjVJeVAxcTFyMm55L1pwaWtjUmZlcFdSaHRBWHJ0R09wTmJHczJrOTdlSk90bmRMSERIbEgzYnhoeHQyakJ5YzUvQ3RsR2RkUGFPNW44NHJsMGhNV0hLeDlBTTlSajhhTDJMZEpYcVFhYlgyVytuM25rRGVGTktPdS9hSm5uY1poZG1KR0ZEOXNkY0RwWHFsM3BPaXdYQmxlS0tObElQbXNvS2dEN3RadmlPVVcraVBkMjZBeUJJMWRybER2VkcrYmFjZGdUMTdWbkpGcDg4VmpKcWkyOGtVa0dFZnp6MS8yZnB6VTZQeU5iUWpKcHhpM1pXazlrYVZ4RGFhdnA2MjcyY2NzQlppV1hhVStYdXA0UFd1SlRRTEtLNVMwdHJ1VjQ3bENvallFN1hHY3FHN2UxYVdrNlpvMmphMElZMHVZNDJadGt6UDhBdWlINUEvR3ZSYmF4czdpNVNTTXlSeGlNeitXUHZZT1ZCYjhxYTBIS0xxdXp0ZFN0YTU0NWI2QlpHMGpSVmVTMVlCbHQ1Rzh3UnlESUpCNmcrb29yMy9VeDlrU0tlRXBFc29BQkgzV0FIY2RqUlR2YzFrNVUzeXVjcitYL0FBNXdBbTFhRU5hMmtsa2ppNUhtd21UYUVIS3RsY0RIUU00QjYvV285UjhTMnRwZVhNMTM0ZnVwcHJkdkpIMlNOaXBsZEM1TWU3R1R6Z25QQXJYOE5TK05tRjRsMkxHTm9HZEJIYVFsMkczamVyU0FZT09EL2VIMHJsSUx2VU5SMWZGb2RTbmc4cVJyMWtuRU1abjNIRGhEakovM1R0OXFoamNWVGtsOFcrK3FkdGREZTAzeDFwTDI2U20zdTdWOStUWkNKOTVLb0ZMZGh5QnprSEgxcTFwZXUzaytyRllkU0NDQ05wSjdYeVl5SjFQT0lSa2ZNUjdZcnFMbVhSOUpzQVBPbWx1VmlSRWY3UWdhVUFGc044d3czSEZjanAwWGhHU0NHNUVEVzVoWXNzdHpBOFpFWlBKVjFZbmc1eXdQemM1cDlCeGN1ZFdxS3lWN2RqdGs4UWFucWx0bXgxTDdKSkZneXJJaXpUS3lISWNGVHR5d0JJSTdkS3lycUNhL3ViR09EVlpUQ1BNV1daTGhjc2paSllyZ1pJeHdCeURuTmJ0N0hkUjZxN1FXdHBQYlMyNkkwU1NlUXlibXlXM1krWkdIVDhxOHBsbjhQb0k1WjNGaGNJeW1RUGRrd094WWdHTXVXSTQ1Ykl5VFNWbS9RZFJ6VFh2WGQ3V3UxZlhwMEtXczZKNHIvdE1MYmFsWlFvWkJ0dVpvMW1tZFZJVXRzSzhQNzV3Ulc4bi9BQW5Ed2ZaOVZrUWg5aUlZbFNReWhHM0traFU1Q050SXdCa1ZadnRldVhzN202RjdaSzhjc2Z5U3pDNmlaUE1LZ2phT1hPYzg0MjlLNnlDVFZVdVBzRHl3dkdaSTVMU1ViVkhsc0M1eHYrWmp0SFByVTdrTnhkMHRPaXN1L2Yxc1pWaG8yb1EzcGU4MWE4bVNScE5zTFJMQWpxU0dqV05sSU9Jd05wSFgxcTdmeDI5M0l5MmNzc2Q0SGo4dUM3Vm9zckp3U3BjZ015WVBUT08xWEdpdDRZcGpMZWViZHRneHQ1c1plRkNjS1VaQXdJeU9NOG5vYTg4MXJ4WnFDUVhEMmtNODA5bEd4SWpUek1FWlJ3OGJEcno4cFdvNnZVaWNxY1pjcmpkdHJSTFc3L0orUmo2cll2cGNwZzFMVDUvczEyeGExOHRCTTRlVVllRjVnZG9Mbjd2R2VLWjRkdHRmdWJteG4wS1grMHRJaFBsemFjYnRETEN3SExONW1BU2ZZZytncUhXZkdFRVZ1REpZcmNSM050bWV6ODUwTXloV0o4dnk5KzBnY0ZUOUJYV1hldWVGSmdKTFBUZFRodVpvWVlWaEZzenFGVmdVQlZpZ0hUS3QxN2lxV3BkR05OM21vNlh0eXQyMitRa3MvaWFPeXVyVy91eEduMmE2TWtSbDJ6U1JjcXlrZ0ZHQXpuSzRQclhCNkJvdmgremcwdDlDdWx1M1JmSW1qa1psS3NRU3hmZ1pVRElCNmc4VjMrbXh4V1lIbTIxM01aYmw1TFdXZUhhSWkzMzJiN3BZQUxuT1B4cWtUcDlwSmNUcHFWbDloWnBENU9jU1FObmNXVmtIT1Rrc3ZwME5XbS9MN2lKeWs0VzVuNzFuWnQ3b2UybHhXanRjVytwdGIyMHlSa3NMUlB2SVQwbGt6dEo2RE5aZGo0MThYMjBRdGZzTVU2TTdqekk1MS9lS3h5UWdjcVdrR2VHNEh0WFFYTXNkNWMvNkROSWp4UmhDaXRsbkM1L3ZibCtRazdTdyt0ZEZwMXZZM1ZzaVhGcEZleHpTSysrNGtWbldaaCs3alUvdy9MOHVjNHllS1RWMTh4UXFWRzdKNzlkYkdUcnMrclE2SkxlUUpiRXhRaU5KcmphdUZQRFpqVmNLeTU1QUpHZTFaVnJaNng0aDBleEZ2Y0N4ZUYya2xmT3llUmlxbGk2RVp3Q01ZNzRxM3F0clpXZXB5MnQ0KzZPVVpYZktzamVjY0ZSQ3I4c1Z4eGdBZHMxcTJrb1MxZUMzMGlHMWdqdTFXVUE1OHh4bi9XS3czQnVjNTVOSjJWdTVxN09Vazc2YWV2OEF3RHpPKzBMWGRMRnovbzloZVcwa2lOUERLNmhESkx4R3lQSUI1WkhVNE9ldGVpNlpCcUYzWXJIZjZmRkdpU3NjMjl5NlJvNUFCK1dRNXg3S1RqdFZhODBpMnVJSjBrMUs3dTRZV2N3SUZTU1JWY0UvZHdjZ0hqQkdCMnJndEhnMFN6bTAxWnAyMWQvTFZMY0ViMmlZSGNFMmtuWTZEZ2piK05OMld4bkNVVnZKY3EwdHYvU0hKb212NlBidERiNmhlWE5pWTkxekU4QW1LL0xoaVp0clAwd01xQU9LN0VlSWRhL3MzN1hwTjVhM2tJamhqQlpjdWhYNWNiV3h3Nmo1d08vSXIwUnRWRnhIUEl5M1RTV3dZaUpSNVVqUmtZUHlrWUxjL0x5Y1lyeGZVZkhVZG9MSklmRDk3ZDNrOHBRenorWERLcHdDWFpRTTRBOVI5S0ZhMXJIWSthUzl5ZTZidmRMWTByZGRaYVJaciswbGtudVlSQThrY3lxckhhQ0hXQXJnQWR3MmZhdkNKdmh6cU05MU5MZVgrb0pieTNJTHBGR3BTR0JUa091MG5HMFpKQXo2VjlLalZubU1obDB1U1JMZFBMa3ZZSkZMVE5KblBsTEg4MlJ3UDFyazRJN09LR05QdHQwcVRNanhXc2dYZnZqSHk1a2lZRTdjY2pyalBTb1JtcXNvUzVvN3Z1bDY5dS9ZeGRQOE5lR2IvU0NMTm83dWRVU1VDNmxlS1hiQ3lyOGpiUmhUanYxNHIyM1YwdkxKb1FmN1F1Slpra1VGRHRRcWcrUm5WZGdBOVNTTTlhOGwwelhJcGJtNXROVjhTK2VtWTRFTU5xdnpjakRPV0xaSGNqc2VsZGV0dEFkUXR6YWEvZVgwUVoya1V3TXlKR2d3NGNvQVRnRDVRQWZwVkxaRWMyamlwUmF1bDhWdndaemw4MmtKcUZyRmUyMGtNOHNLdSt5eWpramx6amN4bGNiaU1qSGIyck9sMW5Sby90TTFycXNhbU9UeXJqQ2JwWmxRRlNvMnZsU1BRZW5CcFdqMXVQVTVXbXZ0U25zMmhmZnNnM0NKbTVpZU1SRGJ4Z1p6dzNQRlpDZUdZN2hGdUxYWElwWERLNkxQYmhaU3crODhtVkxLQVFSZ1ZLMjFzWnk1Sk50UG12OEFKcC9Nb0RXOUd2TG1TMzgyK1M3a2pLTk5jWW1qWnZ1aGRxakdSaklPT25XdEpkQjhONjdIOXN2THFTeGVCMmptaXRnWTFpWlZBTW9RNTJObkhRWTlldEZ6cDk1Y1JTWFdvUlF4c3lNa3NOekM4bnpaMlJzSlFJOWd4eUNEWG51cWVDZkQ5cEhGZU5kejNUWEVZU0c0KzFoYmVOZVBrWTUrZFQwelJkT3c0UmpHVGs2alZsZXlWN3ZwMjNPdG0wbTN0NFo3bUhYTDY2amlpTEpjMjZDYVZBTXN5ektjRHB5Q295TzllcjJVUzNNSzZwSkxxVS8raGJvSVpJMVR5NHBQdWt4ZzdzdDFVL2pYamVnZkVVeDN0dFlTNkJMcHlReTVqZUp3ejdpY0FsaUMyRGpQdjBOZXRhaDVFbHNiaVZyNjZWWk5zMDBjcmpHMXRwVHlrQkxrZzVBeGlxVmwzOHlwdzVKUG1qSG1mOHUydnBlNHl4aTBtZXl1N3E2aW5iYnlRSXRzb0pBK2QwWUFub01rL3dBNmphTzhtdFZsc2RRbTg2NUJ6cDBqeHdxMlRsaW9rSHlqREEvcUJYbk1tcitFcGRZdkF1cHlYVWk3R3RpTjhNcXNwKzYwaWtNUVIxSEdEV2ZxT3UrSjdTV0NhU1BTTG0ybWphUmZQdUZCUXI4cFRmd3pPT2h6M3BhNnZvaWVSdVVZT0NUUzJiNWJyelo3aHEzL0FBazlyYTNVZHZEQVpiZWFPUndCRmNveXNNK1lyS051QURuNU1tdVliVk5ibTBxN3NoNFllT1VYWlNkbzUzZUZvaDgzbVJjazVQb285NjU2MzhRV3R6YVNYV25rL2JHVDkrbHRsNDM0SlVCU2Z1bitMSGVzSHd6Yld0aE5kSTAxenB6MnNVclhoaWthZTNmY1FWYjd4WmV1TURCSTROTnQ3cnFieDltMUtLYldqV3V2VTlLOE0zTU04WU1FVjVMc2szTlBQYUJOdTFmTDJNejQyN3R1ZmF1Z25QaDdTb3JzeDc5T1ZuZ016cHRXUVJTY2tMc081UU0vNnc1d2E4NnV0Ymd2cjZDenM3ZStCdDVFV0c1alIyVXFPQ0R0QjRJNlpHZmVxVjliYVN0aTk3SGEzR3NPemsrUTkxR3laUTRLbDVkcEN4bm5aZ2dWVm03ZE5US0VrNVJpbDJ0ZnowMzBPc2k4TzZkbzl3czEvcTJzWEp1NWk2M0RYVGlHY2c4TWNmTGhRZUJqbnRWS2ZTTkVzOVFGdzhjY2lQZ3hpYVhjRlZNRXV5Z2tuUFFLL05aV2tYdmhhN3NvRlo0NGJaNVZFeXhYWkxMeDFkaXpFY25xTUxuazA5TGVHMjFaSTR2RVVNdGtRVmt0bGdBd3hVdkczN3Y3NHdQbXlldk5Mb1hPVHFWSGV5cyt1L29iTTJyUVRXeld1aStGbW5oaGtrU0praUFoeTJEODJDRGpQUHZqRmROUE5xWWxpMHk0MDJQVFl4RHpITklzVWN1OWg5ekJJSVhwMXpqclZ5VmRMa0Z4OWoxU1dDNWFINUdTVmJhS1J5djNVYkFVWXoxNU9ldFlOd0liNnp2NG1jYWpQYWxmTGhhNFpwUzNHOVdVNERaeDk3cWFYV3hjK1dVWlgxZTJqV3RqYXV2RE9rNlZEYU5OYng2aUlMbGhuemdubHJ1QUs3ZU4rM3FPL3ZWS0hVSDE2N1M0MHJUMnRoYi9BR2xQT3U3YnlaQTJObStIa0t6dWVnSUczclhKVGFPRlpMYXppaEU0aE1id3JjU0xLc1VtWk54VWpPZC9VNXpnZWxZOGM2dGNRelM2TmR5d3hSUU9MMjVsMmxVNVZBbTNiaDNQUUhqcFQ2ZFI4MEl4YVVkTHByeXNqMFhXOVAxczNubnZlU2l5a0k4dUc1ZzhobG1aZ04wanhaTG9kdUNEanI2VjZYNHFndU5UOEE2VHFiNDgreUFTZkNGTW8veW41VHlBR0FQMHJ3bVh3NXBLbUtlN1ZveE02bzF1MXhLNm5mbFFHRE5rRmh6a01PbkhOZlQzZzNUb3ROMCtiVFpoNXR0T3BVUnZLMHJiWkYya0hlU1F1T2dyR3ZocWVMdzFiRHowalZnNDM3UGRQNU0rMTRXektwZ3M1cFYxZE5jdW0zOVhQTC9DdmllMnRiSzcwNjdZaXd2MFJXUG1iUEluVEd4aVNEaEd3RmZqanFhOWcxcUhXcm53VkpwdW5XVjdxRTg4MGlSejI5eXRvOWs0VUpGOW96aktnRTd0b0trZEJYeGw0cjA2OThPNnBQWVNreVFuOTVDN0RpU0pBU0c5enhoaDY4MXArQy9pRnFka2ZzdzNTYlVPM2EvbHpSL0l1ZkxrT1FRTjNDdHg3MThadzluTmJLNmRUQTQrNmpSYlVLbS9MSHMvTHN6K3BNMnk2bmozVHhtQ2FrNnFVcFE3dGRWNStSOStlT0xPMzBqd05wMTRKMVRVTkVTemp0TGtIRHU1S1F2RDdyTU1ncjM0TmZGVGFMcXk2M2VXZHkrMk8ybmxnZHQzS21NNEh5OXllRG52WG8rbmVLdkJOMzRnVFZ0ZXNybTR1b0JGOWtta3RIM28wZWVYV0ltTml1ZmxiR1JXRDRvOFVXZW8rTGJ1ODB5MHVHZ3VJSWpJMHFlVVBPVEs3dm01d1Z4bjZWbHgxaWNIaXNxcFY4TGpLTHJVWnB3U21ycFBSdGE3clEyNFNvWXFoanFsR3ZoNnFwMUlQbWJpN1hXeTlEZjBQVG5sYWQ1R2l0WW9oL3BsMHhHWTFYdDZzeC9nOVJYcEw2b2wzSkV5UW1DMmdqOHEwZ1BWSStwWnY5dCtwTmVFMjBQbVhLM0Z5UThpZ0JWWElSY2NnLzdSSFlucFhlUVhmVHArQjZWK0pjVThaWmptdVZVTUZ5cUM1VjlZbEYveEpMb3ZMcWZvMlJjTFlITHNkWHhNZmVjcFAyYWYyRS8xUFRSZHFFSkw3UXZKUFlZcjZVK0cyamhyR1hVTG1KUzEwMlkxY1oyeEQ3djBKNjE4cWVGOU1uOFJhb0lFejlqZ2tVM1VuWmlPUkVEM1A5NzhxL1FhMjJ4UnFpZ0JWQUFBNEdLKzc4S2VFSjRkMU0xeEZPMHB4Y0tDYSt5OTVmUFpIeVhIV2ZRa280R2pLOW1uVmFmYlpIUXJHeWJmTG5Lais2M3pMK3ZJL09ySXU1VUg3eUk0R2ZtVDV2MDZpczVaUVIxejdWUTFPL1cwMCs1bmRzQ09OM3llbnlqTmYxQzdKUHlQeENNbkpwYjNaOFgrTFBFQTFueFJxTWtNdStPSXBwOXYyQVp2bW1iQjZFRGo4S2wxUzlpdHJSSWVpc0NXQTdSeGpKQSt2QS9HdkY5THY1cGJleGtrZ1dWNzJXYTVWdk1LT0RKbHlUK0J4WGJXc0V0MXJta1dyVzA3bTV1VVVoNUZkU2tYNzFsR09tU29GZjV4WjFTcThRY2F5dkwvQUhqRjhrTlY4S2ZJbXRlaVZ6K3djSEdsbHVSUTAwbzBPWit0dVpuc0tYZmdjYWFtaDZ2ZVRXV29veTNrbHh0WUxIUE11Umh1aENLY1lQRmZVSGdxeDFpMTBoUmY2cW1va3lGcmU0VWY4c0dBMkFzZVd6MXlhK1pGMTd4bnJWMWEyT3QvRGhaWVpwaEd6bkpTSkdPQys3bkcwZGVhK3piZnlvb29vNDFWVVJRaXFCZ0tGR0FQcGl2OUVNSmhhT0Z3dEdqU2lvMDZjSXdqRzFyS0tza2Z5ampjVFVyVlp6bTd5bkp5azdwNnZzWHJtVXgyOHpMa3NzYmtBREpKQXppdmpoTERXWkVCR20zWnlxOG1NcU9uVDVzVjZwOFEvSE1HaVdEMnNLeXkzdHhIKzdTUCtCV09Oek4yenpqSE5mSFdyZUlKbWdkcHBXY3NRUG1jdWZYdWYxcnVoSlhma2VKaUpLS2dwSis5cXJkajdiOE0rSDRwL0M1dGIrTEhtWExTbEZjSEcwZ0RsU2ZUa1Y4Mi90RWVLSTlCMGlFd1dxelBIRERGRmJESURlYkpnS0F2UEFYSUZhbndFMTJTNXVQRkZpMGdiWkxiM0Nld2tCUTQ5c2dWNGo4V3ZGTTl6cStvVFd1SFZIVk51VnkwYS9LTnVRUm41YzgrdGZCY1NVYU9JaGhhUEt1YXZpYVRtMHRlVER5OXJxKzExYjVuWlZ4MHNIbDJNcTg3dENoT01GL2VyUjVORjNzNy9JK09mRGZqaTQxNjN1ZjdWdDNzQTBOd2xzWXc2UjVQQmVWWStlK0ZmanVhMWRLOEZULzJwSFBONGsxSzRVbkVhcklYakdWd29rMnFXMmpzNTZqcFZqVWROOFgzbDdCTGF3Uk9xTE1vdWdxTEk2NTVpWUxsV1U1NEg0MVdnOGFpeDB1M2p2ZExsaXZaVktvbHhaeUFza2JibU1iNHkvSE9NOVJYVFpKYUkvbkZWSnpxUzkzM2Y4TjdkTjNkbkMyMms2cGI2OWUyK3A2Z0hsTTI4UVBCTjVMdXd4NXIrV0JnQTRBejNyNk44UFgvQUl1dlhaTHEyMGVLRld3QkNUTzhvYmdIZVBsVmp5QnU2VkpwbXErS3A0N1dPK2tsakprUi9ORU1Ra0F3WDJobE1pNUhvL0lyQXZmRWZoYTNlK0d1V3p6V2p5eHlwTXR0c1ZOdjhMUEdjZ3V3eW9JNm1tdS9RMXB3WE5wTDRuWnRxMjNvWmwwbGw0YU1oVHdpbDRMY21XT1JGODdlemtBdmxWd0NjZ1l3T2VsWVdvZU5MR2EyMUtDQ3p1cmVYN1BtS05iWVJOQk0zelM3V2NBZ3FUa0U5NnFTYXZvT3B5M00raFRhcGV2TE1pdmJyTTBLUW1SY29DQ2VkMlB1NUZiZHBZM1J2Mm1GMU01blpXbE53R0NZQ0FCb2lQbitVQXF5bnQzcGVhdVlTNTR2bFNzcitYNDZIVCtIOU8xNTdJdnE4Y2Q0bHdZZ2tVaGpZbUlwbHNwaGdySEhyMXJndkQ5N2IyR3V5UTJzVnRwc0dkNnE0YVJENWhBUllWNDU0eWVDT2NWMTJxM2t1aHhMY2p6YnY5NnlUWEVVcUNOVUpHMkpsM1lYSDRuaXJLNnZadnBxM1ZwYW1OSTJhRlBNWjQ1Zm5PQ0k1SEJLN1IyNDlqVkp2WHVSTmNsbHoyUzk1OHl2cXZTeG9YTXVxUzNhUXo2eEpBWEVhTWtjS09semhnTnlGdnVzUWZtVEdmclhOZUtQQnZoYTZMWFU5Z2JhYnpYa2xqUlhkaXVCdENoU2NNT003QlhSWDBOaGJTUlhObE5KTFBMTHZsU0M0M1R2SXFjTkpqZUhJSTU2ZHE4OUhpVFR0VmxhRXh0YlBjdDVieXpJM21NT0ZBSVYvbFlaT01lblNobnFZYUdIbEdwN1d1cWNyeFMwaythK3VqV3gwOW5wT25hMWE2ZXkzMTViTmErYk1seEpFSTVsbDZNemgxMjhjQTkrK2F3anBOaFp2cVYwMXJDbHpEa1hMUVN5eEszQmZlVlBBM0VaeUswWmZDRngvd0F3ZlZZMGppQkYxRGRTbVZyZ0lEbENrZ3dUbjM2ZGFuMC93ckZLMDlwZWFVMERvdTZLNE11K1FrbkprQ3hZaklVL2RVOGdVWGRuK0J4dURhVWVWSmRXdndNNkR4UnJTTThsdHBjZDNhNzJTU3grMGJ6TjVuQWNlZVNRaHgyNFk4MXNYdHJjNjViMjBsdDRiU1NiRVhtMjB3Q0NGMGNyODBoeDhvd2M3YTRXNStIdW42SmRyT3VyM1Z4QmV4SXl4c3pJU3c0VXQ1UkJDRlJ3aDcxNlpOWVdlaHhXVTBkL2VXVnZJLzJhV0NXUnAwRHk5QThhQTdmNzJjOFVrck80Sy90SEMvTWxhVDcrbllOSGgvc3lHNVRVTGF5czJsa1dVcjlyRWtieTg0QURFbFRuQUE3OWNWaDYxQ3RwRzF3dG5wZW1tSzNSWW4zZ3hCSElaMkpYUEtrWkh5NXozcm9iSyswQzZqdlZoakZ3ME4wVU4xTGJxcEZ3dmRqa2N2anAxeHppcnNlb2FaWVNpM211MHM3aTZrOHRsa2pVcXdqQUJJQXdkcEhBR0NRZmFrL0prTzBseXRXWHFyK2x6eTZEL2hLWXJXUFV0SWwwMmUydFhabWw4cG9IaFU0M3ZrQUsyN3FjOWUxZXM2TFpXVTl6SGF5NjVQUFBMRkRNdnpKRW0xOG5IN29ibUJIM2hubnRWRFU3elQ1SnltbmFrbGxLWkVnek5GTlBia0RLTXJSUm5BT091VDdZcnlUVDJpdE5mdlk0N2ExdW1uaWE0a3U0R0VjZUltMksySXk1VlNTQmdZOUFLcTcwODlnbExsaW0rV1RUczBuZS9tZXRTK0piY1FZbVdhNDJ5eVc3Q0NJd0FMeXJPN1NFRGFDT0Q2MXh0dHBOMWVYQUtIejN0eEVZcDUzTVhsdEdkNnFBaHd3R0NPblhqTlJYTng0cTAzVDQzczRtdjdFaGcwTjB4MlJNYzVYNThTQUE0MjV6bXRTS0RYZjdHaHVMelRJb3YzTXF6d1FYQk15NElhTmdEc09FUEpCN2MwR01uVW5LUFpMWG8zMnR2cDVuYnBwTXBFODh0eFl4UjNrb25rdHpFc1cwZzVNZ2JBZmZqZzU5YXdyR0pGMVFTUjIwdHpDR3d1eDNXT1JIemo3eWdrZk5qZ0FWeDNoM1RybTQwMTExZlJiV1R5R2RZRVc1a3VKb1YzbDhGbHo4N2RNOG5IV3VHOFdYMnF3UjJRMGZSL05sa2QzdUhBYU9OdVFEQ1czQU02bklPQU1aemlvWE5mb2ExbHpWWVJqeXQzM2N0L205TEhzZHhwdXJJVGVXbDVGNWtXWWtXNTJ0RVlUNkxGdEcwQUhrODF4dXFhdDRzdGJCNytMUmRNdjlPbFE3bXRvbU1neDh2bU1SODN6QVlCQXlPOWIrbjZneDB1VDdSZFFQS0luZTR0VkFra1JDY0JwUWZsWjBVNE8zcmpKckMvdDIzOE50ZDJxWE41SkhISTNrdWtRakJVanFXd3ZUc0J6aWg2bk82a0l5Vjd0TzZkbmZYcCtSNTFvWHhRa2t0UzBCWXl2TEtwdEpZd2lwQ1RnY0tnQXgweVQxUE5lalhIam5UTlh1STRKOVJ1OUptUzFIbnhpTTd4dGI1Vzh4UmdubmhlaEJydGROMW53bGZXazAxcEpmVGZacmNTT2Zzdm1HUlp3TndDeUFibTc3ZWNpcWtWelpyRE5GRGJRK2E3TkNZSm9Uc1lLU1F2eWJoaFFQcURRMUU2SnB4Yld0bnFrM2UxdW15SWRHOFhlR0w2L3ZwYmZVZk5FTUFqbm1rZ0liUGFOM1h2MXdmd3JRRjFZNmpjeXdsOVFoTTBBS0ZvR2xTQjFIeXR5Rk9DRGhSa0VjMWMwdTN0NTdlTzRnK3hMSUNKQUlJUk9xYi9sWlZaTnBKSFlrY1ZvYWRxK3NTUlN4UXZKTWlSTXkzRHhna2tjSGVoS2tET09uWHBWS012TVZscHpSZkszb3QvOEFJb0o0WDBXMXR6ZlhGamFUM01zR1U4M2VIQmo0YmJ2TzVWR2VjZGVsWXorRGZCdXAyMGs4ZW5SZmFWWkZpTm0va0dGSlB1TCs2QStVZHNnODlUV3ZhNlJjYWlaNWI2Nmh1cmlhMU96eW95clJLdWR2bHRKa3NDZW80clYwRFJZclMxdXJyVTdHYTJrblJTck5jNzRFVk1MdFJHR1J1UE9DTVZYek5vdWE1VkZjc09WcFBwcDFkanlIdzU0U2tzTlFONU5wa0VscHY4dU9WOVFNbXdjZ0ZveUFNc2VBTVY3ZGMydWlRUnkzcDB5ZVpFVGVZNGdSdklPVkFnVS9PUjBCUFRHYTR1ODhhZUViaThTeGd0RloxbUJWMVh6VUxIZ25jVlpPTzdFWjk2MW12NDVOV2lqUzNuVzN1U2ptYUpUamNjSXVXWVpUSkdBUGJOUmRtYjlsR1ZyUmUzMmZsMVd3eGI3VUgwdzNlbjZGRmJ4S201cmE2Z01SREJpeFpSanEzSFhpcXI2Wk5MWTIxeGU2S0lwMTNMSUxlM0VzaERIekFJNU1qZ2s1Skh6VmYxcXp3dHBPMXNMb0xMSUhEelNDYVFEREJvd21BK2ZROFZoWE9qeXlKZFJUK0hKTHV6bms4eFVRTUpodVRPLzVIWTVBR01qdFJmek01ZnhFbTViSmFLOXIrU1IwTmdMWlhXQzRudWZJVXl5QlpMVVFqQjVDT3prcmdldWNObjFyeTNVN1MyMUszK3d5ekpEWnlJSGdta3ZBNUR4TmtxZkpJd3VPUmpqTmVuMjl6ZHp3UGF0cGRyRll0YmhSRXlaRWJLY0RLekhHMWU2bkJOWUUvd0RhaE5wQ2RNdDdTM2lLTVQ1Y2NxcW9KeTZLdnpoc1l3bzR4VFRYVTU1eXRHTGpmVFpwUHlNNjEwblNZUXRoOW12YjZJeG9ZeExQdWp5emhzS2lrSEo5VzR3TTEzSDJqV0xTMExKcGxsQ1lWQVJJRWtWd1hQSkdjY0FkNjg2c3ZQMVM5bDA5YjFyUmxuYnlKaGxSTEhIbHRyQmh1UU1PaFlqMkZhTi9vYVM2bXEvOEpGSkNzY1UwOFNvVkprQ2tLcEpiQU9NWTVxcnJRMGpLVnRFbHJ5cHByUTN0S3RmN1V1YnMzR3BpU3lka1pMZTRqS2ZPb08wQTlEZ2p0V1hydWsySzZuYTMwdDA5dEpJeTd2TWdNOXU2b29BQndNS1Jqakhhc1RUTFR4TnAydlRDUFZubnQ1VWFlS0dHRlE2RWdCVlNBRW5IUExWemwyODJuM2MwMTU0bjF0VWpqLzB1M0tCREVtY0FDTWJpNnRrNXh5TVpxTHR1NWZMRndjR3J5ZlhWM2UxbDVucXNDb05SVkliWDdXOG16elp0dTB4Uk11UW1JMTNBWUh5Zzg1cWxxSGhPeTFTYVdXNGNxd2N0SGN4U2VYTEgvRGhtWmlDdU8yUDFyemlIVkx1OWtOeFlhalBkV3R4Q2p5SWQxdXFwR0FRNFk0QlBja1l4M3JyMDF2VTcyd3VJL3RscEtJU29NRnNmUExKeU15b0dIWEk2SDJOSmtxcEM3aTR5OTNwYjhMblJXT25lTUlyeTdXR2FJcEZHNkdhYTNBa25rSzg1Q1ozWXpnSFBOYlZvbXJORkhjYWRQYlpJWHpvaEh0ZkE0WVk0STQ2ZzF4TnJwMFVHa0VTNmVMdlVFQXg1U3RHZUd5ZUI4eUFZNzVKK2xhV25UZjIvcG1wekxjNnpaM0VmQkt4akVTZytZZkw4MFI3bEkrOWsxVnJMVTJwcDNTaTJyM2Z4TjIrZHRCSW9mRmk2eGRHNXZmSVI5cklMZE9Ea0RHOWgxSUI1NlZUYndONFZrbU5vVXhNeUxOZXllYUdkdWZtM0xKa25kbnJUSWRZdDI4eTNtOGRRdmN5aHZzOXZOYUtoTFBncUZWaVF3QTlEZzF5U2FEQmNpNm0vdGE2aGtnakVVN1JzSXBXUkNRU1FWSklIM1FCMnFrWXpVWXlpbmVTbTdwdVhaK1IybjltNkhvVi9EQ2IrZU9TVjlqdTRIejVCTVlVZ1o1STZBOWF0ZUliYlZMclRtdTdHYUpMaUJseWtzckFUN0R0NURuQ2s0NVBVMTU5RkRwbHVvKzFUMi8ySU5HUlBlL2FZMmpZTDhnakxZREwzRGV0ZXR6M21tQzJ0Nys0a1lxeUJUSGJxYnBNTndweUFCdlkxR3RqT01ZOGtrNHFLdjhOOXZtZVZ0SDRxMC9VUE92SWpITkR0QmloYnpvNUZjN3VSakNNdU1qTmRuRGNhcmN3WHNjZHcwVjYwcXMvN3ZZcW9DUVFjOVdQSFE4bXRxODFIUzdTQ1M2OGxHZ0dTWVh5SkF5RDc0RE1PQmpKSGV0VzQ4UzZUZGFRcmFkYlNUWm1YZDVDcXdpS2o1V2RjZ2daNHhUdm90QzR3U25POWF5VjdSVGJmeVo4K1QrSGZIMXpxYzF0Y2VJN21kNVAzbHZGTGJTS3NibjV3TjY3Z2RoNHhtdlNJOU12TG14dFVrMUN5Z3U0cER0TnZhYndpNDVHMXNCbTlHUEZhZHZxdmpKR0NSWE1EVHlqem50NTFhRDF3b0FEQURucVQxck8xbnhNdHBkTWo2YWgxQllqREZGY1hpd3BKR1h3U3dISDBCK29vZTE5RG81NmRSODdTMWRyTkpiZW5YUXpyYTAxQ0t6bmlnamlXZVBKZ05zNkt5S1d6dXh4aFdQM2czQTZDdUkxRHgxZFdUejJtdDJQbFRFc0lTRjJJVU9SdVY4WVlIMTU1cXBhM05qb056cVV1aFJwS1RCRzg1dUdkWkVFalpCa2QvbDhzY2pjRGoycjBXNnNkYVMwVFVMUFVOS1Jwd2pQRGR1SklVWEhXSVl4ZzVKNjA3TzNRd2pTVWxaYzNMTHFtdG4xODFxWDlGMU93aDFUeW83TzZoWXFvVm5iZUcyOGdZRFo1SFN0RFUxc3IrUzlkTFNkN3RFakVrb2pJdTRpRStYYVR3MlJnRVZoVzA4OGN5Vzk3YkdSZjNndDdtSk43QTdTZDdFak9WT01kc2NWeGVyZmJiTzVQMjd4MU5GNTBNZXhrdFBMZHVTUXg3WXp3U0tqUkhOVGpGMDdPU1d1elZtcm9wSjRxMG1LV3pqTnhxVnA1RVF0N25mRzMzd2QyRG5rWlBYMnIwdlRmRjJpUTZmRzh2bDJVRTMranEwS0tJWGNJVGxXd0dKOStsYzNxTmxxZHBCRmR6YTFGcUU4c1RoWW5HNk9WY0FaeGpPVDJybDdKZkR1bm1OYnZRa3RMaGwzdzNKamJZNDNaS1licG52anRTNkV4cVJwemFTYXVycTluZlR5MlBSTlMxdTVMYWJwNlhma1dNeEVheXlvMHJySUFTTWJXQnczYjBybXJsUEdzVXB1WS9FRnRQY0t4aXk4SVVvT01Lb09UdHgxWTFwZmFFTnRiWG1sV1N4Mnp3dThzYVNiNVFkM0txbk9EOVR5RHhXYkRKb0hpT1I3ZUhUTlJrS2hFZDE2S0YrVXF6Y2JRZWhQWElxbHFqV0VwdE5jMTNwWjY5T3hvV0kxaDlMbSszV1gybTRpdUFmSWptM2VhRGtnSUVQSEhidUs1MjI4THk2eFlrU1dMYWJKUGNONVVBa2tNc0M5Y0lSZ0E1emdFSG12UnJTejBDQ3hsdFdnblpDVVZKWFg1Z3ZPTXluSFBaVDk2clZ0cUxRMnEyeXhQSk9xeU1IamtBblpQdmJnVzY5TUVEbk5TbjBLZnM0dURsYTZmeExWK2g1bG9kbE5wbXZHSjRyeWE0VlNWUmJmYkdHVnRvSkRIQUxZeCt0ZW16MmNhejNkckxhUStWNVFma2JuUG1zRCs4R2V4SEI2VndWMzRsODJlYlRkWWt1TGVXN2pWMGN5bFdMSTI0UktSeHVJNFBjVjZSZEhUUEZWaEJ0ZWVHNk52c3pBd0RlVXczRkRuTzRkTWtjME9USnBxbTBsSFM3MGpKV3YwYVBEZGJ1dEp1N3lPMHVZbzdBS3JSeFhkdWp1VjJZT1NRZUZPUjI3MUhjNm8wa0x4YWZxTXF4ZVVNQjQyY3V5TmtzV0hCSnoycjFMeEpFOEdqMkVGcmNndXhDMnMxeEFNTTI3NWk3S3VkNFBTb0pmQWVtNnZEYXgzV293TmUyY3BkWnJTNU1MSUN3WS9JY2h1ZldxM2FSRWNPcHlVZWExbHE3SnU3VzF1eHo5clk2YmRhZjVodG83TFVBVHR1RUgyZUtkMWJHUzZBakxIZ2cxMFBpVHhUSGJ4WFZqSmR6cDVNYitlMlVsM0hBeUVjY3J6M05jMmRMOFYrRjdLL1g3ZkRKYVQzQldPQzRpM011NDVNbTRuQkpPT1FEVzVhNnRlVzJpMjYrSXJHSnJlNUg3N1lpdGs3U3hERWZ3NDZOMUpPT3RVcjhyNmx0U1Q1T2RwdExtYVZ0UFAvTTZUdzVjYVJybWppNWhYeVFJbzk2eXdoNUdNWXdDcDdqQjlLN1RVYnF4dWxOaE5FSTJVYmxkVjh2ek1vUVVJVVlKNHlhK1Uxc29iV2J6dE44U1c5cmEza3ptTkJISUg4cVRsV3dRZUZ4akg1VjdLTkF1b0ZrZXoxcHJrU2hvM2p1TXl4UEdvd0NlaFJzRTROVTF0cWJwdEp4aW92K2JXOTFmc1ZMblEvQ3E2YWtvV09FeHdHUk1ONStSS3dYZHRZYnVjWXhXWGE2VFlScTE5SHFoaVczamxJaWpoT1VIUUNSVDlEeDFyTjBINGRXVXR0TmM2Z3R6TnN5a1VZWmtVamNSOHBCQkNucml1OWxoaSt5UHB1cHd0YXdYa1lodHpITnVVbkJJS2w4Y3FCMXFlWjl6bmpTaS9aTnd0ZGIyKzU2YkhGZUhMcndacVdtWGQ0bC9GZlQyeklkcXA1VWx1VlBCQWJka0hPRDcxMk9zK0tJOUpOcGNRQzRSTGVSRW1oU0l6SnNjL1BrWUczam9lZ3JHMDNSZEcwR3d0NU5PajB5YVNmelZlVUJWREtnM2NzRGc0eHlPdFo1dk5XczlPbHpxTmlFMytXcTJ5c1hPNG5Dc3JBNHowSVBhaHJYUTBsS0ZINEl1TVZ1dE9idnVUWG12YVplUnBlMk9wMlZubVlJV25qSWtWc2ZjTEhvY0NydW8zT2xLMTZ0c3RyZG1OaDlvdDIvZGpZeWdlWnp5Mk05cTBMYlNMVyt1OU4xSyswMk9ka1p5U0JsZDBJK1hjZ09NNVBCTmIyc2VIL0RXcDUxT2FSWXpzWVRqeXZMZGtiaFFDT1JnY1VyMmFIeTg5S1VvdEp2WDN0Tk8rcDUzRHJHclN0TFpwb29TU0U4bTNuUlZ3dlQ1V09TQ09sZWp6VHovTGRnenRGYVA1aGdNQ3lGbUhiakovK3ZYTVd2aHVEVDlXR29SV0FnamtHeDJNcGR5blk1R2QzNkd1ajFHNDA2R05ZSnRRTVVMZ05ESUJ0a3lwT2VoSnoySk5LeWRoeFNqRnVUYTVlN3Q4L1E4OTMyTjVhYXBjZjJUZDZmZHJNelNPb0FWSGM3LzNoNmdFZEFLei93QzF0R25taFdhR1czdW81QmNOTUM3S1NjWVBxVndNMTFOMm1nWGtZaWwxMFN6U1NiMHQ1ZDBRTzBZUU50eUd6eHpYZzl2cmgwNjd1TFhWdE9Td2lZR0x6SXptVjF6L0FBRTU1N0dxYmo1bkJVaE9VcnhVWlhXeXRkNjlsMTlENkd2YmtXMTFIY0xhM00zek1wdW8xVjFJa0F3RVVEZ2V0R3BYZW42U0xhOW10MjhvaGNRT0M2YnowTEtNaGNEblByWEdhbkZwZC9aV0Z6RkhkdzRpR0hna3dXQkdGSkdRdVJqRmRUcHZreUpFMXBOUGNib1VNeXl2c2NkbDQ1enU3OXFWamFFbzgralRiczE1ZWlzY25wSGlId2Y0Z2EranM3ZWFHVzBtVzRMV3dZRXJHY3M2OGZOakgzZXBxcFBENFMxelZYdGJsVWpsbGZESWdNZHdYNnFXQXdOeHpuMUZlay9hTlEwV05QczJuNGxXUStiQ0l3bUZRSGRzeG5nazRGWDdXNjFPL3VJYmhMYVdFM0ZvN3JiTWdjZWVTUUhkZ01yZ0R0MnBwYnJVNjFHbnozdEtMN1cvRzZzYzVvK2orR1k3TzVVczEwWU5xSytHRXNRQnpuZG5xRDkzSGF1ZnNSS2RHbXR0TDFPT0lyZHNzZC9QQkk1S2tsbldRTU9EdU9BYTdPOGdhTzAyWGtpUXlJWS9NbEJhUGNBUVd4c0JCYjBwWnJXT0czS1dONU5jUlhtZktZdVhVYmp2KzkweWZmbXEwTTc4a1l0UlNjVmQ5OWU2WnorazZiNHVoMDI1WFVKM3ZFVU0wYkE3UzJBUW9YMEhmM3Jub2JMeEZmdXpQZXdhZlpoY3ZFeDgxdDZqN3UvM3h5Szd1MjFXMm1odUxTNWl5dmxTelJSU1NzcUV4SENibXlPdU9ockEwUzV1bVNSYi9UVXRiY2gyUzRTUkpWY09NRWhWQjllRGpyVGFkeVhIbXRKTzZhZk5mL2h0dFM5cEYxYTNNdDFKYWp6TFZWVmJtQjNkV0FJNWVQSjZBMUxxbW5lSUlVbG10SHQ1NGdNR0c0VDkyNk1SOGh3RGxoMnJOdHJqd2xhckhlV3Q5SVl2UEVmbUNLUS92QXZIbU13eXFuc09sZEhkWGV0VDNNYzFnN2ZaSm9GS0NOVmtqSkdTZk94eXBKeDA3VWhLS2lscHJlNlVYL1doNVlmRE91MjF6RmVYR2cyRndqeW1PV0dLM1YyYU1rRXNNOURucFhvRVgvQ0s2V1hpanNZN1NaMzNiV1hoaTRQeWpqZ2pPTVZmMHlQeHhQQkMwNjJWb3NTVEV4QzRKZWJQQStZL21LemJleDFDZlMxR3B5bVQ3UEhsR2FRTHRPT3JFRE9lMVZyYm9iVDlwSDNWRnYzZE9aWFdubVpGdmZYOTJ2bFd3bFo1OHhXOHlRbGtoZm93TG5BSUJIRmJOMHQ3ZDZja0RXcUMvamRDc1VwMmx3cDR5RjdZNUhhcXF5V2oyVHdPc3Mva1JSek9rR1E2QUVrc0NNY2NjanZYSHkzMXRmYXpiSmIyRjNLKzFvb3BKWnpCSnNISnczNDlEVDJleHpSY0VvcTZmTXJXUFNCcUwzTU10dmEyL21qNTRiaTNtUlVFVVpHQjE1STRPYXlMNkR3MUpBc1duM0VzRW9LT1liZGZMREZPVGc0L01WZDAvUjROTnViWFVvNGJrNERCNEd1STVBRklJNXllZWVjVjViSDQzOFZQUGNyYktoQ015dzc0VTJqSndRVkhRazlEUzdkd2MzR05weVNUZTlyMlhscWp2THU5UkpHZ1RXVEF2bVJwSjVwVXMyT2NqZDkzUHBXQTBFa2QxQTBkK2wyczhzck1rcllZa2NxeHgxSGJGYXVrK0Z2RStzTmRwcmRoQXpUU0JrbEREQUJIekZXQTRJT0JnOFY1akZwSGpmdzlyVnpGYTdKWEtGdHJBU3ZISDB3b0hjVWtPcFJsWmM3c3ViVGY4T2g2em8xeHFHbWFWTXF6R1dBeHF4OHh0eFg1anZ3ZXFnL3dpdEN4a1MrdW5odm11UkE4S2lDUmdEanFPTWM4Zzgxemx6QWttalhaU0RVUVFXYWFhM1E0ZHd2QllNY2tMM3h3S282SHJObmF6MnR1bHpjWFNNWWpKS3NlMHhoZ1JsZ2ZRL2xTZWh6S2RsVHUyNHUyK3BxK0tkTnU0OVRpRVYzY1FyREFtV0FEQ1FaMnFvSnpnbmpOZGRvWjBmVjQyKzNXMFgybXhMUnpGZm0yY2tIT01jWTVya2I3V1BERnBhUlIzT29NWnJsUzl2TVhPUXlFc000NkQxRmVYL05jUzNMNmZxZHhaVFNSckxjTGJuN1F0d0ZCM01wYkdHK2FwZTUxS01JMUZLVmxHV3l0ZGZnZlJsNGRLL3N5UkpMVm1qRDdZWkcrNitNYkNCMStsZWZlSG90V3ROUXZwTHVSa1ZJSDhveVNCdm5KNUI5UUJ6OUs4ajhQNng0bHNudDRicStPeVNQZEFzdnlsbGNsZHpLZTY0N1Y2ek5wOW1QczVua2FVM2tNclA1UHpOeXZ6dGowQXo3MFdleGhVY25WUzVVK1JyVmFMVTZJbHJ1QXh2ZXc3a1lFb21Sc3puQUpQcU9jZHFLOGYxSzYwYVc5dUlyUml2a3liR0N6YlEyMVFDM1B2d2ZlaWpsOHpDZFZSazFKYXJ6ZjZudXRucWk2aGFYTjBtbTZycDl4aFh0aks3K2E3a0R6TnlNUUFGSFBxUjBGZEJGcUNTM0VBdUx5TzVGeDVxUXhMYnZjQitTU3lCY0FML2VSampQQXJ6dldtOE9Xc2x6clVHczNjU3JKdmxnaFl5UlRidUhNZytZcHUvaEpHSzR2eEg0dThNYVZaYWE3TmRUMlNTaDRaMExpNlRMNzI0WURiakFKMmpCendhbFhkcmZJOXVNT2VvdlpSWHZPeVN2cTcrWFU5Z3RMN1RBWWJTSHdsY2lKZDd0TXFvc1RDTTU1VWs5end2QkhlbzdockcrMWk5Z2owMHVCbVM0allsQytWSTNXK0crVmx4dFpRT1QwcnozU2ZFMXBkNmZmWFdtNm1zRWpUZVlpWDl3UzBidVNSOHo3Z0NWN0FjOUs2T084OFIzY3VuTHBlcVF6Rk9CY3p4eHNKR2Q4c1lsK1V4akdjS1NjOTZFbTJOV1YwNDI2UDNWcjBKWlZ1ekJITlk2anFjR1ptaENYZHY4QWEyWVkzQXhtUWZJaWdENWVwN1ZqNk5lYXJxMTZiaHJ4ZFFJS3FZN3V5aFNWUnR5WjBlTWdiZWNOM3JzTk9tOFp3WG1xR2E2c2JwQmdzcER4U0ZBTU1RSEp5Y0RPRHdlMVo5eEJlNnRwVmpjYWFzVnErK1F0WTd2TCswQS9MdmJhQUFRZStPblNtMXFZdVRkTng1cnRyVFMxN1Bvem40ZExiUzdLVlRaeVRMY1NLa0wyc2tNVnVqNEdHbCs4R2ZQcU9tTzlSV0R5bTd0clM4MWJVZDhzVTB1WUpoSkZLek5nR0pYeGp2a0E4VjF0dm91dXhKWnJGcWxzOXJjWEFXNEF4RkxERVIvcWt3TU5LeDZTRVpGY3RZYXpvOEZ4YldjV293NldJcFpBOFFMWEF1R1FrSGRsU1NHUDkwMUdyM0ljYk9sSFRWYkxyNm5HTGVlRnROdjRHTGF3a1VTR0x5cDNXS04yUnM4QmM4RW5uQnIwZVR4RGFYOTNhUWZhVXNibklDK1dtNE1wYkJKWUQ1aDJKcjBPV2J3NWVXTWtWemJ4eHl5bFlkNU1ibUpYVmdKT29aRkJ4MTVyRDA3VzdXd3U3VzJtdXphK1h4dVZVWjBFWkh5REp3ck4wSzVwNkdkYUxqS0w1bHl2cXYxMk0xWjBhMzJRdEpjNmhidytWdnRiWVJ5dVdiY0pFVjhmTURuazR6bXRHMzBmeGNMeTFaZFZ1TFdDU0JOMjFRTGhtM1pZVDVCQU9UeUJqaml0TzgxUkJMcU4vYjN0N1BIQWtpanlvbGpqajNFRndrdmNKalBPQ2VhNC9UdmlONGUxUFZZbXVMblU3YXhrZ1ZuczQ3WVNtN0s4bjk0aFBsc1NldUNCUy9VN2FOSlNuWlNXOWsxdHR2OEFnWHRmdWJ1S3pRUExKZVhEaVJKclJwRmtSMVBCY0svQzdnTTdUbkZlSzJ6U1hkMWN5VzNoYWQzTnZJYmd6bGlnVFBsYmh0T0R5YzU3WndCWHNtcTIzZzI3OFEzMm9hblo2Yll5R0ZJQkhiU1NiZ0hPME5JekVlWkljRGtqY2VheC93RGhGcjIwaHVIMGZVN082dFJJbHhjVy9tK1dYV003UklaTjNTUC9BQnlLMHZxUlZvd2xOcFZIT0syYTAxWGtSd1ErS2JPenZqQnA2UTZqRkgrNWpaQWlPc2d3UUpNazhqT1NUbnVLU045WXVwVmoxZU8yZ3ZFZU9TQ0NGUklqYm1WV2QwZDl3VkF1T09HcXZINWFPTFc0dWtzTDF2bm10K0NwWmx3R2hLTVBMWmxiNWx6ak5iOS9yQnRMeG9ZOVd0bzAyeENTVzdqSW5hUEFCSlpBVjI3Z0R3ZVRTdmErM3FjVjR4ZzR1bmRjMmozdS93QUNIWDROVnVZdDkwc2NOckRhbFpyMDI4clBGSVJndGhoeUJuSWJrMWJzOU8wcDRIaGJVdlBaMlNRVFNNaXJPQXBDN2luUTlEeDF6azBOcUxYTXpYUjJHL1NkV2lNYzhubHpSOEVaQ2xjQmw0VkQzcnM0YkxSN2lXU2J6SWJZUXZMSjVheHhCQzBoRzVpRlBib1ZJR2M1cU5OVG9hY2t2ZVQxNzlEeUxWcmJTdExpdWRTKzF0YlRMY2JIUDJnYnlCOTlVTW1jRURCS2M4WnFmK3p6cTBNOTFhYVpxOW16T0owbldGSndRZ0c1by9OSVlJZlRna2RLNzZiN0lZbnRyQzIwK1l1b2tWbWRDeXpjSEpRWlpjZy9JUVNNY0UxWDFtVFY3Z3d5YXBjUVdGbm5iRkxicTVKZEQ4cElPNE56d04zNENub05VNlNrMmx6U1Zuc21yL000eTgwNjg4dTVpTnBjWE5uTTRsbEJSWUdXR1VCa3d6QjJad3dDN2VDUHBXeEZZNmZDa0VFdGxNc1dSNWtabldRcWZ1c3BYQStVNUg0R3Vocy9FRUY1UERhNlpxa0R5U0U3d3BlU1lnTmc1SlBVOUFUN1ZvV0dqSFQ3aTVkOVF0NUNseWtaaE1aY0dZZk44NUl5ZUNNWkpDbWpUY3o5bGUzSWxaYU82MDduazFqSGVXczlzWk5EZ3Q0RWZ6cEJkU0NJaEorZmsrOG9hSTR3UDR1Uml1bWE3MVpKWTR0UkduUnVKaTBMU0lkNXprQmNZejE0YkdNVW1xWHZoblVJcmE2VHpiTjJPNTF1SUhrTDd6dHk1SkcxaVFRcHpnNTYxcFdNWW0wNVpkT2xXS0ZGbGtQbWtlWURNZXVNa0tHMjlPOUprT0xVcEtLUzYrNjkvVXUycWFKcVZoRzE0WWpNamhTb2pYSVBJeUVPQ285TThWNVBxbmpydzlic3RoWjNWN09qWEE4NzdQZ3FxN2NENWwrOS91bmcxdTJ1bjMxNXFXcnlQZTMxcTAxOHJpS1h5N2Y3d3dxZ05uS0RHQVIxNmluNldsanBOdHFVTnZZM2tiRnlqeTVhVkRLQmdFRFl1NGxqZy9vYUh2NUdyZE54YmFmYTZUMTZhNk02YlQ0OVN1YjFMdTB2NDU3WWhpa2M2dkZMRjVhN1BPQ1NCUnZMSDV1d0hTc2JVcHJtZVNXOGgweUhVL0luVkxqYVJETWdqNHduUWtyakpibk5kRnBIaUhVN2U2RnJxOHN0bkxJTXNrZ0tpTlF1TnFiaVJ0Q2tFc0RTNnRvV29QTVk3YUcxMklqa3RHakdZRGdqWUFlVzR4aHVDS3RKdDJGS01WSG1TYnM5WStaY3VtMDZlM0FDVzlqSXNJazNUZ3BHMHJBT1FmTSs5Z2pqMDlxOGtPaWVIVWVNM0RxRFBjcUdQK3NnWm5QeWhWTEhjbzc0QUs1NjE2aXIyc2MwclhRbnQ1RWhqdFZ1dmthRjNmNVQrN0FmQlZpQ2V4cmxybVBYUWx2RU5YdDdXN3R6dWtQbFJvbHlGWmlWS3RncUQzUEt0MXBhYTdGTG1sWjgxdTl2TGE1emFheGQybXFTeUc3dGJsSTFlQkJGYTdtUWpreHlZQTVBSEI2RVpyY3ZkTjFTZHZKc1BNZ0MzWG1TelNLL21SUjk3dUVOakFHUmtEdFVMM1ZocU1KbXVaYmhuVXQ1MzJPV01lYXdVZ01TaERNVGdqYXZRZGE0aDlNdUlyTzR2QTJvU3hMSEdRNGtaSlBKSE8xWW40VWc4WXlUeFZXaWxwWmt1U1VsYTh1MTlybmVIVXIrNFNGNUZpdmxpMkNhU3pqUmpMaDhCV1o4c0J4MVBmbXBOYi9zeUMxdTdsNTRGbFNOSTNoYVZkc2F5WVBtTVFHTzcvbm9TRHgzeFhsdXErSWJ4a1d3a3NMMllLb0R5SjVVVEpGTW8yc1hEQWc4RElJTmM3YitEZkZBdUxpR3p1bTNrSTB5elFBUkJTQUFpVGRTNHhncWVvcDZYK1JkT0h0Rjc4a20wblp2VnBkTkwyOHJucmVwMjJtbXl2YnA3RzN0cDVCYnhuTW5sSlBzd1EzblJua2hld3g3MWs2RjRsVk5TMUtCTlN2clh5djNVMXZNaUczMjRKWGJPRUJWRzdaUEpQU3FlbzJ2aUYyaWp4QklxQU1wZVlTZklBVkpYeXdvR1NjWVBCUE5kUHFMMjlzdHE4dDVwOTFMUElnZUs0MnhueTBZcXk3Y0RPM3BrY2NlbEt6Vzc5RFQycmp6WHZKOHVydnFscC9rY1ZyWGlMUm9yV3dGbmRUWFNTQ1NTUzgzK1FZekFBUmJvMElHN083alBCUE5kdHBNdHhMWUxpS1dSM3Qya2szQmJpWmd3VmxNZ0pDb3JIMEdLMFRxM2hTSzlleG0wVkY4MHhyY2lWRWpoa1FnN1FNZHdPbmVvci9Uci95cmFTT3dodDVVUm1aa0NReHZ0R0VXSTRPNU1kVjVwcUxmOWFEclJpNDgwWHN0VW5yMytSUWwwZVZMNjIxSnJSdFB6RDVjN3dSeHd1VVg1c0tvSGxxbWVEbjVxWk5hYW5xT25KRGNSMkl1bUgraU5CbUxmR1ZiTHNPaWtnOHFldGFhVytvRmhjUERjQ1FJSGxKdGk2b3pER1ZJK1ZnQ09Gd2ZYcFdaSEZjYWRwMnFTWE9vM0VLZlBPYmt1TjQ3YjJpQ2txQUR6NmZTcmJWbjl4bnkxS2pTYmZOZnE3dXhsYVRyTjVxRUlzYmp3cUxlT3lUQ08wTVU4RWJBZEdWOXBIcWNISTdWbDJ2eEU4TjNpeldsM0dscks0all5QkpZMFpjQlJKRzhicVJrRC9HckhncnhuWVhjMTJpNjdkWGp0bGlKa1R5Mktjc1ZPUVNDRDBOYjJ2YW5hWCtweXpYSnRwbG1nRWFwRmJKSnZqSXdCdU9Ua2R3TVlGUTByN003YXJoVCtPRWxKV3NydFdmZjNqWWltdHRVdG1zOUx2SVk3bTBrekhOSXNZTEt4KzRXMm5ramdQeldkNGVQaWlLOW1zZGRKUzJqL2VXL2t1WDNzdkJLUGs4WTVBWWZoWE93emVHTk5zQ1kxV09EWXFQZHdxcDJ1QVNFa1hHQXVlY2dja1Z4Y2ZpaUtHRzh0WUx1VkZabW5XM3VJZ3NKa1dQYTNPWHdoQnkzVW5OTld0djFJcHk5M1JKOW5aN2ZJOTI4WVBhenVkVHRyWkhpVlBJdUcyTkpJamtBaDFqSFBYNVNWNlZMcDJzUlcwVUlTK0N2YnpSdHNFanVqTElvQ2dzeFp4Z0hnR3ZPTk9oMW1LQzNhSzlaOXFxR250T1ZWRzVLb1NXRFI5aG5CSFRGZVVhOWNTUHJ0a3FlSURhaVYvczZ4U3hFR1JRQUFHSVVBWTZaeGluWjh5YXRmZEVRVlNWZHVFclR1M2ZWcjNWZlpKMlB2MjZ0dFA4QUdla1hPbjNvRWR4YXpNSTVsWEJYZUR0Y1o3TXZETDB6WHhsZjZIcWZoclhRTDVmS1FySXNjby8xY3Vkb0cwbnA5M2tIa1Y3Um9maW5TTkZrRnQ5djNvZ1dONTNPUE1mUDNnTS9keng2VjducUYxWWFoYVd2Mm1HT1dJVEx1VndHRzJRYkQxK3RjK1k1VmhjeW82dmtxY3ZMekx6N28vZWVHK0thdENNWlJhbkRtdTRYMmE3TStXcmZVU2NuY2NIR09hMm85UVU0TzduNi93QXE5TnUvaE40WW5sTDIwOXpaRTVPMktUNUIrQnlLeDVmaFNsdTlxejY1ZG0zZVpVbFB5cVYzRENuSUhBendmclg1SGlPQWNiemU1VXBTWGU3Uis2WWZqekxYSDNvVkl5N1dUT2ZHcXd3b1hrbFdOZXVXT1A4QTlkZHQ0WjAvVnZFbXB4MnNZbHM3WW9KRGNTS1VlVkFjSHlRZlR1ZTFld2FCOE1QQ2VtM0N6dGJ0ZFRMejVsd3hrSUk5TjNTdlVielU5UG5DVzluaWE0aWtSby9LK2J5V0JHV1pod294a0VkeHhYdjVWNGVZS2pWalZ4bFJWbW5kVTByUitmYzhiTU9QSzlXRXFlRnB1bW1yYzczK1I3TDRmMGZUZEcwNkcwczRsamlSY1k2ODl6OVQxcTdyZmlhTFNvNENWRHRLNVZRemhSa0RQSlBIZXNTTzlUK0U5U2VsUHVFc2J5RVJYRU1jcVp6dGNaSDErdGZ1VVVvMDFHS1NTVmt1eCtTZTNjNm5OTnVWM2R1KzUzbWphM0hxTmhGY1JvVkRrOEU1NUI5ZlN1SitKK3BOYmVBOWZsQitZV2NvNjR4a0VWdFdzME1NS1J4S3FJb0FDcU1BZXdGZVcvRllQUDRBMTZNTnliT1QrVlpWbS9ZVDc4ck96QzFJL1dxWGJuV2g4bzZkTUlyclNZc2o5MVpNZjBSYTlyOEd6ckw4UTlDakp6dGh1M0E5d29IOWErU2RPMU5WdU5HY05sWHNtVUhyemhYSDhxNmk5dVZPcGFaTjUwc1pEeUp1aWtNYmZPdVFNcnp6aXY4QVAvSjVReTdpREFZdXJUbE9OSG5tMUZhdTNOdGZ6UDdHekNsTEdaWGlhRUpLTXFrVkZON0s5ajlZTlY4VWFCcENnM3Vvd1crUndqdU54K2lqSlA1Vm82SjRoMHpXYk5ibXl1Qk5DWFpOd0JVaGxPQ0NEeUNLL0k2OTB1NzFpNGhzdElqMzNqTnVkVUJaaUNNYnBIUDNRUFZqWDZDZUF2RFY5NFc4SlQyN1hLelhraGttY2svSXNoUUFBRnV3eHlUMU5mMTN3M3hMajg2cXlxLzJlNk9GVVpXbkp2bWNrOU95ZnlQNXl6ekpNRmxsS01IaS9hWWh5VjRxeVZuNWF0Zk04MitORjU5a3ZiTUxDR0Z4S1ptbDV5Q3FDTll6Mkhjam12aHpXL0VubVNmSzVDb051Q2UvZXFYeEc4VzZISnFrdjJLOGt1WkpNRzRuTXBjU09wenU1NFA0Y0N1TjBlUDdUWkdRTXhNOFNpYWZadUNDVWhkcWdqazRPVGprMTlEbU9jWVRBVUZVclBsVTZpaXZOcytibzVUV3hlSnRUbHpjbE83OGtqNkYrRm5pWjlGc3ZGMnF5VHJFbHhGQllRTXpZSG1rNzJmNkluWDNJckZ2N2V6R3QvYW9rRU1rQ2hwMmUxSmQ0MlhJSWZuSTdISGFuWE9tUC9aMW9OUFMyaXN0T2pMeHgzVGNzdjNtdUpDb1B6c1J1UEdEMHJrNGZFV2x6WERoZGZoU1lNUExLeEZjeE1DZDBha0FNb1k1Qis3MnJ4NmM1WW1zOFMwMUZ4NUtTZjhBTGU3bC93QnZma2tmbHZFbVlLYzFoWVg1YVV1YWNsczVwV3RmKzd0NjNOYVR4RDRLMDYzdXJ0clY1WWhlUk82VzBUd3NzemZjY0lvQkk2bm5ISGFzdXkxcnhMYzI2WE5scnJ4eHpUdUV0citKSE1SWWtiWFBCMmNmTGpybkJxcHFWOTRWWmhCcXpUM0ZxU0Mwc2FGUkl6S00vd0NwNnEzUVp5QjJxTWFhNm1HT0MxMUY3R0dSZkxNZHhDOFJBYjV3cWdEQTZNTS9OM3J1djNaK2JlMGJWMWI0bW5iVFU2N1VUNFowVzhrdDdxeDFPUjlRbVdacHJHT1lJY3RqcXJOalBQeTlRT3RjanI5dFlhcWpTejZoY1JMTElzYlhCajNnaVFaVXNXS0RnSUZCOWV0ZEFtdCtJN1M0TUNYTjhzYXlPRXVMbGxnVjBJd01CMUlMRHBrZHVsZWhUUjNqcGN3K2RCcTd6d01HTnhBcVJFSGhXM2drRUtjRGpwMXFySTN2Q3Bvb3JSNnByL0xjNFhXSXAvN0xzNGRPdVB0S3dSN1JiTkdqcXhZWUdmTFVGd0FEeG5OZWYrSHZIOTlxRWJMUDRmRjhvaUN6Q0daR0JaUDRrQitmZUJ3cWc4Q3VuMHpSTHpUVEdzbmhuVFlGVldhNWVGbExBaFNkM09CakF5U2VsYVY3SjRxMDZBTHAxcm8wbHhNVmtTS1c1K3p5U0kzQmJiRUFpeUhHTTU5NmFUWFVsS1RxcEpjdTIraVhUcm9Xb2I2dzFiU1l4YldGdmN4eU4rN3RaSFB5NFVNUXE5MnhuQkdmZXNlODB5MkYwaHVHakZyR3Nhd1JvM2xTSTI4c28zbjVHSCt5UWVsYzVlYUhxV3ZRNmRMTHBFbHZjV1YyR0NwR1JiOC9NKzVnVHVCSEJJSUk0cS8vQU1JUHI3UTJzQ25URnRnWFNKcDQvTWphSmNGVWtSc2tsVys2L1hITlRka2NzN3dkN3RXMlZyRjNTb0xQVHRHRFFSSC9BRWZIelFqZE9VYy94N0JqSUlISUpIZXJ1bDZoYVhjMTFtN3VibTBzdDhlNUxvUnZLN25wdFVxU29BMjV6Z2p0bW5YVnJOYjNvazBnK2Rjd1FwSDVkdUZ0d0NDU1dtVHV1TzNVVm5YbXFOYVdGNEpOWWh2aEpGSVo0YjE0b2tTUU4vZEpYNUFQdWxReE5QVlg2M0ZCcVRhV2pXdHQwLzY2bk9YOTlvTGE5NWRrVXVZbzRpc3M5dktiaVcwSlBYeTVRVkhKNkE4bnZXYnBoOGRXVTBsbERQRHIxakgrNWxubFk1aDh2SjhzbGRwM3RrWWJvQnhYVGFaYjZQSkJCNXVtNmJwMHJ2dWQ3TWt4U0xJT29aMUpBQndPTWdWMGVvblNOUnpMcHpOZnpSZ3czRWJHSlZtTHRrQXV6S3dDRUhqdUJTNW5idU9NN09haW90UHB1MjdIbjhsL3B1dmFiREZEWndhYk1aSENScXp3eVJ5RGxSdTJsUTJlU3VNVlcwdTUxVFRETmI2cnF1b2FoZVQ3NElvWW1lMlYyR0ZRd3NQbExIUElPYTNMdlJMYlU1cmkzZlU3TzQyVzhiUW9pcktiYVpQbWVOR0J5L3FDZnBWMXJqVE5NaFZJZnRjZyswcmsyclFoWkpRZ0RaallZNGJncURuTkMxVnRETmUwaktYTnlxTW4xdDA2RExyVGRSVy9ONUpwVU05N0pHa1R5eUV4c3V4Y0JKMFZ3c2ovQU4wN1FUMHJrOVV0YkNQN0VmRTJpNmZOQU1OYlhDSVlKRmFVNUh6RmdNa2o3b3o3MTZqTnExcTk1TXB0WHVaVlhmR1k1WGdtZGtHTXRHQnRPd0RQSitsY0ZkV1h4QzFxNVJDNldWdE1JMmt0NVZGekVOaWdwTWQyN1lIUFFBbjF6U1hOZlM1dGZsbEtjYTFtdEU3dlRwMjZsQVdmampXWXJzMityYVhaM1FKRHFpVGVhNnFNWWxKWGNwd091RG11eTBydzNya2VuNDFLMnNaWUNKbzJkUVk1bFZoa2Vabkh5NXljQWc1ckhTemwwL1ViUXhUYVhia29mOU9jTkt2eURMSjg1VTVCKzhPY2NWdHA0bXNtdHA5UGxoMHFTNE1DWFZrMHpoSTVuWnlBekpnQUFkZlh2VnBXM1h6TVljczd4Y1VwYTNmM2I5ekkxWFFkTDBnTGVIU0xobGxUeXZMdGJwd3dYSXd4ejVoengxL0d1cVMzMVRVRWV3dTB2bHRkeXkzSG1rdEo1RFlJaFdWQjgwWjc5d0J6VTJyemVKN3FJWGxuZVdseFp4ZVR1Z3QyUXFyc1NwZU9SdVFWN2NFRTU0cm1yaURXMCt4cEFrNjNFUm1ra0Z1aG16dEFLNSthUGtuSU9CMXBQbzlDNVJjR3VWdHJUUldWek8wM3dGcE9pWEl1SS9FbDR0azdib1lmTlpES3pMOHFPMFlQVEJJT01nVmIxMncwSVhwbHM5SWlTZWFXQ1ZoY00yK1hiODI1QXpiUVc2NVlBazlhdVcxMTRtamdXRFZ0TisyMnZsSzBSbHQwaWxjajVuV1FlYmxjZHllRFcvWXoyTjJEYXo2YkhIS2tpT3NjMDBHVzNrQUl2bGpkZ1pIZlBibWpYY1ZSMUp1VVZaWDM5ZHp5NGVKTlcwNjg4cVBUN21XRVB0RTgwa01VY2lCY0ZGbEFPU0NUd1RuMXIyV1B4ZllxSTdhOXVveUkyUVc4aXltUXdydDRNN0FBYmVlQ1NRYTVlKzhPYWFvbE1Xb0pDMFVvZHJlSmhIQW1HRGJtM0RqMFA4UjcxUmxzZkM0dE5PaXZRYnZ6R0x4TEkwajJ3Mm5ka2hGQUhvQjZWUEtteUlXaGYza2xaWFdyOWJuZVdtdjZmY1QyeGJ4QllRZ1c3YkpKSlZsamJPVTJqa3FCbnNPUlhuT3JmRURYdER1TFdhUFJJYjlXaFpyaTcwNlpIVlZpQkozTXdVNEE1NUZUWGZocnd0RGV6eXA0Y3NvWXJsakJPMHNaU09YS2tsa1pqaFFNZ2JnQWF2ZUY3ZlJOTEpzN0cvc2JGVkt4UEJMY1BJdnlnN2xWRzZ4a3Rrc01IM3BxUGZYeU91bk9tcEpwT1h2ZGJxK25xWExmeEtidTFXWjdTNWprQ28wOTFiTXBqWjArWWVXMFlZRmVlUU9wcjFUU2RiYS90NUp6UEsxc3lLZktsd2JxTjl3VTd5ckVGRG5JNHhUdFVpbnRZaWtGcUN1QUI1VXJ4SUFDTXRpTlQwR052TmVOM2ZoajRjUHJUM2R2cW4yUzVuY3lJeTNoVVNTN3h1Q2pJTzBFSEJIdldqZXNVWEhtZzVMbXZwckcxdGZ3UFE3Mjd2WXRRdWJpSjJ0b2JlUnJmN1lIV1JtVTVPSVFRVHo2WXpYUDNuaU8yaWxXNmUzdkhFazF1RUFXUkF4ZkpFcm9wKzRNWXdQYk5hTWVyNlZaM2NOckhaUTI4TThwVW05a1o1V1VBN0hBeTI1YzlHUEJySGtOL0xjdEZMNGIwU0tWZHpLNlRoVEprSEpYY2dHQ2NEcjcxTitoeXlzN3RUK1Q3K1IybDViYXc4Zm5XOTRsclBJZkxuUGtibzJpT0FPTWdLMlRuSi9Ldk1kUzFQeE5iV0hrWDJqc2Q3dEJEY3JKdmhtTXhBV1FGT1FTT2pIR0QwcjJDd3Q0N1dBS2tVaGttVXMxdURsVTlTV0grc0RBZFQzNlZrNmhwR3JKUDU4VjdkWFVSejVsdE02K1hHUHVrcVYrWU56OHFnWUo2MHJxNW80TjBtdVZ1NjExMnYxT2MwMiswelhOR1MzbGl2WVRieUZubUYzNW0xd01rTWR3WXFNZjRWemk2WnJzZDNaM0Z2NHAzMlJBbkE4cFlIQjRVK1l6RmNnZE1kdlN1cEhnM1JGVDVKWkxaWjVWU1R6UUpKWGRXSjVMWlVnbnB4V1RxVmo0ZU1OM3B0emFXalhKQlRkZE9sd3dQVUVBRmlnWWNkcVQ1ZVl3VUtuS2xQbCtHemt0N2RFaXJxM2diUU5mL3dCSjAzVnlsNUZ1S3h4VGVldm1PTWwySDNXa1lqNXNuSGF1WjAvd3hZdW9oYlc3aVNlMWtYZE05Z1lVTWc1V1BwODIwZHM0RmRWYzZYcTlscE1iV2QyTEtWQklJa2l0QWthc3piZUloOHd6L2Z6eFUraXpwQmJ6YWpmM04wMG1Xa2VHQmhPaGQ4TGxFYmJ0MmtISzlSbm1sWnNwdE9GbkdLZDF2MjcvQVBBUFA3V1NIVFRjaENmdGs5bUFvbXVOcU8yNGs3RWt5eHdEaklKNTlLMllGZzB1MUgyaTJodWJGcnNva0Z3Y1RTUjQ3elNOZ05ua0FWcm1Ed2o0c3RVM3pQUEcvd0EwVnVMZGhkSUNwWWhQTXg4dURrbnZYbGx0NFcwT0tZVDZ6cTEvSTBUbHBMaTZLd1c2Tm5Hd05qcUIxMmsrMVhhNnZzWWZWMnJKeXZLOWtyWHUvbCtwMkp1UENFTjFFdW02Z1V1cFZFcnhySTBnaVRjY29GRE5zNjV3cE9mU25XMXg0YTEveXJRWEVzWi8xTHhNckxJN2JneGFOcE1TQkRqcGs4VnpPbkR3dnAybFhkM29uMkM5a1lxM215UXN5b1dBeWR5cURqT2ZtUFVpdlIwMXhJdElzcm0rdDdQYzJFWXJiK2F4YVE0SGxoUU9vNUczT2FsTDN0N2l1bzFKSnA5TmwxV24zbWRiMkhoKzZzYmVRbHJaNDFaRSt5T1pQbDQ1NE9PUVJ4eVBXdXFzeW1pM1AyS0dHZThrdTA4cHB4RjhyTEdtL2E0ajRWUU9HUGM4MURxWGlGTEZiQU8wTFhrZ2RiZFpJOWdiKzhNUkFsV1BkY0RIV3ZOOVIvc3MzVmxiTHAwOFV2MmdGWHRQTmtqR1Q4MGJ6cXk3blVrNHo5S3BYNXRpNHc1WmFkazlyUGI3all0N3FPL3ZGRm5wdGxwTStXbHQzZGlTU3I3QXhhSmdIRDV4Z3FlYTZUVWJUeEpKZlMvYXBRdHBJekxjR0NaN2lOWTg0TWNvY2phcEhjVnhsMU5wMGQyWHNKRnZDekNKTFNhVnhjaHVwOG91VDhpNXlNSHBYYWFqcGVxNmlqVzY2cTFwRGwxdTRnZ2Nzckg1VktnRGF2cDYrdExTNlZpa20xTC9BQk5xekk1OUE4SmFmWXhKZTJLU0xhL05CY29aRzI3MkFpMm5QQ0gwenhXaC9ZMjJ6dC9JdmhESXJ0NVF1WlRGSXl5OHNBekFrQVlJVW11TGgxelI3QU5wOTFkWFN1dVVablF6dWt6dmtTc1Q4cnBrZmRYSUJ4WFFTLzhBQ2RReS9acmpVOUwxV0s3bENvbDZwaVpXL2grUWh4a2R4VDVub1U0UmIxdFpMMGZsMkVqbDFob3BOMnFKWlJ4dktIaHVGRjRabVZnV0JpZkFHRkFLc0Qzeml1VzB2VzdLem5uMCtDRzR1VlRZa2FSbFdFY0o1VWhHd0Zkcy9ON0d1ajFXdzB5Q2F6ZWU0akVvbmFacjYzU00rUTRHMGlWaWNBaytvcnFMYzNEWDF3bDFkV2Q3SGRRRldoRVVVYmlRRU41aUhkOTBqdDlDS0xhTkdGcHlhWE5hMjNyNStwZ2EzcU9vMnhUeXJPTGJkeUtSSE5BWUpZOGphZHVjZ2tkUHZENlZnNjE0dGkwMjJnWFVOT2svZnJ0YVJKeEZrVzUrWWxsK2ZKenl1Y2U5ZXNlSzdhU0RTWWdCWlIyY2tpckxGT3NrcGlHM08zNVdJSmJqQU5jRGR3cThSanZOSDgyeVpWWlpyUUpJVWtiMWlsK2JrOXdPaHA3V3VhVklPT0k1ZVoyY1hwNmpkR3Q5RXZGZTVTSzlSTFdNYlpKb2drYlEvZlYxWWNzZWVQYXVrMVZMV1paMW1uaGl1V2NGSnBvQklzUElMSzRCeXhmK0hHQjJybXJMdzllVFRlVi9hT3FTMlpqS3lzMHlSK1U2RWJVVXhrTUQ2Wi9HdVFqdHJ6U29aN2ZVZFdjT215VzNLb0RLZHNuUXN4K1pSem5IR2VhbDdtTHRUaEZ4aEd6M2ZSNkdsZjJXc1MzTXRwcFYzcGtzbDNEc3ZJSHRqQkc0SEc5a0o5ZXc2aXFWeDROdUxiUm9FdGI0UFBhU0k3MituMm9UYXJObVQ1cFQ4M1RBSGFxUDl2YWZkV2w5SytyM1dweXVxeC9aNVl2c1NNcjQrZFMyU1c0eUNEK0ZYTk8xSFZiUzdqZ3NieTd0cGJtRXNIMUpNdE1xbjVuaXp4bnRuR2VsTFhjMTU1Sk5XdWs3dExXMS9JNzY5dnBJa3RvWnJ1N1MxTWJpUlhRU1RoQ05xTXhHRlZUajd1TWl1TGZUZEtpdFAzQ1RhcmJ1cUxHcS92NTRaR0JPOTkzWTQ3WUE5SzJieGRWdUxxS0FQYkhFZmwzTi93RFpkek1wSStWYzVPZlVZNzlhcGF0QloyODhFVXQ0Yks5Z0R0SEdrZmxvNTJsZDYrVU1CaDNIV3ArUnp5bGVMY2xlSzYvOE9YZFQwT3p0ckdCN0NHNWl1TVpqbGNEY056Zk1BWDZJVHlCMUk2Vnk5OXIwY1UxdnFHcVc3eHpsbWlIbUJzd2hma2NGR3o4K09kdzllYWZMcU1Fc3NNMXpyV2t6VHBicXVUdUpLeHNPSnRoTzdHY3FEeWFwNi9ZYTVyRWtxUnZEY01KSTJaQndqYmNMSTNsUG5FZ0F3Y0htcXMydk14bGE5cnVOMmtsdDA3SE5wckhoL1RyeUMvczJqTnMxcWdkSXNodHhKQklHZmw0NlU2UFVmRUxlSXhjV21SYlRySkppRzVpWjJTTTVES0Z3QTduQTU0clM4VFh1cWFWcG5randaQkRhbzhnT0ZMTTBBVWdsZkxKSTM5bVAzYTI5Q2lnRm1KVTBtM2dJZzNRamU3U3BHUnRQbUJBY24zUEdhRnpMcHVqV1VmWVhidGFUMHYwdGJ0MU11MHU5V3ZMblVvcnZSYmlLNVlMTk5iVE9ra1VLellEc2dVOHR3Q3Z2bW50NEdpKzFUWEZ6ZnBabEJ0dHBON1pmekQ5MXlvSFBIR0s2NGVITTIwdHhmdE5NbUlqQ0VlS05aVEdRQjhxamxjZGljSEZVcmV5MFBXRTJvSm94RGMrU1pyaThEQjJLbmFpQk05andlM1NsZlVKSnVibW82eVR0Rzc2bks2cERvd2ppdEw3VExyVkRGaVNPZG1XMmxRbkFaZ1FSOHZIQUF5UjFya2RIdW85RXpMWVgvd0JtRnRNWDhwcFBPZFdkY1l3eFhxTzY4WXIyRFc3aDRMaTNnaXZyVHpsZ1JZcldVQWwwQnd5U2NBb25zRGcvU29MVHc1cFR4cTkzQ0p4RVQ1WGtNckViU2NwSGtMbFYvdW1nenF6cXR3ZzV0YTNzdExOUFJtbjRRMU9MV3J1V1h6N2k0a0pNam43UElrYWpCNERjTHV6eVd6VlhVZkF1amE1YXlwcDkxZTJaVjBWcFF3S0FyOHdHNGpKSFFEQjYxeU05N2NUekpCYUs5bmJSNVhiZkswVzNxY2tFZ0RjQmdnajlLcjZmY2FSSmJYMGVtNlZxVXV6RWhtdDdqYkJ1VDd4UXNmZm9Ea1ZUdXJXTjZQdVBTR3pkMjNkMzliSGFXUGhhZlQ5Tyt5dE5KZVFLNEFhUmhjN1czY0VxZzNBYy9nYTBkRzhVK0hyaTVOcmVYTEdaWWlseGJ4czBrTWVHSVB5c1BsVVl5VFhOeitKTG0zRU5yZjhBZzNVY3BnczBRREZDb3prTU0rWUNEa2tHdEtmejQ0WnByYTIreStZaXNFZUZTa2lTNURFSElaR1B2MHFlbGlwM2hhWHEzMTFXdXAxMnBXbGc5dTVYVGxXSVpURVpET2dYQlhBVEJLbGZUdFdCUDluRWx1N2FHMGpySEpKTTBJbFh5cGo4dTVRZUdLOWdldmF2UGhvZXMza1Y1NWN3dExTWWhaQkhLWlV4RU1obWNrRmM1d01IZzBQcGwxcUMyOEVWMmJtS0lUQjRFa2FGQzBhN2dpbGp1R2NkZWhOVXR6bjUzTGxmS2xkMmVpL0F4TEhXTlIwM1VKUnFEM1FLU0xJc0QvNlBHWTJQVlEyTnJmcGl2WGRSV0hYcmRkMXBMSEZES1c4MjVNY2pSUzQyckdxdjEzNTR4K0ZaTm5lMkQ2Y3NFdG41TDdKRlNTYU1zWTJUNWxUbmNTVkhQQitsWVdyZU5OZnRwTGEyYlQ0L3M5dXpDNW11V1Vsc1l4NVc3QWFRZFY5NmIzMFJ0U1hOeldsNTJWbHFsdGRubytuUVd1bVMzRUJ1cmJ5REJIS20yM1NKRkFQWEdNZE9vclF1ZFUwQ3htYTVrOHBZWkQ4OXhIRXpJWmM0QmZHZHBJUFg4Njh5MER4dkRaWGJhZGM2QVd0Q3pNdm5TcXNrajlRNFVranIzN1YxRnhxV3ZXQUxUeDZjWUdrSm5XM2pJS2J1Y096WTRQVGRTZWoyS1ZXRUVuZUx0cmJXVFYvTTlIMFRXRmUxZFJiTmJ4U0ZuaGxVSUk1aWUrQ2ZtQTlUWEw2aTEybW1tU3ppRXNZa0gydEJLR2M0N3Jra1lHZnBXWm9XbGVIbWxkcE5UaGxZeDVXRWZPa1JrNERzQ1NNNTZrVkN0MWR3cmROSEZMZGVkSVFGZ2hWRjJOZ1kydHp1SjV5T01VbjMzSWRTVXFjWXlhMVRTczAzK0J5Mm1TZjJZdHpOZDM4c3R2SVdScmFYa3hxVHYrWnVyTjZZNm11Z1crOEo2aWx1OWxMSHNuamRmbWN3cWpKMUxBOGgrY0hHZVRVUzNscmZXendYVmdCQktDVVNhTExxVnp2eVJ5cHlCZ0FkZWxlVTZkcDF2S1kzRnMwV20zQ2xJWVNER3l5QWwzWm14bkRESlZqK05Qek1veWlxTHRhVm4vS2RoL3doWGdFWHJOTGRYRUYweVJtQnA1dCtHSzR3cWRTQWU1SE5iR3BmRDdVZFkwNjNqZTlXZC9QM29YajNPTnVQdXJuQVU0NkN0WFNkRzBlYlJKTG0wMHlkbThrS3FSeTc1U29PNzVDMkJoaHlPYTlGMDZ6dnZzVnVMek1jY053QkNQTDNQNVJBd1cyY3F4NzgwN2RXZHNMemxHVFRkb2U3S0x0Wlg2MzJQQ3BmQ2Q1cHVvcEVOU3Q0dCt3WEVOd3ZtS2pQOHFoUTNLZ250WHMzaHp4SmJ5YWQ1ZG9JWTVyZGZMY1JxckJuQjI4OVF1V1BDMHkwbDhORmJvcEdraFJvMTJTeW5KWlRsczd3VDhuM2dhOEMxSFZMZlQ5WFdVNlRaTUVqTTYvWnQ0bGRkMzN5VndIM1p6a1ZTVjBURit5YWNaTFZQYnR0dmJjNjNWZkUydHZkSThUVFllTk9JNHc2Yml4SlhrNERxQWZiTmR2cG1wU2FoWUxLYnVkYlpzdTl4RG0zMnN2R0pCenhrYzlxeHRHbTBGNHJwNExTU1BFVVVpQ1NGcEd4MDJzUmpkM0hyVW1xNmxyZWx2YVBaNlVqMk03TzBsdk5BZk1icnVLUnNlZ0hUbkJwYVcyMU02VTVXVGxPVXI3MmQrdHRqc3JEeEI0ZnY3V09PRDdYY0t5U2JXNEt6QkJ0Y3E3OWV1ZUtvNnpwTnJvOWxMSlkyenE3QVJSd3d5aUZaSFlnWkFPUUQwK3RjdjRmdjlBdXBwRWV6dDlQdUlaQTYyZHZ1aldSV1FESVdRWVVIT1ByelhwSzZOcElqZ1c2Q2llSWsyOGNrKy95aDFDcnU2ajBKNXE5a2pzanpWSXY0R3ZzdmF5L3pQbnp4TGRYbDdwaGhPa2llK2hjQXdYQUl3SCtWeU04NHp3RFhVNlNzdW42SEJIZGFYRnBma3I4MXhHVldBRmZYY1NSenhpdlFOWTA0end6TkxPMFFpK2ZlckttOUNPQVdKLzFaOU0xd2RwcHR0ZkdPMnV4cHM5cThrU1NIN1U4aFlyMGRGR1FDUDFxVzE4em1mUEdmTExhVDM3OU5UdExpZlQ1SVdtRjhza1FTUFo5a2JBTE9vQllidURqMHJqOVpzaHBjRWhqbThpMW1pWlo3cmNJNUdKT1ZYeTFQUS9uVzM0ZzhEK0Y3TFNaWWJkYnZUNG8yWjVIdDNMUko4d2NzM1hBeDZmaFhqRm4vYTF3a2t0akRhM2VoMzdDRlJLWFpubFQvV0F2MVYrNEI3R21uYXh0VXBUVXAzVWJKUFhXNi80YzlGdS9HTTlsYTZlOTAxbGMyY3lrUEx1TE1NOEF5OGNEQXppcSttZUt2RCtxV1QydHBmdUVjWWEzT0p3eFBKSWNuOGgyckV2ZkEybTIybWVkSm84K3hJVldTQ04xY2daNnJ0N0RyazgxMEgyVFFOT3VyQmhGTlpSNFpWWklRRWRlRHVZcUNBZmVwYjF2YzVKU2x5NjgxN1dYTnA3cktvdnRaczdEejlNbm11STVpVmtCS1loS3JrN3U3WUhyM3JLdHZIMXA5clcxdWliVzRsVkFKSWlzaWxTT3BQOEFDMkR6WGJYVmlMcVNHNHNOVXQ5akRkSkEwZTFKY0g1a2tJeUczZXRVVjhQNlJKcHlhZGVhQWxsNWp0a29SODZybVVLR0hMRWp0MXhWTHUzcVRSVFRsZVRTVmtyTzY5ZXA1NUhvV212ZHpYY0Y3SmNUS0JJNkVia2NrN2NsQnh0R004VjNiVEpvR24zL0FQWmNOcWJseGJsWXlPcGM3aThoSjc1eGp0VzE5bjF2U1dqRmhaV2NsczhSWGFUNVREYWZsd2UyYTVHYTMxS0c0bHVwcld5akxPa1QzRVVoS3VTdVFXUnVtRGtIUFdra3I2YkVOT2pUY2syMmt0MTArODZkTlkxcDhyTnF5UXVZa015VzBmRVpQeXNCdUpPUVRuMzdWdy9qc0pIcUxYSjFwMGFZUklxZ2JIQjJjaG5IQjNEbkZYSllGZTFzditKcFpTUEhLV2prTWV3eUVZeXJIakFCNkhzSzFkZXNJYjBXcTZoSFpYTGVZV0t3TVdrUU5IdE9Cd01ESEpOV3Qwek5TbEtsUG5scGROTk8vd0IycGsyZWgyUjBvWE1CdVRjVzI0dUptZjVoenQrVUhCQnpWWi9FZ3M0cmVkYnVlTzBtVHk0eTlvak0waXR0a1ZzOC9LZWxkcEJidGZXeVJXMEUxdUl3QTVWOXFzcThaWURQMy9hdUsxRzM4RXdRM2EvMmxOYmVjdTFtV1E0TzRoMUpWaHdFSTU3K3RKdTRxYmsxQlhzckpLUzB1L0k2U3kwL3dqRlp6M3phWk5keUtqYkZqQWRnZzVKMnNldnJqdFZ1MXVOQlcxdExtMnNpSTRvZ2VJOGtJQjNWZXZiOHE0TzMwWFNvSkl4L3drK0x1T0VlUk5FMldtM3RnNVFkQUFlbnBYcWNMM2hqZ3Q0OVEzeVF3cTl4YzI3TEVTcWRXWldCNEFCemlwZTNrZEswVUkrN3B0eXBPL29jdGM2Zm85OXFNWnZMT1ZnZVlSZ2pZR1BHTTlpSzJMR3dXMDFHMHZMZTZaenU4b1JIbEZVSGFVR09oT09sUjNVdXA2dFlHUFQ3NWttTVRQOEFhSm9oSUgybjVHV1FmZHpudDByTjhxUzZKdVp0TmtqdmRvTVhMUlJ1MGFuQko2ZFR4bWxxWjhxU1R2ZDgxMDlyUGZwY3UzRm40ZXR0VHZKcDdHMjJ6dVhFcmM3bkorWURHY1lJNlVWeWw0OFYzWVdOdmZYUDlqM2NQbU5zdFpmTVdSSHhsbURkRG1pbDcvUTZtbC9QVC9BM2RKaDBHUDdSSmFhdE5DOE82Sm83Ui9PMkl6WkFLc0hia25rTDB6bXIraWVJakFVdEx1SVhjMG9sbGxsbGtqa0NxblFSazR4aGVYSDByaXI3d1RveXZKTnAzaGlJekNObVM2Z3ZSc0h6YlFjcmphNmpnNXh6WFh5dkhLcFZySjVOOEVMTVdnOG1aYmhTQnU4Mk1IY1Rqb2Z4b3U5a1orN0dyN3NtMWE3bEpXMWZiVXVYNThLV3QrZFFodUlXbGs4NGIzbVNLTUJqOC96Smt2MTlEOWFzYVRxdWg2dEhicFlTc0ZobjgrTFQwbU1McmdiVElqamR1VTU1Sk9DTzFlYitKUEEvaDZiVVlKYjNTWHV5NlJxR0RaUnBoZ05pS0pqdElJeXdKNjlhN1N6MDZ4WFVwSUlyYVNCWEJhV0sydFBMV0V5S1U1QVloMGt4bmJucDBwK2Q5alZ1bENLNVhKeWNyTmN0a3ZSM2R5eHFtb2F6YzZ0WVJXOW9oWWd3eWp6Uk5DUXJGOWhsVUVpUnUyU1FLME5XOEMybC9lQzlsczlZdFdnQmtGeXI3SFZRb1pVVlUzTVFNNEhHUmpBNHJ6alU5RHR0TXQ1SXRKdmJ1MnRnRU1pMjF2NWpHU1FxUUU4ejVveUdCem5PUFd1VThQYTc0cm0xZGJLYTd2TGlHN2h1SVpybUdBaVpKSXdkaHkrRkREKzhPTythbFgzTm9MV1RVdFUzcmV6c3V1MXRqMHF3OEs2VmVYL20zT3FYYlMya051ODBzMG5sQ1JFWXR1Q2tBZ0wwREU4MTJEMldnNlFpSWRZRm0za1NDM2tpbWpjL0tQdmxuRzVud1JsY0Q2MHR3YkM4czlQdkw5WVkyczFlM21rbWRtbDNTYzVCVTRBQkErWTlLNU9PNDBhUFVaN2FIUkMwMGxuR2hlZDJOdktCOHlKRzBtQ0pHM0VrRGtrVW05TDIvVWlFNGE5WGJSMmY1ZENoYjZWb2VvV1ludVZ1Ny83ZVVaNUx1NldMekpGTzBzSTFCWXFUMUZjOVlYL2hPM2hacm5UMXU5UXV3aVR3aVpvRUNBN1czQmgzeDFKNzRGZTJhTkRGcHQxTTl6ZGlPZGJjU1NXanFpdEVuUWJsRE1WS3QzTFo3bXVmdVlmREY3TklzMnQyYzl1VUVodDdoSEZ5cEhLeUNRa0ZGeDBCR0RRL0x1S05PWEsybWxxNzMyWG1UZUhaclVYRjNhMmVtM0VkdTBSVkZNb1JCZzhxQUd5MjBucng2MDk0YjVMU3d2cFk1SGlTZFdBdFh6R1FmdmJtWmh0VHZnNXFyQnBvdklZRkJ1bU1iUkVpMmhqQWtZRU1wWmpsZm1JM0VaeGpBcld2dEx1UnFGb1pOVm10bW1Od0VpZTNRK1l1QXVEZ2xTdU1uSkhQNFVvNkxjeDVYSkxmUzIyaXVaT3JSM0d2d0piYWRGRGJ4amRLc2tzSWRnek5uYUlKQUFTK1RnNUpBcnM3TFFOTGpIbVhXajZiZFRGSmJlUm9KQ2tubE93TFBMR3A2ay9lQzF6MnBSZUhqSEk5M3F5cXNzdXpjUjVrSlZnVnlwQUNyZ1l5Ni9nYXc3UCt3NE5NekJxOHNyaTZrZ2JOd3NMYldIelJKSzJTK0N1NVQxT2V2Tkp5OU56cWczR1RlMTE1SGNSMjhzb2lGMU9sdkZKZUZNSkE3eHN5RGRsbUFBUnowSWJJUEJCRmM1cmw3NEtsMWlTenZ0RVl6RGNVKzlzbjh0ZCtXaHl1YzU5ODF0YW5hMnEydHJKTkpjUXBMQy9tU05xRHM3eE9RR0tOSG5EQWpBQnllMWM2SXRZdXB5QWxwTnBVYzJKUHRYbXd5TkNWeUdUZW9BT0IxUWpCcW5leG0yclJTU1QzZDlmUjZtL2NMcGJXc0M2VlkyYnh5eEtFVnpnMjBRd0I4Z0pZNDUya2RUeFdSOXFuWVJtRFM0d3NFYmhMbU9CdkxqVWdnN3R1TWc5K00xblIrSDlPbVVIVHRWMGVLUlpRWlpyWm96THQyN2tPRzNGbUg5NFlKcWQzOGRhZWh2SW5zOVNodkJML0FLUElUTDVwQzREY0FmTjJJSE9ldEszNEV5VStkM1RTZG0zYit1cHlFVXZoQUNJMzdRd1NRVHNxU1dEZVMzbXN3QzVEQTdXUFVBNFVLZWNWM0Ixb1F5eUpOWlRtM2dEUEVrOGtNYnJOSWRwQk8xdG80em5uMUZjMUZKcnpXTWhsMGFXMHRiaGtUN0FiVnNxR0FEQ09WUDRPTWc5ejFyMExUWXJTOHVyZlRvSnBranNzZWJiM0NlWTdrRVlIejVKSno4eHlldkZOM3R0dVRacWFqRis4bmExdC93RGdISzJuaW1PT1R5WllyYlR0NWRyUU9FaU1Ta2JmOVpGendlYzkvZXVaa1NkTHpVbnZwWXBFaFZobTE4NXl1NFkybFl5ZGhJNUg1MTMwbW1hTE5jRzRzNzlyV2Z6aEpMYXNrYzhDeDRPMkxrSFB6WklLMWphNG1zV2NzdHZIb2QzY2ZhM01rczBEcis3WmM3MXlnSkFZSEs1emlodDdNbDBwY3F1K2ExMjJub1U3YTNlZTVoSTBpYWVHZGhpUDkxYmVZckFNQTNtT1hQQjRBSXdlY1ZOSnBIaHE0MVNVWGx2ZTJ5V3ZsUEVtL3dBNHlQMTJneDVKd2VDb3F4ZlFhZGV4YWpZVFd0M3BwdkZqVDdUY3lKNWl6Umpjb2pMc1Eyd2RNWUl5ZWErYzVORCtJRnZycVd6dll6NmRDKzE3bDVrVlhqVUJwQ3F0OC9tS080SEZOYTMyK2JONlZGeWQ0T25GeHUycE8xMHUyMnA3bnJQaHkxT254eXdlSFJLTnhKR1pWbEtNMlJ0VjhGYzlTT21lbFNzMmpTaXp0VnU3eFpaWWZMZVlUQlp2bFBHN2NDQ2h6d2NBZTljYU5UOFU2WGV2Y1dlc0xjeHZjTThra3M3UlJxckhPMlBBYjV2VEdlSzZ1NHU0NytXM3VMOUlaNXZMTWZtbnkxZTJJQXdQbndYVFBLZ2NldFM5ci9pYzgxRG0wYStXdjZtN2EyMTdCYVNOWk1MKzBqU1F0RGZSaVNVRlcya0E1ZFFUa25PTVk2MTUvd0NLNS9FME5yYnJwSDJvWFZyY0Q3UkpMSUZnamprVWJWUXNWVWlQbjV2cmlzYld0T3QxMXV3VllybTJsa2lXVVhLVGVYYlJTQW5LU0tBTnVSOTdQcjN6Vy9ISkxad1EybXZYbHY4QVpqTkVrRFc0a1I3ZU5tMjdTTGxNTXVEd0ZCUHBUVGFSdkZmREtNWXZXL0s5VTlkdERJMHpXUEdtbnJCRHFGaUJIYk02VFhXOFN4c3BVbU9RQU45d2tnSGptdHE1YTAxNjRzWlpqYWlielltR1N6d2VhcTUvZWdCTnpZNEhVQ3RpOTBEd1dseUwySzR1ckNHVnBJR2RVS1JSeXdqbmVnS0t1U2Y0K3ZwVWx4bytwU1dkcWRMOFEyTjI0TVNJMCswZWR2SkIyak8wajBYSDBORFMzSnJLYW5Gd1VZcHZaYWI5dFRZWFR2RVVPbkczamowcVdIWUdrQkFpaVFuNW14SW1TRGc1QjQ0cnp5S3oxdTMxcEhrMEs0aGlpWm4rMmkrbHVZa2NZTzJRWmJBUDhYSFRtdWkwN3hicnVuNnFsdGRXRnJJNGs4azNQbVJ4TkxKR1NNTkh3ZUZ6aHU0NHhVRVZ0ZjZoZHlUVHdQRmNHYVdCdkluV01US2gyN2lZZ29BUEdBZWFwcittVTVKVSs3a3RQZTc3YmRUSnU1NHRlMUpsdTlEU0NSSEcrWnJoSWtKUnVmS0tZeUFCak9UeDJyS3YvREFlL05uRERwaXcyL2xsVzgrZFVqVnp2QUJCWXRrL3ducFVQalh3ZllYV29FU2VHTHB0Z3g5cXRwanRrRGRFa1Zkd0RnODg0TlNXTmg0Y3Q5VHRMRWtXMTNIRElaNFZtYVVTT3JaVkhERThxUmhjSEJCeldpaW1yMzF2c3pyZEdNTVA3UlloOC9QL0FBdVZwN2IzWFF2M2Qwa1NJSlo5UGhLeGsrZEEwMGE3Z1NTREdtRHdBRHlNR3ZMYmFiVTVFK3pKYnhheFpyS3M3U3N6S3dsSjJoU1pzSGpQSFkxOUFhZ2ZFRUdrSzJseTJpMjBuekw5c2xPRmpQM1NHQnprbmdBMXoxckJycDBvUS8yaThTQlNaa2MrY2hXUkF6Q01xTWxnVGdmcFUyc2NNWnVLYlVOWDNiVnJlU1l5Sy9hRjlPdEpyWkxpNFpabGpobHdwSUM3R1JsakJCSVVETEhyMnJzOUo4UjNVN20wa3NMZ3hTQVJib21ZSmtnbnpXVndOcDdCUjE3Q3ZQYld4M2Fjcy84QWFwQ3NnRDdTeEpCNEtoZHBMRG5rRFB2V0hyekNhT1AreldTRXNITThpNzBZcnM3eDkvVEk2VTdkakdsV2sybmRKeXZ2dDhqMGJXZEs4TWFvcTJNdjJpSXh5Z3pTbzh1MUVIellEQTdZOTNjNEp4a1ZnUHBGZzFzc3NzOFVlTGQwaWt0NTVYWWhDQ0hBbEIza2c4am5kMHJoZEJ0d05FVzFtdUxrU2w5Z2xNYmtzVlBHMFNBQlZ4Nm5ucWE2R1Q3ZjlxaVM5aWluRGtxa29oRW5sRlh4dWZidUh5Z2RCMXErVTZaemxyRFJxTXJyUi9OaTIwZmc1b0k1WjQ0amM3b295YmFHTXRLbzNLcU9vQU8xeVBtd2VUaXN5NjhOZUhiS2E0bnU3bVdGNDJFYVFDVFlvVnVFQXdyTTVBT2NqOGEwcGRPaGlGNDF1ME1DUmhVbVVxOGNqaVRxbThuSTlkdlk5S3g3eUpyWjdsN3k5ZTBRQXJIQ0ZEc1kzNjdTU0dBT0t0MzF1YXVzL2RTdnRaMzdFcXhtM2hMMk56NW84dmNkcWhwQkVod2RpcGdFZ0VrakpKSE9LNU5mRVY1ZXE5bFp3SkxORzVMd3JCNUNScVZKWWt1RGc0N0hnNXhVMTVvZWczN2JiYVd6aTNlVzJIZVNLWkRnREw3U0VJSTVYaXF2MmY4QXMyTHlKWjd4MWlERldEdU44ak5zYkNxTUYrQVFlY2lwc2ltc09xYmZ2VGIyV3EzL0FESm83cnhMcThhdzNlalN0YkJkcUttMUZRWncyTURHQ0IyNXJSdklOSXVJWTR2a212TFlLc1RYVVpFTUlJKzZ5NUlBSFQ2ODE1UmYrTDRYTUNSWGQ0cktxb0M3dWdaUWVXSzR3UGNZNUZXV3Q5Vml1THU5dGJHUnZNYmFOcENxY0RkaFdVakNzdlFFVmFqYTFybS8xZXNtbnl1bGRlNnBYV3Z6ZXhuYWpxRmplSWZzMDBubVFGd201VmpWaWVXR1RuY3ZZZDY2clIvR1hpWFJMT1dHYTFtazA4RVJLSkRuYVdYY0JIS01qb2NnZEs4NDAyNnVKUE9aVlMwdUVsTWlRM0NGOEZSbjVSd01OK3RkVi9hV3FUUkMwdkV0RnR4bGl5S05yTzM4S3BrYk1BOG50UTZjcmU3SzBsMVBxTUxYK296U2RPTXFlMG9PVm12Tk5hUDVIMjM0VCtKZWo2eEZFaTNZVzUyQVBDL3l1RDN3TzQrbGQvcjNpOXRNMG1XNEZwOXJRWVdTUGRnYkc2c2VEeFg1SDZ0Q0xhVm5oYVJvVklLdWNCMXozK1U5TThBMTZKb0h4VDhRNmY1YVBNTHVFREcyVW5jQjdNT2Z6elJIRlZJcEtwR3o3clZINkREQndyVTFWd3RUbmkvc1MwYThqOU8vRHQvNGUxclRZTHFFVE5DMlI1THpPNktWNmpHNGc0L0t2WjdPL3RvbzFTTlVSQUFBcWdLby9BWXI4K3ZEdnhUOE8zQ0lna0ZteEovZE9BaTVQOTBqaXZlcmZ4RkhJb3c0SU9DQ1A1aXZSaFdnMWROTThpcFVyVXB0VGhLUHFmV0VXcUtWNFBjYzF0eGFrcDQzWi9UOEsrWDdieEFPT2E2U0RYUndTMlA2MXVxbzQ0aE5JK2xZOVFBd2ZUdFZUV0dXKzBtN2dQU1NKbFA0aXZHb2RjWEkrWSsyZmYwcmJYVzFZNExkcXQxRTAxM09xRmRLU2Q5dFQ4M29MMmV6dG50aUNKdEx1V1FyNm9wUDgwTmQ3ZDNrZC9wektraFRjdTZPUUhrTU9WWVlyRitLSzJWdjRnL3RQUzVoS1pBUmN4cHlHMjl3M1RjUFN2SGJMV3pFb01EZVpBU1RzQncwWko1R0QyOXUxZnpUbnZEczZHTm5PRWRQYU9kT1hUWFZyNVBZL3B6SStJYU9Kd1ZOU2w3eWdvemoxMDB1ZnF0OEd2RzNoZVRSSTlMaWlpc3RRZ1VDNWdKRzZWditlZ0o1ZlByVzk4Yk5iOFdEd2krbjZCcGQzZDNOK1RGSzhDOFF3NCtiSjQ1Zm9QYk5mbEpKcmVsemJXa0lWMHlVYmxIVSt4R0NLMTA4WWFxSTBIOXNhbS9aWVJjeWZObmdEci9LdjBUQWNWVGhoWVVxMkNxYzhVbys0bForaDhEbUhEMU40bWRXbmpJY3JiaytkN2Vva253eDhVUXdtWFc1SU5OQVFtTzBNZ2t1NVNPaXBFaE8wSHV6RUFWNkkrcU5ZZUg3TEdVdFZZV3p5cEl1WXpzNUlEQTdzSHJqOEs0MjBhUEFsdkoxaVNXUUs4ZUNTVzdtYVhuYU1rZFR6VlMxdDlOc28vTW1rU1JyeVJvWFdLV0s1aTJINWxSY1pBMmo3ckhMQ3B4R0RubTFlaFZ4ZEJRcFVXNVU2TGQzSnZyUHA4ajh0emppZW5sMkd4R0Z3RmQxS2xWS05Xc2xaSmRvZjVudEdtYWxxLzhBWk0xdC9hMGNrYVd4Qm1uaU1pekJEd1I2OERrZGNDdVcxNkI5TzFGYjk5T1M1WklQTXQ3NUpYQ0t4eVhRaFNRMjFXK1h1UitWWmpXVm9ZV21oaHZvb21qZHJ5TW1OMmJ6ZUZ4SnlDTWRXeHpVa2VoeDZuZk5wOXBjM05wUEdZYm1HN2psOHlNNUc3NStGQ3A2cjFCeFgxdDMzOGo4SmhVazVxTG5MbWQ5ZVo2WE9MMG54L3F3a2phTFFMMjRuY01Kcnl6TFRFZ3NjWkczYU1aNTcxN3dMYnhUcTluTkVibUtTR1JXUGtTVENCb2QyTnZ6SEorZjdwQjZjNHBVbWwwUFVJWVhTSzNkRXkwMlpNRnBHdzBvTEREWkxjNU9kdlN1VnZQRHZocldOWXREYzNzdHRMdllRdFpXWGt4eVNSc1dFanRqYVJ6MTZIclRmTDh6cVNwNlJqQnhXcWxydS9tVTlKOE8zaVhON2JHRzl0NVpFMnh3M1U2ekdOV0dDeWlmSXlQWSs5ZWt4V09sM2RyOWxtdFB0ODRkQk1iY3ZDVThyTzl1RGpKSXhrWUJhdWZqOEthWHA5OWNOTnJVOTBpSkkza1MzU3lKRTA0UFFuNWdNZmRJSDFyYXROTHV0S09uejJ0dENxT3FwTklwTWhRSnRHL2FoUFh2am9SVDFTV3BDZzQxSkpybXUxcStuUVdTeTBuekZLYWhLMGNzaitjbDFKSkFMZUtNWUdVTzN6Q29PQTJjSHZVZGw0TjBPMGorMVdLVzdxZ2o4a2w0MlB5OFozeUhPMWgwQkhCcWZ4RFl2TC9ha0UybWFiSmJ4eXBkeHZNN29oRW1WZkhtTVFYT0FjTHhudFhOMytzYUliZUNHM1ZMVnd0dkpGR2lvcGFUYmxTVUJaVkpEY2JRQVJ6a0dxaXRQNlpwVWxUZzNkV3Y4ajBMeE5hVzBGekNyeXlXc2MzbkNPRnJrUnBuZ3VGQnlzbTdwZzRyazdtQzJndUxHRjlHblMxU1JnZ2dsRWhFampJamVNUGtLUU9GSXdTT0s2RzhPdjNmMmE1K3lSRUJ4SW9Gekh1ajJZTzF3NUcvSkdjQTVQclZUVFk5QnZUNTBGdTBWeGRFWE4xOGlPZmxWbEtPQ0NNQWs4citOVHVjOVNFWE4zdWsvaHYxT2lzcG9aSjRQN05pdE53S1J0Y1hNWVRjQWVZd1YrYjVUMHlNanBYbUdxdzZSNGliN1RkV0Z2TGN5TWpOQmNNcXdKRUNWR3hsKzdrOGJnT2dxN2QrSHRMT3NTM05vOXZIS0VqUnBiVzdKbGROdy9jdUhPRjQ1ZmFlZTljdmVXTjdvMDF6RGRtK25ndmk4Y2NkcHNFUmxmT0dlT01QNWJBRUE1NHh5S0Y2NmpUbHBHTGs3ZGxwZnNySG9lbVhwMHVTR0s0dk5LZ1F4SkZOYkc3TWtoRHIxajJERzFzWUNrWjk2M0gxRzBndXBCY1dDUVFUZ2llNW0yL09WWGhsT0Q1b3djYzhpdkRyclV2aDRXLzRtY0QyOTNFbTRsWWdwRFlBRWF2R0NXQzhaRFpKcnZQRGwzWURTN04zMXlHSlZXQ0l3M0JBOHhnZHJFSkx0T1dISUo1NzVxRXQzZEdzZVpSaW8rNm5zdnozT2d2YmJTbzlVU1ErSDdDNTArN3QyRXR6Ync3blhJeDgrd2JWWTU0QXdTYTZ2VS9EK29ReHdQRmZwSGJXN2hUSE1GVVlad3dZTVFkdVFjWXhrZEt4cFJaV1VTMnQzcUtHS2RDbHVCZGVXV0labWJPMEZDM0hMRDJybklyYTYwNjB2WklYUzVzcDRKVWt0MlR6MkNZeUczYnNZWU5qYmtVNDdlWkRiaktYTnFtcnRyUm9xWDNoM1hMT1dlOCsxQ3p4SUFmSnQxdXRpS0M0QUc0WS92RTRxL1pYTnpwMFVabDFxUFVER0UyWFVqeFJGWXdBUUNxTnllK0FPYXJSNlpEZmFUT3oycHNvMkN6ZWJHSHRXZ2tCRzBtTnM1QUM5QWNaN1ZORFphYWwzTEphdTgxeE9IYTQrMjI1VlVqVHFHazh2a1B6amtEdFJHOTJaUFdMVVZiVy9tZGpxdW9zcDA1YkMzUzhJQmJGdXUyTkdVN2dyeHFNcURubHMvV3VadlpQRW5pS0xVN0FhTnBsaTF0QUJGUE9rYk5HZVQ4cW5QeWNjUDI3VnplclRhMXNWN2FXNGdWUDNMUndxa2tFaUtQM2FSTXhWMVp1T3B6V1pCcEdrWE5uNWx4NGFhMEVnalFTTmRlZWx4STR3d2ZhK0dUUE9PaFBGVTNyNm05T1NhdTNwcGZ0NkhaNlJvRnpESGJUdFpXZHhHcnBnMng4b3lPQ0FaWFAzV3dlUW9QUFhyVkhYUEJrZXB4eUcxc2RQODltYVNaL09rTTBySWR1UWd5ZHBKKzRPQzNKRmNqSGU2dGJhbEhEWi9iSGhobUVCczdxeUFoMkZkbTJJb3dHNGNGY2tZcnNZTkIwWFVMU08zMU9TOGh1SVozbUwzRjBCSXpOaFNRRXpsY0xnWXpnMUxkckdjSXhTZG5iVHZhKzNXeDVWZjNWdjRhTmpkTmZYZXAzOEcyM2ExbXo1WlhKSlJXUlJ5ZlFpdWlzUEUxdHJXb1g4OCtqMnZuN3dzY2NpUmd6S01NSXd5NFlrWTRZOVRYb01LaTFtaWgwb1hkN2F5K2U3VEtGVjBsWnVaUE1MZ0tjTHkyT2E0VFdMZncxZHZFcHZjM0tONVNRN3o4N0hERE9RZDU3OVFjODBrMTArUm5VbEwyTzZUbHE3YmFkdWg2Q211UTNWby9rcEdJWVpmSnU3T1dWZHErWU9RUzI0bGxQVSsxY3pwMTc1VVZ2WmFuZVN3Q081SlVmYW93V0Q1RzBTRDdvejZqbjJybmY3SGkxRFhydTZ1RWxhSjJFZmxUenNrVXBkZHBpNGpERFBYZm5HYTZ1NjhQYVBGRzhzMW5ORk1zV0I1ODVraGZQTE1vRzRzUUJnc1BtUFVWS1Q2bUR1clNjcjNYYlN4dWFwcFdsWGxpR2oxa3hXNmhoTElaWW1SSlc1QmRDU3JZeGduR0JWSzYxK09HOG5hYTRpdGJpTlBJU09hM21uZ2RKRndXSlJlWXp3RUsxNS9wcmFGQloza05yb3JlUXlFcGZSQTNQbHVCaklWd3piUmtnWkJ5S25pdlBHZHJMYWdYdjJuUDJjTVd0QlorYWlqYVk0WFk1YzRiOWVCV3FmUks1dHowK1ZTaTFvejBWSmRidTdxT2RkVDRmQVMwalpiUlhWQUVkbmQ5eDI1NXdNWkI0NXFycldveGk5aHVubnRXMzdZcnVKMFNVeDhuYXNUS29aaVQ5MGpPTTE1bmVhRnBGekxjbTRrOFFSbVJtYTVoTHFrRENOZjhBVUVqUHlJUmphdk5XdEgwN1I0TGI3UHB1bDZqYUVNVlM0ZDFsakVnNUNvck5nZ25qcGtIbWh0WDZhaE5ybHNwM2sycnJiWDFaWTFLNmh2Wk5HZEwzVmJhSlp2TlQ5d0dUeXRwM0k3YmlkbnkvT0crVWNrVjMxMXJGbmRhZk5hM3R0YjNqUkxGNVR5bVFQSUhIQlVvQ1FSMEdPSzRFYWRmYS9CSkhhR3prdmJaQ2pDSjVBeU0yY3MzbGJRK000SXhuSEZVSXJieFBwRWVucFBZNmFzVStmTWNKSnY4QU9pZGNzc2JNTXNWTzRISXhnZzFkOUdsMElYdEpRYmxhMTlXMXVkMXJNMnZRWDdRMlduUnY1UDhBcVhTWmkwempoUklwMllUc0dIZnJ4Vy9wR29UM2tqSmYyZG1sMnRxN1d4andzaWM1STJjS1NudWM4VjBFYmE5RTF3aDFTQzR3WDI1Z0RtUHpFNDI3Z0NRZU9lZmV1Smx2OVhTNWtqL3M1YjR3bnpXVlR1a2pkVjNaQzhEQjdIcGozckJKOU9ocEtWbkYzZXIxVnY4QWh5bGZUYURxY1czekwxTlE4MUxvUGJsOSsxVGpPMEZnRjljZEJVMy9BQW5XaTJldm14WFRyc1hzNkFpV0szOHhYeWVDTUtNWXgxTmJ5M21pM05qRTV0bzFheWpNazFraE16UnNRdnpneEVGWFVOMEhKNm1xK29XMzIyWWFmQmFUUVJTc3pSdWJqTWp5UXJ1M0xHNUxOdEhJR2ZxS3JUektpMnVhenZmWkwzWGQ5OUdkSnFPbzJHdUNhem04K09jeGlWaTBiUmgzeUF5Z3N3NUhjZzhpdVNrMExWRmtzTHUwMUlzSW1qZ25VUmJUNWF5Ym1JQ0hKT1BrNTRQWE5PdVh1SUlML3dDMHlOY1lnWlJicTBiTXdJQ3I1YW9BNTY1NTRIV3FFTm5ybHRjbTkweTBqa2pFUWIvU0pKVE9UR01lWWQ3RmR4emdnREk5TVVhMlhZTDh6dk9EYjBiMDEwT3lsOHU3YldDODJwTEFaV1dLT2FNdGJBRUE1Q015c0ZHY0w5M0ZjREw0VzA1THU1bEdqdmZXMjE1WXQxdTd0Ry8zUExQbUZnQVJ5RGpOYW1uZU50ZTFXNWh0NVBEc1VLU05MQlBkVFRveW1TSTRBVlFjdDFHTytlbFVMdTh2ZE5qdnRSdXRNdUptVzBpTUp0TWdGV2ZEU2ZJK1FTZTVIeW5yVjYyTG55dWNWRldrOWJycGZYcGM0WHcvcjlqUFpmWUxGWTlLdnZQalJMZStoWWVhQSs4QklWSzRPYzdUNkd2WWJXZlg5UmgxRjVXZ2hTSjNZcEFiZ01ycndTRE1xaFBwMDcxNS9ybXJhbnF0cS84QWFscEN6TkxFMEVhMnp2ZG1PTWZjWndDNk9TdU05dTFYUm9tdk5DMGNsMVpXMWdZV2pGdmNMSkxJcUE3OHloenV3TTV3Q2NBWnpTc3JMM21SS2RPTW1vUWJqcmUrL3dCNTExemQ2VjRldWJTNXVnMS9kM0VhZVRpMFdTNEx5RUtDM2xnTHVHY2JzNU5ha21vMnVteFN2ZjJtcFF0TVpXTWI3VDVtenFTSThnT0QwSlBGZVphRnBGc2JpU0xRdjdLVzdhQkdWNG51REZHVlBFclF5RWJzNUp6eml1cjA3VDljaGE5azFmeEpjWDhBalpMeUFXeW0xdUk1a0xnSUZ6MHowem1tNzJ2ZXgwWGhOUmZNbGFUNWJxKy85ZHpxNEpkSTFoV2I3Ykg1eXQ1WjNUbVJvb2lPRzNvRjJPRHdjY2U5VFM2WmRSU2llMjEwTE1Nc3B1UUpGTFI4bFFRb3p1QXdmUVZ6dmhHVHcxTFp5RFNkV2dkbzhHV0paTnpSUkFnL0xHK2RwSFRiay9Xc0tQOEFzYVRVTFdjZmJMNExNNkxEREdoanROemJuV1ZVd1RrL2VKNEFOTzF6SjA1S21uS0s1dDkydGZrZFhMcm1zM1UxckhkQ3d0b0pnKzN6SW1Mc3hPSFhNZ1hIKzZEejFxQWFQWWFWY3kzQXVvTFNlUm8xU1ZnMnllUWdqSTh6TExJZW1RU0NhenZGTnBGUGFSVFMrZWtGeHNVeVJTeUlJMlU3QVpFQlliaDZkR0ZkSWZETjdwUW1TMjBlRFU5Sm5LeVMvYVpzdUdjYkN5eG5JVkQxRzA1eFV0TXhoR1VwTnU4cldkN3QyWFIyTVNHL2tzcmlHM3U0SXZ0Vno4bURDWGpDN3k0QmRGeGo1VHdPU2E3R2V6Vy9nUzR1TEoxTUVydWhpVUtGVlNRVHZBLzFZQi9LdkVwbzdMVXJLL3NyYlVHMGk3V2RsWXRtTkl5R3d1MUR0eXZVQW5ybXZUTFB3czFscDhObmJtUHp3K1o3bVdZbVp2TS9pMjd0dTdKL2hISTRxbGEycHZRNVpVM2RYU3V1VmIzKzQ1Nit1SnRVc2J0UHRGM2FSd3N5TmJXMHVFdW8zVThFc09NbjdwWG5wWGtHZytGSnpkQ1N4MFRWbzRKVUN5eDM5eTVKRGphclJtTUZzSHZtdld0Y204YmFTSTB0NFJlcEd6U3ozb25VU2trbkdFT2ZsQTZudFZMVWRKbWwwNjBoYTBtaGE2VUxieTIrNTNpbVhPV01pYmNvU2VSK05adm1UWmhLVlZMa21uYlJ0YWQ5TmpvRTB1YU9lN2l0WWZzQ0hIN3RZWlhiY1J0RGtFa2Jjbk9jMWxUNkhiWHpYTnhlWGJUeVFIYXlRWWFSR2pJeXlET1F4SjVIUTFoWHR0NGhoMDZ3RTMycUtXM2VUZEliaVZZQWhHQTdzYzdpTWJzTHlEWGNhVytuM2RoUEpmbXhkM2tWZDBNc2YyamNqaGsrY0JjazlmbW82N21YczE4TGcxbzNicCtCNEk4bmhYVGJHNVFXN1g5dUxsbnVaak5jTTZOdWJBT0ZVRENqcGpnbnRYZmFOcTJqM1ZpLzlsdzJscGFYTEtZNWJxTU9zRWlvRStVRTRVWUdNNXl6R3Vqa2trMHE4ZXlzeHFjb2VkbnhjSUlrWUg1aTVrd1F3WG9NRVpOWWtsMzRlZFpJanFGZzBxZ0orK0tSTExPTWxTNVhBMmo3dU01d0tkMHRGTFFKU25kTGw5NXZXNzM2RVBoZlc5YXZsdjRMeXl2N1dkb2xFYnBHUzQrYmhsMi9lVnNjcXVjQ3NPTy84UVBlNm5iWFkwcS9rVU0wY0NLdHNtVHd6ekdUbEI3ZFdxekpxbXFhaHF0dXJOcFYxc01Ya1JXdVFteFFTUXJzUTJTZVIyN1ZyZU1Eck54ZVhIOW42UkRlaUVHR1hUcmo5MkpqYmticFVjdG4xd0RWV2VuWTNVVks2VnZqU1YzcDZYZXlOclQ3YncxYUY3aXpqc0Z1MzJmYVliZFVjRXIxS2JsR1FDZW81cnp5Yld2RFV2aVMyVzRzYnZTc1ovZWhRZ21sSXlRWWxCTEJpZUdPRGpPYWlzdkRkbHBzQjFLNDhOVHgzQWllYWFGYjM3VUVqYlB5cW5PY0huQkdNOTZzMk9zcmRXaW04dTRvcmxZb1ZWbGhrM0dHRnY4QWozbGJraGoxeDFwV2JSblVVRXBOdm1Ybm9ycnp1ZDVNZEcxYVJrZTVqbWNzdHJHekNTM01SQzVWdGpCUmdIcnQ3Vm1XQytKNFZJSGh5MjhtTXNrbjJRcVozVURKeXpZSlU0eitOV1d2YmU4dmJlV3d0L3Rxd2d1elhjazh5WmdHQ0lwWHlBd3pnNC9Hb3JuUXZFZXJhZEVzWmV6OHFRRDkySXdKZ3lkRWJKTEZlaFZxVDlUSndpNXlTaTIzcmZYOFM4dC9iM3JKblJ6WXhxcFpXTVFrRVRLTUJYVnM0VTlEanBXWkdMQkx4a3ROTmkzRzRhS1VMUEd3ZENPQ0JrS05wNlp6NlZjMGU2OFJ4NkhFdXA2SEplcEdxczYzUGxSTTdaNnhvTWs0SFFFMTJkMVBva2dlNUZqYXdOWmdaVzZRcTZTeVkyWUVhdGs1NXllOUphSW4yYmJYTk5KM3Y4TnIyM3NlSTNGdnBvdjVMYjdiQ2tVTjFhejNYMmhDc3drWEpXTHBsWThuSVZUMEZkQkxwM2dEVnBQdEZ0ZFhVR3BxVnkxbnZNZ2tKM0NYWU1qMkJQWTEyNjZ1WUpZR2g4UFNpN2Rwb21BWU8wbXpHMXpJL09PVG4wcm1yeVdYVFkyaE0xekNaZHJFMmUxNVZMTnVPMWtCSlZjWVBIT2VLcHkyUjBLcDd5VVhkSlcyYnRmVXlOWG44UjJWOWFXU1F6elJORUkxa3VRSlZkNUFjdkprWlhIUWdkS2JKZWE4NGtsc3JDMnRKcEx0VWsrMVhMUXdpVGdONUtESlgzSjRxSzFVNmpyY1pnMUM5bVJHM1JpNlJvNHpzYjk0akVBTVh5UnNWaG4xcm9Jcis4bnVBdHhyenNpenpMTEJORkRna044c2JaR1NyWUlMOXFTMDZtTGNZVDF2YStpZXFPV2JYUGlMZFJXU0NLeFpKb21MU3FUSkdXVW41QStSaCtNOERqdlhUUUo0L3RMSkwvV0xaRW1pNVEyanh5cE5HUUFWS2Z4REp3eEZkc2l0bzkra0ZqZC9aZzdPMFllTGVtSjFLa0l4d0R0WThEcVJ4WGkydjMrcTNMdzNWbmVUaTdqdUdlWlowYVB6STgvSXNlV0FSQVJuQUZGb25US1VYQnFUdEsralRzbGI3N25kUjI5OTl2bG1oMElHTzVsalM4V0tVeFBFeU1IWGRHR0tsU2VPQmdpdTlaTHlhN2tsaWlRVGZ2dklqVEFOd0FmdVNqSDNGSi9oT2E4azAveG40ZnZJYmU0VmIwRlYybVdaR1dQYzNHNUdJK1ZRUjFKem12U2JMWEgxQkRDMm5XMTdaWEEydUliZzc0eUFja0ViVDgrQms1NHBPNmRtWXdpb3VLbmVNdE9uNTZITjZ0WWVJYnV6Z3RDeTZiTEFnYVVCL3RHNHZuS0tCZ2pvTUhyaXVFMURVWFM3c3IveEJDOXhENVBtSk5FZ2N4eUtDaEdVQk8zdWNHdTkxVFFkRjA2ODNUUVRlVTZPN3d5WFJKd2cycXpTdWR3eDZBMWhhSEZESkk5MVlDOXNyTzRqalJVenZVckVlSHhKbmN1Ums1UFdyMjgvTWlidFVsZE5ybXRaYU5ycGZTeHg5dlpXV3FlVmROR1RJKzlZYnlHVWZ2RjVKSkI2ZStlUjZWNkZZV0dsejIxekRxV21mTFBiUmJKWlN3U1R5K2pLVnpnalArSXJUL3NtVzErMFBwOXBHbjJ1WW02anhFRm5UUDNvaEhuSlZqayt4cms3ZnhwZTZZYmY3YkF0M0k0RENhTkFvSUdRVVlOZ2tranNLTmVobW9VcWRXTDUzMVM1bzlESXRkQTBaTEtPV1BXVVhaSXFNcGN5QXE3WU1aWEhJd2NEQkhyWHBpZUlKSmJlNXQ3YTFoYTRnM0JZK1djbFBsSGxxT3BIQndSeFZpeWl2bzdoSlYwdHpDMGdIa3l5b0hpa2R0MkFBR1lqR0R6VjQ2eG9PdFhralFhUkxjR09YeXpjaUVPaGt6Z2dGQ1c3ZmU2R2pTK3hyQ255cHRTVVhzOUdtL3ZPWXRQSHFYbGpxWXQ3R2E2dUxLV0ZUbFNvY3VQbXk1VS9kSXlTUnpXTEJjenpSU3RIQkI1azBhdUkxa2JiSGtsWGpkaW9COU1lL0ZiRFg5di9BR3NkSnRaWHNIdlg4dEpaWmdMYmxoeXdiaE9ueWs4MTBtbzJ1V2dTNHYwQ3g3bGtnRnNyaVR5OHFWRExnWkI1QjYrbFc0NkdWVnVwRk5mQ3RFL1AxZGlyOWgxWllnb1EzY0Vkc29aWW1DUEh0RzE0eXVSa0JlUWVlbUt0YWRZUVdjVm90MUxkWEV5eGVZQnMydTZ0bkJZQThzQU9SMXhpdU0xL1c3ZDdjenhTWGRpMHJGRmthRXhwS1Y1Y0tjN3R3L2lPTU1PbFpGdjQrMTNTYktKYnY3USt6NVk3dU96TEkyMGNIY1NUajhPbFJkSTFTcFJuWlhidGRMNHRQbWRUYWF6NGQxVFU1TGllN25TTmNSWEZ0S2Q2b1FQbGFRZ2REbitsZGhkNmRwMnFUWER4M3VtV2pxb0plT05vNVZZWUFiQnhqUFE1N2RxOGJ0ZkdtZ1d0dmYzbXBycHNjazVoamVPSkpOOHJBbmVySXhJR1BsT2U0eml1bDAxNE5USzNrVnBhckM4a1phNVUvdjJrSHpiRzNqNWd4NEo3SHBRMmw4a1hvcmN5NWxOdDdOYmVmNkhVM054cTFuYlRTVDZla3p1ODZNVWJKa0FVRU9GR1YybkIvcFhKU2VJN0M4MGFDTzNTNktNMkV1cmUxWkVnT2NsVU1oeXJLT0IyelhUWEUycHc2TEpPMCtveHdyR1ptdUhqamwzSGR0S3I1ZUNCazhqQXdLNGJRSk5TZTVualh4YzBsbTVMT0lyTHkwUlg2bC94NHo2Q2pVVXJSaTlXdWFLNWVhMTNmdC93VGJqMDIxaGpRMmwreXpCcEdWN2dseTVKS3ZISUd6a2c0T09tZWxlUjYzNHI4VjZOYXJBbCt0OTU4eFZudXN1SWp0eXFweGtFSHA2VjdDLy9BQWoycWFmTWwxcUZwcU05bk5ocDFDUlNlVHV5d0JQQUFQVTlhZ3VZN0hRaGJXc3NabGh1SmkrK1czU09LMWpLNER0SUNmbUpPTW5taE4yS2hlTlNOa3JKTnlWN0p0NkhtdWdlSS9FeDFsOU8xNWJTUzBqaFV5eGVYKzdMSEpETVNNbi9BSFJYdnhYUklybUI0ekRGY0tvRHhRTW9JS0tTcWdBQVlIOHE4bHZidlhyZldVdXJTdzB1NXRISWpjeU1aRlhzUjVoQklIVGo4cTdodE1oaU9uM1YvT21uVGt2SzhFYzRlT1RCQTRHT25vTzFHNFZKems3cmthVFduOHBtMytwVEc2RWpYMGxyY1NLSGtodVZieXBWUFRHMEVLUVI5NFU3VDcvU0d1VXNwclFYSzNNakNDN3NrQ2lPVjErYk1ZeHpnakw0NUZaMGpYZHhxRTBoOFVJaUxLdTIyK1V4cEVBUjVRQnh0Sks5VFZydy9jWFExaU16R09TSzVnNXZvblZBWFZpT2R2UHlZeFR2WldNbEpxU1YwMUo2Mzg5TlRzTDlkVzBxWlZ0cmxjd0NhVFk1S0tVR0k4QWpJMmp2bnZXQnJBMVJSY1R0SmEydjNUOXA4M3pCR1pPU3lnam5kMEFxZWV4OFFOdXU3YlhvcnEwWlhlUXNOdzJBY3FkbzV4anAzTmNWYzZ0ZjNkNTVMNmZlSkZCY3hmWjVJbzQ1R0RsUzNtYlR3UVFNQmV0SzFoT05tMG96amQrN2VXbnkzT0trMVMxYVdWbThYT2xvOTBTaW1FN2wyZmVqempHNCt0ZWs2ZDR2ME8vQWpXZVY0YzRqbTh6OTZHNEROaHVRd0hXczlaTk8xRDk3SDVOM0kwenJIYWtDMFZXWUVzclorWFByV2VQaC9xZ2lXNjB3MlMzRXkvdkVMQmpHNlpHQ3hKQTNEZ21wSWp6TnZsaTczOG5vdE5iRnlMdzE0b3U3cHBOTjFaNUxlNFVTaExubDBiSHlrTm5CSGZQYnBTUHBPcGFkTmRYRnlZemJ5T2tadVowVkFoUHl0bFI5N3BqNmMxU3RQK0U5aVMxdEYwVXhQSXpMQ1UyaFFkbkpCSEdBUm5QVHRXWmZXVjVjK2ZaYXRJOG9ab3pkdjgyZHlmTnVPZUVBR1J4d2FmdmVRcHFGNDg2YWVtMXJJN1N4OEplSG1pU09XQ0NXMXVacFhnTUpiNVhoQkpaV0pPUVJ3QjZVamVFUER3MCtlVzJ1M2lmOTJxelBQdjVBM2NOMEFJNFB0VUdrU2FWcG1uUlIyMStxV3IzSVlSeVplV0lTcVZ3R1hJR00vblY2K0ZyZVdEYU5aWE5sZHlDSUxNcWtGY1l5U052M2p0NzlRYU9pSGVGcEoza2wxMzMyNmpiTFZyVzF1YmUxYlZGRU1pZ0NlTTR6dUdVVEs4NUI2Vmg2eERaYUhwWDJxOFdWN1R6VkV2bWdYU3RJVzNGaVRqQWJrRVZqNmY0SjhPd1doZXp2a0x4dkhGY0VoM1pkeDQyRWZkeGpCSTZDdExWdkZYaHZUNW5zTC9TcDQxY0lyY0dhQWtEcWZkaHoxbzFzbVZUcFI5b29YbEpMVkpiNmRPcDJ0aEJwT3BUMjEzYmFIWXRDZHNpN2xDbEdjWUFPM09NZW1lOWVRNmZxZmh2KzBwNDdLMzFHT2V6a2xXUk5oV0plZjlXeDdFZGpXMW9zTm40YVp2c01FdDdhM09HRWlxeVlMdHdEMXlNSEdQeHJadGRZZ3RybU5MblJuaWxubGQyL2VGbzl3WE80NXg4NVgxL0NxMTlUT2ZzcEtTY3J0TjhyMnQ1Nko5UE12V3Y5bVdreXlXVjBzUU1xeHRiR1ViR1NUcVNwNmtIa2ZsVmEwdHJxOTFpRXdibmh3QWppY0JDUFdUbk9EdDZlbGRVOXpwTjVESTM5bVcwOERva3IzSmNPRUFHNU1nWXdEM3pWNjIvNFFpS0czV0NDM1FMKzhuR2ZtWUlOd0dNaklHT1NPQ0ttNjEzMkZHQzkyODRxenZiVlhPV3ZyVHhxcm1TYXhzNTBZZ1FwRUZCQ2RBU1c1N2NpaXUwMGJVZExrTThzV25veWwyS3lQTXVEdk9TQU04RGdZb3FHbWh5bzBLajVwVGttKzBuL0FKSG9waThRWGVuM2lDWTJybVJoQk9vNWtYZ2ZNQ29BWVlJT1JqdlhtMW5EcjhWbkFIMUcvbGdrUjBsZ3VFdFdtVWcvZUl6dFpjZTR5SzRnK0hkWHQ5WnZXWFdMMll1QUxpTzBFeUREak9aRElTRDE3QUR0V2xhZUF0UTArOWtzOVRzYmU5c2pPbjJlN1lzb2pWaDgyM2N4Q2hNWUl4eWNWZlcrbHowbTNKYlBTMTM1OWpsci9TdEplMWd0cjN6N1hVWFJERmV4SXMwdHF5RUVLVWpLcXNiOUFFSngzTmJNdmhyekpJNXJ2Vk5RSWRsRTh3VTI4Y3Z5WVhjb0J3L3pZVEkrWEp5YTZiV0pkZTA2S1Q3QjRiTTBNY2NpTXpUbDJrUVlPWUR6bE1nSEFPUFN1WGZXZkVGM0hEQmI2WkRaSlBFakV0cUxqTzA3dG9WQ1dReVp4a0doWGEwSW01Y3NWZUtTMjZiOVBRMU5Rc290TUF1NExTOEZ3WXBib1IzRWpIWnlFS0FuSktIYm5hZUs0MzdGTjRpVnBUclA5blhQQ3kyZ1JDREpKOHd4dCs0cmQySjlxN3k2dHI2d1NSN254TTZlUnRXSVBjR1JWVndkc2s1Ykh6QS9LckRnOTY0MXJ6VzdTR2FTeHV0TGxDemI0cnBWaGQ1RktrT3AyZ2Jteng3ZDZoWDJWdENlV0ttMjAydE5MWDFSaytDL0owdTh1ZE8xRFdXK2U0VllaRmNwRWVvSDdzOE12WUU4Q3VvdWRXMVRTdGF0SGJVWmRXdDNtRnBLeWt5SGtZSmt4MDY1WHNmV3RKZmlENFB2SjBpMXVOSW44dU9UeS9MWHlodkc0YkdKM1lPUHo2VjJtcGFscEtXTU9wYWZlenpReGxUdWd1dk5YeVhBVWp5NUNkMjBZK1hxUHJUYVRUVm1tYXpwcVVPWjlIZFBiejJLZ1hUYlRVTGVjMlVGN2FSUlJSUlRUUUs3dTJEdVRmZ2huZkhPT2hybk5TMXJ3YkZxRjNZM0dqYWdqVG1TZTRLeDR5WkJ0TGJrT2RyRHFnSkE3MWF0cGxuczJhSFZwSTdPZTFrZExXOUlhNWQwWU9zbmxLdjhPY0VubjJyaXB2Q2trYzB5dGViemRpVklGZnowalIzSUdSSVNWeGpQQjVQU2tyR0Y2c1dvcmJ6NlB5TGFhdjRBaDFhemxiVnRSUzFTU09DMmhqY3hRSEM3UnUycWN0eDh4SngycjA3VTdNVzR2WjMxV1Y0ZzRFWldaV1JtKzh5a0FZQk9laEpCcnhLOXZyMkdmK3piN1RaTlNpTC9BQ1F4cXdaWFZkb0JLNDY1K1h2MXIxR0c0MEc2dEVqL0FMTnZMU09JQmtVT3NUeEYvazU0QkdmNFMzOFZVME9MOXBTMnRwZHR2ZjdqVjFQdzNwemFTcW1LK2w4eVJ0dHlJdHp3Q1VaeU54YnFSZ0tNakhhc2k2MHJTdE4wSzJhSFI0RGIyNzRnTXNJSmk4eitOZW9CQUdHR04zU3N1eThESWtUeXdhcnFPblNCd2t1WkRjSVdCNUcxMlpRTWtEcGtVdGhwQ2FScFBtUVdPbzZyS3NseEdwS21ONUhKMlNQS3JNVlJPNm5idUpGUTcyc3JHcmcrU050T2JwMU5IelkwZ3NTbHZaeTZndnp4SkU3Q1FsdVcyRGpieGduSEFQRmRGY1c5OWQyb1A5bUlsNDB1RUFrQzlRUVRJTjJNRWZkNHo2OWE4T1NIUjcyNEYxYzZIZVdpM0VoUVhVTHp3QVJ4RHkyU1VnL0t3eDFBR2E5RnM5RHNHdTVMM1Q5VHZKNDR5Z010MlRPbVFvM1FLeENINWdmbGIxRk96c2M3aGVOK1pyKzVibHNlVUN5OFVlSGRWRTAvaFN5aHQ0NS9PaG5SSTVZM0E1M1A1WkpPTzRKUE5lN1JhRkxjV0FleXVOUGl0OEswZHhiSTl1c3UwNCtVNU9ReEhJd01Ibk5lYkcvOEw2bHFNOE9oNmpOQnFOdElseEw5clZsZ2wyakt4c3ZWUm5xb0hPSzB6b2VvYWhxdC9manhKbDVyUldrc2x5TFV2R29MS3BJeUVQZmpOVjFOcDA0Mm5kY3JsR09uTTIyN0x2M042N3R0WXQ3dXdjTHFHb0tVV2FTMVRVRVl1c1EybFpTZG9QTGNGZnFhWmVhWm91ajJsN2UzZWxUUGMzc2poZHJGYmwwak9SRTBrSUIzZzhaSDNxU1B3ZGNSMnhhSFZXWkVMRlZSM2Y3TzVPNWxUbk9UZ2JjOCsxUTJENnZaeEtaSTdpS1lOS3EzalNDNm5sODQvSmdGZVl6eGowNzFGci81RTNjVnFtbXRwTHJkK1IzVm5QNGVGb24yVjN0SloxQnQybXRwWlJHNVg1RDh4YnAxeHhXTDlzMWVDNVcyZEJJZkpieTVJbzFXTzQySEIyN21YOTd4akhwMHEzNHAxclNiWVdNZXIydHhkdTRoZ1ZRckxGSThxZ0ZaZ2dBSE9PNUFQSEZUd1htbjZSZWlPQ083MkpFQkxHOXloYTNFakZpcmgrVkJQQXhqTkYrK3BWVG01SSs5YUtidTBucWNYZXoydW9YNXQ3dU10SjV5UmVUZHdrV3h3T3U1dVIwNEFQMXlhdDZmNEswU0IwdUZ0SW1tTGw0YnFFaUZvblJnb1YxamJucnlSMTlLaHRvSkpMYWEydWI3VmJtekVaWkhtUlNpTkdTZkxqZE10endQbUJKNXJ5VzA4UStIOVQxRzh1ZEF0b3dtbW9acnVhNUpIeTVBd0dkaW9aMndGT09hbExSMlJuVGpWNWFrb2MwNHJWdFg2OXozdlh0QmU1dVp3bHliSzRndDlscmRXMmRrYXN4VkVLNUljTjIzYzU0Rll0NXJYaDJKWkUxK0F2S3FEQ3pxaERIYUF6SnR4alBVS2ZtOUs4V2kxblNZNzZXT0RRNytDNDhvUE5IaDdnd3N4K1VvWDZGaDkzSk5lbDZWSWRSVzRlL2t1aUxtM2EzQ3pCREUwaXA4d2tXVUFqamtqcU9vTk5hcnpGS1VsT0M1ZVZOOXQxL1d4ME9vWGRyTm85c21uUEExbUM4ZHhOR202T05EOHc4OVQ4MlRqbHVvUGFzNnlua05pc1ZoY2FackkzeXFsa3FuSURFc3VQTTZ5QWprKzlZbHhxOWxwT2pqVDV0Q2VkMG5ZeFBFeUJRenFEajkxeTV3Q1FjY2pCRmNqcUZsWmFyWnJxVnBMZWFhbXh4SUk0U3l5U0tBclNCUVF3Ym5ra1p4elZMcHZjYjBrcjNkMXZaMlhsb2ZRMm5hdDRpdWRMTTAxcGFRenVHV1cybGtETHRYNUZEbkJVYzVWdWVEMXJnOVYxZnd6ZFdDUlNhZW1wenhTTEg5bVNMOTVCSWVxOGJmbFhJSU9jQ292QytqYWRmV1V5TWw5ZmxiWS9adktReFloYjcwYlBKdzdiOG5wNm1ydmgvVE5HbVMzZDVoT2lnK1lDd2puaFZBVUlLa25KM0U1eDBwTFl0dXJLY2JMVFRkN2FuTmVLYnZ3akxhV245cFdWNloxYU5ZNTNEbllxY2xWZENOK1FDTW5uc2FrMEx4ajRLMU9DekVPazJCRVRUVHZFMzdwM0NyekloNFhJR09DY2p0VzNIcDdXS1RSMkZ3a2UxRmpLenlxMGhZdGtUQTRLZ3J5QjNyaEYrRWVuaThqOC83SkphMjQzUGlTUmhKNTdaQzRCR0dqeWRweWM1NXJWUXZlN09pak9NaytlVXJycWttditIT2p1dE04UWhqOWx2WHR3KzVsWUZQUFVKa25MS2RyY0Q1UVR6WG5PcStIUEdGM0ZGSmIzWmhrd29TNWRVRXJCc1pkaWNsbDZaSVBIYXVtOFMrRS9FMXRGSUxMV0lyYTBWM1VGSUdlYVRjUjhoaVV0OHk5NUNSM3JwTkQ4S2FnbW5MYVhXcjNrOXh1U1c1bm5iQU9mbUVZVTRKVnM0NEpQTk5hSmFtRUtYcytWcWNlZFNUVWRYODNkV3NlUmE3bzgrbUdPOXZJWkk1TjQ4dUNJa2lUeVZDS1dCQkF6aklIVDFOZWtRWExYbG9COWozbzBDU0tHbGFOTVl5NnlkRkxEUFFaNlk0cjFrV210UjIwUmh2NWxlT05WT3lJYnkrQ0JHNGJPQXVNWnpYQXcyWGpHNVdXYlVMeWFkVmtkVFBKaUYxakdDaklGd0V6akRPZXBxMjlqV2NZMlQ1bmZzOVNoZWk1Z3NZMTJTd21QeVFpMnp4b0hRRDVtSUF3Q2M4anFNWnFtWW1uMHVTZXcxTUxkckRKTDgrMEV4TVR6aFJ5RjdFNUZZTjlwVU56RTBlb3pTQXFDeTN0cTV6SW1ReXBJTTU0SDNjZ0U4MXJRUTY3Y3RhZlk3Q0Y0VDVwZVZjYzdmbFhoc3RnRE85ZXVlbEJ4T0Q1cmFOMjIyMVgrWjQ3ZWVMTlhHZzJhWGorWkhNc3d1THFWeHZLbzIzSXh3Z0pPQWU5UzZmcnZneWZVRUhtczdORW1GTUppR1A3N09HSHpaNDNkSzlTMVBVbDArL2doaTBxSXE2TkVKTGUwSldOQVEvRzQ1YkhjVkNkTzBuVWtWemFXODBCWmg1aVJlVUI1WTNCUW1EMVBUdlYzVDdwbm9LZEdVSk9WT1Y5ZG1yZmRZNXM2dG9VK29oYmRMeEpDV2dIa3Y1a2JGRzM3QTJTV0pKNTlhNUxWWkxXNHNWRTgrWlRJNW1VTDVyb2c0MjVmQitZYzVJeUs5QnR2N1R0WGpVYVJhSDV4NVozK1V3M0hPQngwUHJnVXk0c2Ryenp6V0tTM0x3Z1NvNitYSU01SkxNTUl3SUhCNE5GN2RUalZuSlMxV3QxOGp5SzQxRFNyYU4vc1RTWHQwVjhyTzVRRVBHUE5IVnVQd0JxVk5BOFlHWmJ1NXVVdHBUdGRrRWlOTU4zQTJ0MEJQZlBRVmZnbjFBaFlZZkMva1J5eEp0YmFyUmxDVGtCMUpKZkhPTTFnM3YvQ1FvV0RuYWlvcElURG9BMmZsQlljN2M4azlLcE96MVBRMHA2SlVydGZGTnFUYTlGZEdyZHJvemVZWlZndTVrWi9uYVhleU1lUExHTUhiNlZ6RjVmbU80RXF2Y3h0RnRWSXlyaGNZd0Y0SkFBOWVEWEwzZDc0Y3VCRUo3V1ZTbTJQZTVDS3g1UEczSEFQZWxtdWxoOG9SYnBETG5LWVptVld4MlBZZXRYZHRJN1ZTcUpRVFZSdHBxMGxaVzhucVpNbXVMTzA2U3VnRGtlWVVqSU83cGhkK01aTmNKZXhnTFA1UG5PckVBdElmbURleDdDdHE0aHRudXJqZGR2SEp1T1BOUmxabWJxT2VoUHJXTmNhZGQyMGVaSlhrajJsZmxiUDNlT000NXJWV1I5ZGhZMEtja292bHZacU1rMWZycHNZMFUvd0JtajJ2SVdEWU8wamNUN0hQUWV0VVpMcUJKdC9sNGJQekpuQS9ESFExczNkdks4U0tpdVNvQzdNakJ3T1NNY25ucWE1QjRtVVNiMFljOWV4TmJXakphbyt1d3NvTnVTbGFUM3N6cDQ3aTNrLzFVd3ovZGZDa2UyZWhycE5POFRhNXBURHlMcVNNWis2VGxEOVFlSzhqYTJsVkEzYk5QanU3cU1ZVjhqdUR5S3dlRmhlOFhZOTNuY284c3VXcEh0SkgySnBQeGR2MUNyZVcrNFp3WGpiQlAxVTE3VnBueE0waTZiYWw0RmJqNUgrVS9yWDVxbStKNU1lMG51cHgrbE0rMjQ5ZnhvVk9zcjZwbmxWY3F3bFRXS2xTZms3by9WKzY4VFhNMW5MSGJYZ2hsWmNJL1hibnZ4VlR3cnEydDJDekc5MU0zZThqWXBsT0Y5VGxnVGsrblN2ekJ0ZkVHbzJ3L2MzTXFjZEF4eDlNZEs2cVB4L3JpS0FYVjhESHpMeitsV28xT3g1RThyeHNJeWpDckNTZmZSbjZVYW8yaVhVclN2TVVCd1hCd1JqcjM0SDhoMkZlY2F2cFhnMitmZEJHOXNGQUJuamNnbkg5MVR5Mys4YStKWS9HT3N6S2YzZThqSEpZNEg0ZEtTUFd0WnZEUDlvbWtUR0dKVmV2UFFZNU5UT0hNbXBSVFgzbk9xT1lVUGU5c291UGFXdjRIMGhxWjhHNmFoSjFLK3VISEpqU1FFZ2Y3UkE0cnBQRE9vNlpQNXJ4UjI4U0NOQ3BTVXRLUzNJREVna25Jd1Y0OXErWjdMUnJiVTVmM1RHS2JhN01WWXNwQzlTVlk1ejlNMTZWb3AxRFNtK3pzOGtGczBpaWZNWlNUYU9SSmhmbUNqK2RlZjdDaEJwd3B4VDhsWThmTWNkaWExSGtsaXFzcExlRW0xcDZkZkk5V3VQR25pT1MrbEUyazJOL1p2YXI1c1RBTTZiQVFWbDJCVGtZd0Z4NzFFbmluU3J2VHBBbS9TTGVPTnMyY1NFK1dHazR5cHhnNDRQTlFXTWVqVytwcXRqTGFUTUVsVXpmYTVBWGlPU1BPVTV3eTlNR3VsdHZHNnlTM2RwY3dYeUl5NUVqQTNmMlpwTVlhS1RnK1dlaGpPYXF5ZXR0TzU4aFV0VWhLS3B2M09WM1RzMzN1bmY3eVdEU0xmVHpZZlpMaXptVzVCZUVURllNaGhuRWJUdElNazg0Snhua1Y2eE5yeVN4V3F6Nk5lbzNseVJFV3JmWmtpbllZSnlEd3c3SHNlbld1TGUyc1RwTnhIYzJpWEtXQWwreS82S3BVQkZJMk9KQXBDWk83SU9QYXJiYWpwcVhkelBackpjZWZicEViZDUxRXBJNUtCYzhMNktNa2lzOUxwMlBQcTFJdHVTYnZmWDErODlkZWFTT01tVGN6d3F3bFc5WkdLdGdLbVlrSkw0WVp4bk9hNm1hTzliVUhuM1NJZ2lCa0dOZ1lNM09Zc1lERThnN3VCN1Y0RFBvK3NyWVN5Mk50UDUwWjgyVkhJVm1BSUJhM0pBRER2bkdhNG15dWI1THg0N2xicmJ2TWNPSGtNd2ZPNGdLR3dDcEdRQ0NCbkZUWi93REFJNTN5dHVIZHA5N0h2dW8ydWt2YXZlMm1pcmR3cFBDQzBWdktMcnlvMklZc2VPZHd5Ry9Tc0xRRzFpOFM1MUt3OFF5V3RtWlhSN1BVTGNMdE1iOGlDWGtvRDA1L0d1UDF1ZnhKYVdVY2M5M2JLb2czcmNTUXZPV2t5U3VNNEJaUm51Y0hyelhmK0h2RXVsM2NOdlpYTjU5bm5rM3lTeG9NQ2NCZW0wQTVERGtnNTV3YW0rcnVqV05hbTVSU1ZtMDFheFZpdVBGRnBmVFR3YXNMcTNKalZqYlI1ajJTQXNHS2dIYXdCSjNSbkk3MWIxaTk4TzI3U2k4MDNWZEtpa21KbE51bVlUSzJmM2t4VUZpVzI4ODRJNjFZMERXOU8wbFk3QUlaeXNjM2xzOGFxOGlSQTVPM2dZR2NnYzVOZGpxK25hZzFqdXM0cllSUTI4eUV0Y05CSEx1VGNWSVVzRlVodU01SEhHS3BXdXRXZ296dW5aMzErRmZodWNEWlhIbWFmQUgxQ3oxVzFDeVp0WjdkWXBCd1NtMk5BQ1N2cWVnT2FaTjhSdFBXUkpMWkx1d084UXovQUdtelpZMmJHQU9DQ0NPN0E1STRJcmQwblZ0TFcrY2FscE9odW9LTklZbVdTZFNpZ2IvdTRZNTREWkJQcFZyV2swUmRNVzRsc0Vzb1BNU0lIWU5zcEM0VUF0a0VGZWZVSHFhYlM3aEtTYXVwYTJ1N2FXdDhpeEhINHJ1ck9MVUV0b0RjYmg5bUUwTWFJRVFFYjRsKytCSjZuSEdLOGlIam54UE5xYldldWFQWVdTM0RMRkdkeXhzNFk0VFpLQTRCd2NacjFteTFhMDFUUm5ld3VOUm1TTjJrZ1JYOG1VR01nRkJKMEp3YzdXeGtWY3R2RVdsVFh2bU5aeTNxUnNDbUxSWldKSU9ReUhJamZQQjZnOXFQZGZxVjdTRFVvdDJVdDIzcXJibm1taWF6YU9ab3BudG9mSlpJSmttY0s4YkhLb0Z3cDU3OXNldUs5STB1MThIdmRNYkhTTG56bXR0N05MYlNTUnNDcFVzUklHQlBPQ1J6amlxbDdxdHJxZDdGY1dmaFM2UzRkWkYyemhZRllXNXk1S3RnTVZKd3VjY0d1L2ZWNTd5MVdDMSswUk9UT2VKUm0zMkFZVWpHQnVCeW9QcGcwMm5aNmswbzA0M2pwcHM3YTczT0V2THlDeTFPQ3p1b1BzOFYxR3Fxc3k3cmQrQ01KdEEyQTlsQno2MVgxSFJic1FHZXpsbmlsWU1WaFJWaml3UXFxT0NTRkpYa1lQSFNxVjYxeGFMSHAxcWgxQzJkaUpyZVNkWlZqR0Q4eFZpZHJEMHpnVmtlSHRVc3hjdzJxMmtsMklwV2ozdkp0ZUpkdUJqZ0hBemdaQnhVdDIxNkhGS1ZOU1VOWDV0N1A1RGJHMHVWMWlXZUNlN2VSWWxSMFpCc0Vpa0FTeEFiUWZmSFVHdG5WZEwxeTlJSG56UVRzKys0RUUrMXBtWVlVTEhJY1pBR01GdXZOYjNpblYvRDJtUUg3VEhJbHU4Uk04OElHMGJBQUcyYmlNNS9qQXpuaXZKZkVFWWlzclRVcks0aHZJcjJkYnBrT3hBOFFYWURIdDJIY000WUhBNzArWmFlbWhyS01sQjJhMDZwMjJQUzRMcXpHbkxhYWhNWnhLaGVSTDFBN1NOdTJsRjJzY3VOdk8zSkZPMEN5c2JlMGtsczJ3N3FQczZTeFNSQUttQ2RpeTd4dUdmbHgxRlhKdFdzTG01aWptaWhDTkZISWhubWlSNFhHRDVlVTVCNi9NVGcxZWtGM2N5M25rYWZhd0NDNUlXU1l4eUk4blA3d0p5VVlIM3lSMHF2bVh6d2V6NXVWVzB1MnREbDljdGRjdHRVKzIyVnhhTGJvNTNUeHdLSkhNd0RFU0hjRkdHejgrYzVyQWk4TEpyR29SMzkya2VvYkUyK2JHekpMNXJ0Z2hoSGd0dDdNTTQ1NzEyelNhcHBDUm01c2RKWXNvVEFXUmZ2RWJmTFJmdktRVDk0NTlxMmphNlhlMk1qM2R4QmJDR2VTS0lSUUMxamRTUTRLaVRIekhHQ2U1enpSYlhhNkcreWZ2Sy91N0dUcU5yWVpzZE11ZEhWcGg5enpMdVFLVkpPek1oNUxMMStjY1p4WENYR2w2QnBPdkN6WkxtT1dTQkRDckxNNnV5c0NUdWp5ak1lekFBZ2RLOU5hdzBXNGVWWkh2Wlk1VzJ0Rk5rcTQ2cTBUcnVQQndPdjFyUHM5SHMvdFRqL0FFMjZFM2xxanpTU3lMdWpIUXFDcklvNlk5YXpzdFdFWXl1bTBtMjlsclpmSkhFYXhiNnErazNmMnpXcE5NczJrRzZZbHN4S1NTUWdJQmJPY2dnNUZlYzZiWWVJcjJ6dDRsMXFIVnRQVzFXU01OQ1JPNk12Q0JFSlV1dU9OeEJ6WHRiUTNkbGV2WkM2RU52R3c4bUZ2TGJjOGhJMnMwclBuQlBPT285Nnl4NGQwaVdXNGhkL3M4OWxLc2JRVzd6UjhUSFBsdjVSUS9NZVJXbksrVzl0eVk4dkk0T045ZFc3TzF2WFlndnZCa0VkcDlzKzJhcFlLcVFCMzM3RElBZHFxUWpkTTk4WkJxT2Evd0RGMTQwVXY5dUxCWlc4M21JMTBpeUFLK0FIQTNidmJnZCsxWkY1NFQ4VzJWK3ErSFUwbUs0a1NkVkV0NFNJc01Hd0V1TW5PUG1CSFN1Z1h3VmVmWTB1dFExTzBFa2FITC9abGtpTWk0SlluR1NyZHgrTlExYXowZDJPVk9yQ01IQmU3ZHBxL1R6TmZ3NXFWanFWMWRUV053ZnRvTWtid0dFaUc0ZGVGZE40R09PUU8vQXJsSWhvTjVjM3NrN1hGak9ZViswUlNCN2VXR1JlTjJGTEltTUFmenJnWjc3V05KRE1WdDd1QVN5d1hscHBzanRoU1BtTWlERzBuQUtsZUIwcnAvQmx4QnFtbXNMZXd1aWtvREQ3YmQzRnlVOHhzaFdXSlN3SHk3bERaQTcwdVhUc2pPVVhHbjhLK095dnFuZnJwMU1IKzNMZTV1YkZiUFVMMjVqVnRyU1FXVFpoSy93U3RHUnZ5ZVFSa1Z1aVc3MCsxaXRtdUJPOHgzMjA3Mjd5Skc3RENveUtPU3dIekhQNFYxVjM0T3NybTRlOWxzNXZ0ZThtREc5b2VUaGlVRzA1VS93a0Q4cW11OWIwc1NYV2szVnhQQmVSUXhicG84UnEvUjFraWM1QlZUMTR3ZVJTbDY5cm1ISkJLNmk0eFN1MjlUbE5Oa2hhNHRNMnNoWUxLMXk5cGEvdWtJWEFTVHpmdW5JeUFNZ2l2UUlKOWJ1M2xObGN6SmYyNEVieFNRUklKQVZ5QXUxdHczZEFTVDdWd09xNmQ0MXU0Ym1mVFo5UHZySzhqMnpmWTR4NWtqU0RZNVdFa0RqR1MzR0Qwcmo5SStIZmpTNnM3S1M4MVN6VzFhQXlKSlBic3BoQ0hIbHUvd0F1QVFPZ1BYa1ZhaStXOXp0aFFTZDFOSzNadTdWOTlMbnVIbTY5WnZMTmRhTHBzMTdiRm5rZTJuK3p5eTVYY1dVWXc1d01IT09lOWMxcHQxNGgxZXhoazFmUmJ5TGNnUTJtNFJQS1djdUpGa1V0eUF1TUFaNzAyNjhLdEZhNWoxbTZ1M25qaEVFaVlrd3FZRzJOaGdJM09Sejh3cDFoL3dBSjNjM3NTVGVHNDUxUkNrN0JIVU9pQTRNWVU5OW9QVGtubWhKVzFGS0U1SnFNVmU2ZDc2LzErSjZ2WTZQb3lMYkxiV3Nta09tQUZEcEtSdEp3bm1qT0J6bnIxNHJ6N1ZMM1dBYm1KcjVWa2tTUkZsak1yV2hjSEpaMzhzN1NCOG81d0s2NkxSTHU2Z3VZcnUzZTNWbURuZkNSZzRMTGhQTUl5T3BCL0t2SXJQdzlxK21tWmJpYWE2dGJ1NWs4eTJTU1MyWm1iSkxOUGdLbkhVSHIycFhhSWJubytXMTNxM3BjdGEvb1QzVmdaUmVKcVFtWlpJZklsaFg1c0FETHhnWkNZeGtqMzYxMW1uM3RocGlSU05BMFRSeHEza1J2TzdiVUozaG1iQTJrbm5rNUp6V0xyR202VmFhWkhjUVRDelNZTEhCQmJXcTNPME1mdWJrQkxsbTVHUURuaXV5dGJhNWpnYTRrYlU5TXRsazVrYUl4N1pDUUNDR0paU3g1WGpCempGUGV4TTR6VlJ1S3VtN3Q3cFA4RGtkSDhZNkhMcVV4ajA1bzdvVHM0ZWRaU1NyRUZtYVNQT3hldkhYZ0RGZFpCSDRwZHpEUFoyYU84eXNvYTg4MUdqbEpKT004QUEvY3dENzExRnhxOTNiWG1MeThFU3p2RkdXbEVaQi81WmpFaWhXTEU4aFdYSFkxNTNaUFphUnFTd3phQ0paTDN6QWpKQzRoZVZTRUhMNTJBL2RJUGNjZEtHcnBHOHVSZExwZGJmaVc3MkdTWFVyV0grMG9UTkhiTk5EYVJaOHpmR0FwUU4xR1R5T3VCMnJ0OUxqczcyMnVZSmttZ2FhTmt1Vmxsa2kvMlFGeGdNQ1RqY3VLOGV1TmEwQzUxNkd3R3RhakJmTmVyTERIT3JiZ1ZKM3hLZHFuYUNma0lKelhUM2VsRytRUUxiUUdNNzRqTUpHam0ybkljREpYSkI5UnllYXRLeTFNbEgyZFRtNUhkN1g2OUNoYitGNy9BRU84dWZKMFJJU0ZpSnZrbEZ6TXhYbnBJb3lBYzdnVDBQV3VmaDhUd1FwZFhldWI3eUtVck9qUVFGWTBqTGVYenRZZ2dFRExOems0eHpYWTZCY1JhZEZGRXgxYTNnWElXNHZMbFRMdGRTTm1HeXhJYnNmcG5pdkxtMUh4WGJYTVZ2REhPWW5NalNBUUxDWmNmZWtHTjJ3dGtmTCtOUmZYY21jNDh5czI0MytIdWtYOUY4WXJxMm9YbWk2ZHI4WWxiRThWeW8zd3VIWS91NUl5QVZZWndjY0d0NmZUUEZNY0szR3E2cXNMS3pZamdtSWl3UndFUWxCdXlmb0J4bXNpTFdkSTAyOG5zdElzdDk0SlhSdzFtdm1GaHdjc29YNUQxem5yMHArdmEzTk8wU0NlS0F6SkpIZTIwODBVUWo4Z2Y2Mkl1U28zSDJwTGRmcU9hcGJKVFMwc205ZHVodDNOall2c3ZycEpKR1dSVkVZZjkyek1NczdvUUhTUkNPalpIY1YwaVh0dkJISzE1YzNTemxjMnJUdisvd0RMYkJZWlJVUEI1R1RYRW5UL0FCRnErbXl4bS9zNFRFc0l0N3RiZ1JzY0VGaUJoa09PbTRFNU5kRmNhRGQzbG5iNmRlYWhjUW45NTViUVhnYVhydVhhaEFFaEhISnhqcFQwU2JzYy9MVTVvdUwwY2RkTDYrWjBPcTZKZDNjRFBwdXJ6cFBtSW93Y2N4eEJRN0VPZHpCc25KSkF6eFhqVFFlSU5CMU4zMUMxa2xzVWRGTWtWeWJrRkdKMjVCT1ZDRGs0R2VSV1pCcGZpVFRybUZJdkZIMmtMTmw0R3VSSE83RDVpTjUyaCtUeW1jR3IydDZuSFlxOTRrclBKYzJ4U2EwbXQyVFo4eWxaSTBjTXBMWjducDBwMlZybWs1M2lyUlV2Tk8yei9yUTd1UHhEcUdvNnBMYTJWMmp4T1NraXZHN1BGbGVHSkdNeCszQjdWeStvZUc3ajdSY3ByTWRrOXpPcGpobGppZU4zeUFCdGsyOE5rRGs1QUJxMzRjMVB4bEpLTGVHS0cyU1p6TUZWWTJ1R1ZFenMrYkEzNTVYZjFHYTM3U0s0aWplNjgvVXB4Q1JOSTF5d2FGUExPVEc1SzdsSjlNWTlEU2R0YkV0MUh5cm1mTzJuMTVWM1Z6Q3RIMXY3TGEyUmUrdHlrSXpBWmZ0QVo4a1liZjhBd2dkQU92YXVxVFQ3dUN5bWE2c2JDYTVoV0x6RE5Ba1lpVitVWlhseVpPU0FPSzVQeC9xRXNWaEMxdGR2QzF5TGFXUHlZMVVFa0VrczV5dTVsT052QjR5YTA3TzZodWRHVVQzT3J3STFzVUZ3MEN6VEFMbHNGaHV5Ri9oSFFBNHFYdWpMMmJqVmJjcnVWMG5lMWlDVHcvNHFOMjF6WnRieFBaRXY5cG1YN050eUJ0VTcyYkFBN2dZT0tuMU93bk9uQzcrMFQzcTNFY1VpeXd6QlhtY1pkZ3VjQmpra3IyTmN4cDloNGpGaEs4M2lpL2lrZmMwY2oyK3lGMVRJR0Y1WVp6bHM0eDJxL2VlSG92N0hoa3Y5UnVib0dkVmdsVjNKRU1aeXpFYzlmVWNDdEw2dEZ6aFFVTkhmVzdkM2I3blk3T3gxYjdYSmJscHJTM0lobEFEeHNKd1dBSEFUQkE0NUNpdVMxZS84WjNNOHQxYWFDOGpyR3hYYW5seFRPckhleUsrQ1JnY0U4bnZVZGpwbWp4MngxV09TNldhVW5mUGNSTmNLVC9CSEVRRUFIeS9NMWIyc3gzODA4bm1OQzhscytJM1dSd3Fzb3lWTGdnK1h6OHJjSDFHS25XL3pGQis3ckpTK0YveTMvRzV4dXVUK0dMcVNPMGxGeHBkeXJGNVBMbmp0eE1qamJnTXU1U09NNEdEbnJWcGRRdFBCd2lZWHVvWFJ1Qm1NVHhtWmxWRGwya0t0dFZoajA2VjFOamFhaGQyUU1yUlJiVW04cDJsU1ZHVnh0S3JnNUhKNmRSanJXUHBPa0pvODZpQ3pqdVhlVXY1a3R5WjVHVVlBRGJ4dDJnY2JqM3FiWDB1T2MxYTd2Wld0WkphOTdyOVNEWGJmKzM3V2VVYXF2a1JsU1lWMnlvZDZrNVRKQkRZSndmVUdrczlMMEN4c0pMU0d5a3ZqRVFzVFRYK3hzTU41NllBWUFkT1NEeUs3UFUvRCtsNjVjTE5QSzgwY3pEeTRvL0tTT0pDTWh2bHh2SVBUUFh0eFhMMzkxWTZLdXhMbEU4c2dxczFxNGVVUjhIYXlEYm5qaHV3NHB0ZHR5Wktvb0pLVjFmVzluZjhBcTVsWEdtMlVlbTZoYi9hNzJBdmFwNVN5eXd1QWNiMVpDTnJGMXhuUFVxY0drMDJCTGkzU0c3ZDcrNmlEN3JxM3NHUU5IZ0xzTG5hY2dISUhldCs3MWFjV081OVAwbGJpTGlOdzhURDU4SGFjZ2hXYmRrNEdCVTlwZlR5NnhQUC9BRzdleFFwQzRhMDhxTmhJMFFKRzBncUdiakNrRGtVSmFDaTFyRnVOcmJXczc3N25CNnI0TzhWem02bXRIa3RwMXVBWlZaZGtoaWJBQjJad1Z5b3lSeVR6WGIvOEljeU92bitYZDNKVExwY1dUQVphUUVFelJjS3ZCM0VaQkZaMWpmUVRhbmEzZDdES0ZtamtCbTN1aERBaGlwWk1sYy8zU01EdFhhYTdxR2tXcHREY2FoSEd3MnlEN1BLUU1iZ1VaemtaREtPUVJnYzFkOVZvaHdjWEZlNnJ4Ky9VOCtsOFMzSzZtbHJlYUZvNnZETkcwRnFKM1ZsWkR3ZHArNldHT0IyNHJ2RTBSTDFMdEpOV2VaZ29aMTh0ZjNjcmNuRzBqbnFGeDBIdlhOd214dnRUZWEyV1M3RnhicXFtNGdKU0YxWWxUdmo1eVNlQnhrY2ppcm1teGVGRm52clNmUkNsNHUwTk9uUGxuTzd6Q3pNZzI4Y1p6U1NHN3VyWjh0bXRuZGE5dERydE04Tm1HK3VGT2xTbTFlTHpUUEpoZ1NBdzI3Sk1rbGVvMmpHYThpbThEMnMyby84QUVsdVRheURBa3N0MlF3WUZ0MjdKK1VsY25BcnB0WmUvdGJKRi93Q0VpdTRMZExtSXhtRlFaZ1FEdTJoZ0RzQndPTTRGVjExWHc5b2wxTUV2dkxmekRIT3EyeFYyQ2tFc05wUEc3MDlPbE8yOStodkthNVk5VTNxdlV4NHIvd0FiNlpiaVZvSTc3Y3NralFLd1pvL01KVHluQlhHMG43eDZnY1YwdW55blU5RG5NK2tHeVZtRVpna2w4bUJHYm9FZU1IN3hHQ3hIU3JjMnBhVmZpNGl0ekV5TURMOW9lNFpIU1dSeTN5N1NRVGtaMmtjK2xlZlFhbjRqMHZVV3N0Umhna2doaVFyTEhHeXZ2Y2JzU0pubkJHYy9sVkxsZXhoN1RTVnVTMGRkYjNmU3gyVjllNnRvdGd6d3lYRjVISE9IZUpaME13Vm1VTUZiQ2d4aGhqYU9UVnkrOFI2cGNDM2l0OURPcFNtRjVQTm5uUzNtUlZKQTVCYjUvUUxnQ3BMN2JyYlg4TnZlUkdlQlFtK0RhenNyODUydWRvQTc5ejByRjBqd3ZjVzBpUEZKSk9yTU56TEdFYUtaYytZN0dNbmFqZENBVGlvdnFQMms0eXZHS2t0ZEhmVytub1A4TmVLTGE1bVdXY1hTU1Fyc2hzcDFqT1NCbG1TU01zemRPYzFyblNidjdYZDNObmZYR25wY01KVnRMTUJvaTZZTHVtM0FJSS9oTlIzdWk2SGZNdTFKb1RBakVYMFkydkJJaHdUSzdZVVI5Z2NZYnZYbmkyOTlvTVZ6NUY0TGlCNHBMaUs1UkpXQ09HREFEeVFmbU9NZkx4NjAwZ2JxTzE3YXZTSzAxOG16MTN4T2cxYlE3UzBtbnRSTGRUSk5INWlpQjNWQmxzYmcyMDU5ZTljSStnVGFZMXF0d0d2WkVKZUMxanVzRjVNL2UrWURPY0FaeitGY1hwM2srSXZKdXl5M2NrTnVSSXgyckpJTWtoaDVtVlVJQ1FjZDZ6NHZHa0UwOFJUUlp4YlF5UXpMSTA3bHBralk3LzNlZHJLUHc0cDdHY2xLcGR1RFhLMXEzYlh0cnV6M2Ezc3BMcThqdUdzOVVnQ1c1TTBOMFZsaUVoQkhsamQxMmsvS1FlZWhyUHRiYlFZYkh6NzNUYm5USHNYVXkzQkRHTWhmbERlV3VWNjlSakZjWDR1T3A2dkJGcTJoWFV0dkJESkdseXFqWnUzakt5cUg0d2M0NXhrVnlGajRodXRrVVZ6cU4ra2tleEZVcUxPTDV1UVpDVGpxTVlxZWpOSnhXalNVbHJlMnZXM2JUN3owRzl1eGRYTnhKb3R2cHR6dVhhMDl3Qks4dTRiamlQQSs3bjVUajJxTzNmVllYU2RKRmdWeHZhMTJGNUlnQU1zSWVOd1BjREpGVGFwcHcxdlJyTzZ0cmFjU3huWSs2WlNQTEFMTXlDUEpCQjZEUE5XTlQwM1ZyUFRMYWJSWWI2NWhRN3Q3eUh6Q3B5U0IwYmRuOHFpKytoek9FNVdkbTFlNlVYYlFqdEovRTloZFR3MzMyellJaXkzeFZ3Zk5rQkd4Vk9RVkJHT21SMm90N2xZYm1lNUhscEcwRUl2SFdOcGthUmM3OTY4RURvZWxjNXBWMXF1bnhRcW1oYWdoWncwODg5NEk1Z0I4MjM5NjN2bjFycHA5UjE2MTFqVFNqU1JKT1dlZHBtTG1OUXV3NWFNRVp6MUpOVXIyMktjRzNlN1NUMmU2dHZmVTFOVTFmdzVyWDJhWFN4YXp2R1BMbldGVmpQQitia0VLd0k2cTNYc2E4OXY1WjlTMCt4dWJZMkxMSEo1YjJwamFZdSs3WnQyWjNLQU1aSFk4MTExeHA5bnJQaUpveGJ4VzFwR3JpNGJNZHVXWWpPVkM3Y2pqalBPZWxaSjhPZUNqcUF0N1BVaDlzbmZmQnZmZXFCRkp5d0hxUUZQMW9Uc2ttVlBsbFVuTkpXZWkyM1J1WGxuZW5SdnMyMmFlem1LZ0MzdVI1YWtnbitIYnRZbnJuaXQrOXM1MThQVzZMY0kvbFJib29KazgyWU9oREU4WSs2TTFGYmFESStuUGJTNmZGRkhlVHJLMGRzd1lGb2dUMFlqYVNUbmpnbnJYTzZ4NGU4UW5UNXRsMmw5WVRKbUdZTUZ1N09UcVdCWGh3TytEazAxZlFTcGM2ZXNsRlJhMTZMdWlaN3k3bmRmSzAyTzVabldSekRFRWFRRWZkdzJTdnBsdWFubDE2RFNHdDVuUzRqU1dWaVlwb2cwY2hiREdGdkxCdzR4eG5yWG5OeW9zVXRMYlVybDRNS3JyR1lHSG1zVndTWFhHMUNPY0hrR3ZUN21UUm85S2ltMHVPUjFBZG1XMXVTRVhLNHlRZXE5c25tbTBpWGZWcjNVdXZWMjAwdWhpM2RzTlZnbHRvSHRJWlkzTERsTU03WitjL3dBWEFPSzV2VWZDN1NiOVdiVzdxMXVJOE9zQ1RMc2xhTWtEYU1BNVVkUUJuRmMwdXJ5dGJXZHI5anVkOGFGcFlSSXJiWS83KzRuTGdaK1lkaFhRd2VHOUJ1LzN3a2lqbkN2UEJFNE04ZUpoZ2hkaFBDNCs4T1FhU1dpRlRyVFVwWFNzMDBucHUxYS9Zd0w3NGxXc3NNdG5CY1QyZDNiUkpJN1R4cktrbWNrc29aZUc3Z210K0c2MFBXRmJWN1o3V0s1WmtodVlwSEpYQUlYekYyNEdRY0hucFZleDhONmJIZldTM04zUElaRktBcGJCMVRMZmRMc3UvR2VtZWE3cUN6VFQ3T0tPS0NLWGNybVNNekNBc1ZZZ3lNSFVaSFBJNm1qbFZ0emFUVFNWNUpLS3ZkMzFTMTJSNHBwbWwrS3JYVkxIenRWTElpU0xHYlIzYmFTU056SzVHN0djSDFyMmpVNy9BRnl6MG0xbTFDR3p1NUdMa3draGJoWWd2Q3NPNDZuYVRYSlFMcE9pNnRhTkpFOFN1NllraHVESVZaenVLcWNuZzlBdU9sZCtkYlM2dEx3UjJMeWVadGhNSzIvbVN0a2tlWUdKQUk5cUdyZERIblU1elVwY3IyU1NzckxYWTh4dEUxRFV0SmxmVExCYmQ0UFA4eDVTTnpNeTdVVWdZejZlMVZ0TmkxUFUwa3VmN1Fqc3J1MEVLS0FRb1k0TzhTZCtTUHZkc1ZadDROUXNkWHNMblVuR213cmRMRWhYWkdwUXFjdXhCNFBIUTlhdmFmZitCUEZGL2JtUzVXMHU0M0FmeTJKV1Evd2drais5MkZKcDJKaFJkcjJlajY3ZVYzMHNWNXRROFRSeWxJN2kzdUhtdHdYMmdSZVVXTzNlZ0E1WTljK3ZGWmNVV3ZhZlBIRE1xZVJjUm8wMHN5bnloZzdjS3VNN2puSnJyYnF5dWJXZUJiUkx1OWpSR2paWW93anRJRG5lQ1NNKzM2Vjg2K0lZUEdmL0FBbUY4eVhFOGNMU1Fsb0pKQXN1MWdNZGUzMDVGQ3ZZMG9VM1ZkUnluQ0hMRnU4bnBmdDZuMWphYXpmMjE0MXBjSmJGTGhtamhrRTV5ZG80K1FjQWtqaXBQRU1maGl6V0sybmthQkhtaWQxTEtTV1lFWSticUIwOXE4RThSYXpxdGhZS1l0Q1c2ZVNVQzVWZ3p6eFBIM3dwK1pHemtFZmpXdlllUFBEV3V2SEZmTVl0OE1TdERQYkJsWmoyREhrQWtjR2xaeFowUXBWM1E1M0JTaTIxZFdseXJyZTJ4dWhyZlM3MjVGc1ZObFBFWXlGbkRSRnBPaXFwempibml0WHhacE9rMkdnUlRuVUxWNG1zMmp0WkhVSmtOZ2tBakpKSTR6aXVxaDFUd3lrYmFkRkhDc01hYmxhT05wRWpia3J1UEp6NkRyWG4yb2VFdEo4UVEyOXliNlJVdFhkSDNoa1JBeWpuNXV3UHAwTkMyTVl4cDg5cFBtVFYvZGUzNHJSbFB3enFFR21XNy9hWm5hSENKR2JORWVOanRCeWR5ajVnUHhvcXRmZUYydE5QdHJLMTFBVHhSdTdxNWxXSmVlRytRWU9lQnllMUZIcTBjMC9hUm5KUmttci9BTmRUMTVvUERhZUhiQzB1YjJhN2hpTWVMNWJsMGxCT2ZuNE9NNXpoVHoycnpTNHNOYjgyYVN5MUJOWWhVckFHdUlwSkx0RUNnRWpHQTV3VGxUbXF0djRtME9PZVBaYnlhYnFEUGdYTHdyTXNLTGtxTjBnMjRYcHRIUGF0TzN2ZkRIbFBlM0J2ZE9rU2ZiSmRSc1FMdmVjQkpVaCs2clpCeUFNRHZTdXU1Nlh0SlNsRk8zdjlMUFcvWTFiYTMxdXhpaVhRcnUxVzVTVEtKTVdWTVNFZ29FWS9LU1Y2bmFCMnA0UHhQdWIrN3ROWjBxMEJnQ05ieVdwM0dXVXQ4ckZ1U2d3ZXJERk1oOFlhTGZ5K1Zwd1ZyMkpEQTdzck5Dd2lZYlVhUnl4Q01UZ1BucUswcnpVTmJzckswbXVJdnNhZWNzWWFTWXZLNEJ5ZDBxaGdWWW52eDYwMDlWc2FPY0kwWjAzQy9OWnU5MDFjNURTTk04VWFnbXJlWmZRYWRlZ2hFRjJrY2dtSkozUm5JeXdZRWQ4ZTFjcS9oalFkSHVJdk9rYTR1VmZiTXRpRWpFZUFTNmlOaUNBUnpnSDFyMVRRdE5zWkl4YjIrdVNYNHVpUk5BWkNURVdKK2FKWlZPMWg2OENzL1U5SjBpKzhTWGRyTHBVbm1wdllYQ1hDbHlOdUErM3pNRnpuQUErNmF1NnZwYlhxWnVyN2tWRldqZlZKTHQ2bm51bTZUNGFzNzY2dklkUWUzKzFibU5wUHA2RlY4ajd1NTNMRlVIY0d2VjdPODB5ZTNsV1c2MDJhZThSdktsdHRQZHpodU15Zk1OdWNaQkhHQlhBK0Q5SFZXblJFdEJmMjFzNVpwSkpTMGl1VHNXWUVzQUQwT091RHlNMTdaYTZlaGhXTzQwMVh1MmlFSWppbEZ2RnM3RjgvTVBMNkVucDB4VVBmVmwxWlRjcGUvd0F6ZGtycmRKYUhueitFRTF2VUZrZlhvNExxQ1ZMbExoYlloNUhSUmtaVnNLcDdqcVIxcWROZjhaeWFpMmwyMm42Zk5FeGFPYVdTNDg1Z3ZETTJRVlhJL3VnVnVYbGxldzZxdW4zM2h5VzRXTHlIU0tHUVN5TXBPTWpZeXR3Y2drOEFZR0tzMm1zYXh2Z2x0NDlNU2FhT1pDczBhUnlLRk8xZyszYmhzY1p4eUJ6V2pXdzR6YWpEbVM2clMvVXhkVnM5SnNkQ3Q3VFY1dFFaVWtNczF6YW9mbkk1UXNxQW5hdWV2clduQllhVmM2UGF6V1drNmxBTUtxRWhWazM5ZHhXY2pjR0I0WTVDNVBRMW42cG8xcFBCUGNSWDl4RWh1Rmt1ekNFQjVYQkFJMjR3ZWdHZWE1VFIvR1BoSzJuUzF0dFExRzRpZFpJNXZQbmFabzVHNzV3V1Z6Z0RnY2RxaHEreFVaTGtsZUNzdHRMMlJQcWVsYXZwS1hFRVhpcTRzbXVuU0pXL3MvOEFjUWh6aE5rc0xISVBUY090UTZKNFI4WFdOdk5kZjIxREplT1dTYTRGeVM0d2VTb0s3ZHhHT3AvR3UybDFQeExmenVMSzFraGozTkNJSG5WRXVGWlFQbkkzYlR4bFR3Um1zSzU4TWFkWlFxbXBXMHozTTNLQVhUenN2a3J2WlFuQUlBSEFPTTk2ZDMyVnhPcTNUZG9wSzk3OHFXdnlQU3ZzdDVKYStaWTZxcmxwSW81cEdUZk9DbkFQQjI1LzJqV1plV2Q5TGJ0QmYyT3IzQVZ3OGM4RWl1NGs2N2k4WDNNWXlxNHhXRHBHcWVLcm02amFLMVcwMDZTTUhiS2lSeXVwSVZXZURjV0dRRGhlcEhKcUhWdE9qMHVSbnQ0N1RTclc3azh5VnhldWpUTUJrQlVqT0U2OHMzQUhiTkVvMzMyUWtuYVN1MUpMbzc2a0ZsNFAwbTYxU2E2ZlJieUdSZ3FtN2E2RWNzSi92YlU3RWpPN3RXM3Evd0JrMGJSQmYyYzhXKzFRT2drUXk3dDUyUHVBNGR0dkpHTThlbFpVTWJ5TmIzdDFMS0lGV1pibU8za2NSTHNBSkJjZ0V1dzUzQnNmalUya3A0YXQ5S2creU05NWIvdkh1WWx1UE8rV1ptM0xOR1d5WXg2Z0VpcFQ2Tm1jR3BSaTVyVk5hK1craGRmeGxvd2hqSWluZGtielJKcDhJamlVRW5hWkdZcjhtQ0N4STYwelV4NGxraHRKSXRRaWhNdHVRVmFHT1JES3gvZGxuVnZ2N1I4dU0rOWM3citpM2pYRnRFOXpkcHB1Q3FoQkUwamhobktidHpiVno4M0hZVnoxcThVTFRhWEI0Z3VoRSt5VldudDBkbGlmSUtaT0FTV2I3eDRGRFVXdFhxVEtwYU9yakY2Mmk3clRhNzNIYVZxV3RXbW93V284Vk9icHJkMm50YnlONDNhT01FYm93dkcxaDBPYzhWeCtweTZEcEV0eHFOejRmMUM0Y3lHU081amtJam4zRGNSS21HeUFleDR5T0s5cnNkSXQ0a3U3RzR2akpkSkdqcGRYUkNTcEdwWldLeUFzVDZoUUFBT3RkZG9lcDZjTDJONHIyMDhzU0lJWGlhUUtFbWY3cklCakpJSkFQNGlsYmYwTnFhdlZqcjdzbHl5U2RyOTdkandMUnRZMWJ4QkpZMmtXakxiUlhHMkw5OGt5SHpBcEs3MVZzbFc2RGQzNjEzc09rNkZvbXFvWWRDdC90TTFtL3dCcmdrbEVmbkt6NEFSQ0NHREhvRDZkcStoTDJTek4weTNGdUJETkpKR2JrdUZWRmNBYnBPUjk4NFVpdUdPajZmOEFaNzZIVDVUYnd5ZVk2Ykp3aGVUTzVpSEs3dm02TU00Mm5pbXJXOGpmMlVJZkM3SzcwVCtaejhrK25XRndMaVhTWmJPR1M5d0hTZmNrd2JxOHdCT1Y0SUNna1lyb0xPdzhOWDl0aVdSalkycy83dDhZRVVrZUNxUXJLTW5kbnB6eDNyeDJmVmJUVWJpOTBpMFhWQThNSU8zeTk5dkZJdlZGQ0x3ZTRiUEE3MWQwM1RvaWRQWHlMWXhxbmxSVFhyaWJ5MTRSVmlSQWNNVzRPN25OSkozdXJJNTQzVTQrN28wbmExdC8wTzUwYUN6bDFXWHk1WkhudG5SWXBaWUVDcENGOHY1U2lqazd2bFlZQzV5SzFyN1ZJNUxxZTJHcXp3eXBobzBqdzBqT09FZ1ZzRTdPRG5qNm11WDA2NHZFc0VnZnhGYVhVNWdlTENRdTJkckZpSFpUdTRKQUE5Qm11azByVTdpMFlyUG8reTdpaUxLa0NCTXhNdWY5Wkw5OWlSMEo2KzlVdFh1YUxsVHRlMnVyWG1lWW5UZFh2ZFJ2cmpTZFVlMGpSbzRaemVOdFZFZkRNaWdra1liZ1krbGVqaUcvZTVKTnRhUlNYaUJoTGNlV3Nya0tDZkxiR09NZE94cmluMVhTdFJ2V2Q3VFUxa01oaWxTR0Fvc2ZPNE0wa1c0TzU5UnlQYXVndC9FM2g2Q3lScmI5N0xhV3pSVEpkcm1kQVcyS0RuSFV0bnRudlI4ak54VVlXY3JjdmJxbXluUHFOa2xuUERlTGNMNXRwRkZIZXh1ZjQ4cU1Zd3paYklJd0R3YTFyM1N0VWJUSTRiY2Zhc1N0dmxiY1BLaU9jQXFHUXNRZU91Y1ZmdkxYWEY4NjZTTzdsUXdKL3dBUzlwMUh6by9IbGhCa2tCdHhPZWU5ZVl4NjR5cEdadE8xUzVsZG4yTEpickZ1aDI3UTdNcDVBWTRQSFhyUnpPMjJoTDBUankrNmxlNzBPbHM1TmEweVdLR095bnUxbVpsSWpsQTJCTUF5a3pIS0tPakRKSk5YYi94VHBRRFFUQ0VUeGNsZ2l6ZVVIUFJXR0IwNUFKejI2MWxycGNtdDZTSHNUY1drTnpJdjJsTGw4c3Fvd3pFSFFEWUIvdGUxYTF3UEI2NmNqUXgySkUwTWlTZWNpaFpXZ2Y1QTdZeU1FZksyT0RTdTdvcW1wVzVYWksyL2Y3enpFWGVrV1dyM00wR3FBM1pRR0tLL3VuZHR5akF6R3JFWWIwYm9hNmZVbDEyOHRtdVh1N1NXNjh0UEx0a1h5ek56bkIzT29CT01mcFZRK0JQRHFUcnE4OWg5cnZSTjVrc2tjalN5aCt6b0dJRDg0QXhnWTVyWXNQQS9oM1I1VW5zbzlTbHVwNUM4UzNUZktqRnNqY3pMamh1Q0NlL0ZQVHVVNHhraythVHNvdTBsWk52ZTFtWitrUytJL1BtL3RXOUdua09waWFJaVJHQTVJd2ZuYmF4d01jYzFsNnZZV2k2bGJ6V0V6d3psYm1GSDg3ZVdjamVYQ0RrRTU0SFU5cTM3NmZXckZRYi9BSFgwTnlXUlRDc2NZakxBa2JYUExGaWVQb0t6ZEJ1L0RHcVdsOWFtSjRwN2FHQXpUM2ErYzIyTERDUkhCT2NaNzlDYWZOcVl1S3ZLMmpTVDlQdk9Ma3ZmRmlhZ2h0OVNqZFhraFJvNUxWOTRKNkFTTXZ5dXVEZ1lHZTlkdm9kNXFWL2N5cE5LSVlHRExKSkRKd1dCUFZXQks0QnlNMDZLNTBxR2FMVHB0ZW1tZVFSdFpyZER5NEdDa3RqY2hPV2JQY2RxaTEvVGRLbWpqaGtsOGlOSDNlZmJ5bU1oaUNXVXI4d0pBN2c0SFdpN0tia3VXOWtrdDFwK1J6dDVwMXRIcVVZVFZMbEhNVE5MYjJ5RUtBbklrZnJ0VUE4anYxNHFLNzhXNmJIRXJ0Tm0waWpkWG1WSkdqa1l0c3hKSVUyc3BIR1RnMC9TSGphOHVGYlh5MEsyVnhHSUJDaEpFeTdOeXlMeU9EbHZXa3VwN2FLeTJYdHdXdDFkMEVEZ1NJVUl3b0o0SFBxTWl0RTIzNW1YdEtLdHJkUGUzdXRhN2JIbXVvUDRidVlwSXJHU2FFUlFxczBtek1MSzVHTVk2QTQ2amtpczNSTGJVck5wa2l2N1lJOFo4emJNNVZUajVzSm5CSkF4akdLOWZ1ZEU4TFRUdmYzY0RxUklGdUJGbG9rZU5NSnZHTWdaUEdCU0h3enA5c2IrUDdKQTVra2plWHlvV1FzUVNWL2VjZ2tra2tMenhpam1SczV3Y1dveWx5dXphZHVoNHJhZjJQZk0wOHAwN0xzdjdoV3crRHdVTExqYVQxd1RtcEpMWFU0TCthRlpiZFlFekxDeWdKNWJkQWpNTTd0d0dkMlNLOVhGaDRXaXRZSVdOdHQ4eVY3Z05HNkI0eXVmTWhWeGxzZWg3aXNxL3dCRTBtK3VvNGJhNCt6d0d4OHNobzJaVmtCTEkwaUVrTTV6MEpyUlNYYzJqVWdueXQyamRKYzN2VzlEdzN4RjRjdmJ1N3QwbGhVcmN5TVkxV2JlRkl3U3lNdVM0UFVqSDQxeWQ1NEp1YlVtSVQzRHhRU2J0NjVPTUhIQ0VkUjcxN0xwM2cveE5aVG0ydXRZV0szUlFaV1JXRW9qWUFxRkNmTUdib1QycjF1NDB1WkxLTzF0TFY5OEc4N041T3dTNEliZHdXei9BTFIrbFBuYTZucFN4dUpvY3NLZGFNa3J1MFU3ZXV2VStTUnBOL1p5Wml0MzJ4eVlNcnBrYldQQkhxU2VuYXJkOW9GM2R3SmVUSkRCYnlGa1FNd0NZQjdLY3R1UHFSelgwZE40Y1JVWVRYRWpQRE11MVVrQ1JMdk9OeW9NL01jOEhQVWM4VjVycjY2V1dqZXhqU085OG5CWm9nZGp4dGdNR1VFT1NPZWNWS20rcGpTeDg1VFQybC9OMjlUd1VlR2JabmVPR0Y1TmttRmNBZ01wNEJ4Mkdhd2g0WXR3Y1RPUVpZMjhoUVBtWnpnS01FOU1ua212b21DM3VMaTZrdExPN2lsQmp6SEVvTGJTeHp0ZGVNdG5sdjA0clJ1L0R1b1hVaGlua3RubFcwWGRLc2FqY2hKNUhtRG9lblhwVktySlgxUFVwNTVpS2MzelYzYlMrOTdXMzFSOGR6YWRCRGNQQVZWbmpKRHQ1Z0s4ZTR6bjhLclQ2SElzTzlIaWZCQUtwSUhJNHprZ2RxK3hOSjhBU1h2bkpIYTIwc2NaVUpJajRKOHdad3FOa2JoM3hXbFkrQzQ3QVhNMG9pa2tSWlZab2l1d3FNS1ZBUWZmOUIxclgyOWoxM3hRb3E4ZVp0Sk96KzFmOGo0b3R0S1RHSkVKWXR0R0RqSi9HdXkwcncyazg2L0xJZ0RqRWpKdWprN1lYMU5lN1MrQ1gxQzVieTdkZDZOa1NPMjNkMjJzdklERG9QYXVvMVh3eTF2bzhuazJienZKR1BMa2hqM2t0Rmt1QXBKQng2Z0E1Nm1vbFhrOW5hNUZmaUoxRkZRcVdsVXNuMVVibmhxZUhoTmZUK1JHc0VaWmxpZ2RDY3RIMURiU2NuMzlhMmo0YW11WUxVUTJja2NueXV4ajNJQVYrOE1ub0RqcDJyMGJUOVFpc0xlMGFmelduRVJGcks1ZU5ReWtaUXF1M0s0UEo0Qk5kK1k5WjF1em1XenZMV1JqQ3FGcE9zZ2tKRG5rL0owNms1QTVyRDJrcjduejg4eXhicVJmTTBrMGxKN2FhWDgvbWViWDNoTFZsa2lObGNhZkRjU3NITVVWc29WVTI0SHpNZUNld1BYdlNYQXZpMnljVE00RzFXK3hobUVpRERLakp4a3NmbERWNlZvMmdYTU5rSUVhMEY0UUlZdzArN3p5ellZaHBjTGpIUFBCN1ZZVDdmNGJ2eGNpNkszSTJFMnFrZloyaXpnbGgzUWdkQVRrOWFseWVuVTRYaTZrNSsrNHlnbS9lVVZ6TmV2K1p5V24ya2YyVVNUV2NyR1NVbTh4QnZkR2pQVUFFazU3Z2REelhWdnBHczZoYUYxVzlXY1hEU0tDaG1XWHpFQ21WV2I1VHRBempqMHJxdEUxQVhxM1VzQ3BCS3Y3ei9SWE1od3YzVlJKRkN0bm5PZUtwVFdlcDJIbjNZdTcyMmpWdkxXWVc3S3d5QVNKQTJRTUhuQUFCSGVvNW5xdFRpbkpyWHJ6Tzk3dGZjYTl5bS9RN2JaYnozbDBqTENaSm9vc0hZZm1ZeHVjZ3FCa29lY2RLeXQvOW4yTXQ1L3dqTjRVTFIzVnhjV2VFbFVzUnVBUUFrUkVkY2M1cnJJYm01dkExckxmd3pYQzNVVHh6eFc3SWl4N1NUSk9NNDI3aU1kampyVk85c1JOcDYzamFoYW1hT0VMRmV3M0pneHRKeUZpQUpQUEdlbnZSZGFHa0p4NXVhNmRucWwxTnlIWGRLbHRUSEpiUGJ5TVVra1hVWUdHRVp2bTJTRmd3WmhqSHBYTFJYamFYcjdRYVBwZDI5bk5iN2ttaXVaVEUweFRkOGkrdUJnTWV2V3ZUZEN1TlB1YkdPOHNKUHRiUXBIRnZhVGZJcWhzbmMvT1ZJNEFBUHVLOFlmVGJIVTd0YnJUTlFtanRZcFhRMnNESXhTU1U4SVBNKzZnSTZBWUI2VUp2dVg3UkpOTjIwZHJwNldYZGRTWHhUb3VuZUk3K09PN2h2YmI5NkhEVDc5NWFRREM1akpERWpzTWtldFY3S0h4Um9NcWFQcGRnMDlwSTNsMjkvYmtOdElVbGhLejUyZzdzYzR3TW12WUxMeGZkM0VVMXRkVzBEU28wTFc4bm1BL01WK1ZtK1hQbWJqa1lIWHJXaGRXUDJqV2JZM1VHREpGSktSNXpJNWtBMmxXRDdUampnQVlvaTNlMnI4cmx4cVhwcTBuS04zYUxidEZ2cnAxT1cwejdaZTJ0aEUrb1djbHlrenJjMmM2Qm8yVUVnRFBUek9COTA5QUs4czhZZU9kYjBYVUU4bWVRelJ5eEEyNmt2QXVlUXdKVURBNEFVNEpyMm15MHEzdTlWbk1Od2x6TGNocDJSbFJRWTFZQXhyNWJITHAvRXZINDEwRi9wK3ErV3RyYU5PdjJhN21CYWVRQnBZUVJJdmxsdUYydG5CYnAwTlNsSHJzWlU0cEpTbkRtaW5zbmJtc2VDK0hkYzhKNjhzOXE4VVF2NFpqTEpiR05FODJYZCs4ZmdiaDB6ak9LOXl1dEp1NGRIbjArMXM0SkhRdDVkdktzY2kzSUMvSXdEOFlYSk96ZzhjR3VldWRIMFc1dmJvUnd2QThmbHBQZFN3Z095emtOc2R3RlBCNEhVaXRXNTFUeFJaMjZXVXlKY3dvNytmTzBnQUNLcEpEdkdTUVN3MnJua25wUTBycTJ4azZrWTFHNHhueXBhZFhmcjJNZXd0L0doczF0Y1JJenBHMXhwKzFJd3lxTXBMSGdnZnZUMUpKT0tyWFBoZzNvajh1MXY3Q1dSM1pyVzNaWklWWW43eW1QYVZ4bjVzSDVSMnFsWitLQnBzT25yZFEzQWdua21MeXUzbUpIR1NFRWFGY255Z2VEanJYc1ZrZEhzTHFTWmRReGJ6SzArSmJsUkV3dUJuNUNRY0QrTHJ3UnpSRk5POXk0UjUycFhkM1pQeXR0WTh4dHRlOFd4WDBGdlpmMmMrbExiQ2FWN3VUWXl6T3JaaEpZRWxreGpnRU4xcnB6WmVITlFuTjFmYVpaUXY5bjRlMnZDdm1seHl4QUNiaUNBUVdIUFNuVDZQZVhjOHN6dmV6THNiRjdhK1RLeGl5R3cwYWx4aFQzQjZZTmRqcHVnK0VDUjloc2xuYVRDcmN5SVpsWlFCbERJeEc3R0JnNHdQclZhcDJPcEtiMDkyTmxaSzE3L2VlYnBCWTNzczhPaXp1MDlzZ1ZyUzRMSVhWd0I1eWhlV1FBN3VDUWVjNHJFMXFmVmJ1ZTN0YkhVNTdhNHRoSWJpUzNpbEc1WE9XRzR4c1h5Vk9DQ1BhdXBnOEc2TTl3NS90YVhSL09EU1FXOHloWUhrUTVqd2p0d2NqSndjTU90YmVqanhyYVhEUlNYRm16T0dTUzVSWGFLWUtUSnVBaUlNY21Ed3BQemRCVFhTLzNHU3BROTF4MDF0WlcwK1hZOFE4UjZkWjMrbDN0ck5xdDdDWUowT0pKQkFSeUJ0SWJsbE9TZWNIT0JnMVcwVHd4YncyVnUwM2lNWGx2RktSNUZyYmplclBrcUVaaUNCd2V2ZXZwMlkydDFZMzl6ZFg0OG93bU1XcXhHS1lUZ0Z0Z0Q1Wm1ZaktnbmoxcmxrOEQ2ZWxqSk5GcTkxRkxOR3B1SUR1YVpsQnlyTUFjN3dUZ3NPdEhaRlNwU2NYR1BKS0RUZkswaXZiV09sYVZDdHlyYWxjUmxCQ0VlSVNIS3R1M3NyTGtGU2VEMHJpZFZqMHFQN1BPWlpmT2lDSjlvMnk0YUlrNUV4anlWa0pPQzJOb05lcjZ2b1VFZWxKRGNYa3JTYlFzUDJzR1NGdHAzSUdFbnZuSUJ6WE9OYVc2U3l3WFVWK2kyOEVJdGtjc2JhVDVpZGtiWStmazRJWUhJNDV4VU5SdHVjODZham8wa3ZMejh5bEROYlhGeXNrQzNkM0tyZ05CTGRBbGxYZ1ljZkljSGdzUm5BcTFwdDNxMGtFbHRxTStsbGlXRWNqR04xWkNTQXI0M01GQjQ0L0lWbDZyNGMwdXdsUVdVejJYblhCM1J3M1VzVnFISFVZVUt2bXVPZ3lGeU9hczJUd1cydHlQY1RUUjNjcWlMN0pPNHM1cmhCZ1lCVUhlUGx5cHlEd2FwV1M2V045VkszTW0yMy9BRXpBMVRVTlExSFQzc2J4b0xXZUJ6bUZyT2FHQkJnQlZXNGhJTzdQSVlmS1IxcmgxZnh2YVg4OEhuWE1xTHVlRXh4bFRoY0l4ZVdOZHpKN3FPZXRkM3FmaWU1MGRyZVhUOUt0cit4bEltdVJzbGx2SW9GYnkybFpIUHpMa1k2WlhyaWxzUEVlcjZsZEJkSXNiMWJVbnpKSTU0bzhGVG41b1diYXdkY0FPdk9lMUZucjU5U3BKMmpLMFd1WFR5ZTMzbkxlSUgxTjdBVDZtMTdMTEhERTZXOFMrWXpJcHlOc2lnTXUzcnVmNWp6Z0N2Um9ZUSttTk9tb1hDYmJaZHR2TElacDBEQWdGVlVBZHVUMXJFRVhpdTgxQ09VYW00dFdTT1kyMGlvaEozY280QjJoY2NFRVp4NzF2UStIdFV1UmJYRnpxTVZ2ZGIvOWRDRVl6TXhBVlFJOGxRTTRZQTlPdFBSYUxjNW5LOXJRdnBaNy9xV21zdEtudEJxbHpvOHhlM2dpOG5VN0NJbkVSd3hLQ1J0NGRUa042ZHNpbTJscHBjVi9kVzV1dFNsaTFHSUNSSkFKRGJTb01pWGNlV2RnQUI2WnlSWERTYXZyMnFTU21YdzVQZGxKekU0TVhseVppYmFOcDRESzJjN2lPSzlPMWZXN08wTVF1N0c4czUyVUt2bFRDWHppeW5hckZjOEhvYzR6NjBKTGZyMk9seTkxOU9WOVUzZnVXajRkbXQxOHlDSXl5aVFKc1pVVlR0VDdnSStZa25CNStVMXlHazZab2Vzd1NtNTBSOU9sRWdXWmpPWUc4M2NXQ0xHaDNrOWorWXA5NTRnRVduUnlXMFp1b3dyL0FHeVJVS0JINFFLNmcvTXJZeGtjakdUV1RMNDIwclVZN3VPejFTNXNTc1NLQzRVSkNNNDNqY1FTbWNBNE5Odm11WUtkQlN2R0x0cG90bGZyNUhwV20rRlo3dE41bGp2eWg4NjVSWkgrVXJuWmhwQVN4WDdwUDQwKzQ4SWFMY1N5UExwbHhNeFJ5ODgxMHp1OFkyL2VrQXltV1BBR0FBS2cwaTVsdE5Dc0picS9TK2Exd29XQ1ZsRzltd3BjakliazRVbnJtb1kwMFN4biszNUZtMXdSSEtGY3RGdmxLN0cya25yME9BY2RSVW12N3RSdHlLN3RkWC96TmVMVHRNc0wxWTVMeThqeHRrRnNzaWJJRlk3UWtiS0FjOGpJeWVlYXZUYWxGZExGKzZXM2xGdzBMbTR1RWR0Z1VmTUR1SUJZSFBHY0hyWGl0L3J2aC9XN2U3MHV3MU40MWVSUExTQ0tTOUoyUDg0WlFwQTJrZklSenhYTGVGZkNTV3RsYzNlbytLcHpHeHVHampLQ0FNcTVYZGpKWmdDY0ZSeG1sZlhaQnpUU2E5MksvbGQxZGVXaDc3WmFuWmFQUERhM2xsZVJ1MmZKZFpIYUVxQVdBNXdDMjN1ZUQyRll5Nng0Y2t2cmZTVTFUeXpieUJJMVo1WVdRc3d4c0lJTFpQYkFBSEZlQzJtdEphaTZpdXRiTURSbUJKWG51Rm1nWUVFN2tFWU9DTUFZQkpBOUs2SFY1ZEJra2JXSDAxZFdndkkxaGxtYUZaUElsaVliU0hISlZnTTQ2cjFxbTc5ZDlkQ1l5a25CY3RvOUxMZnJwdGM5TnZkRDE3emJtOWdQa1NQZGJRdDY1OGwrZG9ES0daRkw4WVlZNjhpdVphWFI3clVaWU5SZ2F6bXZXOHFWbEVoUnBRb01jYXZIdGpLOWNqclh6eDRZK0xQaGl6bm5zN216dkdGMUpKYngyU2pNY0VMUGtFN3dXa1lrZGUxZXIyL2l2U2RKdXJkTGZ3dEhiNmUvN21WM0daSE83anpTVGtLcmRlQ1QxSm90eXRYVE9xdFFuVGFWU25LTGE1a212aXM3YU05YXNkVjhQV0Y2K25XOTlKRExhUXhxMW8xd0FqUVpHNWdDb3d5aGozem43cHJ6ZHY4QWhOdEcxK2FTZTJ1TlZzSkxiTHhpWGZKSUdmYXVjZ0VsTTUyQTVBcjBHRHhyNEx2NTd5d2VYN1BlemtyRkswWWxWM0M3VlZHSk9kcEdGQkdEV2hwL2lYN0daVGNYaytvT2ZNamxReFBBa2JSOEs2cVZ3VjU0QTY5ZUtha3Vsekp6cFJzMjR1TFhYcDhqRnN0WDBhODBVUlMyNjZmZWJJdklobFZvbFl2bGR5c0FTblFrRWprMXptamEzNHN0TmJQMjIwc2ZNRno1YU9VWEQya0l5ekRCNGJjUjhwQUo1TmRoZlhXczZ1QnA5ekZhMmkzcEtXMHpxSkZCWWJHVURCQ2JqeGduUHBXYzV0N1hUWVd1Ym0zbHMxTzVmdEh5U0xJWEtxZk1YUHpZSHlCZm1QY1lwUDBJVlJMNElYU1drck5OYmRQbWRkRkhld0dlZlVtbWttY0IwYTNrRXhpVXJraUpjQTVQZnJtdktwZFh1djdVTExkWFpoa1NXUjNGaEVDR2s1V1JwZGd3VXpnY0hOYXZoMzdmdXVMenpCY1cwYnVpVzF4T1JzVnNBcVRoaW9MRE8xamdFWkZkcnJFYVdLWDd6UlN4aVdHTlEwYUc0a1ZZbnlwR04yYzlBTWNDbHNuZC9JeFUzSk5SN2J0ZDlqaGsreTNGbk5PbDFKTkZIR0l2TWdScHBtVlFOemJwTWhzWXlRUU1kYWhhem10dFBnamd0cmU4RXpoakM5MmZPWVNJWFJsa080WkM4RTU5Nmd2RzE5RXVyeTFlRzRaazgzNWtTTmtnSFJnd3dBRGpxQngzckI4bTcxYTJiK3c3K0N5dUo3dDFsZ2tQbEFKR3U0Z0p5VjI1UHpBQUh0U2JWdjhBZ25Pb0p1UHU2SjJ2MHY4QUk5TFRTL0RhM0VUUmFUY2FlREZpNFR6bU1RYllUZ3J1L2VCc1pPT3RUM2tQaFc2L3N1MXZZQmRzV0N4bG9mdFR3dnpnTUZVNHlSMEp5UnpUOUc4T3lSS292WjUwbmlpWnBmT3VrdWxraHpqNXdnSEhQQjQ0NjFZanN0S3M3SjdkQ0pHZlpIREpiUmlHV1ZqL0FBQ1hBR0IyQkk3MEtWL0k2YVhNcDZwUnU3THAva2NacnR2NGkwMmE1dm9MVmZOdEpkeXhMREljcEd3eWtTbktxeEF5RUF3UlhPYVpjK0dialU3bTVnc2RRazArV1pROGN2bWxZSmo4eng0eXBWMk9PdmJwV3pkNjk0MThPM3p5clk2dFBibFE2aFVTN2tYbGNSOE1kM0o1UFd0YlJ2RjdhbmF6eTI4dHpwOHNEeU5OUGRLa0twUEl1QUJHZjlZVDFJeDB6aW5icWF5aEwyT2tXdmUrS3lrclg2a2VwdllUVHVJZGNDRy9EcEpESkY1bmx0RU9qRDVRekwwN045YXk5YXROVDBmVUlYc3RMdTlXc25sZUtHMWE0WDl4S1Z3U3luSkdPUXVUaXRUVXRmUllZV09ycjVGNkhTS1czdFJNOGM3ODVmeXovR1J1OVIwclhsMFRTWmxzVnVOUmRic2dJSkgzUmgzR1BsMm9jYzdzZzU1UEl6VDIwdjBPYU1XbGYyYWtuTFMrbXA0dTNpWFI3Vzh0RHF1aDZyWktpdEphM0I2d3piZHUxblhJSzVYZ1k0RmRyWmExNDMwN1VOUnZiNndpbFdQeWQ3czZ3bzUyamE1WVpHQUR3bzZrODFWbk0yaXpSV05uclA4QVpWMUpLNWVXYUlUd1NvT0NrWitiYVRqT0RqSE9hZEYvd2xFa01GL3BHcGFacTFyYkE3cEZTWE1ZVjgvTHMzWjR6bHNjZHFMM1Zyblk0TnhwMmhhejFkM1pOSHFNdDFwbDVZWU52REdoTEw1SVJKVURNUWZOQkNFREdlbldxdGhGOW1qbU1rcmlCWXhKUGkxOHNOR0FXQkIzS3BJSEREQjlhbTB2V0dEaVRVSkxWMFpuU1NWUTRFUkpKT1ZJVGNwNi9OeUsxNzdXdFBSSVpiRlBNaVVDTzZsUTdFQUM3UTVjL2NVRGtZSE5CenFYTzAyMDdQYnIrQjRIZCtLNzI0dHZPMGl3MVR5b1o4V3NrSUJSbGxPQVpvY2JtVXFDQVQrVmVnM2wzb0YzZjJQazZkZHpQZEtmS2RKTmp4N1FTMkNXQkhKNEhRWnF3bmlMVEcwbSt1NE5JTFJ6N0ROSkZkeHlGb1ZHMFNBN3h5ZXVQeHJsWXZGaW9rc051MFZtOWpJaCswWE53MXk4c1kzZk8zbERwZzhaN0hwVDkzOFFuN082V2xrL25hL1JNNWFRWGNkemNidGJ1TlBFTWpiWUo3dUhjWHh3QVJrTGp2bmc5YTlmTnZkVytsS0xTUzJ1cEk5c2tHeVNKNUpUakorWTQzZDhkSzhxc2I3VEw3VGJ5U1d3OE82amJ5RjNLd0hjMFFZN1RzVjFRczI0NXpuUFlWMUNhUnA1ai90SFI5T2hhU013ZzIwS3lRVFBGeTdxaUVqQkpPY2pyVVhaTW9VMDBwTjg4WHNsK3BqZUpkTHN0Ylc5RnpiVFd4bEt4eVJTYm9Kb01jS1dWV09WWWNGc2NWRDRlOFBlS2RQdDVMSzlodUo3UmQ0U1R6d3JSaU1namFkaExoZW5QWHBYb1JuMW5WbzBSbzIwL2NZOWtXSWl5QXNGWldadDJTVHh6eUs1aDd5NzBxenU0UDdXYUMrdWpKbUlGV0llSTQzTGxud0d4akdPdEM5RFAyazdPTFVuRG11dE92YzdLNDhCU1NyZFRXSSt6aTVrVjNoTTRqd1ZBMnlReHFvd1Z6emdpdVhudlpXdkpMWFVMV0NDVHpmczhFMTVGSkZIS1ZCVXV1N0paMys3MUhGWU9yRWFiSkZxTWxxOElhSlVlZUNZbUk3eVFITDdSc0o0eitkZXovMnhZM21tR1dkSVl4YnFpU1NUcXBReXNCdktCOEVQZy9LUWVhcGZMUW1GV0VwVFRoS0xWbW4vQURXM1BBZjdHOFhXT3FKS2RDMHE0aWsvZG9VeWhTTHM3QTlDdU1jQTVyVlR3ZGVYbHpCY1h4amRyVmc0TWFHT1ZCS3VDUmdLTWcvZHprYzEybDNZYXJKcFRuVHRWYlVtTWZFTFJsRmNPbUZFWlhBVm1QSFBGZVplRjd6VXhmSlpYb2xtVENIQ3VKRVVMbFhYYkp0empISUdSa1ZGbmN6cXZXTXVWUjB0bzlXM296dEUxKzAwdlVMeXdsTjFxQ1d6eHhzclNpS1UrZU1CZ1NwVXV1UndUK05WYmRCZFFXOXRidkpNNnhNcStaQkZKNVIzQnNqUE9QVGQ2NEZaYzBGOWRxOEI4aHBnanJiVHZGSjVieHN4ZFZaZUZWd1JrOXgycnlheWs4YnozYklYczFpbUlsbmEySVp0MGZPWFZNTU1kNmZNN2JiRTM1MXpSNVlxTjkycnZ5WGZ5UFg5UnR0ZTA3WkxiNjJZSmc2dVVtakNwT0ZKZDMzcWNBeHFjRWRRT2xkVkJCT3J6eTZsRkMxdnFFa2FLR2xqYVR5eGdxUVc0Mmp0eG11WTA2U3drc1ExL05OcVVUQnNSY01oZEI4b0ROc0pjanNSanRXcHJYdzE4TjZuZVNYZHRHWkZpalFPcXpxeTVPRHNFUnlCSVBUSUJOTzEyalNsRlZHcis3eXQ2S3piT3N2NUpZRk41QnA4RnZzaFJBNVlTU0Z6bjVJdjdwUDhJSFZxNExTdkUvaDNXM2t0TDd6cEpKNGtFc2J3TUpyZDFrd2drMzRBT0QwSFhGY3g0ZW44UVd0eERwZjJ1M250aTByckhHekM3aWtLbmJHeW5DNTQzSCtIUEdhOWUwWFNmRGR4clQ2a3ZodWVDNGpDdE05d3BVRU44bTdjQ1lzODR4d3dyUkxlNXZDbFQ5NU4zZGsxWjNTZlc2UE45UytGMnRuN1Zxa1hpUU1ReHVZWXhFSW1jS3BaaHUvaElBQVU5czEwZWhhcTE4WWwxRFRZb1RieFlaTHNGOHNNRUJwR2NuUHNRQlhwUzMxelpSWEVMd1cxdWtVMXdrYUlXTE5EZ0hjZkxWZ09UeDM5UlZuVEpQRHR4YnpzSTRQUGRqQklURis4bEtuYUdmWU9RYzRIYmlvMGZrYVRVWk9LWExGcTEwMXY5eDRycW1pNktuaW13dkxyU1ppRmpWbW5nTFJXYmJzaFMyU01CZS8wNlYzVVd3TlBQSTA0aGFJek05cmRGVTJzU0F3akNobTRHUnprMWMxUU9zRHh6MjYza051WXdGakFlUXlLTUVHTnp5QURucWMweDc2d3ZJN1d6MlNtT1pHaWlrbGlFWjlHUVJ0aG1BSTdIUEhGRDNNV3BjM1gzWTJTdGY4QXBGdTQwalN0Vlh5b05RRnhGRUlsZ0U1VjE4MStyeTVIemtucXA2SDNxdjRkdnRkUzhudHJpQXRiaUFxU05zVVo4dmFGS0JTZVFlVFhqNXRkR3RQTXRacjN5MXRrQkl0aTZ5Qm96OHlscE51NE4xNStiSFN1eDBQVU5EZVdJL2I3aDRKR1VSSFlvMmtIY3VTaEs0OSt0VTd0R0xxTG1oSzNXenRLeVhrVTlTMGZUckRXTHU5czdxZXpHNlJ6QmJ4WlJHWWZOSklDVDhySHRYUzI4ekpZUnlHVGE2SVFkdHVwaVhhZUI1Z1ZTaEhxZVByWFZ3UmFVZFVhQ05MWjVJc1IyNlNidmwyWWJ6VVhPQ2NOMTZucFhPNi9xbG5GY0M1Z2hSNTdOViswUnFydytjQ0R0VU9HVlY1L3ZBNEhGVDNOTEp6azNOSzdmMzNQTTdyeFByNzJrVVVUMjhOcWJpUVNTT3U2M2pVb2NLTUtEa1o0YkJybFk1UEhOcWtFZXBlTHRQbHM3bUV4ZVhKdWJ6VkkycTJDaDJudmtWMldtK0xCZWFlNHV2RGt0a0pKbWdacEdqUlpQTU8wSE12MzNIb0RrVjZwZjZyb2F4V3NVMm94UW0zT0ZqeEMyV0s0QkxMbkFJNlVYVmxycVVwU2hHcEJwTldhNW5aNzlFL21lS1dNcVhtbitUYVhOcGN3MjBpdGNRbDJ0eTZnQUE5QnVJNzVydnRUMW5VZEdBYTlpWUY0aEh2aWJ6VnpIeHUyakEyai9aNXhWZTkxTHd5dHpKZXhhekdzcGZBWTdSRXdLNDhwUnpoZ09veGtkNmpndjdPMThxd2p0TVJOS2todUFTKzVndThaNUJZWk9DVGdldEtLV3B3SnVEVjAwbHM3M3VlWjZocTBkN3FoY3ZaU3d0SkNxK2NESUFYUTVLczVVa1I1R00xMk1FOTFISGRhZmNYcVdCbll5MnYyY0g5NHB3cERuUHpaVmNISGV0VjdpenRiaElaMnRwVm5DekpEQmFSK1dDVXh5V0xFTUQwQnJSbXRyQzUwaTB1V3ZIdUVqbGsrWVJCem1UUHlZakdZVG5uUFQxcW1ySW0wbko4clYwbTdkTlR3dzNjVU90Mnd1aGZtYUFyKy9lTWhKQm5JWG5kZ2tIclhwRnRwK25SMnR0RnJGL09nSytaQmQ1VlpOeWs4eGxncGRRZXE5cTdUVTdmVXhhMjk2ME4xTGFRZ3hwWndUN3BRNEFRc1hBSUREdUR4WEZUV0N3YWJkUmF4cWsyb2lKL050bG1CdVhVTGdiVndGNkE0YmtFNHlLVHZaTTZ1U0NqZTdUWDJXdmllOS9RNTJ4czlhc2RWKzA2VnJWdnFVY3NUeXY1eUdGMVZzYmh1SklRTWNuY1B3cmIxVFR0WENUUzJURHlybmY4QWFvRGVicmUzbnovckZEQldIdnppdFBVOVEwM1MwUzRTeG5saGs4dEZ1b1VKS3FnR0lRQWpEQUk1RGRhbk0zaHk1ZVl0TElYU01KTGJMR1czN3p1WjMyOVNNWXgyNkducG9aeXF5YXUxSGxhZXRySnI5U25hZUpJWnJPRzJiVnJYV0x4cER1WlpURXNjWDNDR0hPN2RuQTlhcy8yTGNXa2x2THAwbHZibTJVeHRFei9PWmQyN0xlWG5PVjQ1NHJSVStESTU3bDlPZUNLWTIrOWtNT1BNeHdRY0Q1U0RnRUhpdU50ZkVZdmJvUGUyeVJuZVA5V3U4RWtFNEhHTjNYUHZ4UmQ2MkZXbEhuZWllMXRyK2IwTnkwMUc1MUhVWkxlMmh0dGpJQTZPZkxsdHBRcEpHSkFNam5nakhwWGNMNGI4UTJzUzNGamJKRDk5RmpYRU1yQ1E4WUtqQUI2akI3MXkxcll6M1RDOHNMRzBkWklYRWQxY1MrU3NlZlZXeXc1NUE1NTZWem1rNjE0MXNMT1ZsdVpaaHVPWlhpZFlsVU50RWdMOUV5T3RLejBzRVZHTUU1eGtrM1pXMzlkVDBPNWsxMkxUSXBwcmFCWmxKT3lWM2xrVlNBd2tVTHlUZzg1Nlk0cTdFTmR2a3V2dFZtZ2dsS0pDMHJpWlpGWWc1Q3lFZXZKcEo5THZkZXNiWFZKTCs0dHBXUkZmeUhqNVZsS01oNDU1T2M5YThGdGRJMUd3MDY5dDdxQ1UyZHY4a0U0a0Voa0J4dCtRbkl5M1EwRzAwdVRtVGJWbFpYUzA3bnJvMHpUekxEYVhGMVpyY3M1M1JwRUVhTTdTRk1hcTNHT3ZKcktzUmJXbW5PNXZsbGVCWW1aUWhETUZQRERuSUxkd2Mxalh0bm9zdW8yTWphY0xpYU1oa2x0b3p0TEgrRXIvQUJiYzg1NzE2RmZ4NlJKcDl3aVhGdlpYRWpIZEo1Ui8waFpCaGdwUDNUbnQycWI2NjlUbWtxYmQwb3FVVnJkV0dXT2xoamNhbWRoKzFCNVBLdUZYYVVpWWxIS0FrRnowR2NjVnhsMW8rcXl4bDlOMCt3VzRhVHpvNDdsdHBDdTI1dGpjS3Z1QWF2cnBuaHVMN1hjV2N0NUx2dGtLdEZDek1EQ2NzNDVJQVlIbFRqT01pcTNoZlU3eElSRGVUT2tjdTJlSVhFVHNpd1pIbUVZQXdWWGtIcHpWWDZHMFp0dW5lS2NOTHUramZWR1lQR1hpRzIxWklMelRMTlVLL0t1V0VoUkR5KzRqYW96bkdNWXJzOVgxWHhWZk1OUVdmVFk3U0tSUXFuTXI4WWJkbFFXM0NxOGw5b2tGM2N1dHhZM0JnM0c0SWZiSUVDamJzREhESGpQQnJoYjI2OFB5eXVuMjZieTV4SjVFaW9WUEF6aCtCdlVrNEhBelFyQk4xRXBYMGkxMGVsMTFPaTBuL2hMTlUwMWJuVDd5MGhlYWRqQzdxMjhiQVZPN2pMSzJUakZVdFc4TStKMGhKOFFYc0MyMXRiYmZ0ZHNFTWlMS2NBa0FaQXlTTTQ0SE5jWHAzaUU2VGMvWXRTc0ZXM3VrVXdHTm5EQlFTV0p4eU92ZkdEVi9YSmZGc056SkhGcVFhT1dXTno1S2xtVGNNS1dWdTdyNlpGUnV6ZGNrS1M1bFpQM3IzL1cycDZiNGRqYlNXUzZsZ3RZcEFpUnhKejVrMFFBV04ySUJVWlBlclRYMTNxV3FYaXpSUW9rdHI4Z0VoQXc1Ky9qSFFleDVyNXh1Tk04WEo1bC9xV3FUZVEzbUNLTm5NY2pnT0ZKSUl3by9vSzlOOEo2UlpOSzBodVVsZUZuYVZ5NDhtSVNLVVU0eWVqRE9hclhYUTVLaWszQ21wcVMwMnZ2NTM4aDl2b2RoYjNrNlFYdDRrcXF1OEJFa1Y5M084TWVCakFHT3ZlaXJRMUdTM3NiYUdKcHA0bWpSa21nV09OV1pRVWZseUI5NGZVOWFLbHBYMU1YRnQvQ3Z5L004dkhpelJ0ZHZZN09QU3JtRFVaOWlRU2VZeXhydWZEeWhSaEN1QnljWnEydWxlRHRLdjViU1B4SUpubldaYm1keVozY25PQUVHRjJxUnovZXp4WFhYZ21rRWM5M3BodDVvbURDNWRHQ3hkQTVad3VWSVVjNTRQY1Z6ZGpQNFQxN1YzdEV0WXJ3eHhnVE1JQmJvMFNrL2NFUUJjcVBUK1ZWdXRFN2QyZXBDb3BVcEtOS3JHQ3R6ZmFzMC93QWoyYTcxZncvZTZQYVc4OTVvN2gwUlk1SHR3V21BSDNuaitVcWNkQU0xQkxwWGd1MjBmVjVWdVpwWTdtNFJmTmpZTlBFeWdZWkFod3BibkhBeFhBejZObzBMc2lhZXNNbG1SSTh3dEpMZWVKSXpoWEc5OXBVTHdBMkFldGRiYStGOUhzaEkwMXpPOEVzbTJCRjVZemJnVWRpdUJ1SUE3NDV4M29VWHBxWnViVGtrMjc3OHkyYThybkQ2UHBGcXptN2plZjdOdkdVWlRKSU1Qa2plNHoyeUdBQXpYdFY3cDBVTnREY0cvaW5GdWdkYm01M2JWamtmTzB2Qjk3SGZkWEY2dUxjNnBIYXZmNmJ1dGc0S2JKclJ5NTRVL3VUdGtRbm4xeFVZdVZodWtoYThnS2lOUmJ5eWdyYXVVQlp6R3VBZHgzSE9lT2ZhaEozVE1KSmFwMmsycnBYMjZGRzdpMUc2VzR1cE5Wa04wckg3S1VtamlnMnVDZk5qYzRKVE9jcVJqMHE5b2x6Q0xTNnRocGNkMUhkTHY4NFNKRzl5V0liYisrWUhBd1FDRDZWMUR1TDI1Ti9KYTI5aktWalNTM3VKUTVsSVVZS2hlQ3JyM0hGUHVManhTYkZMZjdMcGR2Q0VLZlBOR0FDVGtSN2RyZ1pIOEk1cFNUUW9xYW5KT04xRy9MMmZUclk1cEhzOVFqSXRqZVcwMWtUdWFYTFJPSDRDL01jTU9BT0Q3aXN1UmRTaC93Q0poREpjbDVXU0tieUp0NkZZMXlvWHpFWUlBcHlEK0JxV05iclZkT2tzN213dmJlMVo0d0d0bUVjYktSbkRKenNEWStZZzQ0NUdhdDZOWng2TEhhSC9BSVIrN1dPYTUvZHhRU3JJN3lybGR4SzdjS1A3bldydHBzN0drcDZlNjdYdHBiVFY5ekF0UnJYOXJOYWFqY2F0ZDJzMGZ5TzBpS2tDNytOenFwQzU2WUdUNkN1MU41NEIwYTlpdDR0S3d6U2p5YjJDRldkWmd3M2c1NURBNHlPZXRXdGVqMFp2REhsVEplV2NUeXl6dUpkMEVpN2prTkN1V0dHNlk2NDVyZ1lOTzhQeldkemM2VGQya3R6Yk5JWkxnTzYzYWJYTzltSTVKZmhXeDlhZlhzZEthWE0zSFRsOTVycjZuZStKcnBiYThTYUhWOVFzcmFRbVBhcW9qU1BMamJoVUJJR1IzNU5kWmJQZVhHN1RwWGFObUc1YnBiaFpkNkVES01vSk9UMFB1TTVybmJTNThZUjZlNFMrc2JLTjlteHA3ZVdSaUNQbURkVzNjNVhqSGV1QXRQRmMwTjljUmFpanlYc0VFZTY2TjBzYzI1amxGQVBDcm5rOEEvdzFPbDJaMnZGTlN2WjZycFk5QnRwL0ZOcmMzRmxaYWxvTjIvbWVZSVpaM1U3aU9BeWpka2pqa25tc20xMER4UkxBMTNydHZwOS9ITHQ4d1JTYldEZ25oQ0ZVRHQ2WjZWM050YTZwREVRdWdhY3V3U09ycHNsZU4xVGZ0Q3JqR01ZeVRtdWZlelc1UWFqcUdnNmdKVmlESmNTU3hzcWxUd1BMUTdDdVQzSHpVS3lScEtVZlo3Y3JXcWFUMDA4K2huMmsydVBxN3hmOEk2c0VJdGxXYnpIM3VGN0JXRWhYQUxjSEhTckZybytrMk05M0JGQkxnYm1TV05vYmhnckFIS0tCZ1J1ZUFUeld5bDE0ZDB2dy9CZm0xbmVLS0xGeW13RTczYklEcjk1TUhwMnFhUHhCSmMzZDdhcmJvWWhENWd1NW9nSVZpWWJrSVlBZkwwUHQrRlFub1I3dnM0M1dqZWxsZXhTMW5RRXU3WHluMUo0WlJiU1NMc1lPMHBKR1dseUNBQ0JnZ2M5SzhlWHdEcWFYMWxNbmlhT0N3bFNRaGtVUlBLZ3l3QVFmZUlBNjhDdlFkZDBaSWJFMzhVZDg5dEZBelQzRWN3aVhKUExxNGJKNEk1eDBvdC9GRmtOQTB5L2x2SUpZSU4wQXR6S2Q1Y3JrTjVoendSbkc3b3d4VHVoeGxadGV6VzFsZUtrbjh6ckl0UHZOTzA2MXRkSFJMbDQ4U2VaTE1xa3JMbGdYM0xoZ1R5RlU4anJXcmR5V1ZqZHVXMHhZSGR3QjVOeUJKSkl3QVpoR21FR1JrazgxNXZZZUlkRWVXMWdzNHBJSkdpZGZLVjkwaEQ1SUFrakR0OTdwZzlEeFhXaHJXU3gwMlBWcnRiWjFSTjdHVXhYU3V6RlFzY2FlWmtNUmtGaitGTDBLakxtakp3MDdQcDJOblVIOFZNdDdGSEZwMWpiUmtuSUhtS053K1ZtQ2daRE1DZHZmR2E4WWZ3SDRrMW5VSWJsdkVzdjIyeGlpSWlFWjh1UlRsbmFFT1FTcW5IVWRhK2dKcktDSXF5UTM4a2NiSDkwOGFzQ3VBeUtSajVzTnl6ZGNkQ0s1NllXVTB6U1c3Q2RCS0kydUpJQkhzblg3MnlRZktTQ09oR0R4UjBOYnVNNzN1N05POW5vOU5MbzBOUnVZTEt5V3h1ZFN2WjU3bVg1R1dGTUsremFHeUZBT0FNNE9RRFhHM2tTYU16U2FrazAxck1qSXJKRzd1VmlRa2JURmdLekU1SjdtdGlXL0VJYTFqa2xCd1BMKzF6S0ZabTRMT1NmdmRNK29QRkpxSGp6d1pvMW5ETmU2aWs5MUEwaStWREpsZDcvS1FvVTRBNHprbnJWSys1TVkrMXFYV3JXeS9NdzRiYlRXME9XYWVLNXVyWmtpQWtuaUtYUVVuQ3FWakMvT3E1Q3NlM0JGZERwZWxlSDdtNlpMZDl6U3JGQXNIbmVjTmlvY0ZvZytGQTY1d09hOCsxZjRpeDMxbGFXdW5lV1pMNWxsa2lMTExqTENNUmt2d0FTMjVqN2NWc1FhZmRSYW5iSWx6WldzemdLWTdVcXpsRlAzSmNnRmdleDdHcDZHZFNYSzF2SlBmcDFzWjExNEQ4UHdYMXJMTm8xMGdlNjh3eEc5OHkyZGlER3JLZUEwaFBJUTlUM3J1clhSOU9NVUVkbHFjczRYelRHR2tSajVvWFlTY2ZNUExQT0NNQTBsbmQrTUpVU0s3c2tXMmtuamhoOG1VT3pFUDh4Y2Joc3dvUFhwVUYzRjRlc002dlo2aklmT21kN2xVTVNUVE9XQkFVdjB4eGxlRDNOUG1seTdtMVNjcEpLYmNra3JKdlpka2REcDJsZUtydlVyL3dDMWw3V08xVS9aMUErVzRVTTJXWnNuYTNRakgzaHdSWEYzbmlYWFhpMDJPNGhudFo3cTVlT1NScmFRSzhDWkdDQVdJWWhjK3dQTldkVnRmRmwzZXF0bHB2ek0rV2tsa1pVUU9DUGwzRWg4QnVnK29xdGR6YXhhem1LOXNSSEZIYUl0bmVQRkxDWGtkakVzV2R4QTNCY2tuanBtbSttaG5VaTNGOHFsdHEvUWl0OU4xNjR1YkdheWEzak0vbVIzQ2IzOHRrQkc1bEF6ODJTTWs4SFBGZERHbXFXRGw3alZFamhVbUlRSkd3U1dYZDh5RnBNREpZOVFPUFdxVm5mYXUwVnlOWXQyc1RHWUVXYUdWUTg4c3VNUmtvellpVGc1NnNldFhXOFRhVlphNWJRM3Q2czhkeE04WnVReXJDKzRjUnNPZHJIcHhqSUZTMTd0eCt5VVd0ZGU5OXZXeHhHcWF4cUZwUExjTjRnczdMN1FqdmIyMXkrRmlVWlZrQTQ3ajcyQ2M5NjlLMHFieEhyK2dTenl6V3Z6UVBza3M1aTZrc2NmUDVnWEtqcGdkZnJXWjQzdWZDV2thZGF6WEZ2Ynl4TVZhTmxqODVDc2Z6WVJsQng4eHhra2pyeFhCYVQ4V3ZDQnRIbEY2cUF6c0dTU1BFVUtMa0tJOWdHTWtnODk2TFBUc2RGT25KWFRqT1d5YlYydkphSXBRUitJTkN2YnU2bTFHNzFHSzduZmZaMmNBSTJvb1RJRXBKakdPMWQ3UEo0ZWcwb201Z1MxdWRpaVNCWEpuemo1VWZZQUd5TzJNMXl0cjRsWFc1cEJGcDR0TnJ2OW12aTZySVM2a0JkZ0FaZ1c2a2pCSE5ibHpwdW42elpoNXRWdXJzbG92UDhBa3l5eWdnQll6R0Zjazl6enhUK1J6MUpwdEoyYmFYUmJlbmtjSk1QUGUxMDY4K3dQRzVZV25tYjRuZFZCeXJHTUFZVmdjWTZWMHphZm9HbzNXa1dWdFBBeXh4RlpWWi9PalRDcklINzQzWTRaajI1RlZwL0Q5L3FEM1l0OVV0SmJkZHp3aTRFTHhzSStyT1IrOEpVa0FNYTRuU1BCMm95M2NDd3RBa0NXOHNjL2xUa1J0R1FWRFBIamNSalBQZjBxWG9ad2pHeTkxLzhBREh0aTZsNGJqc2JTUlREUEhML3kyaDJCVmtiS0FONVhRZ1l5M1FqbXNHK2gwdlVsYTNubHVMbUNQbGlCSEZGRy9KM0l3R2ZLN0E1eU91S3lOTjAzd25aK1phdzJLU3NJRit6T0k5dVpYNk15cUR5ZXE1NkRyV1haYU5JOGt5eld0azVpeDVhekJaSk5xZ2xpRWpDcGhXUFZzODlLMFQ5NHpjNHlrN1d0K09uY2xuMGkwc29JSjdDeU9xb0pWYVMzYVJVVUZsQVo0MnlHM2tqNXNnNXJndEsxaVhXYnlSVjB5U3pXTjlyUU9nQ0NUcEp1anh1WUVqcU1ZeFhaNlRmNjlmeVNRVGF6WXl6cE1ETGlOZUNGSUVaYVA1bEI2QWdjVmkzOE91MjkzTTkvYXBKWmhrV0NhMnVSSThhYnNzQUZBYzU3dDFvdTBWSzBvTzBJeWFzNzN0K0hVNkMyaUZ2YVNmYVZsVnNKR0NqK1lzSkF6amEzek54MnhqbnJXYTkzcVYvbzZTeG1WYlcyZ0VnY1dvZEhPUnM0TzRnS1FjOWNEbkdhOWFpdXREdW9oRkdZNFhFSnlMbmVIakdNNURTN1NkMzhPT2NWeEY4K29hTVd2TUtxbkNNeXlPb1F1T1JJRlZ3emNaejBQclEybW1aUnB5VFdsL1QvQUlJKzYxVVNYVHhIVG11TmthM01Ud2lTWWVZZWhsQ2hUd1B1Wnp4ZzE1NWM2MzRZdm9yalpkNnJiWGNTc2ZLa0pHODRDY0Yxd1Z5TURKK1Uxc1Q2cHFsNUpPOWpxbHJBVGxtZXhEenA4aHlIbTNZQ2s0KzZvelhaNmRwRXBtMjMyb0pMNTBMNzFlZmM4b21PQW1BQW8zN2NrRWNEclNkckhTM3l2dTl0SGEzcmM4WXZMeTZmVHJPRXg3WGtIbUxINXhVS0lzWkxxcENaWThnYzRBNXJLZ0JrdUpGdll0dUkyTU56SThaQmpMY3RoY2NzZW5JcjJyVmRJMGEzc3pMSFpha3NpM0NTdkdxbHR4QjMvSW5KWlIxTzNvS3lsbGVLYWFZMlJudElwQWhoZ2d3QVplaTQrOHd5ZVQyTkM3bksxWktISmU3MDNPWXU3QzV2cHhiejNjb2c2R01YTWNQeWxjL09FM2NINi9qV1ZxRnRZMjEvSGRReUlaSnZLS1NNd2xTTUFjeG5LNFhBQXhnVjZERFlhZDltVllCSkZFWmxmTTF1alpZRWgxQmkzY0FEQTNjY1pwYjJYVHA3RlRldEhBc2lKQ3NvTW9RcHVCVlgza0FBOUMyUFEwdW92ZTVWSHBaNkk4KzhUMit2RytlYUM2c28wQ21keVdXUFpJcHh4R2c0SjR6NmdjbXRQUk5HamwwclVMcTR2cmU0ZDdkcmllV0s1QVhnNVRKYmo1eno2NU9LN1BRUERGeExQZjIxcGNuekxVK2Y5bURSdWl3TW94THRZSE9lNDY1ckRmOEE0Ui9VYmlPMWgxbTFTT0JXZVdKbWNFanVyNUpIeW5rZGhUU2ZZMFNrNmFpNldtNmRyWHQzT1RlUFRMUnJqVUwrL1JiVGVQSnQ1c2toaUMyMk1BZk9BVDh5OERQVTBtaE5IcWNhc3dlUzBqY2RaMFJWakIzRE1ST1ZVazhHdW84WitIOVNFczJxUlI2ZExaeW8zMlNQTWFqeUJ6SnNmSkFZTmo2NXpXQmQrRXREbjBXMzg3V2x0cFVRUEVWUkR1aWxHY013RzNoOC9NZmxxWkpkZEdiS2pHMFU1V2ZOYm02YUwrWGM5b0dsNlRmNld6enpQRk9rc2dqUWlLYVFxNHl1ZG9BQkhVZjN1dGVVSjRkMS9UTlF1SXByNjVNZDY4Z2kzN2ZzOGhJRzBPZUFNbjhjMTJlbmYydlpDR09LTnJwbzRpeWdnSjVnMkJsMnZHeEVnejBQMUdhODFpaitKTTFwQjlydmpIWlN6dWtad1pWa3dCdFJqRUR1Sko3bkhITlNUVFhOQ2F1b3RLMGxiZjVOSFN2QmVKcGpMYzZLa3BobFF5bGtVeXdTbmdyZ3R5Wk52REE0RmExcTdOcE42UHRoUVJQQ2swVWdWWU5rMlFKWkZ5Zmw2WmJwbkE2VmZzRHJOL3BVbHQ1bG84bVkzY0V1MGpQQmhTaERnWnoySHJpczNUZkRWNkpOU2ZWZE11RlF5Ymx6R3JOY1NvTXFYVUVGRlU5QjdWYTY2Mk1vcTBFNHE2aW5mNXZ6SDNOelBCRVMranhRUWJpOEU4U0RhYzVSZ3hRY0VEbGw3amtWVzBDNTB6VnRORWQxSmU0UkRDN3BQSVRjb01NUE84c0FzRDJ6MEhhdExSNVd2L0NtbzIxeHA4MC9sYnBKbzVsTzRPMlczeFl5SGo0d3c2OXhYa1ZoYjIxaWt0eHAxM0tkZ1Z4YXJKNStGKytWQStWaUkrdWMwVzFXcGNOTGUvSlNiV2oxWFk2eSt2ZkRGN2JmdUxSWHVzTHRNWlp0cWpnQlpCakcwOEZjRmZ4cnJiUzgxSTJVc3RycHNobk50QkZMRE9nTnY4eDI4YmlTUXc1T085VlBCdXRlQmRiKzJRNmJKTmIzRWltU2VhRENMaG1CVUFNTWh1TTRIdlh0MnAzZmg2Mzh2N1BlUlFsWlJBRmUzRXprRWp6UXdCREJkM1UrcHFYRnAydTBhVHAxVld0VWx5Y3FTNVphTmRkanllRFI5Sk43WVFqUWJ0WkdnV2VFNmRJWVlveTJXNktRVllaT09ja1YwTmpvMTVCTVo1RGMyc3I3SjVRK3k3Q3NjajVEOTVXNDY4NFBVMUpya3VsZlpOY1JHdjd1YUh5VU1hT3FxeWxnUDNRVGxCZzllMks4NTBxNTBLODFXMXV0VXRiaXhFTnU3R1VTamJlWitYY2RoVWs0R1d3QjA1cWx6UDhBVXRmdkhaelRhNnQzdjBQU2I2UzV2VmpXNzBoSkl0ekxCTERKNVVzWlZkekVUS3dPODUrNk9QWE5RNnJwSG1xdzFFVHl6d3hLc1MzTVRzVjg5Z1JpZUxidWNkYzhZUFd1c1h3VjRYU1lYMm43NTVESXdXSmJ5Um9lT3BiY2NoOEE0QUhYclZxSnRXMHk4bWtlNXV0VnRJeHZlQ1RiS1VrYmxSR01EY1VBT0NldllacE4yUy9NM25IbGFUazlMV3RzbS9Uc2NEcFdrMkZ0OXRUUjdHRDdYSk9yTjU2YmxBMlpZcGxodEJBNUpCQTZtdG5UdFU4VFIvYXJPVFJtYjkzSkc5MUNqYlVhUlJrQW5naE05K1QycmJ1TmZzaEdmczJqdUpZcENZQmJ4RlpIak9keGpqYkgzc2VvRGUrS3p0QzhSTmY2UkxxTXRqZFF3M0FNYUxrS0FvRzFIa0p4bFFSNmZqVld2YlVpMFhOM20xYTZ2MFdsOVRuZkUxNXBscmNhTmJhdHEvbG8wQ2VmS0pDRDVpcUI4OEpETVZJNUxqbER6elZud3JwdmgrTnJpRzF1cmpVWkxkbWNFU0V3R1oxeUgzc0YzOGZkejA2NHpWVzQ4WGVHSllKVGQ2TmRpN3RqKzVta1JKWkdVZ3JsUXl1d1hBSU9lbmFuWEZwWVgrbzJsekJiWGxpSGlTTHp4ZG9DaXMyVkoyakFkUU00T1FSMTRvMFNDVXFjVkIyV3R0YlBYL2hqc1pURmF5WE5wSnBOcXRuY0lCYlJUeGtaa1VBT25tQTQrWmprRUFWeU9vNlg0YzFEVDRnK2tSeW1hQlZsdEhtaGxrOHFEOTJXVTd0M3luN3ZKNjExK2hhalpYMnAzZGk4MDBGeklvWXd4eW9FTWtZd1pWVlFGWU1PY0RxZWxOOFJhVnAxMUo5cHRraXRKb25JVzRlell4b3lIY1ZJNVhQSEJINDBYMFZpcnR2bmpOTFhSN1d0MVBJZEIwUDRkV3VuV3NFVStvMjZ6U0F3Um1TZEJHUVR1S3VneHRCempua2RhNm9lSE5ldGttZlNIc0loZHl3TkZjQzRmWWRwSlVGSEk4cHNMa2xlZXh6WFp4MjJsNjZoMDZabHVvRnQvTWllTzlGdSs1VGovVktBWXdPQ1dCeGsxd2NtbmFGcHNjVWxqYTIrVnZwRW1hN2VXWlRPd0JkRllodW80TGtZejlhcTczdnF6V2RhVGh6U25kdDN1M3YxMWZuMU83VFY1YnVUN0pxVm1aQkVrVXJ3WWh2SXd4YzdXaklJRzNnNEo1ejFxN0pCb0kxajdSWnhJanlKSjlxdEhsbWpsZFkvbno1WWJENUo2am9SWG1RVzgxQzd1TFZkSmp0d2ticGNHV2UxOHBvLzdwOGtCbzhFQSt1SzYzVHBkSWU1RVVNa1Y1Y1J5UnZJbm5sSkZrYkVickdXL3dDV2VNbkJIT2VhVHZmb2M2bmR1T2pmbTcyOURVdVk5S2xsdGJtRFVMbTFTVlMweWVjaUYwbVBLc0pzZktjOEVuSkhGVkxhdzA2MWh1alk2eWgxQjJHMHVGM01PUWl0d1dVRURBMm5nOUR6Vkh4SDRLOE02eGJmNlpvdDVKSEEwODZlWEs3TklwSU9PR3h3VDhwT1FCMEZSV25oYnd2WlcxckpINE8xZVNXTzNFZStkUE04a0kyNWNGbUdRTTlSak5GdnZOMUduWlNkK2EydnUyWHlkLzBOelZkVGNXOFZ0KzUxSzZsUlNiSzlqY2JnRDh6ZXpnSEJIYnFlSzQ3WE5GOE56MldEb3FiM0xvYmFTOWt0bFJqajVvTWtwODNSY2NHdTZrbGMzc0VNV2p2QkN5U3hCVEdlQ1YvdUVuRGtIbGpqUHJYTjNlcmEvY09IaTBqYkZwOHNBaFl4aTY4MElTZ2VCWTJPM3NPU2ZwU1cyaG1tN0swbW1uMnYrZXBwWC9oZTEwL1NaSjdmU2J5N2Z5ekZzVzUzdEZnWktoaUc4d0VuYU4zU3JWL3BGbTBLWHVvMkxXYUdOSW5NaUF5RUt3MmhjZzhuQVhLWXowcDAyc2VPUE11cDAwMktMRFBHc1FsY001alB5bGtsSzVIUElQVVZ4Y1hpbngvUGVteHZmQjJtU3d6eUttNks3M0twak9ReFVIY2M1eUFlbE5OOUdpNDA0VDlvOW5GWDFhVi8xWmhUL3dCa1g4dDFjYU5MZFc5NUZMSjViU3hqYTh1Q1FxTmtGQ28rVW5IWEZjRHJHbDZwcUYzYnphaGUyK25UUXhScThTU3M4TjFJQVczYjFJS1NjL01BSytrYnhmRVdtMmhqdHRGbG5qaE82TVc4L2ttTU9CZ0tHRzBrZXBQSTR4WG45ckQ0bjFpNmxhNzBpS0lOTTMyZHJ4UWtxdkdQdlBMQ3UwZ2s4SDBIRksrdXF2NW5OVWhVZ3J3akZONzlYMjJacWFQWVJXVnVsbGRhcE03d3FoUlZ1MlpnODQzSGNmbCtWZU51RHdQcldZODlwWk8vaytIVE5LSkFqM05tUmRiZVR0Ylk1M0k3YnZmTlg5UjhHNkpxRm5lUHFOeklra2dSMjNveG1nT2NLNDI1YkRjN2R3eVI3MVp1dkZseG85MVpSVzRFcnpuYTI5L0pZUXFvQ0JQTUhMdGpPMXU5U3U1bXBLNmMrcmQvVDd6aC9FMFVXcWVJRFBGcWt0cnFjZHR0bmVGTjIxZ1AzYXlFTUYzZG0vU3JHbnQ0by9zNlczdEx5U2E2amxWVDlwaEpkNHZMQTh2Qkh6QkQ4d2JQUHJYZld1cnc2L3FrbzFpM2phQzBMSzdBTWQrL0JLeUsyMEVnWXlweWM5SzZ1ODhKNlZQUE5IYlhVclNXc2VJRmVUaVdCaGdvOFpDZktwNUM1eWVjWXE3NmZJM1NsT09rNys5cHpXdnNmTi85bWE5Wk5iUWFwOW1tdExpNVh5RnRZSlZRN1FlU1lCeTVJTzVUMVBOZTd3MkVpaXhudjlJamtqaTJ4K2M5dVZBQndWTEs0RFJub3UwakFJNjFyMmVrYTFESkcwZDNIZVJJOG5sd3FwWmtSRjRIbUFnS2M5QVFTS3hiNjRlM3RETmM2L2M2YVF1OFJ4ZVc2Yi80bmVNL3duMGFwWDlhbGE4OTJyY3pYYTJpTXhvN0QrMElrdTVKN0pKSWtOdEJCR2tTTGsrWUZrQ0JoNWhKKzhjOXFiWjZUNFFlNW1lWXgzRjNjU1p1THJVSVc1QXdBc1c0QlNlUUNmU3VSdXRjczNodm5ndXJKSW1VeHE0Z2VaRDVyWnk4WTJBY2dsaGc0N0hpclMzUGhmVnRPbnVsdnBiaExXNlJmSlVsRmxuKytyUnhPcmtSa0E0QTVJclNTMnQ2a1JjcFhkbDFUYXZwOHpwSU5PZ3RrZ3RiSFFOTmhWSjVWV1A3VElCSk11WkNkNCtYY0F1VlZ1VkZhbG5helFHNUkwUDdRa3NlNlZ4TGlSRUp5d2lrd0FGUExEbkxaeWF5V3VZSTdmUzlKc1ZTeE1UU1BKYkxiU21ReU9TMjdjeFlFWkl3ekFjVnAydXErSVJZWDBxTkZjcExCTXZtK1EwVzE0MjJaM1NmdTFHN1BUdHpTMTJzT1ZuVTVydDYzdlpkZlU1alZHMFc0Zzh1STZTTlFWb3hBWmlTVkN0a0x1R1ZRQU55Y0hOZERwZXBhZHBOMXBseGVTTkxMZHhMTTl4WW9GUXdxT0ZmZGo5MlR3V0l5QWFpZTJ2TDZ4dTdyVmRMKzJ4bU9CSThmdWs0WEFZT2puZEh4eitkUnozR2syV2gzZW9Ob3lHSklVWHkvdG9rank2OUlpb0pLNUdBYysxQ1RWdW9sektVWG8ycld2ZjVGeTFkYnk4c3J2VDlSMHlTVVN6ZWEwRnRFSTNVRVNkRHViZzVIeWNaNXJyNzY2am1zSmJXL0ZwWjNFMlpGVjRoS2lMa01XUG1LUGtVYzVQYnBYZ2R0NG44TkpPdDJsbERiM01iSzNrSk9Wbk1EcHUzZ2RtWGFRY0VCdlN1aHVMelhOUUpuaDFpM3ROT1dMTWdrazg0Z0RKS0VBTnZSdS9Bd01pcFMwMVQrWnB6TzdXaWN0bDB0K0JzMm1xWDlySHFGdHFlZ2lOb3AvT1c3c2JXS1JibUZjN1pHVkNkeWtnZE9tZTFkV3Q3RnEwYXkvYi9BTFBJWHdzU3lQTDVoY2tiU1ViSWRCNjhaNjhWNXBZd3RMTHA4UXZaeHQwNWx0cnEzV1NRSm5BTWpad3BQWUtlUjFxSFdmQ1YzZldkODJrYStzV3BKdGxUWnVqVzY4dFFoV1JpUGsycW44UFU5YXBKMjMrOHhqRlZLMEl0S0tscFp2VDhEMHZXOUwwejdQY1NPYm1TMnVvMWRrRzVXbWJvb2tWdm1ETWNzVjdqa1Y4dXlUZUYvRC9rMjl4ck54WitZZ2RiYVMzODYya1ptNFlHYkRJQWZZK3RldXRkQzhpajFhWHpnd2kvMHFKeTB2bGlOZ0dWd3ZKQUl5dURUTlMxSHdIcnU4R3lXK2tuVll4OWd0ZjlKMnNEODc1d1ZHUjNQV2tuS0xWNzc5RG9wY3Z0SktVV29ONnBmbnJkQ2FVbWs2bnFNWmh2NGJsYm9sZnN2MmFKVUlSTWJ4SkR0MjRQUm03VjdWcEdnNnBhbVdOcEpHdGdvVUI1R1ZRekhHTnA2OWNxVGtIT0s4aXNQaHZwL2h5MHZiMGFJYmlTSkhObk0vOEFvd2Y1UVJFeGpZcVNTTWpJR2U5ZFovYThkemErZFBxYVJSb3JCSWJhTGVzU3lZY3hPK2NPNEgzdUFCUkpYZDczTTVRb1U1M2x1cnRPeWk3ZWFLRStvWGRnMWxiYjdhZUdhU1Uyd0NyRUFzUndWYUlrTVFRVGxnY1pxbVg4R1htc3ZkRzV0SXJ5MzNmYW9yY2xzYmsvdS9lWjJ6MUJ3T25hcklTM3Y0YmVLTFVnaXhxaUlwV1FYS3J3UUJORXhBVnNkQ09uYXR1eDBhRFRacDQ0ZkRzc2MxdUdLM1RRZWI1b0hPMkdabXlDeGJLNUdEelE3V1hvWXh0UFdMVFhLbjMxSFRYV3V6U3d3YWZhMlZqSWpZMzNEWWtSR3htUUJpNFpXQncvUFhqRldkV1BpYTBnakROYWFnc3QwQlBBWkhpM1FzT0VnWHFTQ0NBVjdWcWFwZldPbzI4Y1YvcHJUYllIREZvZ25sTXVBd1ZpZWVjRGFmbXpnaXVOL3NXMXRtV05GbnRMV09QWk1QTk1vVjg1VndaUmhTQnprRUVVbSt4VW1sdEs2NlgwMzhqaFg4UmFyREtZazhNaXl2OEFjQWJPOGs4c29TZCtZOXhISkJ5VDB4WE9QNG44VDNsekRIZWFUSGZCNUFHdC9Ld0VDbjd3a1FrRmx4bkNrNDlhOXpndHRBOCt5VjcreGVjTUlZcnU1ZFo5N3NNTXY3eklWejZBYy9TdFdaOVAweXdndnBOVWlzSUZZS1JGTEhMQTBqeUg1ajh1VXlEaks4Q2xhTjlYb2lWRk9Xa1ZxMi9UeTBhUGxyV1BFK202czl2ZHc2YlpGNFo0TmtLeXpSeTcxWERKNWUwQWpBNUI2KzllbWFYYlMzY3R2R0lESEpDQ0JldEtrZ2lRTVcybUppbkFZOVJ4WG9PbzZHMEsydHhaVFdjOHR3bTg3SXhKRk1xRGNWVWpMQnl2UWs0UElGZVp5ZUJQdFIrM1BqeUo0R095emk4cFo1SW00aSt6eTk5bzVJSVBGVzlibzBsR1RtcnBxeWRsZTk3NjdvNlM3MXVQVDBuL0FMYWp4SDVzZHhIY3d4R1NKbllHTkhKR0ZMS1RucDE5YXEydW5CWTQvczNpV0pZd0ZRMlp0VEtSc3l5dXNpdUdSampKelhOV1U5cE5ZUzJLSWJwTGM0bXRXOHVTV1BZdTVwTXlIQkpIOTNvUjBCcjBxUytYeUprMDJhV3h1WW9FM3ZJUWR4emp5YzhFYlByMFBCcVY3dlVWT3B1M0cxb3ZkWDM3RXA4V2FHSkpiZWJWcFVsZ2pDbTNlMFZHT0J6dEo2azUrWEZXMHRkWDBlTlVqaTB1NXQyUnd5UTdyUlZUYWRvRHZrRXUzSEgxckhkdkVOdzBVVjlxMW5hU21GbGoreXFHa1oxR1FwTXl0aFFmeFBRbWc2bHFXbncybDBkVHR6ZEdLUlZqRE5MRGN1VUJMS0l4OG9UUEJKN2sxSE1yN0FtdWR0eTI2M2VobVhWcnBXc1hKdUd0RjB2WkQ4cmx4RGNxQ2hMTTZyd1JnZDg1NjF5azlrWmJtQzlmUmZPdXJkRk1idFo1YWRNQlJ0Wkd3L0pIVWc4MTFkM0o4Um83eTNDYUJGRGFzSXpKZEV4YjErWEwrWm5xcDNZK1hyMDYxMEZqcU1keHFDV3IzYnRKR0FMbTJnamxDeVJsQTZkVHRIbDhaMm4yeFd1dlJldXBUaktTbEp2bHVrNzN0cExvL21lTEsxdDlsdVloYjZQTE1sdk1ndG9vbmpkR1g1M0NFODdnMkFPZWF1YU40bGVlOW5pdjU3RzJ1bHRwWTRYRDdaYmdYQ0RjdkFZaVhrZGVRYTlRMHpTN2U4aDFCNUd2bzQxbGRjdmJocEVPTUFpUDc4WlBYSS9QRmVmYUhIcnNOMnM5dHFHbjNpeitiSTZ6Yklwb0ZQQTg1R1V1V0pITEFuME5Rbzd1L3dDSnlRaXBSbEtVZFZkclhYUTF6NE4wMkdDenZyYnhrMXBJNnA1a3NraXpKSWNZeUkzMjVZRWRlTVZuejY1YWFUYzJ6UHFGaTZ6b0VTOXRJUWttTnhiSE9CdFk1NEp6em5OWEo5UjhVeHBlMms4VUZ6SmJ2NXR2QkVjTXBpK1lqSkhLNFB5ajNGYUkxcnd4Y0pESHFGcGJ4TlBPa3Q1YlNsTGhIWWpCZU1nY1pQQVVZUFdvYms3R2pxUmxHTi9kU2FUYXRmME5HWHhEQW1naTRkbGdkZ3pMTmJ5ZnVKbVRCeUZjSElBWURhTWRDYTgvbWpzcnZVclBVVmoxQ080ZU9SSm5qdEF5K1lqQUZrWEFBT2UzSlByWHJzV2xXbHRhMmxscE4vYVNRYmxuU1I4eVRJa1krWklrUHl0dXh5cll5YTgvdTd5Vy92THFSOVZJamFKSklFa2ljQlhEQUR6Rmp6NVFiK0lnNEJ4aXIwdHBycVkxRTBuZVh4TDNkVitaTGIrSk5UdC9GVFhVRjFNNHNKSXZ0YU5CS2dZbGh1VUt3d0MzUFR0elZQVS9Ga2Q1QkpEcUNOTGN4U3lOL28wb01xUitadVh5MlU1WWNMK05jdHFrZnhEaTFNd3RKcGQrak9nVllqSVRESXVIVndjRXNtRzcxZXY5SHVMVzhpa3VKWUxTMmtSRGNGSUdDamNQTXlUZ2tiOEhyMUlvNVdrdXBOYUZTa3BSaEs2YnUwcGMxdncwTzd0TlgvZXBJOTVNNlNiblNQN1BIRk5GSW1GRWZYRDdpY1k2NTcwYWZySzNWeGVtMDFLQkwyT1ZQT2RyY0w4aWpCamJIek1RZTNYM3J4YTRtMGpXTlRpTnRyY00xcGFjL1k1R080T0NTQ2p4Z2ZLM3B3QlhYTExaVFdQblQ2RnFhR1ppa1U4Y0lkWm1KKzd1Kzhub0FlT09sSzFyNkI3S3BxbTdTVWJ0YlcrVE82bW5qdUk3MlBWOVJTemxZSkUwU2hDenFDU1FVWDdvUDhYYzFnMkdvejZmcU41SEhhMlVLZmFKRWhqZktpY2RRbTJKR1FaeG5yelhrK3JlRG9icTJlNm1VV1h6THZtbm4yZVVVNHk2L2ZETTJQOEFaTmVzNkZlV2VpYWxaNmRCckNYRTBqZk9abzJVRmltOU9NbGRqSDdwSkJwdDI2R1VZUGtwdUxjdmViZDA3cnp2Zlh6UFFGOFQ2UlBjazZyb2pySUlXa0NmMzlxOEx2QkFJVGpqSUdEU0s5dHFzOTM1Mm1pUGVmSlRJZU1YQ3F3d1lsakJCSVVmZFBUdlhtZmlIVFJkU0xkUzZKWkZKaTNsdEJjeVF0THVVS3F2R0FVQkdSbjV1UnlLeDdIeExZNlJiVGFPUERWNlVXNmQyRXMyQXVBRklEakpYZ25EY0VqdlYzMDJPMTAyN3FVNHUvdk82V3ZxZW9SMjlnTHd4SkJmMmw4aGpOb3QrdXhSR1FWZEJJUXk3V3pqMTlLd0xmUWROMG1iVWRQMG1WYkltNGlhUVJTU052aWNibEFERUZldlhvYVIvRUdtWGM4OWpISGNEVDFJUm1FRXJ4TGtmTEd6TGs4bnEzUE5kWEJCcGxwcU4ycldlcHU4VWlrUUZnZGpxb1lzdTRodUFkcEI0b1htS281MlVVckp0WDFhdVora0I0Tkt1Slp0U3RKRDVnUzRsSUt4N1NjaGl5cXVXejdFVk5xK214Mnp3Vzk3ZW0xaTJsNFowRHBHZ1JlV1dVQjhFbnB6MnhVQjFDeTFTRzVaWXQwc1VZa1RTN3U2ZUNUSVBBQWx3bVBmcDFyUjhWWHZoZjdGYnlYTm5MREF6YmJsYmhuYTFmZ0hDcXBiY3l0L0gvRFNWdFFTMFYrNnN0YnZYc1Y0dEgxQXBacWJ1MjF1RzVRZVpLaXg0SlU1VXpNdkVnQXpqdVR4WE5Mb1dsV045TCs1dEp4TGNiamJ5UkNDTGtOdVlwMWFRRTRYQkFyYWpQaGxubGZUb0xLWUl3MmlBeDdGWW9ja0Z0ckRkNmV2cFdUcHVtU2d6SCt5TlZsdlV0aXpQSTdXc09mK2ViSHpHQkp5TUFjME96VFNIS21uT2ZLbnBydnBkZVJ4OFUrb3pLOXRhMk1jS3l1aVJMYjNhaFptSkNsQXpmTXB3TTdmU3RGdForeDJON3UweStpbHRibFpMaUR6Zk0vMVpCemh3VUt0bkFLbnBYYzZ6cmJKRnRIaHkrMncyaG14QzY3a0NMdEx4czJONTlpZHd4WG1NdmpXeHQ0b1d2dFAxaUNCUTRXSzlpOHdQRWZuUUJzTnlUZ2RjRHJRcmE3azA2RFRUalRVdFZhMTc2NzZibmM2Yi9aT3IrSDN1cmhUSEpKS2t6d2s3aWhMWVNYSEF5Q3ZPUHFhbGg4TTJRTjE5c3U3ZVcwLzFmMlNWV0xaUS9Qa0RLZ0RIOEorbGN0TmFlSDlac3BITmhybG51a0xSeVN4WVNBNEJCVUlRd1VIcDJyVXNQRFdwMytuZlo0Tldna2xXTlptZVNYZCsrVWtiWFZ1U2k1eUNjNFBCRlBTejA5Q09WcXlYTHpKdExYNTl6c3RMMFdHM2d1WmY3TXNyZHdrcXdwSE9QT0N5RExCV0k0STduQk9LaWxnc1Z1N1pMbVNhVVhFWml0MmtpeUxaa0hNaU12eklvSjQzY0h2WEU2ajROMVpKTFY3cVl6WHNnQiswUEtTMkI4aFVQRU04a1lHUm5GVkxid2hxa3VuUXBlV2wwQkpsSWhCSXhSQklQbklHVDgrQmtsdXVhbDN0dVFsSFdObXJkMXYvd0FBOUJ1TkQweWFhZTF1U2w4c0Z1Uzg4b1F6Ymt5ZHJlVU51MDhISjZWdzlscG1qZVpaYWpZM1YvcDBuekRaQjVaU1FsZWZOVCtJa2duQTV4elhVYVEyZzZWUGMyMDJ0elNYOHpqZm1FS0VXMkczQ2dESHRrOWFxWGRzSDFScmUzanRydU9NU0Y3S1hGdXlFcnZYYVcrVWphY2pCNHdhcSt1K3BYdnFTY09YVytucnBzWjl4cGZpYTB2SmpwZW9UTWtzcW5CVUIxTGo1K3Vma3gxNHhYUXgrSUx1NXVJN2NRVzBrbDRpeDNFVGphcCt6QTdobEFSdGJPZHc2Q3N1M2FTMWp1alpHUjVTa1RPUVB0RWNqT3VZOEVLcElDZ2tyMTcxMDFwcUtYZG5ISmJYVmpINUpMcGJ5eHJ2bW1IenR0Y0FZWEF6Z0RQRk52UmFHRithZHJ0YnV5Mlp6MnBXTFJ3U0paYWJEYjdHWnhtWjU0V2JyOG9VbktuYnh4a2RhaXU3L1UvdDR1Yml6aGRUQ3BMcGJsbFhLL00yNVFHNUhCQjY0NXE3cGx0cDhhWHQ3ZFRUdVdrbFQ3VzA3REtoTU1GYVFCVjNxMjBFOWF6cmw5VDFYeUxHeTFXTVdxd0xKTjlvaUFralUvTkhsbytHQUFJNmZOeFN0cnE5U3ZacVVXNHlzbTIwdlEzOVYvdGUvdjdPU1N6dVYzTEhBVEZheEVCU0JJZHpPUVZWbXdjMXh1cDZOcXk2aTl6cWxuRWxvWlZNZHhBQ1FveHVKbUNmZlVnRWJnT0R5YWZhNi80cHNuZU45WHQ3NENSU0F5U3JKS01FcXNCQUdXQXg4cDR6ejByVjFIU3RWaFF6dEMwclg2ckdsd3lLQXJGY1lmYWN4dnlSa0RGRDlEb3ZUZXJibG85WFpvNU94MUhWSjcvTnY1RnhCTXNqR1F6UG5hTWhaRG5uYm41UTFiK282ajRndVpYVzhzN1cydTF0aERIUGJPeUlxTXdPWEc0Wk9PakVZcXRveWVMck82dmZNMDJkNElkMXRITThVYmlNcU1pUm1Vc1F2R1RYRld1dXdSWHptWFRkS2x2bXdra2Nsczd5eUtSdWFJQlN3UEF5U09NVXJwMk1ZMDdKeDk2Tjk3Sy9tZHBGcUdyZUgxdkJhcXhpM0tVUkEzenM3WUlac25hZTRQSU5kL1o2eE40aTA2UlpiZlVMQlJJckNSb3dKR1pTQU51M2dnWVBPUFNzSFROTGlOd3MrbHl6NlVNQXplYWlzZ1dRaHZMUU55ZzV5RVk1RmFWMVlhekhkWGtjMnRTU3lseE1GZ1VXejRMN3Vpa3F4SUZTOXpUbDVJT3pianpIbk52NFAxR1BYWjU3aThrdUZ1ekk4VXNBQ3hydStZdktyNDI0OXVTYTI1YmE1dHJpK3M5UnNUZGFjak5JQ1pIbWxmdWpxRStWU1NlQm4xelU5eHBWajlydjdtVjVnMHJxWmlHekc4ZkdIZHNZVWs4WnpXckJlYXdvdWhIcG91cldXUEVNMXU1YUlLdUF6RUU0R1FNRDg2VGQ3ZGlHb3libGIzclh2NmRMSEJhTmVhSEJmenhhZHJOMjAvbXlpT0JBeXY1a2crVmNnQmVNWUorbUs2L1VOQThZWGlXMTlZM3NySjlsa2pkNTNNaGtMcVFTNFBRcWVNakhiaXVmdE5VUTMxME5RdGJ2VHJxVzE4aWRWOHNwSEd3NEFSM1lrakFCSUFyWDArRFVQN0ZMdGVYVVVTU0dLRGFJemJmT1Q4d1VFSDVodzNyVjJFdVNFbXJOMlY3WFRzMTE2bmorcUw0ZXZMeTJndmJCclc4OG1HT1ZVQ2xWa0hHNWQ1RzdQVW52K0ZkVC93QUl0cU0wSG5Sei9hamJrcEc0eXJsTVkrWGRuSUE0R01qclVtcGE1NHlzTHRtYlRkT1RUNVlDMEZ4SkdibUtWSStBVHlSSHlPQWNjYzEzbWw2d0x6VGJlN2hudFROZFFNd3R2UDJiL0tKeUlreGtBQWtCalJacmZ5T3V0U3FPMnJhY2VheWQ3WFI1MXFPcjM4VmhEQmJXTHY1bHl0dnZrbTh0eXlBQlFXSVB5Z2pxT0QzcGcwbng1RUpiaGkyKzNaVVNlVnM3aWM4S1V6dVJSbkREZ2MxcDNIaTJCNUo0bjB2VU55a3JLVWdHR0NEbUpXVUhBWlc0OVR5S3U2ZExvMnB4Nmc5cHB1cXJkUnFzUUtpUkpWVWZNenN6TmgyeDJ4enpSYlRZNUZDWEk0eWoyYWxaNjlpTzF2cnlOOVJpMWl4dXJpTStYSEpKdGVhM0xna0xrWTVUNWp5T2dya1YwN1ZaRGNXa0drU1J3SkV6UXBCYW82YjVTUG54aGQ1SUg0ZHFzYWI0aC9zV1JyTFViK2EzUkYydkJLSlRJQVJnaVRCT0FmWGpGZHZaZkVUUTd4WnJXSmxqbG5qbWwybWI5MGpnRlYyU1lCVld3QjBKcDNzalNFSjhqOTJmTGRyVzdUODlUeTRIeFZad1c4VWt6R1BhU3NjMXRzVlc0eVI1aEhKOUIwb3IyM1drOFYyK2xRU3dJMTNNWnlzaG1VU0tpN2NoVTgwSGowSTY5NktXcjJaSHNKU3MwbXZTQy96UnpxNk5ZM2VscmNSYXVOUXRrSUVrcXd5YlFqWUJDcEhMdTNEdngrRlNhMDJoV1V0dmRXMmh3VDRrYUkzbHVza1poY2dMakQ0QlBQMy9BRjY4MVowL3c5RGFSQ1c5OEtuU3pIa29sbGVHSUYrQVZaV0lHR3lBV29TWHduWjN0eXNtbnlhV3NjSW5GeEplczhSWmVWSlJpUXpEOURTMWZjNm1vcHRSYlc2U3RxL3VQUnRRMC9VdksweHJ1N2xrdElsaVF4eVJtZWFaaW93UzZncWNFWjNkaU0xaWFMcE9uMkZ6SmZOY1hOMGpnSTBNVCthanBrbmUrRGhueWVXT01ua0NyRm5xaVhzV21hbHAxM0pkaTdhYU5uYVRQa2h1Q1dYQlpWd0R0QjZVYWxINGV0THJ5STlIWjFuQ21SSkdsaWoyWXlwVndNRmZZNTQ0cHJTeEVuS1VtNVJjT1ZwTlNNdlBncWVXYWE2MU81U0o1ZksrenV5d2xkbU0vS2dKWitlVHh4Vm03OFBhWk1za2EzVThNRWtqRVFtTlpJeU1aRFRCMTdEb01rMXlWemJlSjVMNjJ1TGk0MHJUdEoyN1lramc4MlJsWEpEZ2hPRjdrOEVkNjE5UTFMVU5HZ1NKZEphK3RvWVFZaktwZDNLL0tkMkZ3VGprZGNZeFMxSWNFbkcvTHN0Vm85ZTVYbDhCMjkvWjJkcEZyVVUxakF1Mk5ZQ3JTb3grZGhIeDhxQTg0NzFzMnVtYUhwN2l4dkxpTzNNdTJheHU3MlJYWmhHU0dSVllBcHRIVTR6M3ptdVYwN3hmYWpXRXRyRHd6WVFOQkRNWGVhSm9wbENaR3hkdk9NSEpvMG40ZjZScjh0bGVhbGVlYUVoWnByRVhQbmdLU0NWd3gzUk4zeUNmVEZUemEyWnZDTkpUakdUZXFiZlhjOTZnVzZheWpuYWUzdVlDeXNra1VnMmNrSDVtQTVJUHIrVmNKUGN3VzEvYnozVjNOZVhFZDFNYmNpUWJmT2JKS29zWUh6QVB0SmJGY0pKSDRWOE42bkg1WG00ODR4dXZtU1JSeGlYZGhuU1E0SUM4QTRQMXIyS3h0ZGN1YkNaTk50MTA0U0ZvdzBKQkVqcU53ZVI4QUFGVGh1T2ZXbjd5UlRqL0FDdHYwVjlVWXQvcjJtMnM4Mmt5UWlLN2hkY3d4NExKSGplUzdURUF5RFBBQjZWd1dxblNJOVVGaGNlSHJIeUoyUjQ3cHBodGN1TW5jRUNxdTRIZ2s1clZieC9vTjNxY21uWGt0M0JjTE81bVdPRkpJM1FBSnZoZVFEQWJ1MzRWMGVtYXY0V2FTYTNHcmtHT1RLSTRWOGJUa3M1VURlQjdjQ20zWmFwb3lxYzBhbTFyeFdyc21rOW1ZU2ZZN0hUa3Q0Ynl3dDNRczhmMndtY1pHSThJRmM3MzQrUW1sMUhVWXJDRURVNWJTYUNaU0VrK3pwTkpNeWpkdElUa3FySHFSNjF5bmlHeDhMclp5aTZ1MGduWlo1SWI2MXR6RGJTSVBtS3lPTThudUI2VkJaYVZvY3VtWFVOazBJU0hZWTNqYVlzNEMvTnRjZ0VaSitWU2NFODFQb3laeWZLbnpQcnJ0ZjUvSTJ0TitLWGg2MjBiYXNqSTBqU0FPUXU4emdrNFpSemtkeDBBcnoyNjE2Sy8xeU4zMGJVcDF6SEZpVHpJNFpHMmtzNmJlRkkvaEhOVXZEOTFGNVFqdVlMTzBlenQ1U1praEVQeXlqNWt3M3lseHpraXUxazEzWEhrV0FMWkMyVlJJbVhZTjVaSG9PWEcwRUE5Nk5GMVpqT3F1ZVVVcE95YWkyMWJ5OVRIMU8xOFRIUmI3VDdEeTF1STdsSlVnTTNta29RVldOaklNQmU3WjVMZHFib25pSHhxMm1SejNkdmFRM1VFdTJXVzdieVd1bGt5cXBBT1F3WGtjRDlLNy9TWDF5WFNicTVzNUVsczQ1d3d0M1VSU1lKREJIa0pZQkJuSko1elhjYWJxRnVOQ3ViaTd0cEI5bFlrV255WUlDNEFiSU9Ubkp6a2p2VFRWck5kVG9qTk9ueXloRjYzVTdXZnBkZER6K3kwd1Qzc1cyNXRXdDQ0R2wyaU1PN1JTZHBHK1ZjQWtnQWMrMUxiNkRhMjkzYTNPbWFUQ3NVa29CamxRTVpEbkhBYklVS01FK3RhR3U2aGUzMWp0dDdlTzF1VEhHWjBnSUlkWTl6cXFxb1lEY3VEdmJCelZEVTlNdkpkRXNwTGk4aXcwaFlCOXl5aVYxdzZsczR4amtER1NSU2RsZTNVNUp4bEI4dDlsZTZkaTNZUG8raE5iYWxlRm9YKzJ1cmtlVThJNnFrY2JjRlZ4M0gwcXRiNmhBa2x4ZjI4bHY4QWFTTTVpSmpMN2h5eWlRQlMrRGpPY2lwQjRlMDhhc0paTEp0UTh1UmhheTNHREdYbFRnczNPU052WWRlbGVpNlg0YjhQUVd3eFkyTXpKTDVqSkJLWlRFVUJWVHRJUHpjOCtsTkpLNzdscUhQR3l1bGQzZlRUcW1qd1gvaExmRWxqcXN2MjYzanNydENXZ2laL0xMeHNUaDBEL2VkczR6NjlCWDBWY1RhbDVGcjlwbHQxakxtV1NKMU8vYWVTRTI4Wlh0bnZWcTR1N2krMCszbnZsODIwNmxSR3FrQm0yZy9PTTdseUNhNFRja0lzNVJCZHpwNTdxaE1MbEVqTEVCUXJrZk1oVUVOakdjMGFPMWpwbHlxVGNaTlh0bzNvL094bWVLdkNGcDRnMHE3aWd1cDRKUExoRFRTMjdFbnlUdERSQVlDbGp3QnlBRG11TDFENGIrRExuVHJleWxacnVXS1NFVHk3bVdieTBKQ29YQkM4RW5JeG11emcwWFVkWjFQVGIyN3ZXa3RyQ3phT1dCSkpGV1dTUmlTejU0YkdBQW8rdGVnYXRwMWxmcGRMTk5Jc01RVHpGWU1GUk1iaGdRZkt3Skh6QW42MVhOWnEybm9icXJPTWFmc3B1T3ZON3Z1dE43Ni9JOEYwSHdwNGFpMUJHMDJLS1NXTzVDeEtzd1g3TTBKd1dNcDVPUUR6akJQR2E5Z1M1dmJqV0xqN2Y0ZGpmeXlCSmNmWkFXRE9jQmc2a2h1QitGWUdsYVI5djFDU1hUL0xoakVNd0JLUnE4a29QQmJIREhQS0R0M3J1Vmh1OVNaTE82MG1kWUlFRFJUT1AzcGRQdjdtTEhMSDZiVDJwTjZHRWVlY1pPOG5kM1YzelhmbVptZ1g5cmE2M0FiMmZTNEpuZHNSUVFoRWxmQllDUUU1d3VPYzhHdVAxL3hCcWRsck1VTnRwQzQvMXhlV1QvUjFMajVNbmR0RFo3OVNPbGVrNnA0TGlaMGt0N2kzRUxrYmJWNGxLaFJuY1F4QjJzd09NZXZOY2VmQW1pSmR6U2kyODJPOFVTTUFWdUFIVVorNTBHY2NOamswR25MVlM1Skw3VjlOdFREMEw0alRYazZ6M1ducEpKYU9pK2FzL3dBaU00MjdtR0dBM053aTlUWHAydlhVYzhjU3RKZlIyMjBiVlZRbm15UmZNd1l1RGtZUEFHTTlLNE10ZDZmck1pMk1WcmJHNVNKNDgyem9KbCs2dTV4OTFnL1hJNjFzL3dCbDZIcUttRFVJYm1hUHpHaWtpTGVWRStSa2hSemdqcUNDT09hVjE1a3hsSnB4Y3JKdTJ2ZjlTbEZjYWJlNmZCTFBmTkFxTXV4Si9JTGRjNENsc2htNCtYR09uRmRWZS84QUNGRzl0TGViU0liNmQ0WGtWNFloSUdqak9HWXlMenh4bkhUcFhBMlh3MThQeVdNczJtYUxhSXl0SkV5enUwZ0RJd1UvT25MREhPZXB6VzZsdmV4QmJTYWFXMHRZR2o4aGhiQ09PTm5HTm9qR1N4eGpPZVBVMDA3SXB5bFRsN3RQbVRTOTVwSy8zdG5OeStIdEQreUpCcUYvZVcwRWpGb2tTWlRCQzdNV0FUYWhDWXp6M3JRMVBTUENsaGNKcU50cGtNc1B6SmRmWjlza1VnQXdHZmpuYWV4OUszcmVhTjJ2WVdjTzVBV1dJMjM3dDFMWXl3UHlrSHZqa0NzL1pxZHVzczl2b3R1bG00UlpyZUlHUmZrSk80S1FDTTV6Z0E4ODBSN0hOelRjRkZLMXJXVnRkTzVKbzlsTGEzalgxckNmUHVZQ1FKWEJqZFY0REpHT2h4MHoweHhUN24vaEtWdjdTV0xUcnU1Z21hSXpLZkxLeGxPUVFDUVUrYmtrNEpGV1pMRFVaYlg3SkkxL2FoU0pGblZFbDNMR1NXUm1QM2VXeUJqb0JpdWZzSmJXd3U3NHkyMHkyMFNLbm15S2NCbHc0NVU4QWtnalBYb0tMYTdta1l6WExlOXJkWFk1NjlXelc3RWtzVDZiY3k3R2thZU1UcEl2R1k0aXBHMUNCME5iT3Q2ajRyV1pybTMxT3p2TFJHQ1hDU1lnMkRqWWpNcDV6bkFZY2p0VzVmNnZwYzEvZDIxeXQwNlFTcS9ueVN0dFdUSVpSR1U2cW81eDE3Vlloc2RDa3NZRGJhaTAwUG4rWjVjVWFMR1FtU1Fpa0U0QlAzU00wYUdxaEpwcTZkdCtoNHFkZTh1L3VubDhQZlovUEt1ODhlcGtzM1ptakFZa0VkZ1BRWnJ1R1BoTzdnbXZtU2VHRzFuQ3gzTFNscERLeDNOdjVKQnpnZ2taeDFGZGpxRTA5dGZXelN3em0wWU1SUGF3cnRSNUR0Q3N2M2hrRDd3K1lWZnV4T3l3M0ttNkVWcUpvOXNVUmxsa0dOcFliOG5jQ0IrQXFkaVpRbTczanJaTDlMOVR5cVJkTTFLOU9vV040b2RBZDdMQVV1RElQbXg1aDJrcTJPVDM3VlUwenhmcUVhSllMNGVKdFJJNFNRbGtMWjZTT1pGSTVPU2hVNU9PbGR4ZUpvTnZlRlpqRkQ1K2Z0S09waWxSbDJyc2JJWUVaSVBKNHp4Vnl4dHBVMFc0WHl4Q2ZNWVJ3dk1ZMWM0Qk81a0JBYmo1U09LZDc5VG5qRnFwSzF2aGFWM3QxS2QzYmFwZFdQa1RYT21hcEh0ekg5cmtqUm1jbjdxdWhBVWowUFByV0JvTmpZTHZqYlhyOUZlUkZtczduSmtXVS8zWDNBN1NSeDFCOWEwZFA4UFhyd201bDBxRjVVRVdMZDNVSS84QUVWamZrYmZVOVQzclMxSzNYVkxGSXRRdEpOa3ZEVzhyU3pvc3E1MjQ4aE1GZllIcjBvNm1zTHlmdksxMzFSaGFub2ZoUFViK0tTUFZwaGYyOHE3b3JlNUVFajdTRHRsQzU0ejA2RWRCVG85QXVJYjRYSzZuTGJwS2NTczhjYzhpYlg2SzJNa2M0eVNRQlhQMk9vV2VtYWdWZlV4Wk5KSHNKZUpvNDAySGI1VGJ4a3Y2RTkrRFhyVnEwODJoUkdTV0hVWVpwVUtoNGxMR00vd2pHMGc4ZnhkS1dtcTdEVlIxSXhUVnVTNlNhMDNQT3g0YzBxL3Y0VnRwWGd1SWlYWVBKSTdSa25LN1NqallTVGtkajFxNUZwamFWcTIrVzlCamRpSVgybEhRcWNOdXd3YmtrZzVIdld2cmNTNmJNMDFqWkVFd2d5UVJOR0daQ1Z3UVh5UUY1REE1OXE1SFI3ZTB2SG5NMXZjM1JWc1NmYXhHU2l2bklVbnF2YkI3ZEtmek01T0VwcFBWcnQwK1IwdjlrNi9iMzk2YlN4dFhoa1VpT1o3cDVXMnQxekQ2cWUyY1lGY2pyOTdlV01Vc2VwbTFsbVJGUllFdFMyRTM3RkpCWWxjL1RpdlF2Q3RucENwY1FKZnM3NE1ibzZHSlkyUEJaYy9QZ0FZQVk4RG5OVDNzR2llZDVhZmFKaUoxODZabUxOdXpqRWttY2pIb2VHcHAyZXByT01iTzFsdHMrMzZueWJiK0xyS05iTCswNHJsSXJiejlvdHBJMEJ5KzlXWUZkd1gwSFN1L2w4Y2VFdGFuamcwVFJOc3FuZGJ1WWtpRDVQU1dYSVlNT255NUI3MTdVL2h2UmRkMUdSNFpMZWFGMEptUXFyUjcxYjd6YmZteURnRUh0VEpiSkxDTzdpc1BEMXBjR0JBRWpVb2lTZGpDTTR4amtnNDVxK1pMWTI1cWNhYlhzbHpTZGs3M2ovbitKNGw0VjByVy93QzNkU252OU5YVDF1b3BpTGp6UHV6UTRPVEhrN2dRZm1HTUhyWHNOMzRUK3hhUEt4ZXhFZ0ROTWlxeENBSEpQSnlOdWY4QVZqNVdPT0s4b21sOFV3eFhBc3JhTVIzTHhYQ3lDWGxCTndFSk9RcEJHQ00vU3Qvd3ZlMmEyV21HNGpTMldSektsNUlHS2JrTGI5N25ncWNFQXQweHhXZDd0NkhMT29wdFNkSFZwSzZmeTgraDZCcHRyTUliS3g4aXp0bGZUaUVsaFJiYzcrSlVaZHB6RTQzRU11TWQ4MXdoMEx4cGE2ZnFpckxMT0wrNmVJeHpibDhsbEdHbEJoM0t5bnFDY2V0YjJwZUw5TXU4bDRiaFU4b3R1ZU1FUERHb1BtTVVJL2RvTUhuZ21xTmplMzJwNlpjUG9ldHN0cVY4c0k2K2ZJcGs1TEtxOG9HSFRKNHhVczZaVkx0MlYwMWE5am05TThGNnBaeE5jM0VrOHQ3OXBjU2dJaUs4THJqSjNGVHM3N2p5ZlFWMW1yNjFleTNFTnViZUNaWnJaWlkxblZGTEhrS1Y2aHQyY2NrTjNya3RYMVMvYXp0N3BZMmRSSTlzYm9wOW0yb01MOC9tTnlXR2NsZndyMERUL0N1aFM2SkRJdHlpU0pjZVlJVkMzR1dYcW00akdDUHhvVytxT2I5NTdSL1p1dTZTMDhrT2swVkxCZnRLL2FZNG5VQTI1MnVRN3J0K1RjUmsvTmdqT01pcmNlaDZYcUR5YWl0aE5QZFJ6dUFWbThwTGdJbUVCVTRDRTR3UWU5YlhuWFl1MnRiMjh0NVlZaXNqZWVxTTlyQzdjdHRRWWJPQU05anpXUXllS05PYjdWZFRXOXpheCtadWd0VWlIbng0K1NRS1R1M2M4aHVNYzVvVjdiblJDbEc3bHQzVDNLR21hQm84cWFyREhwRVZsS1lJOXdpblFQR0FTU3BaY2dZSjY5RDYxeWQ5NEI4SlNYRjFISmEza2tnaEN4c2x3NWltWGhnUktPRnpqcTNUNjExUGlUVE5WZlVyYlV0T3Y3U3pTYTBNWVl0RzBlZDI5VmtVN2hKako2Y1VnOEZhenFXalc4TTNpWjU1cmlTYWN0QUNFYUhQSmFMSSs2K2RoSHJ6VkxmY3RLZk56S2I1bzlkVTJuc1owTmxvY1Z2ZVd4QVM2UUI0MisyYlh5RkJJUmtISVVEbG01OXE1clR0TDBDL2UwdGJuVTdXNHQvT2lWSWJ1QUhkZEZ6dENzdTFsaXoxT0JuUE5kUlkrR1BCOTFLWlliS0tXNmpSdkthTzRDRndnQy92UU9NazV5RDNyeUd3aHZ0SzEvVjduVDdsNUpiUzRVcGxWUGtvemJURXpFL2Y3WS9FVTJyWGtyL2tjamlxYmpPTWt1VkxWS3ozNlA4QVU5YnN2R1drMnNtczI5OXBFRnJFYnBVdUlUS0ZsalpHMmhpQ01jbmpQWHZWcXl2UEJtbjNqdzJQaXlhSzRhSGNiV1gvQUVpUVNEbmN6N1haU3FIQlVjZ1Y1WkJwSi90NXRSdEVndW12aTdYOENPclNoU29iSGt2OHVVSGZQTFY2bHBHaGVGN3FDWFU5ODJuSUlwSWxXSmtpbG5JZmxtTVdDdzQ0Qlk1b1NpZGNLbE5xWE0yMXkzaTIxbzdIcWlhdE05cC94OVdzY3ZWQTByWUxidG14WGp3QVFSMFBRbkZjWDRoMXcyOTFhcHFFVTF2RktzZ2thTGZ1RWd5dXpCNk1jNHpqakdlbFd2SmphVFREL1lLeHF5RnhNZ2toeElPb2x3TU1NWTRJcXpZYWhxOXZDMTVlNmtMbUtOU0FqcW1JTWZMdUJVbkk1R1BSZWdwMlJ6dVNuekxtYlN0cmI4ek9iVFZ1N3lMVTRyaWUvV1NQSGtzK1kzaVFFQTRpMmIrMldMWkFxcmMrRjlJUzFpbHZySFNjVEVlZXNrNzJjdm1QaHRxTW1SdEFHTUU1SXJydFUxSzN0RXNtYWVDS0NDSmZ0SWdqWFpBV0I1d01BTXcrNFFQVUd1TzArOTBMeGpGQnBrOXJiRHlqSVVpRThUek5DK1FVZEZZaEdPNzczcndLVjJ1bWlPdWxwMDFTWFMrNTA4R20rSExlOWtUVDlLdHA0bFh5NFd0NFc4MkZGQnk3TXhLTmc1MnZXMUxwZW9GR3Z6cGhtWjVWZnlaWkdqbDRCeUNyL3UyWUtUOHA0OWF3STlWMHpRTFMxc3JTMmZUWVpwRnc3eFo4eFl4aDF6MDgwWXlBZU1aeFhIemVKTlcxdTdzNDlMMVZMYlZEQ1duZ0VBOGgzUS9LWGtCS2dNdkpIT0J3S1Y1Ykdkb3VXcjg3ZE5XWk05N3JNV3ZTUGJYbHZGTDlqMldzUWxpSG1NSEJDTzhSeHhqbENlbGFURFY5U2kwKzJ2ZkNNQ1B1SXVUYjNNU2Z2SXlTRlB6QUpodWM5Y2NacjE0V2tkN0JvVXJ2NWs4VWYyaVF3eEsxdks0eU5yOEZ0b0E1WUFFNTRxSFVMT0dTZHBrdG9Mank1SGxLTENoY3UzQUpmajVWNUdjWjlxSk1icE5KTFMxMDdQYzhTSGhIeEpiMjRhMDArMDA5WmJnbGJrU1J5eW96c09XV1RBeVI5ZlRGUHN0ZThUMmtqeUhXYmZVcll5T1htOGxJcFBzOFRGVEp0TzNhMkJqcGc0cnVScE92MklpazAvVDdXejgzZEpjeDVKVDdRQ1F5Unl0bkliUFFrWTU2Vm5henFkKytsYnJqdzAxbElESjlwek41YUkyZU1PZ0oya2NncmtkalNsRk9QYnpRNk0xU2NwS21tb3RmRXZpZHJicld4amVNclF0ZmVmYmEvZlcxM0lxT3p5M0JDeW9BZVZJeXVSMDI3ZTNGTjBqV2Rjc1pVdGIrK2U4bU52TEo1VFRCb0doUENrQmNyejkza2oxT0s1YTQxVnJFV0dtM09tUVhHbjNNRWVabWxNanZLMlhaQzU1VittemRnRThDc2p3WnFPaTNOdEtJcDJodW9aWTdpT0JOT1VOR1FjUENWd040STZrOGV0Rm1ZL3ZuNzEyMW83OUxQelBvMjMxakZ4Qkt1a21JU1JLRmxaUThUeG9veUJodnZqR0FPMzByelRaWmlLT1c4MGE4dGhIRTQyV3FySmJSUnA4d2xDSWVVOVJrNFBOZEpkK0cvQjEzT3pTcmNXRi9kV3hsVXhobzhPN0ViMFRuRHFXNTlBYzF4OTNyVi9wZjJxMDFBMkxwYlN2Q29DeWVaTXpBRFlRRndyTVJuZHlEUmJjcVNzdDczMlhuMnNhZWthdEI0Z3QxdGJXYUc0aS9kcWJhNmtTS1hKR1N4a2ozbHNZN2dFRHZYV1NhWHBqU0pidzJrOTVhbFZkUEt1UE5rM3dydUNoZVBrUnVSeUJqMXJnOUU4RWFSZHl4aTUwalZVbUJZeFNRVHhTSGFlU2pHSmtQSUdCdTR4V3ZwdWp4NlhjWGZsMjJvUVRORzhzV0k0VVpsVS92UEpkbVl5dW5YRGNFMDJsYXhTakZLTWtydS9scGJvYzk0ZTFIeFJwcldCbDB5K3VZTFNDZUtXRDdSRTA1WGVXTGlNbmR1d2VFT2EzN0wrMHRYZ3ZiSzIwSzcwaTRoamNwSTUzS1g4eFdWSGpJS09yZzV6MkdSMXJ6ZDc3V2RMdTVwNWJPYVczaWtYTnhQR2JiS1BobWxBUUZUSVMzVW5tdEs5MWJRTHlFU1IzTzNmRlB0dExqbHRpRGM0ekNkMkMzemJ1NTRGSy8vQUw1MjVLVGdtMjNicTlqMWFEUTdlT2F4RnRhM3R4TEJFWXplM0JhRnd3SHpxakxnNEhSVWJnQ3FYaXEvd0JYMHlDemV6c0FxeGd5VHk3dG8zamtSWU9UOTQ5UmtFNHJ4YlNQQ0Z0SnBGeHFXamFwZFd5elNLVlM1bWtlT1BHQzdpUmNOSGp2bko3VjlEMnYvQ1EyOFUwTXBhWDVWbFM1anVGa1dVa0Q1REkvekFjNHpnQURwVmNyL0gwRTRRNTV2bWRtKzFuNlc2SGsyaitKUERPcFNmNlhCUGJTcXFUU2Z1NUpKbGR2bWtkUy9idWNMeGc1cjFuV0xyUkhzTE5KZFNtdVk3bEhJUzBDbWVSQU1lZEs3RmNJbU03Z1J6eFZUVkRxNGpSakxGY1JoSkl6RGQzQzdKUE1HRHRkY1B0STdEcUt5TGJ3anFkdmRSUjZlMXZEWkZBR1NBcmN4UXBFY21QNWxETmc4a0FlK2MwbnpLTFMvSFkwZzF6WGRPVGk1SzZWcjI2LzFZek5DMHVTTm9yZTB1cmFTVjVpVWtXNk1jOXZrcU53Q2ZJeFlubk9jNXJvYmROU3NOYXNwZkkxSFVyaVpYVzdGdWdEU2VTZVhreTVVRTlBM3A5SzZHRHdub3VvYXJKZG9yeFRwZzNTaUlJWkFUdStac0tRaDJqQzU2VlFiU3JHeTFCTlhuMUlXb3VHbDgrYTdHNFNsbC8xWWRRQXFjbmFPZVBwVlIyMUpjWEZSc3I2N1hSMHVoMyt0S3U2ZXp1WVVmbU9PZmI1cCtVQWxtK1hJR2NBY1pGSmE2UHFwMUJXdUkvSlNXU0ptYTFMSHpValVoZk5EYzdUNkRCRmNaZjZyNHBzMGh1TlB1N0s4czJ0Zks4cUoxY0VodHorUUZBTE9vR2M1NlZ0Mk9zZUp0U3VoNWNVMWtrb1RBZVNLV1p4dDNGSllpZUdLOGdyODFENzNORW9XZ201T3oyMDB1YXV0YWxyVUN4dzIxNVpXcm1Sc3NKcEVNd1RsVUlPT0JucG5nMUpkYTNlUlc4VnZOYXd6WEZ3NFNSVE1Sa0dNTVNyTjF4Nk56VjlKN2w3ZU9XNTFXQzZCa2wzUVQyelcvbUNVQkZqVUU3UXE4ZGE4OXROUTBlYnlyU1hVQThrYXFzZHJidkZjS0h5TWxzOEVrOG5rWnh4U1hMY21ia3J0U3RleVdxc2M3Y1BwNzZ4ZFhOOXFrdTJPY3BIYnEwa2EvTXZsaVBjQUFDUmdMazgxMHNHajNtazVrczlIMDZHMmtQbHM4SmN6U1JIZ3F5cG41Z1I4eEhVaklyb292Q0U4Y01GeEhDWTNsQmFXMmhsV08zbFRQT1ZLbmF3SGNBTWFyM3RtTk52clVXVjNQRE8va2s3WndZNDl3QXpMSGdPVlljSG5rOTZhVnJmZ1lPbk9tbTJucTFkMzErUkhwMmo2UEZxQkI4UFdqWEx5eHRLOExSN2tNZWRyTTJSbFJubmJ6bnFLcXA0aTA4NmJkeVMyOXZaUzJVbjJaNUhqMmJNdmpCNHd3d1BsSjZua2lwSlgwalVWYXdKWGU4TWtMeWJUR3l1b3d6NHlBb0RuNWVwUGF1S1N4bDF0SkxDU3pFc2Fva1VkeGJYUGtpUHkwMmdUTGtiK1IwYjhLalZzMDUrYWNFNTNkN0xyYzlXamwwZTRqZVZ2c1J1a1ZwUG5IemJVR1ZWbkJiQWJ1ZTFjemYrSzlRODYwbUZ2NXpTT0Z1b2tXUnlwNVNRMjRBWGNvNHhudFVrRUdtYVBwVGhVMHNKYnh1R3QzWFpJQTIyTU81T2NzekRCNmVncmNqMVd6V3hqdWJZbzF2YnhlYkZjcUJQSEg1WjVZTnd4VW41UWVsYTlFS2JxT1NqcEZkV3VyT0x0NWJUVk5SbEU1dWJNUnFQc2M2eHZib3JOeEpHeTg3dCtPYzlCZzA2enRiVzIxKzZ1RXRRZ2haREpPMGdoTW81REk0eW9DcXd5cGJqdUs1dUh4cG8xdnF0eUlyZDQ1ZzRsamxZeUIyU1JOdnlyay91M3hnWTY5cTlhdTlRbG5tanVKckxZa2NLdXlTdHVMampjUkdRQ3hIYzhsVHhpczAxdHFZUW5EbHMzZHhsMjZQVXJ4dkZmM0N0Y2FZWTdWa2xXUDdUdUVtMHJraUpRUmhUak9TYzl4WGpTZUUvQW1pNm13T213d0lYaWtqY0NhU0FFTGtsZzViNW16eU04akdLOXB2NWJDQzZrdUxQemxrMnBHemhQTFdOR0lLL2V5T01mbDFybHRjMXZSTUt4dEprbG1hUkljVGVTUzhXWGJhellUY1c1QllEMm9VblpwTTZaVG43OFZPenZyMmt2T3h5WGlDNStHK20ya2kzRU1oaGtqYURGa0dqTVFZRXN5QitTUjNIYXREUXRRMGk0MHlKUEQrclhNY2x0SmJtTnJtVnlzb25KSlJrWTg1NktCejdWeDE3YVduaVhUTCtSYnEza2VPNFF3R0E3Sll6MXhJVjh4RGtjYnhqY0s2UFU5STFFU1RhZi93amxwYzJDMjFzeG1pTzFwMlk1VkYyYk1NQ3VlZmxCcFcxUWt2ZGR1ajFzcmFGWFVOVDhPV3MwZHQvWjZRV1VLUEZlVC9hbTJ5L01DaTdTdUdERS9LQnlNYytsYVMzM2luN1ZGRHAzaHVKUkNTcm91OHh4cVZ4dURjL3c0NHhtcmR2cDJuUVczbDNEM21seUR5cGxKWUZJbXlHSTh5UVpKeml0MnpobWhpbWxpMUtPOWpuamRrdUpRWXBHTEVPRkNNVVdSY2pKWVlPZWxWcWM2VGtsZUtUKzF5K1NQRC9BQkpKNFkxYXpoMDdVcmk3czdpeHV2TWpTT0ZsdHhQdUdZMmRWWW9OcDVia2duTmJza1Y1Y3RPSmJmVHJlMUtwRXd1U0x3SXVDU2tqS0dKejJ6aXV3ZjhBNFM2U0NaSWJKSEMyN3lSbTRWVWczY01zWjdqY09NanYxcmtkTTFIeDNIWVFHNTA4UUVCMmRJWEJtUldPQis3SERrZFI2WXFYZFdGT3BVOW5UM3RIU0xiVGQ5N3BhRkczdFBFbG8rbnlRWFJqMnh4aU9LMW1DcTZiODdQS1pRNFA5ek9TQlYvVnRjMUJMT1krYmVtN2l1RldmN1JESk9rZ1ZqdGVKVlhidVhHQ1FNcldIZCtMTE8ydWJHOWE2a2JWR3VKa2t2WjdBcVpFQkNSUnpjcWZNd09HWE5TM04xWlNYOCtxVFNhaFpiZHZtdzJzNFpWbDJnTTI0RmdHZnYwOXdLYTEzM0psQmM5cFNrMDdXaTFicjA4enNvdmlQcDBPcUJOUXM3YXlpblFtZWJ5SkltQ3lEUEJZWVppZVNCMW8vd0NFNml1WUxXRzF0MXZmTnVESkJLamVYYnRMZ2dBcTRWbFpoMEhRbm11SmdrOEdYNjNWcHF1b0c1c2xuS3cyK293TTF6Q3pLQnRFb2t3cTRQVWRPL05kVG9IZ3ZUTkN1Wlk3VzhWNExxUTI5czl4QXl2QzBuQVVzR0t2c0lHU2NaUElOUzNmcWRjNFJVRmFjdWZtMVVrdG4yTUdEV2JlV0kzdDljSktzc2tJa2poS1NlVzhlU3NUUmZ3T01mSXlua1p6WFJOOW9tMU8zbXVkTGx1YlM4WGFpcEVrYldwSXp6d1BrUE9GSTRyTjhSMm5pWFRMdXp1clF3U3RiemJ2T2kwNk9jckpuYVh5dXhpbnk1NUoybnJYU0xxR3RhbFpOTGZ3R0JkNGN5MnBNYWs1RzlwSFRPMEVEcUJ6VkxXMmh6MUkwNHZkNjN0Zlg1c3dKZEVhT3lTNjByWGtodElvbEgrbjNra2JSRE9BWFhhZmw1d293QUs3YU83RDZBa1QzNksxdS8yZjdaTklQTUlaZk1qQWZuNWVlYzlEMXJ3M3hWcU9oMlBpZEpYMFV6UUZYVTNMYmlGV1hJSTJOa05nbmQwNjk2aFR3L0hKZXJCSzdySmJ5RmwyS3NFT2RxZ1BJTTVmakgxeWZTalRaaWxMbGpIUjNhZDJ0YnM5RWFmVUlyMjV1ZFZXTkdhM0VrTnhibFp4RkdCd1dqS2dTWUhyeWUxVFhGdGNhaFoyRnhOcFVkekxBcXNwamgreHpiVkJCTWFFRHpFWmY0ZXZ0VFJING1pbWxPcmFYTGN5cko1Y2NsdXFTUnlDTlRJRmJZR1pHR01xR0F3YTVSYkR3WmRDSjRMelViU2JiQXplUmZvOGJ5U1kycVN2S2tOalBBb1Z3NUpSdXBYaXI2djFObGRTMEIyZ3VMaWZVYlVNcXdSZVpLaklWaitSWWg1aS9LZm15Q2VtS24rM2FrN3hQWlg5dnFqb1dXTjdzUUdWQW5JWjFmaFNHR1FRY0VFRVZnSjRuOFM2ZWx4WjNXa1MzRnpGOHhNeW1kSlBueGlVWjQzWXlDT3d6WHNXbVhrMTlOQkxjNlBkeG93UlFHVEc2VmdUbU5pZnVOemtZSEhXbTdyWG9US0ZSTkozNW0wMDluK0hrZVk2eHIvaSt4bnRZdnNKdGJuVVdTTnBrZ1NmZmpJTFpVamxDTXFPbnBYWTMybzJrdWh0SmNhcE16UVBFKzk3ZnltRXk1d3J1dzJ2a2R6Z1ZqNnBxbXJycHVuTnArbnRiRytETkhiellmZUFwSWVVRXJnWXprZmhYVWVHcHRSMUhRSGp1clMxQ1hTRHpFZDMyeVl5UVZVcXdHU09uU3BkdE5HVzRheGp6VzBlajExN25sK3A2ckZKWlJQYmFjc3N6K1d5eHhUc1pZMVhCOHlLU0xhZStSazhIdFhUdXZpeldOR1pMS0s4MHhFTVVyM0Y2NjNFTGtnYkQ1YThsczg3aG5udFNTMjE3WUY0bnRXK3pOKy9tWklpaUpJcFVJRUxBWndjN0FDUGV1SDFEVk5KY1hURFJacnFlQjFESmJTU0JXWGJnK1cwekRKR2NncHoxcHg1bDZGVXJxQ1hLbTI5bjU2YTlEMGpTOUpGdFo2VDUxMUQ1NTh5RzV1YmNDRnZNTFk4c3J6dUFQWnNacm10WmhHbjNXcHRMUGIyOGxxalNnTFpySUpDUnUzWUdQbDduMDdWeGw5NFY4WXozV21YZWhXTXVreVhzZ2FhY3pMTXJSN01iMlVaWVlBN1YwaGcxNkhVZkpieFJGZTdGOG1PM2xWWUI1Z1g5N3YyNTNQczRIQnh4bXFqRnU3djM5UzVZWlRqektVYlBWd2Qxb3RMZGowT3h0TFRVbzNWSTdTNWFVaG9aUkR0aG5ieXk2eHlmZUpqT1NHNTdWeGlXMnYyRnBmUWFYNFNtdEx5TU5LZ3pCTGJDYVhuS01yS09nNHprRG9SWFNyb3IyOHNBbm5lemlqbFh5SnJhWDUwa1B5bU5SbGpnam5nWUFycDQ3Ni9oOGcyZW9QUGlWSS9QbE1VeVRBc0N3UlN3SWMvM2oxNXBhYUdkR1VFdVdVYis4cGE5bDVYTGRqTnJlb1dWb1Q1VWNRUVFteXVvbFVTeXVlWlZlSU9PY2NER0RXRExyYU1KVmh0Rk1rYlp0bFV5VzRrSFBtT2ZOMmhWR01aR0J6WEY2NE5WdnRVMU9DMThVcmJrM0xMREZzWE1jZWR5b3pJQjVtY1oyak9LOUNrdUo1ZEhOcHE5OUpGZHh4T2ZPWUtzaWtjaVJTY0E3Z2VuSG9hbTcxZlFVdVdWbHpyK1hYcjk1TEJybXYyOWpKTmVYQ29yemVjSmxrY2VTcHpoUVIwVDVlaDZaNHJ5alV0UzA2L2FDWFVkRWd1N3VWd2hlQXFrOGJaT3lWSkd3c2l0akpCd1FldGRSNEhTNXU3QWxOVHNibElKWFJES2pNVmpiNXVWYm5PZWdZNDdDdFRVcmZ3S21uRFVyanc4a290M01zakloRWFNVDM1endmeXEwNzJNS1BNcHU4bjF0ZTd1dlJIbjd6U3pRSmJYbWtUeUNEY2ptU1ZZcFdXTWVZRkFsVWxzcWNFcVRtbUR4UjRNbmlsVCt5cExKYkdPUXZDN25NaGs0TVM0SkJadTQ3MTZZRjFpYTF0MzA5WGdhZWFPTkxXSnZOVTI3bkhtSElLZ0h2dXh4eml1YXZJUEMwc00xN2ZYTnc5dkRPSW5Gdkk4bHFaY2JOcGJ5d0VZNXhrZDZKSjZXWnNxYmNMY2w3dTYyMTY3bXRkMzNoQVBwa2NGdWtUVG1JcEdzQmhZYm1DN2QwZWNPQ09DY1pyZWp0ZFl2cnpVclc5MWU2U01aalZIS1FBbkdkeXFSODRBR1FkMmM4MWk2ZHJIaDl0Tzh5VFRiaVdHMVpKaExGS3R3QVkzeWgzWUFCQjQrbzVGWUdvZUlRbXNYOTIwdDdhVzhLZzNGbGQyWWtSbmxqTWtNa2NpN2dyOTE0cDIyQ00vZGswbGY3YXM5dmt1NTZWWjZBMFU0ZTV2M210L0lZSGZHWi90RzRFK1lTd1BSVHdBSzhXdTlTOFhXY2t0aHBkc3B0MmtFT3k0bWlScm1IRzdlaDJrS3FEZzVPUm11OXRmRTF2YStWTGJYOW1aR1FUU0xjeU9XM0twQ3JFUUFwNXh1QnFyWjZ4ckYxWXgybHg5cVlnSThqN3dnOHVRN2dxc2habUFKNzdUU2NtbHRmc1l3clVuR012WnArNjlOYksvUzZhS1YzcHZpbVhSYk9lV1d4MDJhUzBJbk1iQ2JQbG5hTnFFQUhncWR3T00xanZwTjNxR2x5UnRkTFpHQzBpTVU5dnVhWE93bHpMR2ZsQXp5UXZPZWE5Zm0xblZyT3dodUJiUjNjVFFieVVqV1pFVE9ObUNTKy81U2VuemQ2ODQwM3hyYjZrNndTbVhTdzhqRVBkUnMwWG5JQzZuS2dGR2tVOFp5RFNWMzBSclVUNW91RUZiZXppbXI3Nk4vcWN6SnEycGF2YXlhWEhyRVZ3bHNGZVo1SVdXUXRHdVNVSk9GYktoZVBjbXVvMDdVWmRLQ3gzbW0zMXVzN0ZmdFRuelZXV1JkeVJxbU5weWNGam1zdlU5WHN0UTFhRmJ2VGhIYnZHaXgvWlEvbXp0S1B2YldVOUIwQjRQU3RDdzEvUU5FaWhzSXRNMXFhTVczek5QYitXck9tRkQ3bkF3L1BVZW5GSnZvWUtEbFBuNXI4aXNudnAzSi9EK3Y2cHJVeldUZmFZWFJtOHU2V0dHQXFUeVZVWTNNcDl1b3JYOFVocGhhcHFTVzdSdy92QklaZnM3T3ZRY1lLa3VPR0hwbXZPTlR0TkZ2citXV2JTcmpUTHUwaWluTXpUU1l1bG1KYnkrRjRad2VmNGlNaXQ3U2JGTllqMUcydDF0TlVoWmdseEVZbWpmekV6enRmQlV4cm5BSFhpbHM3bWk1MDQvSGUyclMyMDAwWnVhUGYrRU5HaFU2VkloWkxoN2xiWmIxbWpEU0lGSmJBUFFmZFU4OG1xZDVMSHArcnBmMitxWFVjVndkNUVaKzFReHVXR1VaZWNOdEpBOStockkwNnd1YkdTelM2c3haTUxmeWxISCtyaU81RG1JRU1jQTV6ZzEwT29PTis2M01rYjNBSm1ndDlrZStKVG56Q3E1STVCeVd5UlR2ZDNaeTFjUk51U2xmUjlsZTk5U3JxTWMwOC9sbTZzMUx5bG9mczVaUFAySGtaa0oyeU1lQUNNZTlkS2tkbklEWlh3amp1YmlOb2x1MFVzVUtwOTFsd1FKRUFPRk9lSzRLKzhPcHJOdkZQTmNRc3J5Q05vb1BsV01OSnVUWm5EQWhpU1dPYzloUytNWmZFK2w2S3M4T2x6encycGRIWVNlV1hFZTNhd2lYbklIZXFUZW55TmFFWE9wZFFVbTNvNzJUMjdzMjRkVWFlOHVMZUM5anVFa3Qwazh5M2MvYVQ4dTFDOEo2SHAwSDFydmJTUjF0WnJuVWRYWFVMY1JiVERJcVd4QjZobFJ4dVZ4MEJCd2E0R3k4UlhyMnQvRHFmaDY0aFp2S2xFNWxWN2JhQmxJd0lpcmREd3VldlUxVzFYeHI0UDAyNkduNmhxaGdTZUdOd0pWODZOUXhHVGtna0hqN3ZVR2pWdXgxd2hKVk9XRWVlVGpleWZNLzhBaGpaMHlhQnJxNnZMYTJ1a2hMT0UzeUdOSlN2eXRJWkRuQ0xqazk2eUxEVU5BMUdHN252SkxlUm9aV2tpVzJra3VEdGpRaGw1QTVJLzJzSDByV3RXOE02amVMSmErSjVydEVRbVNOcGxCTzhrcW9ZQUhibm5aMHdLOHhDK0NyWFU3T1hVYkc0KzB0Y05MYlBPM2xpVGE0dzBiUkJReURra2tIZ1lOTzY2TXo5akRtYWQ3SnR2UysrN1BvalJsdFpvSGx0YjcvUmo1Yms3VXpJQ3ZSMS9pSTZBK3RmUDBVMnQzalJ1K2hYOGtheUJJOVBMcW9WT1ZiZTJQM2JzVGtNZTNGZXhSMmRrbXBOTm9tblJUWFUwM21QSWt3MnNCazdYVXRrRWhpYzdmcFhOeTZocU05NHpmMlVZNWtFcVNBRTdXeUFEem43MkNNWkhTbXU3UXFpcEtuR0xTa3I3MmJUOGxxVjlEMEhYcmJUTGVlVHdmS0pvbCs5Qk1JMVdQT0dIM3ZtSSs4ZDNCcDFsYlhHa3JCTkw0bHY3ZUZ5c1JnQ3BJRWtmNXNidWV2NlZyMkV1cHp4V1MzVjdkSDVKWENSM0VhTVFEakRLQjgyQjB4eFZhMjBYVXRQbHZSQnJkMVpCNXZJWjJoYTZlV1NYbFZETndTQms3bHhnMGFYMDZGeGltbzhyYTNldXUrcFFTYVhUNHZOMWpYWTdxYWFkb0lKUnRsYkEzRUVQMFNRZzhnam5tcHRZczdPVWlYVHRhbHQyQ3FYdTF0ek1oSWJDcW9CNUI2WUdPOVpXbmZEblNwb1lZWjlOdTc3ZElKMHUya0NTcHdDek1NL0tDY2srdGJVWGlxVk5jdTQ1clc3ZUdLUlkzbFI4SkdNS0VBUUFLekErblVVMnR5WnVLa3A2NnR0dHgwMFo1RHFzZXJhTGVTWFY5ckVreTNuTXNkdllpM2haa3h3Ky9oU2NlZ3oxcnA5SFMxOFIzSDlvWEdqUnpYRE5oSFFqelFvK1lZRWUwYmlQWEdhNy93QVF0UE80ampzVzFTS0pjaUVYTWNVV1Z5QXM2U0lwNEhBNXozcmpOT3RwWTVvZlBzclN4KzBSc3FXZnlUTEdEeGxBalpLa2cvTWVhR3RMR2xibXNwY3lkM3l5dFphYmJJN3EyMEs2czlOODYxYVczbE14a1pweC9ySEkyN003aUZPT2cvV3VObXQ5RXYxdWRNaThVZWRjaVNMS3ZJRzJUSzJDVnhnU0hCeGpwVy9ZNlRvbWtXRFNSWDZ1NENOSklaZDhYbDRKRFliT0k4bkJQUGFwcEZ0YkhXVGV6TjVWdlBGNVFodUlZN2VGQXczRXF6Z2IvWmM1L0NpN3U3TXpoR0ZsNkpMVzV0UzZiYlJhZkpiTFpqei9BQ3l2bnU1OHljb0NSaFpGSFVnbGd4SXgwcmtyYncvcXVrVzk1SFpXZHRxRjIwSG5TcklxeHNxc0FCZ2pEZklXSjRPQ1JXcGE2RHJaMHUrZXp1bXZwSkhieVJOTUxtMWNZQnpzVVpVQWpucmc4VmR1Tkh1THp6SkJiWEl1NUZ5SlVjYlk1bS91bDJKS0w2OU8xSGRCTlhVR29hMzA2YmZJOGR1dEU4WXZaaVQrMTRra2ptTWNyZVhJY01RR0M0TzRBNG9yUVR4cjQwMDY0dTdHYndqUGVDS1p2TG5rRWpJUU9DVkVlUUN4T1RSVFRTNk02bGhjU2t0S2F2cnJHTDM5RHFtOFFhSHJla2VmRnAwN1hETkU3SGR2WUZHNElYY2QrdzhFY0VHcU1GanJkOVBCTnFXanh0Ynh2SkRER3MreGp2VVNiM0V1Y2s1d2NFWXIwSzQxSFU5TjB1YVM5bVdLSEFCRnM2d01YQXlZNGxBYkRIK0xIVHZYbTgveEcwMUxXNHVJZFd1R2UzVGFzVjBZb2tCYjVVK1ZnM3pyam5CR2V0WjZuQW91cEtUNUpOZEZiWXJSMlBpTm5NK2svd0Jtd2o3YzBqWklpZE1KdEtza2JIZGtEQTdrODF1V0hqclYzZGRQMVc3dExXWll6SUFRNWtsWEh6S0VqSkFJQXh6eURUTkwxYnhEcWcwKzlPbFFXbHRjVE5NcEVwak1qWTJrNUIrN3R6bko5TVZNMC93NHM3Z3BxY2d0TDhTaVdCTG1NekNJazhTRThFNUk3MU9uVUtlczNDenZaMys3eTNOcUN5MWVTeXMvN0Z2MHNMVU8wcm9rMmN2TnkyOHlFR1BkakdPUUs4MzFxMCtJQ2xQOVBUYVpkOGR4TE5KNVRvNStVbDBPM2QyS25yWHFTeTZIcUZuY3hXZW82VnFYbkNWV1haNVNueTB4akFPQmpQRE5uUFN2SjduUWJXNFFOQlBxOXFZWlk0bzRZNG96TEVUZ0ZoaGh2QTRQWWdIcFF1K256TDVIZGM5cjN0cTlMK2RqMGJUdkQrb1hmaDREWDQ3RzlsYTRLeFhLM2l3L3VXQUpKZnB4Z2doc2NjWnJqYmo0ZTZMSGIzRXRoYnRleFd3M041TUN0QmN5azVBeXVDcUpqbkJJOTYwRjBLL3MyTmc3U1gwbHpGRXMxb2JUejR6dEpBZnpOK3dOSG41dW5Kckh0YnkzdDRuMHk0MGsyTU4wQ1RHak80R3prK1h1NkpsZVN2ZWwxMVNLbFZ0SGJsdnVvNmEyM1BUNHIvVlo5RXVYdFp0TTA2NXQwaWlqdTBsUVo0SUlielZiYUI2RHA2MXkrbGFscDFqQmN3M1UrcGkra1ZwcEx5VzdhVnlGVEc1RWpYN2dQY2pwM3JFdU5DOFF1bDJkTDB1MldQYWpXMFc1WGtWRHpsV2NNb0JQT08xTjB1SzZPc0xlYWxlUGFrcDVHUmJpSXlzaHdzYkZBRTNjWUJ4bjFGTjdrdHZsc24xZWp0ci9BSkZpYTh0ZGJrV1ZuWVpqNFpWS3M4YURjWkMyQ3hPZTNUMXJ5bTRpZlRVdTMwZWExRjFNcnlwUGNMaHRxOEdOUWVyTndOaEZmVUNhcDRadGRPaE0rcCtZYmFNU2hQTlR6STRqbmZ0VmZsNHh3QmpCcUd5aTJOTExQZjZmOW51bkxXNjRLeU9yZ0ZIakw0NUhUSlBlbnphK1hZd3B4blRxS1ZsSmRWMDc2bnp0WmFsRWsybXpYSGlLK1VHWVR6V1UxcHUzM01PVDh5UlpJanlPdzVGZW5SWHMwTTJuM1Z1MDkxYnJsb0poYXVWaE1nTFkyNU8vcmhqMVhvS2JyV3AzTnpQcU1LYVpkU1hscEJHeSthUE5WQXdJSTN4ZGdPK2VhODU4RitQZFgwdS8rd3kyMGR0Ynh4RlRFUWVHT2NvY0RqSk9mWHVUVXQ2YkhRM0djWDd2THlhdHJsV2pmWldQVjRyL0FFWlJjUXJvMXhwbDJaeEc5eklpelJSeVNNR0pWWEJKM2RRQ0Jqclc5bzBoODQ3clcyU0JaR2xReEk0ZWJENUx5TEp4dHlPaTlPMWMzNG8wclZOYTBpM3Q3ZEluakxKTkVkaEVhZWdKNFk0UDU5Njg3MG1EeEhhMkVsdnJOeThLVzVEUnlFa3hCVWNLV2pIUEs5Rjk2bHJSYW5OT28xQzZrckpwY3RyYjlVZW5hM3FkNVl2Y1hkdGRNU1BJWnJQZUhXUmwrOElWNCtWaDJidlhTeWF6WTNrc3BXSnJYemsza1BjSXhWM0c0TmtBNEs1d2VvcjVwMVh3cGY2bHA4dW9XbHZkS20rWWk3bFZsak1RNmxZczcyM0hrTmpudFdEb0ZwYjZOQ1Jjczl4S3pzeUl5SGxaTURvY2J2WDFGVFpwYXRGMW91blJkNUxuYnZ5Y3J2OEFmc2ZRMmxlSkhqMVhVNFJxTnNkazRqSzdQa0RyOGgzTXYzbFlEa2l1ZVc1OE1SM1dwaWN3TGZSUU1MSjRMb3lFeU11OHRrTnl3NVBPTWppcGRQc29kUVF5M3VrU3p5ZVZLOGcrNTVjYjg3T2VRVHQ0YXQ3UmZDWHc4aDFTZTYxSzF0ay9jTkxGQVN4M0RjQXVDTUJRTTRIYzgxckh1WjRhVjFhVGt0WGJacGVyMFZqZ0xENGdhYkNVL3dDSnJxSTh4VVdWVXVWeVFGd1pBTm9LajFBNkN2UjlOMFdhMXZML0FPeW9KN2E0VDdRMXl5a0ltOFkyaFFTeWdnZER5VDFyMHpWdEo4Q3dhakZlUldzRnRJWVExdThZQUc1ZUF3Q2dsaXVjVng5eGFhelp4M045cFYzUGRuQk00bm5aV0c5UU5xcDNLaHM4bXMyMGFWWXhpMHJ0NjNsN3kwL0xReFBFTnhxVmpvTmk3YWxOdmhjUnl3bVE3WkZuNkJnU1BUam5pcFBER3Y2YnFNOGd0bzdtT1NLRmhJN1NQS2tTbkJBWmVTb3djREhURmFSMFo5UnQ0Ylp3Sm9XalJaZklJYVF1aWtmTVdHUXluZ0VFVkl1amVHdEExajdGYVhPb0pjelFoNUdlWDk0U3d4NWpFWTNvdm9md3F2ZDVTMGsxelhkbFplVE02OG5lOTFhRzd0UEVjQWpMQmJlMTNNdjc3QkQ4Y1pLa2dqanBXM1ovYUlSYm9zRnlscmNHVU1rckNFZVpraDlnQkdFSzk4WnJydEw4UCtIbjFBUk50dWJoaVpWREhjNjQrVXRnakFMZGM5cTVqVjdmVGJEVTdrNFdjWERKY1NPWkdCREEvTmxVNEt2MUdPS0VaU3NrcWttdDdhTTh3MWdhakJxTVVXaTNNOHlySkFDVlRiRkNaR08wSWVReHdNNDZBVjZGY2FQZlRXMTVMTnJJaW1uY2dNWVZpY3lSa01xS1I5MHMzVmVmVVZaazE2MG4wcThFc05yRGUyMDhxZ2xTWVErT2NsRDhxc282OVQwcnkvVlBHVVZ0SlkzZ3NZMnVVaU1Wb29pay9kdXd3V1ZCZzRJeVFTUGFtbTl1b1I1VlZTVWI4L1JhNm5yOTdwMW5xdHhiQzkxTzdpblZFajh1QzVMUVJlV011dU1ZREU1eS9VbXNUVmRkMHV5ZUcyaGtqZVhFTUhuWlpybFNwMnRsQU1zU1Qzd09heXROMUt5bS9zNmVmUnJzM0xCM1c0UzNNRnNVNTNidzNMZS9HVFdZMXA5bGdpRXV0eVgwdlFzTFVSdEdYQVpDZWQzbDlnU2UrYXErbGpTVXB5dnQwVyt0amUwNjU4VHgzMW41VnRiTWtaZUdYZkl3TWlsdDhiYmpqa25vT3RlazMrcVhFUmtlL2U0dG9vQ2pJRElxZVpIeVNDaUFuSFhjYzRBQXJ4bXo4ZmVNVHBNMXpOWkpKRGxYU0l4NGZ5VVlLY2Z4SGs0eWVLdWFqcjlscXVyNnZhM2NNVnBHcVFzSmJ1TmlDUmc0VGNPeFBVVk8vUUkyaEY4c3AzamE2YTBQU2REOFlhWnJkdWY3T1ptOHRSR3NVSUFaUi9Dd1p5QUNjRThEa1ZTOFQyVnpmYWQ5b2h1TmtSZVNReVNBU0x2aU9TUnRJWWNjRUEvaFhPMm5oN1Q3YUthNXRkU1pnMTM1ck5Fbk1rZ1VCUUM0K1lBWkpIQUZUWHVyV2NWcllpS2FTYlQybDhwbENGQXZiSzd3T2M4NEE1NjBOUFEwbFdUaTdyUnE2MVQvQUNHYW5xQnRkQmlpdnBiYVZwb3liZTRzL3dCeUl6aklCTWhiQllubml1VHZmdFVXbndDZlhIVldiYTBrRW9MeWtFTXF5YmdRTnZYYXZhdlZyZHRJbXQyL3M2V0pqQVpJWjRiaFVSVklISWxWaDBiKzhQclhrbHBvM2dQVHRHYXp1YlFKSFBlU1NJTWlaSXBFajNHUlR4NjQ2RDZVOXlYQzdjcFNzMHVpWDVub09rRFhXczFGajRxRjJ4Um1JbGpCUjJCRzBLUXpaSEdEMEpyWTB5MzhXbzhzK3BzTGhMbGdzaS9Jc01hbjVjQmpna2Vnd1RWSytzZFF0dkRNWTAyV0NLV09aSklsaUN3aVdOaUhQbGcvS1dZSG9lbGRGRGVYbW8yQ1cybzZQUGJ4U01VbGpuYmV6WVAvQUMwWUFLRnh6d2VCVXJ1ZFhMSGwxY2x0WlgvUXpVbW4weTJGN0swQ0xDakQ3TGJzSFZrQXdIaVlZd0NBQzU2aXZLUEdIeEV2ZE9qc0pyYlI3d28wVFBNNm9ZbkRNTXFBVDFIUEpJcnVwL0M2UVdGa3lQZldEaTRZMjFxa2lCWVJOZ0ZYSnlNakh5NDlhNmkzZzFpU2FPd3VGdVdEUmxvNW11MGtlUXIxUm85dmIxRlhGTC9NbW44Vm1tNDc4dmUvbXRqeXJ3cDRsOFJXMmp3WEVtaTNZYVJWUjBrQjN1cXR0MjdDZHhBOSt0ZWlMNGszUlJuVExhVVNCMmttaW1KakNZR1BMWlF4WWJlMlJqRld0VzFDSnRPa3R2czBndXBQbERlZHNuaDh4c2JseG50emcrbGVTLzhBRTNrMCt3dUwrMk43SkhkdUdtWm1TYU14dHRjdHNCS2g4WktuMXhVdlZiR0ZTY29LU2pMUjdMZTMzam9kWHVaYi93QTY0MGEzV2E0aU54aE1MTzNrb1J2allCc3Z6OG9IV3ExdDRwc2J4N2F5czlTdVZhenRnVEJKRHVTUUIramlVS0NRQnhrOFp4WGFYOWpIZXlTV3MrbVEzU013bWlNV3dUZ2hlRVlvVmJCNkRwbnZXbmR2QnBjTUx6V2Q3WnhuWkZMSkhBanFxdHlmbVlIUEF4anQycVNZV1NselNiZXQyOUxHTHIxL3FYOW5Xa21teFhxUUFPMDhwSVJvQUpBQVNtU0RFUVNDdlVqNlZRMTN4bmZhU3hXT1MrdUFrU0dXSDdKSXUyTm1DN3d3YmpmbkF4NjF0WDkvWTNDUlhkbXNieGtZa3VqR2ZNaVVqNVQ4eEk1SFVFZTliTnBZeFRXYTNXb2F2NThOdVdpRWlTTkNoWE9kczRCWlhQWURITk0wdmVwYm0yUzJka2VlWHQxNFBrbiswR3psbHZCYm1hM20yUGRTUEN2S3NBUjhqWjZoeFd6WmFiNGsxS3lGeGIzZW9XMXUwTEJHaHRoRTZNY0VFOWlWNTZEb2FtbSt6MnYyeTN1OUZ0NExjeUxKYm0wTGtBdndIYlo4eEJ6MTZEMHJvTk51OWIwcU9jM2NSZjdYY3lTZnVHYTRGcHRIQUpmYUdCR0FxWUJ5YWUvVXVEZzI1T1RWbmIra3p4V3owM3hhSUw2SWVJN3lhZTNlWjNpYU1RT1NPSTJMTU9VWVpKQXptdlV0SDFtN3ZmTVdiVEl0Tm1UeW81cnM0SWtCSUtxdUFjcy85N2tDc3pUdGIxNjR2cEJGQWwzdGthY21XWWZhUEpsRzFrTUxENVFEbmdZcjA0YUFJcDVrdFd1YmVOeXlyNU0zbWVXR1RnaHBjaFMzUHk0T01ab2Rya2NzNVZMcExmV3lTMzlERzFWYk9XS0tlTkdXY3N3KzJRUm80YjUvTEpWbVhkOHZPVGptc3lXNzE3VHRNM1hGMUJxRnhHaGFGYnFGb044c2piVVdieThiaGprZnJXNW9jbC9HWXJjNmVMbVNOdGtrc2Q1R1BtT2R6TXFZYnpNZmRCd0syb3JYVDArelRTcElES1ptVlNUR0pHUERMTnVDNTJuN29QNFV0T3h0QnlkNUpyVzIva2VjVHc2aWw0MTViNm5vc1YzREVWdWJlTUdDQ2RqMDg1dW8vd0JrODlqWE02aFo2bHFkMUJLMXI1Tnc4QzR1SVJKZkpJQUJrdWNiVk9EOTRqSXJyTlg4TWFwZnlXcTI5dWh0bkNoV2VRU3pRZ243b1ZpUndSa0VIaXQ4MmVvMnVxckRGZngyOXROQzdzQy96dklGT2ZLMmM3UmpjeXQwelRJWFBLNmxHeVR1dlA3em0vN0d0YlhUb05LbDFLV0M0SUxSSXRxQXJsY2ZNRkp3VGdkUWMrMWFPa0xGWjZkZGVZYmU0ZDRzeVhLd0pHdUVIeUszVU54eVIxcXZKTHFOL1BCRE5xc0duUGFPMHl2SmJtZGluVGRJell4a2M0UFRGYzNheTJGNWNtM25LNml0NUk0ZVVXVHJFN0twK2NFbkF5Q01NT2R0SjZFTk82Y1ZvM2JSZVJhZzBqeExxZHhkenRvdHZEQkpMR205akdjeG9wKzZxWTNJVHlGSElxb2RJYlRaM2cwL1ZSWnl6SEVrRnJFSXhNVkdOMjlnQUZ5ZU9sVHphSEZheFEyOEhoT0tRd3ZHOFhsWE8zbmJqekVUY3ArWHVNYzgxMEUrdDJWcGVYRnMrbWxwY3hvSUlabER5SFBMcVpNa2JTUHUwK21uM0ZXamE2YlRsbzczT05qOE0yRnhweVEzMm1hakk5dk16SmNoVVJTVzY1S0hKVEk0SjRyaHJZNnBvelhVd0Z6SkV6cDVtOW1kWURNRHNUeXp5N0VESTVyM1YvRTd5V3RnUCtFU2EzZ2U1OGtONXBkbWtreHlVUUZUa1o1UGZJclkxKyswZTFBdDcvVkJZaTdlUlluYUZWQ0RPeGlvT1NCempKNjl1S09teGJnbmRYdWt0TkxibWRjUGY2aG85aXR0cG5uaHZMZDNpalcxa2pUSVhCamxMSFlTQVRuampJcmtSTnFWcGVYc1N2WjNib29raXNaekdqTkNjL0tYQzRMRnVlRHRGWmRwb3ZpTzhudXY3TThTSkc2c0NrYndUS2RyY2phQVRnTmtESVBTcnVvK0hQR3Q2cVcrcDZjOTYxcThTS3FYT3lKd01GZ2RwQkpJNlp5QWFhV3hQdk5RbFo2MjIxMjc3SFF4Mk9vWGVtbzExcEduMkYwb1ZvWGpuakViaVRrQUVaSjV5U1ZQV29kTHY5Y2h2TEd5dTdjdFBZeE5MYTNZVTgvTnVLTVZDa3ZqZ0Q3dnJYTmVIUEVPZ2FIcU11bWFqb245bTNHWGpSSUlKSkFWTEFrSnZMZmV4d01ZcnFyalhkT3V2TGxzc1hjbTkxVjV5WWQ0a3dDaFpkdUdQQVBITlRkNjJOWnRKM3UxZi9NZ3VOS25Pc285NXJEVzMycnk0eWlKNVVzZ1VaQ082NFZ1K2U0TmNMNG44Q2FCUEhKYXcyZ0xyNWhCWjJZc0pPUklHQkFCeU1BbkpGZEo0bnNKWjJtazFMVUxKZFBnSzdZTlFpTFRXd2t3QnNlSThuUHJXMXFmaEhXSm8yZzBmVUo0cmJ5ME5xc0VnTWJBbkxTTzdaSjNEcW5ZOTZhYjdrOHMwMjROcHI3VjlWMDZIalZuNFVmUWJwTDZIUjVyNXJaaHZjU3E5d0hPQ25uUkFrQWRzajhhOTQ4TmFucTJteVhBVndJYnliUGtDQ0ZCYWs1TFp4MTI0eXdHY2cxdlQrRUxLSFRiaTJubWxjeWdNckNKUG55MjdlMGdPU1dQVTVIU3ZOcnBOUnNiK0tDUFVzYWV5eWVURk5iYkFqRVlPSDQrVG5JNU9TTVZYTVJlckNhbHpQYlc3dS9UeUtHcDZ6cHQ5ZlhzYzhQMnhmTlR5M0VjalE3Y2JsVk1sZG1PMmZ4TmRIcGxpMm96eDZqSG9yNmNmczZSSkl0d0dqeWh5dm1vbWQ0SE9HUFk0cklTM2lnemNhbmUzTjBabENTeHlLUWx3RzZveW9EbGdQUTRyMkNLYncvRkxiUVdDU2JaOC9aMGpqZVZ3WWpzSVZXR0FCajF6anB4UmJ2ZnlKb3hxdHljcHBKdXpYVjZuaHZsYXpvRGk3MXk0OHl5bGxNQSt3UmJveUpSdTNTcklPVjlHR2V0VFFlTlBCR2k2dGUyRnhwaDA2ZVQ1WW1heEtMZEFIQVlHTWZMdTZmS2E5NEdudzN1bWZhNzNUNUdMSTBqd3NGVDk2djNjSUNTSE9PQU04MXlWcHFXbG9rLzltd0ZvNW9tdVM4cjRIbWRHaUJ3VmpmdHRHQ0R6aWk2N2JuZTFUZzlWbzFvbHByMGV6T1AxYldiKzk4NTc2MXVaZE4yT3BnbHRtY255Z2NHSnVIS0hJT1NNaXVhK0h0OVp6MnNsc3Q1YjJUVzhHMTdTQU1WRFNmZWFVeUFIa2NQM0dPSzlmV1ZHbHREQmJhakdDZ2p0Z0F6QUdTTUJ2T1AzZ0QwRG4xTmNiTmVhdFBCcDE5WWFIQlBlaEpvek1ZeEdKUExjSzZBZk16RVlCSVB6RDFxclgyT1NWTldkN3kxVFQ5UFE4NXZQRStyYUhkM0Y3UDRjblpwZzFySHFQbUw1Q3FqWitaMVVFcDJ5UUQ2VnF4ZUx0WldDZTdiVjQ0TFJrL2R5Q0h6SVpHT0ZCTXVBdzVPTURuUE5RYU40bzhUMnBhMHYvQTBzeU93amtkcjBmWm0zWkNCMG1ZNEdPV0g0MXI2bDRYMGVmVDFsdWRIdHJRV2NnbUFpek5HZWNNUXNSK1JSMUdNbWsxZHE1ZFducFQ5NnpWNzhrdWEvd0NMc2N0cThYaldiV0xPV3c4U3c2WEpQQVJKYnhQSmNSeXV6WU83eld4bHZVQVY2Slp6K0lKN3E3dHRUYU9XOXVGemJyYmx2TFZaSXlwK1p3U0F4NTVIR1R6VDlOMHJ3MXFDSmNXU3hDVTVXS1pZWkRJa1RuRzNIekREOW14bXN2OEE0UTJlenVvTDZUeE5IQk5DcUdOV2tVZWJER3h6a2JVS3BuakhUTkxXelNXeEh0TVRPRVUybWwyU1Z1NnV0L21aMHc4V1dXclc0djdYVG9ZelBhbDUxdVlRTjBKMkFySDkvQUh2a3RYb3MyamFSUGNQZVRSUXlwTElCNWtablp5dTRoR0REQUJPY2xlbkdjMWsyV214M2xwTlp6UVNXa0plVkNBck9Ndmo1aThoMm5QY0hJcmo1L0RHcjZiRWJqVFBFV3B3UzJ4bWkrenp5Rmtjcnh0Q25lR1ZpUnlPUHBUNmJsUlVYRk8zTHA1dlU3UkpUcGtjTU4yNWVTT0NXU2FlU1JsSVJwY1J0aGNNeDJuR0Rna2RhUDhBaE10SzFXL0NXYS92NGc0a3V0eklJb1lUd0k4b2QvVHQwSnJCaThSNnZiVzFoTmQ2UGJ5WDg2TkpmQTdUS1F5N1EzbGgxWHk4N2NBQW5ITmM1cUdwYSsrb1hVMHVwUldTM0VBSWR0MFVjVEkyQUkxQXprK28rOTNwY3BqS3J5dHhiVXVaNkpkT2crLzhNNnUwa21vVCtJM2tDQlcySThrRHJ1WTRKYlp5RkhYMEk1cnZHOGRUYVJyTHJmNmo1OWlZbDhqenJReCtlell3eXlKbE4zcjB6MU5jVjRadFd2YktEVUJxa004YllZeHJJSTNWVkpIbGtCc2pKN1ordGVrM09udks4VnMxbEhHOXhjcWZzcnZFclRjRURQbVo4emc4Z0VFZXRFdHZNMXB1cHI3bkxLK3lmVTVaZmlwb1Z1TG1lVFhIaXNYakR5UU5tVjREdnhzaTJoQ3dYM3lEbXJsbDR3K0c4bW9UcHBRbWFhUFlrMHNVT3dZWmpnZWFNRkFjNUlQYnBVdHhwdW1SbzhjT2pNeXM4bHVqN0VrSG1vY0JuOHpxb1lEQndNVnhjeGJ3L2J0RkZCYndYalRyZENXMXQwSFVoZHJyR1NOeW5rOWVQZW1yZk1tV0lqR0Vyd2s1Sis3SytpOHRrTjhSK0svaDNkNnMwRFgxMmwxZGVXalhDdEtkb1FFRXJ2R1N2QXllY2pyVWxoQm9iV0QzV21tNHVaYmJjSjRMYUpRZm5Vb2tnUXF2eW9lZHFpdGhkVDhMYXJFUTJtVzkxY0xISzdDSGlYTG5lN0lTRkdXUFFucDN4WFFyNGJ0OVloS29MdXhObEN4dGpJV3Q1Q3N4SkEzcjhqN2VqQWpJb1NSWHV5NVhadE5YYXYxOUxJazhPNlRyRng0UnVyR2N5ZlpvNFNrZHhjeEREdHV6NWdIR0QyOU04MVJQaHZVYkd3V1E2MDFxN1JwdmxFRzF5ZDJBSGtacFFvK1hMTngycUN4OE82WTB0azdYbXRHUzFqMkpMSXhlTXNnMjdIWEg3d3AxYzRBSzk2OUl0ZkQ4NXY4QTdWS3U1d1JHMHpTcEcxdW1Od3doSHpMa2NLeElGRDFaVUlPMGZpazdXdXppVjBSNTQ3aTBuOFJYQml6QVhra2dWQXpKbmd6T0YzaHdjOERyNjA2R3d0N2k4aThwQmN4UkIzakU5NTg1bGp5Y0pHNDJFakdHNEgxcnBJNGJhWVdscnJGNXV1WXp2aHVGUU1HM2NZMkRNZVY2QTg4bXVHdk5EOE1RNnNzQ3JweTNDTkdRa3RveXhyNW5lVnM3aEtPN0RvdEQ5U3BPTGFsZFhUdHBiN2pXRng0ZlpyMFQ2SmR0ZVFoVU50R3FKTkh2SUpKQ2JSNWIvd0I3SnhuR2FwNnJKcE03U3l6dlBaeSthSkV0NURKSE9rcEFWd1BKT2RyNUdlZlVpdUcwejRpV21vYXJlUmExWVFwSmF6WEVYbVJJN3lDVkJoeWp4NUFHM25ISXh6aXVrdEx6VUlOUm5tdVBGRXcwNXdSRmJ5MjhUTThSVXNyYmp5R0o2WkdQV2xyZDNaTTQ4c3ZmYWpaM1YxWjdlUjFXbytLTk50TDk3TVhYa2FqSXNMRzB1VHZERmdCdGtWd1FYUFFITlp1b3lYVTlwQnFTK0Uybi9kYm5SYmNKSnVROFl3eTVLbklPUm5QU3ZMUENYamJ3L0w0aW50NUk5U3ZaWGNtSHpaWXdzYll3T1FNTURubXVuMWI0aXRaM0ZuTEhvb3ZvYnNzRWUwYnpwWWpBUkc0bGRTRVVsU01ObnBSRzd2WTJwd2xVbFp4N1BsZmJlN3VrZHpwajNON3JOM1BMOXF0VkVNcjdia3REOW5ZL01VQ3R5Yy9lT0Rna2RCWEphM3JyYUNKTHkxdEpKSk5yZVhjM0VEWEN6UWJ5U29iZHVBeWZsQkdmd3FlNnYvRCtzTnAweTZoY1FYY0RBcGFSWFl1UG1rT0YzQkZ5UXVNNE9BUnhXWlkrT05Sc2JxT0tMUnJxWnA4eUpNdHhpVjg1Ry9hMkdWVG5PQ01EcFNhVjBZeWJVNFhhdDN2cWN0cG5pcXo4UXkzRnpwbmc4cmRpWnpOZE9pUitZeWtTUHZhUmxBNUE0SElydU5NdjlQdFlvck5CSnAxeWxzbm0zRUVRbDJ1akZ0cm94Y2o1ZVF3NmlpK1hXOVh1RUZycCtxVzhjRTd5eE5keEl3WGFlaVpKSllra0FuSEZWdFEwWFdHUldheXViblVWVXhSU1FTa2JsYy9kYjdyaEFEbGhuclJyZmZUc1JVbHpWMDR4YVcycnYrT2gyZHA0UDhQWFZ6UGZhWGNOTzEwWXBKL0xlUll2Tmd5M3o3U1NOMmNIdDdWeTJuNjlIRGNYSzJPaDJPbVRra1N2ank0dG5Dc1FyL0s1STVJWHJYVWFDUEYxbkdJNHRMaWlrV0tRQkk1em5NWXp0a1JBVjVKNkhuM3JJMUc5dC9zVjRkUTBlRk1ONWttMk1BR1dYNW1aMFlLR1Z3TTVKeUtkMjVXWTNPVjRKdWFiUzA2T3kyTXZWUENsM2MyTDNkN3BzVnlZSVkxbFZFeVZWbkREeTM1T2NjbnIxSUZaMnZYK3ROUEZid3dRQ0tXMGxuVXgyOG1iVmh5Wk5zbzNxb3huY0JqdmppdWRzdkU4c0Y1TmQydW1xWlZpZEZEWEx2OEFJcDNrSkdueWhqMjdEc2E5QVhWL0dWMjBOdmF3TjlzbnN3OGQ2WjlzS0FFT0RJT1dBSElHN0lQU3BTdTdXMk1LYWhKcFhsMnM5Vm9lQjZYci9pYlY3eWZUZFoxS1NDSzNkTG55NVdNYkxDd3dmTG5UcXVQbUE3L1d2UzdDMThPQXROYmVJTFZyR1VvUmJtWlppcm9ESDVqazhxQ0dQSUJyM0IvQ09tNnRicTNpSFN3M2tKNWhDeWxsVXF2STNKOHpER01tdkFMZlFmaFBwYzExcDdXbDNieVlTVVJTVFBFazNuTU1GV0k2SU92dG5yV2ppcjN1ZWpWcFU1cHphNUc0cTBlaVMzYlBRTksxM3dSSnFxUnltMnR4NUgyZUZsMm9zUVJqaEhZbFNSL0V2SEZhY2Q1ZWFTYnVDNDFTVzdzV3RuTFR4UWh5RUJQenlNcW5rSGpQNlY1YkI0UTA0MnRwTHBGbmZRMjNsNzN1TDZSOFJianQvZG1RWTh2UEo0em5wWHErbVdmaVRRVGFSMm1nMlY1WVhFakJaRWtKOHBsWWcvS2VwYnRqb2VEVWNyMTk2NjlEQlJhcU5OdHBYYmx0ZFA4QXJZNmE1dHRKbnQ3ZG9wN2k5WGFNeGk0UVJReEVmTzZoeDh4eGpQZkZaK2o2SFpDRkxXRzhsdHJkSjV2SmltaDNJcDJrQjRTK1Juak83L0dvL0VkbWw3cDF1N2FSSmJYTWJPaVRXektrOEtzQjB5VHVVRWZNb3lRTVY4N2F0cHZpNjcwWVdzOEZocWtOcUdtVlpMdVdDWTU2NDh3cVFjZkxnME42YWVSU2hGVGk3M1QwM3QrYlI5Y3F0OWFUZVZMcVNYMEU3bFU4NWxkRVVqT0hHY2xSMFhHYTh0MVg0ZVBkYTgxeHA5eDludVlqR3BWcC93QjNOdUdHTWtUS0F1Qnh1WHIxcnlMVDd1MGluc1hPa3oyRTM3dVl5eHpZVkV6OGdmY1hDbnQxR1IycnQ1UEcrZ3czRmxZU3hMcWQ5SmRDU0s1RTd6TWhZN3NCb2lBQU93NkQwcDYyMkpoTlN1dVJ2UjNhMTA2OXpsN08zMUs1azA2TFI3aEowamQ0eGIzY2J5aktzZGdWbURCRmJPRnowSU9hNjF0UjFPd3V0U1RXR1d4a1k1My9BR05WaUtLdTBPV1ppQ3h4OHB3TWNnOWE2WFdQRTk1YzZlRnRvN1cxdUpJV21pYWFkMHRuaWJneUFsUUhRazQrWGxUMUZNMGpXTmR0NDdlQ2E4MHU1M0pMOXBoUlFFUXEzM2RycWQyMFpIcWU5SDNFdU1ZSjh6dHIzczM4amk3ZlJkTW1lM3VMQ3p1SVVralF0SGFueTdlVHpjZk8wSk1oUXQzSXlCM3FlKzhUYW9sL3JGeGFXV3BOREdSNWRrc3FSb1F4SXhsVkJDcVU1NzE2TkRySGhpMDFPVzN0bzlIdGtaUWtyK1VzYktDZHVDMkNPZU1jWUhXdVoxblV2RmtOeWswVVVOOWJlVWZNV05TcFV4WUlkdHcya1pPUVl6ejZVdWhQTkJ1VjU4NnY3M25iejBNRWVOZFJtdDdXTzZzSnJPYUdSdk9qMnRGR1pHQmJ5aTZoaHllbzZacmZ2b0d1b28vM2x6TFp5US91dklqTndJWFVuS3NOb0hsN2Y0Y1ordFpsaExyOTllU05kTEM0V0Y3aU15UnNaRXdTUnRHMFpBems4ODEwTnhhK0o3Q3pFOEY1SGNrOUhpM2JsaTR3aEtFZ2NrY2puRlUya2xhNXphTk9TVGFhV205akwxRFFwN20wTDNVVnRxUzJzK1VnZk1WM0hHeEpES2liZzZoVG5abjlhNTJMWC9EbHJyZHBiVFd0MUVrWmltbG10M1owRG9TRVdWUnVLZ0tCdUdjYzU2MDNXTC94VXQzRUJmZVRIUEhJUmF2ZXhOdEJIYklCei9kNElQU3RUUjdPNjArQXRjTkpsUi9xSUF5S0ZQOEFGTUdDN2xQSEs0eWFtMnZZdDFZWGo3blIzYmZ6Mk5hejhTZUg3ZThNVTJxUlhFalRFbmZHUTc3OHNQS2ZnZTI0OGtVc3VsVDZsY3I5bzEyS2J5NWdGdExtSklaa1Ztd05waitmUFRhdzRQRmNMcU9rYWpQY3hTeVBEcXRzekpJMEtvRW1qM1pYYXBiSXljZk56ZzFtblQ1THFaZFNrc00zQnM0NFBNWjIzUmdOaGVCdDI3VHhrZmpTc3Jyb1RHYXUxSlNzMWYzYlBVMU5kdk5UOE9hN2MzbDg4Mm9yTkptSzVXTkJMQUNSaFN6WkIyamo1UVI3Q3VodGZGMm15V1BtWDhVbHZadE85dEVHamVKcEpUeXI3VjQzWjZEanBtcExMUmJiUU5PbWUrdllWYUFBNzdxSnBJa2xDWTNCZXZ5bm9lVmJxYXl0VTFMdzVieTJ3dU5RbGdqZzh1OGFaUUd0cmxTZVAzWUtna2dFYnNBK29xcjM2dTUwUGtsTis3cmUxNzc3VzBPazFFNnROYlFtU1NTNW50OEdHNHVZUXdNVE1WdzRSaVM1UEdjWUdLbzJtZzZUbzF3MHYyaWF6TWsyeVpGbE1MUW5ncmlFN2dTU2UzQXowcGxrdmhhU1cvbXRkVTh4VWtrYUo0RENaR1dWVHZVQUVFSEo2OFlQUVZjdC9EWlMvVytpZ3RiM3lwQkdzOXpLTnEvS0ZBVnNqQkJHRzNaSjYwdEw3bU05RzdjemV6VnI3YmVvKzg4UTZOcUVFY2NiWGN0MEpYZFliell5eUZBQnVHT0NNOExrYzg0clAwTHhCZGFqWlRHRFNMQ1MwU1lSeTI5dE51S01RY3liSEIydU1mdzRPUFd0VDdGcnVxM0VIMmNRMlYxY09ya05IRklHWlNOekl3SEczR0F1VHgwck11ZEIxS3c4UW1EK3pyR2F5bGRtTUVTQkpFM241VHlmbVlMempwanBWSzk3YmlYTHl1U2p2b3I2Vys4MjlOazB5ZVJJUHRCMGE0Z21rQ3BNdTZUejVWSDd5TjA2SVJ3Y0RKNm12THZFSHc0MDlGdDFzOWtwR0N5UmJWRHNuTEZKY0JnVG52OEFTdXF1L0NkekpKZTI4OXFrYUYwamplM25jSzZ0azdjWkFVREhRY0hwWE1TYUZmNlRBa0ZqOWkxYWQxYjdPbHhkeUdSQUFQOEFWWllnREk1NUE5NmFlMnBwQ2M1M1NiaEs5bHFrdm03aXA0STBwN3E5KzAyZDVZM1h5TXNoazh5RzNBT1JKaFR0SkErL25uMHIwNmEwdXB0QXRMUDdYRHFEd3h5bTRsdFdFVWpLZVUrVUtXNzVHMnZIcjdTdkVoMFFXOTFKQmF0YnM3U1FXOXdVZGd2T0hLaHkzWEcwa0d1cThPNlJvMmwvUEk5d3lGa0tTUlNlWEdoVTVKbGtZakRaUE8zSjdWRm0yWlRxU2p5UmNrMzhPNnVrdk1UU2g0U21sczIweUM1bWlodFpDWnR1ZnMwb0o1YmNBQWNET2NFZzlhb1JYUGg2OHVadG1tWDF6ZlR0dk4zZFFxNWtNbVZWbWY1VktFRHFCWHRjQThOWFVMeDJHcEtHa0NpUHkyRFBGSkdDRjNqYnl1YzhudFhCM0dueVhPa2YyZmZTMlYvZlFobGpraERXeUpHT29WbEEydUJ6Nlk3MDdwV1JzbXZaVDFVVTMzM3YzUEU3M1RiaTN2RWovd0NFamJZUjVhTEpGNUtuQjVpYm9HQVBLc0R4WGZDNDhMM2RoZld3bjFHMHVBRWpTK2xrRXViaGNqWVYzRTgraDV4V0kydWFkYjNGdGFYVXo2eEhJSlpJNDVsUlVXQ0llV0FzaEh5dm5KeUFNbm12WUx1dzFHd3R6TnBXbFRTeGdKTkVxcEhhbmF6WUVjaDNZWndNN1NCK1ZEV3VqM3NPS2JhNU9XOWxaY2lTc3V0blltMENPUVFQYm04dU44QVZ3cnFJNUpYWEIyR1BLcU1IZ3RubnBUTDJCYmkzZTRoOFE2alpPMHlvNlRiZ3NpYnR6RFl1QnlSd3g0TlVsbnNtdTNudWRNdm9MSzQ4MHpSVHhHZG9aNDJQeXhsZzJGSzRZamtlbGRIck4zY1hzazF4WlJ5SkdMZnlvWldqVXFZM1RjTnF5RURyMEdNZ0hyVmNyVjlUQnVVRS93Q1pTdFpMdjFzWnVvYUpvRm5vZm5YRjVmMjhBbWR0dW1wNWNLTXVkd0N5RWdBa25rNE9lMVpJZndQY3dQY3ZhdEtrMXZ0V1M3dUNkell4dGtNaEJWd01EajF4WEZhZlA0bGlNS1J3YnhjRXNGbUV1ZG5UQ281Q2tBOFlQNTFUMTV2RmV2WHNlbTMzaGxwN1Uydm14M3NrUzRNY1RjR1BhUXZzU1NTMUN1NzNXeGNYS2NwZTdheTVwWHMzWmIydjE3SGFhcjRrOENXVU50YkhTZjhBV08zMzRTWWJkUVIrNkliNTg3Z0NQV3RyN05Hc3NYbGJZcldTSjNFQURLcHp1QWsyQVpBT09wWW5HTVZ3YlJlRTdMVE50anAwelNvSkhkbzRCSVNyTHVQbUdUTzRLTVlYakxWcjYvTFlhdnBjZXBmOEpQY1c2eVdzVGlHU0VySkVDY0xJeUJ2bERmdzhZcVpTdFpmOEFkbEtuSnhzOUZxMVpiK1JCYTZYNDB0YjRUV1ZsRmNXNWppV04xbVlHS05pUmdSc0Z4em5yejcwdXNOcTl4TE5KYkpaV1R6enVseGJYVnh1Y3J1R0pBVTVaRDJVNXdLZnAxdnEwc2tOMXBtdmw1WGdTTTdXWkJPMGErWHhHVlBPT1Rqa0hGRjU0VzArU1NXUzhzWHZyNVc4dFRMRThEM0NzTnJmNnNrTklPbTdHNDllS3BLNjh5ZmNjTDIrNVhWN2ViTkVYV3Nvc0YxcHQycGp0SWN6Vzl0L3BBbktNQUI1WUJLZ2RkNFB0VnZVdkVtc1htbXcvWk5MdmJXUXpGWVpyeEJDWDIvdkdoQ09GQnkzR0RqSXJxN0t6MFBSVkFrRFc2T3J2SEF5ZmFGTzBmTXFvVkRzcDVZaitIbXRKOVIwSytoTnphbGJoNEZJdENpbU9FTU1iNUFwSUJPZWhHZmFwc3JyMU5xYmlxVDVsNWRsWmZpZWQrRi9FZXRYY2tzTjdEWmVWYnhOTTFnNmViRENoQkRLSmZtVldZOURuZ2NWcjZEWStIWTdlNE50ZVBwd3VBVEVSbWFBdVJoTm1DYzVQSEpQcFZuVzczV0pOU3RiUzB1N1BUb1o0QXF0TTRLU3VSbFZQbEUrWUNSMndWckJpMHlQVXJlOTM2bFlDWUJkMHRpWkZYY3FGVmo4Z2pHQ3d3dzRGVTBaU3ZIbFNsR1VlYjRmNjEwT0oxZnc3RkI5cEVtdjNFSXZXVjVyZU9EemRqS3Vkb0NLZnZFWnprVjJXbWFmcUF0WTh6V1Z6RXR1cW01OGwweUpVS2xRU3U3YU9oQkFPVFhPNlBwNjJjRjVmV1BoNmVXOWdPMlJvaWNPTURMUUVuNVU3RmMxVHZQRUN3elNXOWpwclEzcm9mTm1DeklVa2pBY2k0SHpjWU9jOThWbTA3bHBLcFpRVjlGcnQ1OUQxNWJTMUtvYkhVcmI3VXloR2dpai9kNWRNN2tES2NrTDNHT08xY0M4bnhBaWxuSDJlVDdPOFB5ckpLeWZhQXgyNEFjTnRkc0U4YzQ2VkY0RjFPTFd0TWt0NzJlN251UE9MaVNCd0pJeWh3RzVVRWpIQkxWbnplSnA5R3U3bTNOaHFPb0JDVmVFUnk1VUVCRHRCeWpjOEhCcWtrbnIrQnp3cFQ1N0tHdDJuWnRXZCtwcWVIL0Rlc2FYWlhNa0Y1YVFOZG9oYU1QSVdkaVQrN1pwTVpkZTRCSEE2VnZEd3ByK28yRUV1cVhjTTRqbWJhcVd0dktHUldCTWtSSVlLRC90SE5hTXA4TzZyWVNXajZmQnZMQnhidS8yZDFPTnJGRlVuYXpkTVp3ZU9hNERVbzlYaTFpZXpHZzYvRnBhd3FHaGFZS3JSN2Y0cEczcUNUNkgyTksvWmZjZENTYWMwMjJtcjJlMXZVOUs4UmVIZEV1STRycXcwOUlwNEd0NDRWdUxNR05CdUlmQktsY2dISWJIMDYxblF5YVpEYjJVbDVjeXFiT1l3cXNGdDVDZ011QVJHMjRIbnFWNHJJOFBIN2VKTk50TlNtdDdhTElKYTdWcnVLWGhTanhuankxeHgyNzVyVnZ0V3ZMYlRvTEhWTld2SnJqei9NV2VLeUlhTHl4OXdSZ0VNdmZuRlUrYmwxTGs1eXArOGx0b3JkZHk5cCtydzJGMHd1cnBIUUlXdHI2V0k0YU5RUUdlVUVqSVk3Y2NGYWZxdXFRYWpGRE5IUHA4MElMR09TTnZJV1JtKyt3NnR2QTR4a2ZTck1sNnMxckhkWHVveVhkcmNXaVJ5eFJXNkx2VEpZTkltZmt3RHlSMVBGVVZ1dEF0QkhIYnBlU1NYa3J3eFJLRmY3TUR4R29pSUlqVmgxWVpJSjVxMDlkeVZDVW9OSnF6MXQvVnpuQjRhdmJLVkxqN0JGTmF3eGd6cERKSkhKTHZiY0M0akJYNVJ3RlBidlhYYWRxdmhXNDFTTzJmVzNXV0tOVWEzWldTZEFxbkEzTVFWT1NUN2NEaW5hdmV6R0tKWXJTSjFGdjVMeFhWd3cyTTJjaGdvNUdCZ0hIWDJyQjFhdy90WFRmMzFySEN5eHh4M0x2TThhS29IeWxKNC80MTR5dU8xUFVWcVViSkpQVHF0cmVmNkd4ZStJdkRsbjUrL1V0U3RJcFBJQ3RJeGNrbGRnVlFkdzVQSllaQXI1NXVOS1dYeGRMZXBiMm1vN1ZWNHBEZU1zM0lJUHk1Q2x3Ty9hdlJZUENxYUhQYVIyOXJkWEZpRm00M21aaXpzdVhKVUJWVWZ3a2pJUFBXdXp1b1V0WW5nYkVlUE1ka0Y1RytWUENxenlKbllRT1BYcFNTMTlUZVVtcnFMZXQxZlZhUDBNeU84dk5WbmxWN3F5blZtakxUTmNoaUpHNFdFb0FSbkI0QjVQWTB5MzhWMjlqcUQyVDZoYjJZdHJxV09XZU9YekE3RWRnVUovQWRLNS9UL0MrbTMrcTNiaVdlUko0b2h1bGpXRGdNb1ZsWUFNemZMazV3QWV0V2RXOERYT2g2eGN2YmE2dHNMaUthSnhQYmJrbGtaRHRaQ3VNdUNjNDdVUHRjeWpCV3VwMnR2SnZUdll1YS93Q0RKN3k4TjVENGxtamltamFPU1pvbGtRaGdCdUNmTGdFSG5wbjByQXVOSjhVWDRpK3o2bFl6U3hXa1F0b2J0aEcwNkRJM2JaUVZQUEs1K1lWMXNIaDc3WFlUTy9pbHIxMGpWcmlHeXhIalBHUWpCc1lIRzBIZzlhcGFaQnBHbnQ5bXNaZFF2YzJVNE1KdWN6UnZ0QThyeTlqRlNjRXFSazAxMmRpbWxGeGQ0SmJhYVgxdHZ2MFBJckM2K0lwV0tHU0NleFZyV1VtNDJqOThNNVlzZmwyblBBR09hOUs4UHllSWRKdFI5dGphU09lZVNNU2JOeEpXUDVtSjVZSXZxT1FlbGVnV2w1SHJsamJ2RkJJcXVycVlHa2huYVNTTWlJYlRLUVZmQSs3dEhxZWE0WmZGTnhwUzNjMGx6NWx2R3dFVDduVWlLVWhjdkdWWUs2NEFQYlBBck95N1hNS2xPMVZPTVVrM29vcTJ2NW1MTnI0c0xLS09MUW9MbGxrazNHUXY1cWJqbjd6RUJsWTVQSGVpdStmVmRKbTFTYWFXWmxta2lWZzhrZTRtTnZtVURlcEFIT2NEODZLdTY3TXg1NmkwNTZmbGRhMis4MjlMdUh0NWZzd1V5R0JnWmZPampPMTNQTFFqZzU1NFlaejFwdXNYRjBZQmJSNk5wdDVwcERyY200a1dGbzJVNE1lMHFkeEFJSWJ2WEw2ZGZmRUxNZTdSNDVGTWl4cmlTTkFpZjNNWndDT3BibnJpc20zK0hHazIxNWNYdDVkWGQvTmRYQmExV2FWakRBakRvUWMrWmc5dTQ2VktVZGRkZWgxMEZ5eGxKMU9YbGo3dDlidDlyTTBZUERGcmQzVjVxVTE3YlhrVThTUk1XaHd0czBKUDdzSWh3ZUFNbkdCeFdmWS9EeTJjQzVoMGZUOVJFb1YwRWl5U3lTUmxTMjFUSzN5bnR6MEhhdk9MUzQwNngxNHJyTitsdHA4VWlDTzFpK2VFc09DemxXNDV3U3VLOXd2ZEtzN0s2alMwMTE3QzNrdHpJc01UckxESkY5NTVJeTdaQTQ0d2FscVMxL0V5ajdTM09wUGxhU2JpMnRleFE4TVFhZHA5ZzE1Sm9zT2lRUnV3aWdlSFpoOXhHMG5CWTljNFA0VmIxMU5iVFV0UHRJdE11cnEyWnc4a2tER1Y1UVQ4aW96RlNvWHJ6elhOV0hpeEJmYW45bnU0SGhraERRM0x1R2pqT0NWUndxc08yTTlSMXJ2eEg0aHZmRGtVRjJsdmRUUzVNdDNhT1NzWXp1RDlEOCtlT0J6U2FmZmN5dnp4bktTYmQ3dFBWdTc2bUJxMG5qS0RTUElpMG00dTNrdTBqeXhET0l1Q2ZNS3NBQ2NZejJ4WE8zQzYvRnFiTHFXbjN6YVlJLzhBV3pKNW0wc2NFazVZRVk0QkhUdUt4dFM4TlhrSGg3VVJyT3B6ejNFN3hsblNLWHpXamlZa25hTTdwTnB4NkFWZThDYTU0YmlhWTJOdnFxSzRJaXVyZzdFS2cvY1ZuNFVnOERpaHBwWEtxVVljamRtN08zTnJieU9lZnhiOEpialZKNHBMMiswd2c3STJpWm8wS2pETUF1R0lWdXB3T2E2ZFBpQjRUdDc2MW1WbWx0NFdsdzBrRERMTmdDUmR4K1ZnZVN4QUpGZW5TZUU5QnZiUyttdW90UGtpY1FpYTR3alB1ajVPWHpuOEFhejladk5OczdBQzRnaHVMaTRpRU1FQ2pjWkVRY0tHNkU0NlpHYWF0YlJzNkpxbHkwbkdMVHRkdHlYVHRvWlY3cXZoaVhVcldRV2R1OE4zYnlobWd0MmtXU1FFTVFXeGdEdWVNMDY0MG54QVdtaWlzYkNTRmdxUlhkeG1WWFlaS2lPTnVRVlBWY2RPYThlMHlINGdTVExkNlk4V2wySVJsRnZNbXd3aFFBUE53TXNXUFRqUEZkcnFlbDYwTkN1cmpWTCs3REpiSEhsenJGQ0dLa2dya2J1U01ZR0RTZDduREtNVkpPVm0zdnk5UFhRMEovQ01nMW0zbXVUR2lwdFdSWVhtaVJPN2ZlSnlEZzRBcjBuVTd1eHRkUFNUKzBJSTdYZnNCY2VZMGU4aktZWElBeDBZblByWG1YaC9VTloxbXhTS0o0dDluQWhkcFN4VTRHMGcrV0Rrc0IwWTE2eDRmMFBUYi9SSlliblR4RXVRYlZiYVhHRU9jdjhBT0FldWNaelRhMTNJcFFjK1pSanVuYTd0dDJzWldxMjJtYW5vTXR2cDkwaXRFSVhGMU9vSWlMWkEzRUVGbU8zOHE0ZTA4UG5UdkVHbUpQcjB2bHB0akVwV04xblNRNThvQW5JVS93QjRqajYxMVY5NG50dEVkOU4xNGVaYnlyR3NLVFFLR1pBUWpaWlNReEpPZnBXRHEvaXJ3akJkMmxpbHYveDloVjJSWlVvUWNMRWhZRWpHY245S3plaU9xcTFGUmFqRzlucHk3Mi9RNnk5MUt5YnhESHA5czdzOEx6WVI0LzNiK1dRdnl5WUtnOVNCN1lyaFBGbmhoOVExQzBSWmxnRVRGZ1RHUnRVY01wYzhaQjVBSFh2WGJ5NkRIZVhGaGZXVnlvanRCSkhjMlJVc1paU0F2M3NnN2g2VjVmcjJvbXl0bzkxalBjMmNsd0FIaWZkTENRTm9nWTg1d1IxN2lsSm1GU011WmFLOHRZNjMvUTBZZkVPdDJ1cXBwMHFJVlJpdjJ1V1JCRzhRd0FXWUVqajF4V1o0anROTDFXOHRwSHZJTktrc3k0WklsODVabmZDaFhJQVVEYU9QUUVWNkxvdWxuVTRyaVdUUVVXUzRqaldOSFRFOGNaK1hjYzRBSnhuSDQxbDM5dlpXVWQxcE56SE05dERHWG1ZNElkWkJoQ3NqQWxTRDh2RlZGcm9yQmFjSUtUbHB0cXJyczczTXpTam85L0RiMm1uYWs4VThFWmpqZG5EbktqQms3OS92WTVybjd6U1BIR2phZGNSMjhrQmxlVGZheXhzemw0c2dTdEoyNDZqdlcxSHAxanFLcEZQWVhWbE1oL2NYRVFFTUFYZ2xNNUdlQnlUeldXK3JhamJmWklkT3M0L3MySkFvTDVNNVRrWVhnWUhhaDIxZTVpcDB1VlZISGQzVi9Yc2V3WGt1dWlLS3pGeXNOMDBKOC83UEh3NWRRZHdCMjVMWjY1NjlhOHMrS1dqNm5aZUU3YVBVWTd5OVZMbERBWUZDc2thakFVdHljazlUK1Fyb3ZEL2lyeFZkU3kyMXpZckdJQktvbnUxK1lzNEJSVVhLczJSd0IxelhONjE0aWZSTldna25pZlZWQWRJN2JkbEZMNElDWkpCWmVtRzVGT1A5STlHbFVzNDczYlZydXlYazdIbUdnNjVwMW9MSVNhSmMybCtraXhSczg3amVSeVBuSlBMZmRJcjZOMGZWTlZzSjVyOHd3eFR3d0tpd3pBY3h5dG5lZDJSdVVnZTJLeEgxM1RiT2NSM05wYXh0YTNNZHlmbU54OW1tbVBLeVo2Ti9oWElhdHJIaE8yOFVXY3pXeXcyODY1bW1kam1WWjJLNEtrbkFKT2NqcDJvdlpuSTVXa25DNm56YmF1emZYWFUxckR3UDRJRXQvSGV6bWQ1YnBsbG1sdVRFeGxBeXhVS2VqRThIOHE5THRkUDBSSHRyYTFzTHVNcmxWbmd3MjFWL2hNZ3pnNDVHZjUxNGZyazJoTC9hZHBlSzZsNDk4YzVkRE9HVEtxRkk1eGdZNSt0ZE5vMXpOWWFIYUMzdGRWdTJrYnkwbThnQVJxQnViY0VMY25vTWppa25lVExwMW5VZHBKT3oxdmRzNkZmQzJtWGx1cjJzcGd1WXJnU3grYS9ucEh0R0EyQWNISVBMRTVGUmF0cXR0b2tKdTVZNExpZUJZaXJsTU50M1k0QUhBeG5CNlY0bmZSNi9lZUpaYlgvaEhkU1cwdTRkMlZrM2JIeGhTUHU0SCt3ZTFlajIzaFBVN3dRV2wzTEtiV09OWW11SXB0anNpRGo3MlZCUFE5aDBvdDNzUy9hVS9aKzZyeWExVHZwMzhtZW4zMTFvM2lMU21lMVNhVkxqYnNMT1BPbEF5eklva1BQVHJpdkliSHhqb0dsNmUwOE9seXlYYXgvWm9USy9uU29FSjNBdXdJUWpPY1k2MW5hbjhKNUI5a2x0ZkVVbHNxTis4VzRDeUNGUjB3WXlXM2VuclhlV1hoMjgwMk5oYWF5ODhicEhKZFFTeEtvdUR5cFpDK0NBYzVGTldYVkhUUHBOU2kyMXF1cTdkREsxN3hmY1drbHBQL2E5eW1MU0pZbEVheXhvejhFTXhBQlppTWxqM3JSMGZYTlluRFc4VjJiNHlLWkdqbFRaUEc1SCtyYlpoUTRQUmw2RHJXdE40ZDAyNzA4VzkxcGthZlpoaFFMa3NHUmp1QkRnZ0RyeU9XclAxRHc3b05wNGR1R1NFNlRjc0ltUzlpekpMR040RzRxVG5hU0J6MUhlaHU2UmhGVkdvM3FwTzZiYjdGRHczcUdvV1hpTjdqVnZER24yZDVkcDVUeWk4UjJrVmNNTWhpMkQ3Z1pOZWdYbC9xbHo5dHRZOUl0N1ZwRkRSVHpPc2k3bUpBeXFZL2VEK0hqQnJucmV5djdteE1sbkxwdDVkRzNMUzNCVlRKS004aHhqUHpEcGpnWXE3WTNjMGtWcVBzOGJia1NTM21SM01QbUZzRmVjZ0ZRZnUvbFV1NTB1cktXbkxhTHRhMnE5T3BsV05yNGhoZDdxL3dCVDA2NHRJaEY1TVRLR2RWaDdnRlJncjJ3UGF0Ni8xN3dxZFZJbGNYRW1vUnZIdDh6ZEU2aytabmFTQURuZzhjRHJUclBUZEJtUzdlUFVaSVlwR2FNbEZYTzl1Q1V6a3FlUHJYTnBwSGhyUkxPOEthTXQ3YStadGU1ODRtY1Rub1dCeVFmOW9VYjNzUnpUakM3a2wrSzAwdjZIQ2FyWkpwOE0ycjZHK3BJaXpNajJhN1FwS3I4KzFuQkIyOXNEcjNybzlCOEtlS0dnL3RLOG5iWk9ybVRUYnFabDJBY21aSDZqSTRJQjVPYTZLTHhqcVAyLzdFUERKS1NuZk5Jd0xBaDF5c3JGaGpIWG9ldmF0UFRiZlhiNkM0Vzh1cksxTVR4eHBJR0plU0xjU0JJcS9LRkdjY2MxcGFTWE55NzlUb1ZLckdpcW5LK1ZyUjdKL2Vjelo2NUxiK0lYV1RSN3RMWlk5Z25DQ1dNUk9WenRmSkJVNEFIZXU2azFTRk5ZTGFmZFdrMGpRbVUyVTZpQ1oySjJxQS9BSEE3ak9Ld1pmQzJyeVdxUTNsN010a0ZKaWVGeWg1SkpVYkNXQUdlOVp0aDRZS0xmQ3kxcmJmV2tTUVdjMTdHazdLcDV5N0VBakpPQU9UaXMxMU1xU2xIbDBXc2xvK21tNjhqb3J3eVdyUVhJMFI1SUhzM2p1SUJJa2JMSWNiQnVUMEhEa1Z0Nlg0anNOUU54YXBwOTRZTFZsVzVZZytWZ0RxQktDVGc4WjY5NnBSYTNQcE9ycERyVnlzZjJpRUZGZU1JdTlWQ3lLc2hHQUdZMXhscDRuc3J6VVp4ZXlmWlFseXlQSTUreWJZNDFMS0hLbkxrcWNad0swdGZvZEhOVVQ5MUxWN2N0dnZaM2JlRi9EdDdxeE1kdE5ielBDNUxnR01TdzRLRldVbkJjWjR5UFN1RzBqd25xdWlXeGhodTVIdDlUaVV2TktBeVFzVjJxV1hvVGhRSEkrb3J0Zk8wYTl2cFlvOUl6RTRqRnpjNzJCVXB0OHNEY2MramUvVTFoNmhwYTc3cGJQeFMwVnJNZ1ZzTUc4bnkrY3EwWjdybmNPbWFOQXFRakpPejh0SGI1ZWcvdy9mUXZvOE5oZFhzVnhNVkxzWTNNVzErTmc1d3pJQ0R0QTR5ZWFOSlNLRFVBSmJwSFdObVNWOEx2bkNnQU1keEhDa2M4bGhpc0s0OElXdW5ha2x4WXJjWGswY2FQOXF1cnM3VWNkdG5PU3c2N3VEV1VoMDJMejF1ZkVFTWw0TGt4VzExSHdWRGpKWGFwTzRnbkhZNHJQZG5DMDFKSnBlNjFyc3ZSRmp4SEY0WDFUVVEycFQ2bFlYRnFra2sxMWFMZ3lJTUJTc3BEZklQN2hxMTRLMVdDWHcvZldiK0xJTC9VbVozdEpMa0cxVGdjQWtFbHdvNTdWUzFMU05mbVdlNHMxbFM0a25WVWJ6V051WkcvMXA4c2dnQUFmS08rYTQzV3JueEJiYUJOYnkrR05QdUxsbE1idmJBWlpUa05qR0RsdlJlZ0hXbmU2U08yRmViZ28rN2EvVzEzZnpNcnhGY2ErL2lNU3ZhNlhhSVl2M3Q1QXdjeUJPaklWSUpaaWVGNmoxclVraDErM2lqa0gyNlpBZDd4WG8rMEhLc0J2WEFaVG50bkJ4Vzc0WDNIUXRNaHV0SnNpa2tHMU50dk5GKzdjRlNvZEFXRElVT2NnNXlEMHJ0TEtGaHA1UzUxT0dOa000UWJOclNSb014N21VZ0dSUFVET0tOamluelNrN3RLM2JmVHF6a3AvRi9qV2ZUck80c0xLTXp6YjBLUzJ3aUR2enhFL0cxdHVjZXVEV3JvVjk0eFlRM2VyMzF2QmJPNVZJN2VQTC9lQy9PNU9ZeVNPTVp5SzVTNDhVYUhvSzIxeEpwOGkydXJ6b1lyanoya1ozaCtVemVXVHVQZXRRK0k5TTFacDVMYUMwbWoycVRMUGFlVTZPZU8rUmdBWnhROXR2bVZVbk9GSG1mTTAzcEtTZjU5ajBYVWJ5R3hSSnJwbE9YQ1J6Q1pES1JKbFNIQU8wNDZBOTY0YlZmSGxuRkRleTZicFJ2Z3MyTG0zRHlSdnNpd0N6QWNjTWVudFZTTDRmd3hhZUo3ZlUzRnRLcU84RE5GSWtlVHd5elk1d2VWcldtOEVhZmU2VmFUVFhqRy93RE1lUkx1TmxhTkYzWk1aT1FHQlBPRGtrMDQrYktncHFwOW15dExYcjVHZXZpTHhWRkpIZFd2aDREOStzaU05MTVVWWhjRE85QXh5eHhnNEh5K2xlL1FhMGcydzMxM0JHWkZSNHd6TElybDJJUHo0VU1xOUFPdWErYzMwMjBzV3VyMjkwN1VycWVNRnpMTUdTUDVNSGhGSTJrOU1nVno5aDRpOEthaFliVHByRlVUenBJWTNrbFpwUzMrckNnRW5PT1NNVW52b3RDb3pxUlM5M1Q1NnQvZWUxNnhlNk1tcVJmYWJ5Nml0cG8wZU9XQ0ZVaGN4dnR5OHFFZ0huN3JkdXRjNW9yK0VTMTZJdkVjYzhjTWp4M0VkOU9yNzNsR1FZZ0NjcjF6eHhYSmVGdFMrSHhndEpaSU5Sc1pyeVZFVzJ1SkhraUJjNUVzYXlaWGFUOTRIa0N1K3N0QzhFM21zYXpMRnB0c3M4RzZDZU1KRnRlU1BKREJqeUZidVB4clJhYXMxbENLbSthTjd2UzNmek05cnJRMnRrdG9OZjBheW5FMlVDRk9DVGtNd2ZibGdldU9QU3Vhc2ZHbmpLNTFyVVV0ZFAweGxoWVFSU0pPWE02UmtodklMSG9XNVA4QVdydXJRZUJMcVhUTE02UkFsd1NXZ1M2c3lZSkZCQ3V1OWR2eWdqaGdLc2E5cUdxV1dsWFFpOEdPb2g0RVVES3NCVUhkdjN4bmZ0T2UyQm1rM2RiWEtjbHlKUlh2TnBYZWk5VnQrSjJ1b2F6cWJ3UlhkenFRMFdkOEFyTkY1akp0eHRZTWR2cjh3cnpuVWJlNWtrTnhhdHBGMUlKZDg4OE14aWtRamp6RkpPMWZ1anJpb3ZEMnQyM2pIVFovTThOR3laV2hpRWs3U1NLNm5xems4N1ZJL0NzUzExYlVvYnVHMm5paGl0emRlUkJKS3NlMktPRlR5ckVLVjh6UEFQV2hjeTZITFc5b3B6aE9QTmJmWHI5KzUyT3FlSVBHMHlvYlNIVFo3WW41SnZzNWtobGJhY0kzSk80RWRUeG5GY21QaUhmNlcwcmF0ZHlseWhWNGRyeE5qT0JoT2lxdlVISEo3MTMrN3hqWVdza3VnMzloZFc2dVcrelBHb0dHT0JHWlZ4OHg5ZW9ybTU5YTFEV2s4K1RTcnEzdkxhUEN5TEVabDNqalo1cUQrSWNnTU92ZW10VnNUZWJoSG1xU2V1cVRWL3YxMEwyaytMUEQwK256aXkxREYvS2dlRmJqZEcwcmpwdUJMQkFwSHluaW90Tmc4YUpHTTZqZUdCRHNjR1JKMlZoejV1MFlCaUpIcWVhcGFKb2N0elBITmJUM05sNUUwa2R4SkpGRTI4eU1HS2VZT2NaSEMrL1d1MzFId1o0VnQ3TDdWZUcvVklaSTdtUU9XbWhqZCtqS1Y0eHhncjBIZW5heHJHTW5HeXZ5cnovNFkzNHRaMTZDNk0wNVdFUXN2bXdTd0lvbFVMemg4L2VCNTRISFExdXpmMmpjelR0YmFwTkMxd0pNMmhQN3BtR1BuVndBd0hIQXJ5c0o0ZXY5TUxpMHZYKzFIeVcyU3JMTDk0TUhMQXNRMlJrRmgyd2FtdDlNdi83UHVvN0R4TmQ0bGhrRUtUUnJKSkZORnl6R1RqK0h0MFBQTk94dlRuSzluTHU5V2VrM0Y3YlcwVUM2b3IyMTE1b1ZrZ2N2RVd4Z0J5UndXSFRJeWFVUFlXNjJWMjBzOWhBeGQyaWtFYWwza09FYWI3d3lmNFNPZWVhODIwSFROZHM3Ti90bXBSWFl0OHl2T2pHWXBLUVNHOHR4OHloZWdCR0syRWswK0xUckQ3ZnFVenlYaFZEdXRWUkovTEl3d2lCSVVIT0NUZzhVbEZGM3MyMmxmVzMrWjZrdGpiU3pYRHdPMFJrSDd3NE94YzQyN0d3Umo2R3VOMUZOV3RyKzF0bzBUN1BpTjQ3dmRHcXRJUUZra09DRGhoMEhYTlkyclBwT296V3Njc2M0MHVJRUc0V2Q0bzRzSEJLQWtmSjY0RmJOaFplQ2J1M0NRUzJqeERNU1RDN0pFYmxoZ05rZ3ZrOS9YZzA5TGp1NU9TU1Y3NzgxaTM1ZHc5M0ZOYXpSc0RuQWloZFJJZy92TUc1M1k0UFFkS3RpT2ZVeElaSUx5eW50cFNJNXJXNVVLQXc1TzE4aHVtT1J6WENxZFowUFViaTFzcExxK2hqTE1MY1FpSVc1Y2JpVGNFL3hFNVVEcjNwbGxybC9xV3R4MkgvQ0hYRUVBUXU4OGpxNXpOeVUycWNFRThnNTRvU1pVYnJkeFQ2cSsvb2R4ZnA0a3RaYmFaTlNpamhoWmpPSlljbVlqN20wUjhxTzVGZVlXTU5vdXJGYjdVTFV6MzBteU1Fdkk3QjJBWXlFamdIT01IZ250M3JzOVJzVGRORE92bHgzRVgrcGphVTI3bG1CVVlrUWxTRGdqQkdRYTA3KzBhOHM0VXVyZTFsYVNKV2t0blV4eVNDTUJXWVNESHpLYW1XaG0rYVQ4bHRjNWJWN0MvdFkwbSsyV2x5bG81TW1YTGxvQSs5R2JBS0Fqb01BazU0cnQ0WjVackNZV04wWkltTW9rV0IwRHFyZktVRHNUdHgwYm9mV3VGdjdtOWh1TGV6TDI2MnJwaTBhUzNpbWhod2Njc1NDekJod0J5QU1ZcmIwcUNQUnIvVWJ1TFRudUpybWFKN2lHTFpGS3U5TWhnc2h3NEJIUUhnVU5KV0pUcCswYWkzSFpIbk9xNnQ0VWcxaTRlKzBTNjA2N1I0MWhsdUxKcFkwT0FvMnNwWlhCN2RQclY3KzN2RUZqUFpXc0J0STB1SlhUekdzNUJFU1dBZHQ0eW9aQ09uSFBYaXEraGVOZFluMUdRM09nenRIRkl5R2RIRTg4VWpaenVHUUFCMkFCNTVycmJ1VHhuQS9uMlZ4WjNxUEVRUkxLOEphVlJnL0x5b3lQUTFLdmNQM1hPbkYrOTVOUGYwUEliN3dmNFhzdFdUWGJUL1hRWHBNOGFYS3RHNFB6T3dRRDVYVTg0QU5lb1Bxa0QyVnVGZ3VFQXVTeithRkJqUElKeGo1VWNEQXlPZW1hOHVqMUx4bmFhZk5KRnAwZ3ZGdUM5eXBkWGpqamNmZEtzQ0d5Y2NqazlCWHBoMWk4Z2dqODdSb0lJV2hXUlJOR3NURm1YOTZ5bzJEd2VnNmtWY3J2VXhxU3JTZDV5N0pYZk5hM1E4d2FIUkxxUFd2dHRwZW00TUVFc0Z1WlRDb3lXQUtieVF3WVlPeklPY2tHc3JROGVHNTJXYlQvTVc2L3dCSzhpNnVoSk5BNU8xWC9kL3duN3BQNWl2ZEl0VHNKN0N6RjFKcDByK1Nza0VwM1hDWkpPeVNSV0FDQU1NWTdIdlhPM1Z0WTMybVhRZTR0cDVva2xDRzBVeEFCVHVFVFNIZXlaSjdlbFRvdW9wUW55OHFrbGRKK2QxM05lSnRMMHVHQXhSdnBpM1lTYU5Jb1hlM3dCZ2lNc0dDdjhveVFPYTVyeERyK3BSeXhRYWhiU1NSM1M3bld6ajNuY3VmTDJuTzVXejF4MFBTdUowUy90ZFN1TlBndUlyY1MyTzlvSkd1Zm5pQUJHNU53RzVTVDFPUmtZTmVoUytGdkhGc2w2dHJiV2x3SnhITVlsRU1SRHBsaXFEY0dCSVBYT2M4ZzBhUHVadDFhbGxaM3NycnUvbGNyYWRyRTFvYmk2R3FOTEhHRVFMZlNQYWp6SFBsR0pvd0NDUVc0YzQyOTZ2UStETkMxSFVKV1NDNCsxeUtIdUk1YjJXUms2RE1iSXdWb3V1MGRqMU5jL0tQR3VvTkNmc3R2SXE3UE50YisxY0RlRnlVTWlzZURqaGhrOFZCZTZQZVdGN3BZMDB2TXFSVFBkTEtwbmVJU2tob0lwRnlIMmpoUVJtbnF1aHBUY29VcnVUdHpXY1U5VHRoWTIzMnVNM1duT3R6Q3lLMXphT29oUWduYUpHVTduOHpna0ZlTTlhNmIrMExwcGZLK3o2SGQ0WmhPRGNxa3l5N0FIVmZPSEl4eHdlbGVkYUpxV3BXMHp6aU8vYTJ6NU15dkVzMXd6cU5xb1pEZ0JPK05vSVBGZHRxbGhmM04wWklycXdrbldGM2lpdllsQWFOdXBZQWtnazl5S091cHRCcE84VnU5bC93UzFmUmVLcGJoMFRTUjltTW84eExVSkkrTThndG5CUmx3U1dHUWVLNUx4WnBGaUxlMFc4MEM3VkFzaFJZRUN4TXBKRE5oUXlveDNjanQycDZlTkx5ZlRMciswTk1HbTZ4QmJTK1M1RFJSRndjQlkyemgxS25yenppc2ZRZFYxY21BTTgycFJYTU9RRnZXaFpwMGtVK1c0Y1k0M2ZNUnh0N1VKTjIvd0F4empEMmtvODN2dnpINlRwSGhRcEZQcFZrWmN5S3l4a1J5dnQ2YnlGSVlSN3VDdy9HdTUvNFNHN2p0NElML3dBR1h6U2t5cWZLUlVnVUtPdWVQTFZ3Yy9NSzYvVlpkVWxzeWJTeFN6TVNBQzVWVzJyazg1eHNZQU1NYnNjaXVOdG4zMnR5bDVLcjNFeWlJUnhUQUpGSkt1OEZta0gzSk1BaEdCd2Vvbzk1K2pLbHkwM2JmbTYrWjBGbnBXbDZnNkczdDNqV0IwTHdSckVua3FRU3JsdWR5akdHQUpKN1ZrMzJyWDJoZUpGZ2o4UTIwNW1ZQnJXNktLelJrY3JHVkErWlZIRzQ0N1Y1SEpvM2lDeDFTeWttc2RiVzJzNEdnalNHV0dXT2ZlR1pwWFk3RjNjNEFDOU1WMGQ1NEU4STMwcVN4M1RwSTd4U2JwVkRUR1FESEw3aXZPQ0RrWUI3MFdTKzRsdmxzazliWHVuMVBTZFFrOFpHR2VTL3Y0RXMwVGJORkJBUyt4aVZEamtuNWVwQzFoYUI0ZzFpUzErejNOdElVWk1RWFRTeHNXRERBWXN1TU1HN05uSjYxbk9tajZmY1FQWTNGcERIRWh0bHQ1N2p5Wi9PMjRiN3pBYzl3TURJcm9OTHRiNjAxaTdNU2pWYksxaldWVmt1QTBqWENnRW9zWkIyc1BVOFo2R3BTL015ajdTVlpXaysxNzMwT0pPb2VON2RKWG1hZTRYY0lwVVcxQ3h1eHo5MlRHUXFzZWUzcHhXclptNC90SzJqdU5QdWxWV1pKeUx0cERHNEdOcEFJRGdZeU8ySzI3TzQ4SXpUVExkV3QxcGs5eTRkb1pwZjNXNkliakhrWXdjZk1WNFBlcmphcGZQbzl5YlNlM3VDOGtxcTdKNXFOQW4zVlZRUXh3VDk3bW0xWmtxTnBjMHBjeXMydXUzVFU1YStodUpOVHNrdE5UbFVaRVV5eVJSa05IdkxnRjNaU2pBbkhPUWUxTGErTFJwMFNYRDZRNXRKNW1DejdHYUpnQ0YyQUxrQmgzengzRlU3ZisyTlRoaHVJSjlGMU8ybFF1cnpXdmt0Q2M3QklWSkc1czhFRDFyWmludnJVVFJ6YVJMTGJ5Qm51N1NCVExHSlJnOFJTRW5BQTNMZzRITkpkckQxNWsyN1BXenQxOHk5cTNpRjQ0Sjc1WlpJcmU0Z1pVdVFqTGlWV09NTWdZQk1kZU1udlYxTlRnTFNDNGpTZHZLTElZb3hrS0YzK1loWW5nZGh3eHowcXRjZUYvRDExQ2hpbG1TQ2FhTnB4NXo3VkNuSlBBK1ZnZUNpaXEycTZjTkpEVzFycWw1ZndUbFVrVGFKNUVHUVJ2YmhsQzV5R3dTT0tHbXkrV29sek9TZXV1dmwwTkNMUzlJMUVTTTB0MWE1SmJiUEpKbEZrVmNZQk9BZW1jNXFwcDl6cmxyZTMxcEZibWRvYlo1UE91RElHa1FJRlVyakFiam5ybnZYSWFUYlR3eVdlcVFXYjNNeXMwTE85L0pNclE1eHRjRVlQT01rRGlvMDhSL0VIV0x5U08yc0RFbHE1dzhUTkJIY0lBUGtPY2tEUFR0VGJlbWx5STFLZDcyOTY5N0xTNjhyblFEeDNwYXkycVBwNldjL2x1MFQzZm1lV1haZUJ2d3lsR0M4RTg1UFNzaTgxSjlRdnJoaG9oc0pyYU1MTmZvcTNLSGV1VlpVQ2p6RjU1UFExZW1TMDB6UXdMN2RDbit0ZTNuM1hBUE9DcXZnRXFwN1lyaEx5KzhLMzg4TnU0a3RyaTZUL1IxY0NEenczQmlNcUU0UG9HNm5IYWtYenprMHJicmJkcXhzUkxvMTBGaXR2RWxsZTNFbHhNb050YU5EdlAzNHhJRU9HeVZPNGRPbUJXbmJXRWhWSmJJYU9GbW5rbG1oR2w3UkkyTnVkeWtOa0VjY1p6WEJlSGZBMmc2WmN6U2FkYTZoQ2pzSkVsVzdDeUVkV2l3UDRsOStCNjE3VkQ0YmlGMDExcTkvZTZoRGF4RVJXbHluMmRlUWR6NVRZSld4OHVhdCtUME41S0RuUDJjN1JsM2phL3F0VHcvWEpOUDE3K3o0TmE4TVhjMHNnRWFTNmU4Y2pPK1RoQzRPSXdlU0Y3aXQ3d3ZwR2xhWEpmSmFSWDJseldmbHlCOVViekdjQUhidFJHQndSMEl5ZTFkWmRhbERZMnR2Y1czaDVKOUxudGxpbGJJVVdqSzJSdXdvQ2tOd1QrdGVYWE9yM3pUSnA4bWhYS1N6eXpoN1cwdTBZeTc4RTdtbERNcFVIY3BIVHRUK1k1eWxPbEdGM1pPOW05TlArR09pMUhWTmUxVFRycTNnaTB1WGZHNm8xcEx0Mzd4czNTb0YyTndQdWs3Z09sTjhMYWI0amg4dGJqWENJSTlwTnNZVE5GRnpqR1dVS2NZKzhLeHRhOFRhRm9WMVpycXJYRUF5QkRDV1M1V0ZWYkRMbVBDcS9jNU9SK05kSkI0cStIdW9XMHNscHEwb1dTWGRjMmtCQWttSUcwRVoyTUNjZzdWNit0WmNyczdtUHM2MG9jM3Myby96dE5wOU56cnRUOFJlSGRQdjdTSysxKzl1RXUxaUpzcmlWb2xpTWh5bytSUnRRZ0FxcGFtNkVmQ21vYW5jUzZaZFN1N3l4cTVqeWZLVU5uWVNTMGI0SzhZSFN1WXNQRDFzSUo3alROYnNTSjRvWGpXY0hjRjNmSjVvT1FCd1F2Nkd0RzJzTlB0clMvOEE3SzFLUmJnWlNHTlBMbldMelBtWUt6TUYzQTV3YzU3VmNVM0hmWHlISnliU2NkZE4zcDVubmZqTHdicXJhc3QzTHJjSG5id1BzVUhsUnBDci92TnhMNEFPZXJZM0d1KzBuVUliYUI0SmRMc1VLdExJSklMbjdUdGtWVGd1cXRuSTR6VXVtZUNvTERmcUYrODk1aWNueXBSdmxkYzV5ZW9KQjVJSE5TalR2Qk1lcFhPcXFra0JubGFOamRibGhhWGJ3cWdIYm5nY2dFSHAxb1dwbEtjNm5NMnJjcXRGTmJyektDK1BJcjYvaGhhOHRiOHlQRWpzdHE2dW1RUTBXZHBaTW5rRW5uclZxOVR4Rjl2ZDRMV08zOHhDdjJXL2RXRXdUa05HVys0RGo3cEdlOVI2NnV0dWtMNmJwMFVnU1BiSTlvbmx5bG94bmRLQUJ0SE9CMXhYRStJQnJWeEREZk9zS1Rnb24yZVdXVTJqUktCbGlvMjRmZDk0Z24xQW90c1p4Y1U1THZibGNuMzMxRzNQL0NRWDBONGJ5S3draWUyWGZERmVSeU9URjkzN3JBQUtSa2pQUGVxK2cydmhxQ3dpZS8xNUE5eklza041TEdKb2l5dHRrajh5UlNqQURoczk2MWRRbjhWbVlDMXNiZVdPUzNqM1BhdytkYnlGdUJHY3FraWhjam5ubXNjYXpxOGVxM0doMldpQlJOSUpKVmpoZ21pd3luYzRWd0ZQQTNiUWVSUnl2L2hqYWxHU2xlMmwwMDFLOXVqM1BiTk0wZlFiSlFiVzJFclRPOFRKRHNqajh0dm5NY0NwbFFlTWhpM3ZTR3p1SnBMcU43WlJiRnQ3U3dTeG5BVVlDekxJQ054QjVKK3RjemJhSG9PbndYbHhOcVducGVUT3JNSGxGdkc4Y1kyNVNOR1ZRVjc4SHBXSFA0TTBpNHVwYml4OFhhamV4cVNJL0p1Vklod29BanpnQmx6M09EZ1ViOVVOMjVIT1RVVnZydTIvUUxxeHZOTlJ2c3ZpK1dLRlhVd290cXBBTW5BWlNYTEZqbkNsUmpJcHkzVFdHaXdzOXpKcUpKZG51WlhmZ0syUVhDQXVyWU9NRG5CcnNOUUw2VG9rRUlhNXVKSjVndk51czN5Wkh6ZFg2aFNWd2NnODRybHJ6WHRXaml0dnN2aDY1MVN6czUzWjU1VUVNeFAzZzBNZnlzU09oNDU5S1NTdUpVM1ZVRmVHMmkwV3ZiVTZTd3Q3clU3VkcwL1ZJWmJhTTV1VW1rYmZ5ZmtCa0hsc3BHY0tDTSs5UjJ5ZUhyUzFGN05jV1UwMEttM3U1TGU4blR6TVBnS1FUOTFlK2VTYTZqL2hJVkVHbmFnWVhWYm45eEpCUDhwbGFRN2tVb3lrQ1FkRkhRL1N1UHUvRFZycjhadTNzWkdXNGVaWkhXUDdOSzJ3WUNFSXgzQW51UjdacEsrb25wR3lqNzNlM1MveU12VjlFOE5QcThOM2IyTXNTcExDWHZqZm5aT3JIRENNSGMzeUhrYmdDSzNQRkV0dGY2WGN2cW1sTEpHMGt5eGlDUVN6T1krUXpSb2VFUDhBRW1lVGppcXRwbzluYStUWVcrbHMwU3lmWjdsSm5rKzBFVDUrZFpCOG9BUFo4WjZDdGdMcDJqazJqYXY1U3BESTdTWGR1Zk5EOUkzM0FrZXc3dDlhY1UvbjNKNXFsK1pUVFYwbGJTMXR6eENIeFpwdC9DK2xSV056YndSeWIvTVNWWUdDd2daRE41WS9kbnVNNUdjR3ZTcjNSTEM2RTdqemRRaWZLYmcrNFFzZUE2bU5sSVhuRGNBRWRPbFM2L2VlRjlWMGFPMnYwanZWamRaWjRvMmEzYVdSZW0wSzI4UmVvSXllcHJvbzVOZit3V2hHaENLUEdXZXhsM0F4TGhsYVhJTzhjYzhialZLNmY2Q3ZUZWtadlMrbHR2TlBxYzdhV1BneTRlZXhmU0JCSkVXQ3dsVE1aWENiaUVjSE9CakM1T09NVjE5bmVUYWRxTnRCNTlxa1VsdUJITzE2VmZibkJqOHNxZHcrbjlLcDZoQVBLanVMaTNGcm1aeEhjeDNKamtoeVE2T3BBSUtuZGxnZUJqQUZjNWM2bDRMaXUyKzJlSTlPbmVPSWlXSlFjU0pJTnhkeW9KRE1SMUdBS0ZFWEpVMWNWcXRmTTlLMXBZTHVDMWhnZ3c3UnhTNWR3V2pNRGJvOXB3eFBCSkxET085Y2JmNnJkNjVhWGF4eHh3N1kwV1pwTjcyeWhzWWtpd0dWanU3SGtWa1dsNzhPakQ1bWxhbEtJZ1pTMkdZcEVyOE01VGdGQVd5VnpqbXEvd0JsdDQ3eXprZzhRM0RMY3NIa21ndG95anhvb0RJNDh3Z2dmeEhIU25kTlc2amw3UlRrN3BhNnJib1RhUG9sem9sbEJiUDludTVoR1UrZTZZQkNpbHNxQUR4azg1NHpXdmIydHZMNGN2U3Q0UElsUWVZWFo5c0pYbVZGOHRpNFFubFR5QU9LclR4YWExemRIU3RZbWpndm9IamFFRnBrVnBHeVpZa1NQS0FsZXVDRDFyaHAvRCt1M0VLeXlhNU95V2NiMjZOOWxqdVJOc0JiYVZqUFU1SUpJNTdqTlMwN1h2Y3FxMVVsS1h0VTVYdTdxMS9tajAzVVNMSXl3VDczV05ka29MT3lyOHZ5eE95TVNqdHh0Ym9POVUydDlIbjFBQzgxRVFTMjBKYnltdGlacmlOUndVeUNIQ2pnakI1NlZ0V1dsNlJCcGxqNW1wUVJYRHRFWXBETzFzTHBTcHg1aXBnNEdlUVI3Q3FsN2NRZmJyUVhPbTIycEpCTHNsS1R1SkNOdkxSQ1ZRbVFSbkdRU0t1eVVVUW9MVG50WjlHL3VNY2VLOU5lUzhUVE5UdFlKRWpHMUZpa2lFM0c3R1pjaFRqcUIzOTZ6NTlhMFg3UEd0OXAxM1lYQlNLR09SR2x0MklPY0JsQTI1SFBQUEhOZWxXTnRwRnJJd3RiQzJhY0VCMGhiTnd1WDNaOG9iaXJ4OWY1WnJ6RHhERjR0dTlTbWV6MXE0U0lYWmhlMHVZTmtnRGZkWkJ4a2pBd1FPRFU4cmJUV3VwcDdPeWI1a2wyL3dDSFJGYmhZZFhzRlRWZFl0SmNnVzV1WXhLcFRQem5kSnMrYmpDK3ZZVjFVK3g5U3ZGV1NTNlpydERkR0ptaFNRcXhLckUvTGJSeDkzQyt0S3NmbVdKbmZWSmRWaUFrUnBuWGV5dEpnS3JLZ0RqQndUNkhwVkhWUEE2M2R2RDl1MWlmSG5iMlpFSjNGd1RFVzgwYmx4OTBLU2NIclVhRTBvTnAyZHRiM3Z1UVI2WmJhcnFkKzB0b0N6emZhb3BwTUkwWE9NcW9VQUsrTnB3U01jbXJjRVh4Q2h0SWhhRFRKSjdhRUVwdEJ5ajg3UVU1SXdBUi9lTmViYXZvbmhlR1B5WXJuVkpic09mSVpmM1R1TTdXak1od3FqM0E0T00wd2FINGkrMldpM3MrcTNFZ2k4cXpLU2lJUUlqSEt1NTJsbURkTzFEMTZtZG9xVithOGxhLzMrUjYzSjRpMW1lOTB5VjdDNVNack52TVhNcVd5aVBKM21Na01jZ2RHQU9hd0x5YWFHTUxvdW1UdkpjSVhsdVo3a3BISUVBWUIvNGtLamdidTFjOUhaK0taYlhVYm1XSzlnamlnNXVra1ZHdVF2QUpLa2hpTVlPT21PRFhHdlkrTnJ1U1d4dDVoS2pZdUxxTXlJTHJDbklMSkkzT01aK1hwMXJTSzIzRks4cHBPS3U5ZGZMdDZucGR0cTk3ZDJDeTZ4QkFzRnJPa3R6OW51UVNnVnNGWlREOHo0NzdxMkxQeG5vRXVvM1J0N3VmN01ZMWxoLzBlZGlvSjJBaGxZalllb3dLVFRqNG10ZER0cExmV2JDTzR1U3JyYjNNYW1hUldKSmpCNEpKeHlTZWVlbGNpWDFSOVEzTFlpQ2VPV0oydDBMR0dNdU1xVjI1VlkrY2JSOHVhaHAvSXVNVlpOSnUrcThsNnU1WTB6VzFYWHRVazBTTjdpM2hSelBBcU9zZ1k0S09wa0RibEorOWc5T2E3bTQxaStmYWIrVjQxa01iMmJMTXNjZHdTU3VDcmNsRis4ZTV3S2JCZGFucDB3aWZSN2JaUHNuaFMwUGtQSXA0NWZKQ01NNFpmeXJxYlh4Qm9OM2RQcGlhYkl5UWk0OHRnd21mWk0zemtFOGdrbkFHT1J6V3ZLa1h5d1YwNU9PdTJ1ck03VEx1eGt1SXJjWDg0bmoyUmwzWlU4eFNNcytGWCtJZGV1SzJXVzV2NU1XMS9ITXRzNDNUTEl6ZzR5cFVoU0dXUmV2U3JkcERwbHJmdGFKZDNjcnhES3d5TVlmSlU0RHNKU3VTQm5CVUhwMHFyWTNGcHFmMmxsc3hBMlUybGlMaVdWWXp3NTZHUUhweU0wbUVZMjkyVGpkdDJTZHIyUExSSUxuVnJ6VFo0WkxHU0dLTlB0RVFiRXhiNWhLaXNEdFlNY25ERFBwV2ZwYWFQSlllZmNDSFZacEl3a2IrVDVheVB2SStaamc3d01uUEJZZXRldUEyOXJhV2tVVmdENTVkakdrVGhpNUoydWVjaEZQVm1ISDRWNXZyOTVJMFVrcDBSQTZ5eDdJSXJocFdsYU0rWVhSTWhXeDM3aWxheUNTYVYwNHA2ZmtkVnFkbjRnbHR6YldkamVXS00yRmhpbWpXR1E3TUNQSUlKRFl3UVRrVjU1Ym0yMHpVSi90RXR4WTNNYUFUUVJ3U01mbWI3bTBFcEpnY0VtdTUwSFVMclVBczc2UEVVbEcyNmFObUVzYUE1eTZqRGNmalc0MG5obDBobmVleXc4aWhROGlQc0taVmVYWXNHK21PZXRWMnQ4eWsvYU55VHY2MzJQTFo5ZDF5MnR0VGFId2hmUEhGTEk3c2JnUjdBRHYrZVA3eWh1Q3BOWituYWdtcXZIUEhidElseGFOSE9QUE1jaUhPQUpCSW9WUW5RQVpCNjEzc21vU1FYR296U2lkYm5jcXhTQU1pUEdmM2h6dllodlVrOFpyazVOUHRiclRyZG9ycWVhTDdWSXl3enFyQ1JtYmN5cVV5Yzd1Z1BIT00wYWR6S3B5T0RVWThyWGJxcm1ITmJ3dHJjMHR4ZXdTTkRIbU9ScGdoaHd1UDlXcFl5RHMyQitGTnRiRzk4MjUxV0xXYlo3bUFMTGIyNWpOMUl3L2lLSTVBeU9veGs0cnVyYlFyV0lORGEyZHBhM01CRFNTdWgzYkpHSE8wN1Jqa2pya2RhM3JTZEwrQzRqS3N0MWF6U1JtZmFZOTdTRGJsSTFYYUU3ajFJNXBQVGJWRHBSa21rM3I1Ni8xWTgvYlVsdTVvRnY4QVM3cWVPV1FlWGQydG5NbTh5SGNHWlFkeWJ1ZmxBUHZYWVM2RG9Va2lTeFhMdmNvSGtNOXd6TmtvL0tidU1iZlRPZU9CVlhSN1h4UmJXZHN0enJseGZHM0o4eUdTQmQwWlhqaFJ1WWxlb3p4WFIzbXUzdHhmQ0NYUUdrNlFnUEpISE9XVW5IbHFNYnZtNlpOS1ZqU1hLM0pOWGQxclo2bm0xcm91aVMrSllKWnRSR3FYUWhMYjN1Y1RodDNMcDVRVEF5ZWR4enhpdlEvRW1vM3pYVUZ2WjIxdHV0MUJhTytYYXN3RGZORkczVWhoem4xcm5MRFUydDlUVVh0cmJOY0pMSkdNL3UyaTV6dEpjRVlJUEcwOG1zN1g5YnRiZVNVUjNPbjNGbkR1dG10NUVrRWl2SU1mSTY1YmFTY0hqSHJTZjNBcTdtNVgzMDBhNmRFWDdsZkh0dmJ4UzI5c2pNZmxraHVtVWhPdTN5bUlPOWVEazlxSzVIVEwvUzJWVmoxZUN5aFNKVkVGMFpHU0oxSkRLZ3pubnFlY1VWbnpMc2pHbk51Q3RGMjg1TkZ6VXY3WXNWYVNIVFpXbG1tUjIzU2tzek1EOG9ERTVCNjRCcnV0QTEzeEJxU3ZDK21TMmt3RGI3aWQwUUZsR05xQlRuNXVPVHdLaDB2U0xlNVZyeUxYTFNZcVFpTWpDWm94SHdPR0lDRDM5T0t4TGZVTGJVWnBMaGRNdFZ1Rm5sV0NielNvVjF5QzQycnQ2ZHptaEk1cUtuQlN1MjAzcGQ2Mk5QeEI0SjBtNEtSM3ZoNnhhVzZta2VXZHhKbkdBZC95SDdwOUJXNXBtaXp4M1VNZjlyT3FzeHhERkVodDNRREhscmdaUWhSd0JWcXhzNDVkTmRkVTFKV2tuUTVMT1RHamRTUUNRVkk0NHJtSXZDZGpwaDArYUhWU1hsdWkwWVdTUnJWbkM5QVA0T001SGMxVis3T3E4clJ2emNxVjBtOXVteHlSMFR4QlBlU3hycVZ2YXBNOGoyOXpHRENyUm8zM0pZR1hhekVIN3dIUFN1bDBIUmJiU2JxU2E3MUJETGFZYUpMYVB5RWtEOHR2aVQ3eDlmMHJvSXRjMHZUMWxXUy8wMk16ekdOVWlpZDVra0E0WjNZbmNTTy9Tdko5UzhhcEhiUjNXb0ZvdVpBc3h0MHo1bjNWT2Z2QW5HU09tS0x0OURHVlMwa294VGN0VW94dnIrWjlCSFVMZUcxaHVKWWtBdUcvMFFpUm1WUVJ0VXNYd1ZJenlCbml1WHVkSzA3VzdaUnF1aFdvbGpjNWNQaU5sQStSWW42bEdHU1NCa0hyWHpqL0FNTFExQ096alcvMHlPYU5wa01CRVFkWkN4NVpOM0s0OUsraFl2RS9nQ0szU1l2RGJYTVFpUVc4MEpWbE1vd0Ziakl5S1N2YlkxajdWMnZIbHM5RzdhMjN0YTQ3UnZDbWlPSlpVYU1TWmtpK3l5M1NTZVhIZ0xoU0FWSjlDZWE1Tzh0YmJ3NjBzY2tjdDFZTE5KZHdHQlVJVUtNTkd4R1N1d25xT1QycjBwdEw4T0h3OFRaMmR2YlRTd2hZNXJaRjI1SitiRy9PUjY0NXJ6bzZIcDJsVzB0NWMrSkhFMTJDcU1wRHhvcHd1SGo2Y01NbW1tdFRHWExDM3dycmRlZWhqblZkRDFPNHRwYmZYazA5cmRWYnlaZzJZSC9nd3dKQkpZNXllU0swSXZHL2hLZVJZdGIxMTVycUs0OHhtaGhFYTVVQmNxRHV5bnMzclZIVTRORDh1VVBmMnQranpCcG5JVUYyVVpDN2dNcURqajNyd1crOGNtMHU3aTBzZkQwSWtrRVUwVWlBM0JsRVJ5b08vSklIY2RLcTZhMDFLdzNOVm5KUmhxbGRybVhUcnJwWkgzQjRkOFFlRVRiZlk5UGtWYktiSitWU2pCMHl6RjgvZFk0NkRpcmt1cXg2ZmRzNlhkdk04aUtiYTNsT0ppck5rSUdCeHNHZXA1cnpIVHJIeFhyQ1NYVjlDc01FMGF5U1FoRmlEc3d3Y01wSlVjL2pYa2NHbGFScDJqenBkM1Y2c3l5N3RzdkRyRm5jZzNqbkpJNmp0eFdPK3R6S2VJbkZLOGJhKzdmc2U3NjM0aTBLK1NTMzFwYmFNaVVlUVE2M0NySWg0QmNmZGZOY1plNlo0V2tudGI2RXlLWTVuTXNqbGxhTTRKM0RiaGluVEJOYytOWjB1ZlFKSVpkSmE3WGlSMlNCaWp2akFHOGZNcjg4R3RMVC9DQmlhNHZacnU3ZHAzVmhaeEo5b0oycnUyT1d4K2ZGWFoyVm1jOHBUcXdUVXJTdDF2cDVYTjdWTmExbHJxMXVyRlV2TjlzejNSOHp5NEZBK1g1czRJZGgwTk84UGVKWTdXQ3psM0xGSDVlMFc3RGMyQVRod3k5UXZiL0duVzg5bmJRMnMybnd4YWMweXBMTzl5ckIyeGtFRkV5RkpQWDYxNktZTk9lM2E2bmtzNHAvSzhnVFFvZDhPL25HQ1NBTTlPUGVvYVhZaUxjcHlVS2lVbzN1M3IrcGlXR3BhZnJkdGVOcDluZVNSeEpITXhEdENYWmlWS0ZtNVlEcjdWeDNqbnczNFh2N1dDQ08vdjdOekpsYmRTV1NWaDk0THU1YkhVNXJnYjIrOFhlSE5TbHVCRExQQmNnSWtpU2ZhVlF3ZFNkb0czSVBVOWE3YU9OL0ZscnBrMDBpbFVrTXNhaHpDeExIR1dJNXdCMUhlcWF0MTNPN201T1J1TFUydmRsWk8zejBNZncvNGVmU05DMUNHNzFZdll0RjVrUG1zV2ZkdE9HRWVQa3lmVTg5cTgvc2ZEa1QyOHJhYnE4MCtwUVpranQ1Z3FCU0FQM1NrSGpuN3JkT09hK2g3MXJOSTc2NDFDV0swVnlJUkhLMmQ0UnNLeUFjWVljMXk4bWkrRkpFU09TVmJLWGJjV3NQbEFscGx3QUN6WTRZSGtuTlZaVytablVjMitaOHJ1MWUvd0JxMzVFdWtXSGlSa25sdjdXT2UwTUNTUnRISXNrckU1QkM3eVNBT3VjOWVLM3g0VW4xRXczcXVVOHRZdzlxOFFVcnRiUG1LRUlBYzkvUTFUMC9UTFdHQ1NCcnlLYU5yWkkxRXN5RTdZOGphTjNDcTJLbGZSdEhrdjdhWnhMYnp4Z3BJa015cTBtRnd1NEtXUEE2K3RIeklqQ21vUnZEUzFtbSt2YzVPNEdxcmVUM04vZVdodEpJM1pWREtIazdiQ1RnU2tmeEhyNzArYlNQQzhoRndiYlRMOHFDMGpNb0V5RTk4ZmRHQ2ZsVTBhalA0b1M1R3kvMHU5c1JOSEdzR29BUnlSSVFDUVdVWUtnOUFPYTBZUEU2M3N2MmROTTA0eXN4aW1naWVNeFpCejVpbGhrc3VNakZKTFZKRnBLT3Z0STNkdFU5Ym5GWCtnK0g3NisvdG01dEozdW5qVmdiYVVPa0lpSHpGaGc1NTlzVjBrL2lQUTRkRTg2MTFaN1c0ZVFmS2JqeWl6TVFqRGIyeDE2Y2RxOWQwdS9zaFlYdHZxbGhMODVrV1M0VlVJYjBZYk9jWTV6Zys5ZWZheDRUc0w1cHJpZTJONUFIWGJzaGlFWVI4WUhUNzNIT0FEVk8zVjJzYXlqTjhrNVRjMXkyUzZ4WGtRYVI0eUVtczZuYlcrcFJUTkpkTVk1ektmbGovdkZnTVo0NDlLcFRQTGZ0cUZyZHdUeFRyY2gvS01xcTdMdSsvRTUyN3VtZU9LN0VlSDRWbWF6dExXNmczVzhxZkpabzlzZk1BK1ZtVUVuSGNldGVMWCtpZkVqVGRXaWZUNXJlUm95cVN0SUVXUldVZFNySDVrSTRKOWFteVprNk1xa2ttOUx0M2J0Nm5qbmlUd1Q0c2g4VFhEZjIxdmpTWldjU3UrOXVQdkRhdUdJQjQvU3ZwTFJOTzFtOUdtd1MrSmZQTnRiN3pFaUFNTjNSVHVCQTZkRDBxMUhxV3N2TGN3NmplQnJxU1FDS3pXTW1LT1BIMzFJKytQVTFKcG12YXN0akQ1Zmh1VkxnTGlLUklEQXZ6REFka2NnWUhxZWxUSzlsZEkyclY2cy9aOHlqeVUxeXBxRm0vSjJPaHVmQ3VteDJraGsxcDdFTVdlNFZXVlpDWld4OTVNRmdNY2RLOGxiNGY2bmZTVFhJMTJLTzN0MFpsRUV6ek1DZmxDT3pmd2tja1Y2cmY2RmU2cnBjZ3ZYWVRUS3FUVzl1QUpONmpJY05rZ2dqNlpxdDRmc2J2U2kxbmN5c2JPSXNXbXVKaDVnakFCQ2tLUG05d1RuRkYzeWt4MGszeTJXdWoxMzY5aVR3N1phUEI1Q3czQUROYW1SUVhDbFpCOHUwOSt2TmROYmFhdDRseDlyTjNITGN5TUhqaFFJdm1RcDFYWVBtQjZub0t5citUVFBEOXVVdTlUUUpjdkswVEp0SktzdTVCc1VaS2pwelhOempWSlhzYml3UDJxTlloQ3Nkck5KYnlJQTNtWlpYT0NTT0JtbmI1YUV4WEphTW8zdGZUdmM3N1M5TWloMDkwV2E0dUxwWkNGRGhQM2dISlFLUU1aVWNEOWE4VjF6dzE0bXVoZHZwZ2lqaG5qaU4yazZ2RzZ5Uk45MUdCNUFIVFBXdm9tYXloMUMxc2RSbXRQS21TSjFoV2NsUUZQM2c2aHVTT3RlTTN1bTY0dmlhVjlQdlk0SW1LQVdvbUQyNVdQQllybkcwOGNnaWxIUi9JNmZjcDJiUzAwU3R2YzZXMjhQYXU5cmFMcCtvUXcycnA1UmpNQkc0UjhzTUVzTjM5MzFGWkVYZ2lHOXQwRTJvU3pvYmhmTURiMGtPMEVvaWpPTm9QWFBVVXNmaHpYNExTUzJndTU3dU5sTzZObjhzcmxqa3hrQUFzT0RYY2FacHVsSkNaNUpaRGVTUlJRRlpuSmJjZ3p1WVorOGZTam5sWmFtVVo4L0lwT1Q1ZHJ5ZHZsYzhwMGROVDBtRS93Qm42emR5eHJ2bGRaSVM3ZWFXSStVRGpZdy9ITmU1NjFiMkwyMGttcGFSdHRuMlNUeW9neURHMlZiQ2dsZ0R4Z0h2VU1scmNMZlhQbXh2Ykt3akluTXkvTW9YNXR5ampBUFR2M3JrdFFOdTlzTGE3MWxIZ3UzQ1Fvbjc2QndQbTZZUHpBOUNLVjNkRzBwZXpldDM1YUpLM3FOMVZZMTBoYnMyTFhFSXhMdWxrS3grWG5hUzNMRXJucndNMXdpZU9OVnZiSGRhYUxwRjNIRk41VWV6YWhhT1RqWXl1TW5KSFhOZUY2cDRFbGoxTzVuR3A2Z3R0SVdWN1ZReUVEK05sWnVHSEI0eFhyT20rQ05OR2tXRW1telh0dTBVc1Iyem56QnVVaDhPbU9RUWNWbzBsOXJjWFBUVVU2VlZ1VFVlWk9MU1dtdXU5enAvN0k4T1hzczBFNmFwYTJ5eGhsaFc0OGlHUUxnTjh5Ymp0VEdPM0ZWOU1sOFI2YmEyeTZOZFd0MUhGS3pzc2JqZDVRNUc5WFhKYnQ4cDQ2MG1uMjFnbXRYUXY3cVM0RTAvbTI5dVlIaWl0QVdPZkxQWGFlUWZldW1rVFRYdlZ0bllRSkZGY1R0UGJTTkhJcXJnN01iUWdQSEdlMUdydWN6cVNmS2xOYWRycXplKzU2NUZlYXZMYTNEeHl3UGUrU0N0djVnVlhjTC9BQms5T1R5T2NpdlBMRzFTV05JOVJ0WWJaaUd3a2NlQmwyd1dFa2U3QTdnMXhWM3F2aHBwSUxtMTFTU3phV2NuRWtmbXR1Q2dMaHprQWUzVG11OFhVb3JiVDE4elZiZUtWWDh6YmJvK3dNNE9FR2Z2S08vU3Awc2J1cFRuRzcyVjc2M1R1Y3pmV1dtdzZNc1Zycmx4YzNDc0dTNGFSK2diNVF6SWRwMjk4ak5aK2w2dDRyT3BSSnArcVdPcVRlYnRtc0hEUk9COTc5MDdERFpQVUE4VjZWYjN1dFNhYzB0cGFhZnFNTzRBeFdqTkd6THdIZHQrMGNNT2ZXdVoxT0x4emQzZm1SSkhCQ2NyRUxZQXVRL0cvRDUybGNZT09EbWpWNmRpTFdtNVdkcmJKUDcwY1BxWGlQeGcwVWkyL3dEb0syOXpMTzhVR1oyWVoycUpTdVFoVTlUMHArbVhWdjRvdEpiTFc5TGtGemF6U0o1aEx4STdzdjNnT3h4OTBWMWVpK0dkUWh1TjE3ZHFaWTBWWjQ0TnFKUGs3eTNDcjh3NllOY3JybW9XT3JxdWtKRmRXTjFGS1dpbmxEQkpOMzNzTWhiN3dIQk5Dc09LcUxtYms5TnVteDNzT2p2cHVrcDVYMlpoREVVZ1VNR2VLSW5lMkdsSERBazlQd3JocEpOS3ZOUVJVRmhlUnhCcGk3TTBySTVPVHRqVGFDY0RyNm11R0syTmxJbGgvYmtsMDBpc2RxWitabTR3ckE4bmpCeU1WNXQvWjJsNkxyOHNsekU2V1ErV1cyamxkWGhZa2Z2QTVBT09lbnJUYWZSbk0zR2I1YnlUK3pkT1Y5ZFY2bjJWcEdxV210MnNGM1pRQmdMRjBaUmJDMkN4Z25DWWtBKzhmNFJYbXVwV2V0YVpxc2EyN1JQRGVlVXRwYXh4c25rY1pCWWo1R1BISko0NjRyc05EU1M0dG9Qc0Z6ZHFrZHVSRUpXVlpuSUpHVkxaNTlNOXF6N215MDI5anY4QVRuVzhpbVFnTW9sS05HUWNuN3AyNVBPUjFxVTFyb2RibXBSMGcwbTlHKzNyM05LUzE4UzZ0cHMwVi9GRXNaYllNeTdQSVlEQkJrNTNLL1BUQXFubzc2WGFTeldFTnBFc0VZOHN5S2pCMmJJTFJ5U0o5MWhqT2NjaXV2dDU5RXQ3V3ovMHA1RmxpOG90SW1WbUM0QUtuUFFBOGcvV3VOYnhKbzBFeldWeGJtenYyY29rUzJyVFF5SElBd0V4empxYWFYVG9WT0NrOStaMjJ2Zm9YZFJTYVhVSllwbzRwYmFSVWpacmlNL3ZDK1J0aklJTzhaNkFacmxZbGgxR2NXa2VtUFlSUVNNU3d6QXhrQTJaaUozRnVmbFpqeFhwaWxidlViZUo3YlVZR1hmRW9LbFlRVkdmTStZRTcxengyckdpOE0zZHBlUW1iWFlicmFFUStVUExramtVNERIQitVWVBLOUQzcHJZemxSVGplS3V1Wlg4dnZKdExzZEh6NUZ2cWR2ZVNSdWZMZ3VYWjQ4Z2ZNbzNBRVlQT1Y0eml0RHpKSXJ4b05VczR2c3VVUkpGV1dYSTUyaVJpdTFWRGY0MXhQaUx3THBzaUM2Z2thMmNTU01YM2JZVkRIa0VBNVJHSTZqdlhCTnJXbFdNU1c5eHI4VTNsbkRmMmQ1ekJXWTRVc1dPTWtqbGU5VnFWR1Rob3FLZXZyYSt3elc5WjhPTGU2aC9ad2tMWEwyenVzRTNrUU9GY2Y2ME9CdTc0S25rY1YzRFdkMWMzMXBZM0drWEtRY3RJODRWbGpTTUVDWUprOEgrQnUvYXVxczd1Uy91SWJxMzhRb3RteFVORmQ2ZUdKYnJnZE1aSTRCRlhUcGV1UVhzMHVuZUlzVzdreVFyRXFtS0o1TWdGZ001OWNVN3BsT0ZPZHBLN2FiMmVxNldQSi84QWhOUEdtbnloVG9MVDJVVnVaSkRFamViSXVDRGtnL00vc2U5ZFhhNnI0THVOTXQ0WkxyVmxuUUpJbHZNWGlrRVREL2ozUmsyaHMvcjYxMDEvRmZYVXBoY1hqM0toN2E0bGdMQkdMSDVpQU1uNWdDVnpuQTZWMC9oNk9Xd1ZJcFd1SklZM0FqZ3VFM1RSdWh5cDUrWmllL0hBcFhWK3FLcHBYVVV1eWJhUE1yRyt1YkZydUdEVG1oYmY5cldHL1lMSHZJRzNhekhlRzJuNWlNNFBGZXdhWHEyb3pxem1YeVZrZFJGc2RYQkJ6bDlxWjQ1d1FhODg4YWVHSmZFMTlDVjFHYTJXT0p2UDJCVUJWanUyK3F2NjEyT24yR2x5NmJGQlBKREJGOW5qV09SVndaUXB3TnpESFhIVHJtcWRyZVpyR000U3NwKzdyWmJmZWR4ZFQ2c05OZGphUlhFRHFqQjdmQVB5ZFkzQXh5ZjRTUHhGZVM2bHBONDExZFg4Y0VPeVZZek9Dc21kNlpJSUgzQVFEMDZacmYweTY4TjIxOWRhZllXVWJQQ3BFNGpWOEF1TTdzdDNPUG1IYnJVT3F4ZVVpWDdXVnc2UXN2bVcwVWgydVNNWkN0bkRqMDZldFRmWTByUzU0cmQ2ZmQ4em45SGswYlZiRHpMblViVzVtaEhsUnovWjNSaUJuaGdPMk9ocnZwdFAwYTcwbUdGbXU0WVNyQ1B5NVNuNzM3dnloanp5UGxKNlY0N2RRYXJQZVdGN29WdmRDeXV0d2VPNGxhRXhCd010R2hZWUgwcmNHa1g4ZHJMQXVuMk4zQzBoV1I1cnB6TVc2dTVZOEJsUFBISHJRbllpTGNVMDRYc3Q3M3VKZGFaRkFFYU8zMVBVSVZEeFN4UVNobWxaMUs0ZnpDQXJaNjl1MWVacXNWbHJneDhPZnRNRHZIRzdjeFBESXVNbVY4aE1udVFNWTVQTlgvczJuSHpocUdwV1ZzTGtGVWl0N3NxMXdDUmhncW5LdVFPRDY4MWZpc2RQT3RKSmJYMnNSM0V5TjluMDJaQmN4ZnV5VjgwRHFvTzNJTGQ2TldhVTZrSEc2cHJybzc2K2h2TmRheThVcnphVmFXMms0RW1JOTF3NUFPMEFpQWZMdEg4WUFIU3FXclNTdzNOcEJjM05rZ2tuRUtreWVla3hraitaVlU1WW1Nam5vS1dEKzM3R09jNmpvaVJXc0pZUlMyalAvcEFRa0ZYV001SVlucDA5UlZtOTF1MHVMbUM0anNQS3VRcDJSM01zaUpBWndNSzRDa2ZNdklRODFWdGRqbm1rMXFtbi9YcWVpdzNNZHpHaGprWlZ0bVJwL0xqRXhadTZOc09TRG5QRlpMMzdQYTJWOCttMzF1c21vTXR6YnVmSkRxdVUzSUhBeXBIUHYwcm5mRnVwYXcybUE2TmRLV3l1NmEzaGE4MktNNVJsQUMrK2M5cXdkRThJNnhEcWtkemRhMVBKUGRCZnRERkZWR01neis2UjIyOXVNZk5SN3RqcGt1V20xdkxSTCtub1hZcnF6MW05OHl4aWZ6UVpKUmJPaXhLUVJzRW9kZzJId09nd2E3S2ZTTldHbGtXMTVCQ20yMzh0WjJNeklGd3hiY3VTZW1BTzlZTTZlSjlGdm9tdUx2VVRhcUNYaDhtS1E3QU1rcjhvK1FkZU9hNHpWTlhtMUs4aGcwLzdkSmJYOFpDRzQzd3hGR3kvVGdGc2doU2VSMm9TZWh5V2pHRHVwTnJleXNlclJQcU13MHo3VHBMdlBhVEJpOXU3UktpWUF4SUNBQXlqcU1uMHJqZkhOOTR0MHFlR2ZUTlcwdjdKY1hheFRKZFJCZkw3a0tSblBxM1E1ckFnMXY0bXh6ckhiYVpiSXFEZURIZUk2ektCOTExYkozbkhCNjU2MWlRK0xkYjh0a3ViU3pLWEJNbUZWSm5ka3lHRG8zcG5CYmsrOVNtMWF5TlZpRlJWM0cvbm8xMjZNK2dyanh0YU5xRnZiM0NZWXhxc2M3dXYyYVFZeVBLMms3bXp5ZW5GZWM2dDRyMGhMNlF5YU5xRGwyeFBLMXNyS3hIeWhsSkRBcU1IMHBOTXM3eTVnaGcwKzl0MHMwQ045bWtpSTJPUCtXa2JnN2crZnZaNDlLOGsxbnhCNCswL3hESnAwRU1vdnA0dk1jTXFMRkxzWDk0VmNmTHRYc1Q5S2NVMnlVNTFVbmJtdXJwMlN0OTU3YnBEK0hXdE5Ta0wzRmlZN2hYbDh1Mit5bzRYcEhsUWQyZjQwNmQ2dGFUNGsrRzUxRnBOTmpEM0wzQXpNMFRSdWNuQUFQWUtlcDlLNXFIeHdOSDBXenVKek1aeUUzb1hMeVNPZWlyOHBVWkdjbnJWU2J4TDRlMUt3SzNlaU9CY1JTQ0JKUnZKWXFTUXI3VHNJejBJL0NoNzlUTlZJcFJlaTYzYWZxZWlhaGRlRTFFcnJva1ltZ1YzV01SK1ZJVjVUSnh3VUo2SDhjVnhWMTRrOEo2VnBNczl2Y3p3em1CelpLWkh1cFpYVWNMSkZ0eVloajFHSzJ0RjFkcExKTGV6aEVFOFVVWlZJQkl3OGgweVBNNEcxOG5raXI5eFlhMEpJSUlvbWt0U0hkbldjSkl1ZVRIR3JiV3hucDc5YUwyWlNsNzZtbGRXMlNTdS9VNS9RUEVkMmxtWU5SMVdTM2FSUlBJSkxZSkQ4dzZaa3h5TTlxazFQU1pyMkl4bS9GMUF4a21XNldGWkgycmpiZ1I4TUQyMjgxMWxoZHhScGMyRjFxTEVtTlZNRitubVR4T2dMRXVvK1U5ZUNEK05STnB1bWFZOTVNTk1naEtScnViZ1FLdnFGNHhuR1R0Nm1vMzlTV2xLQ2kwOUhxbWNqcEY5NDdzdFZ1WUwrNHQ3aU9XTlhXNDgyTUl3SXlFTzVTNXlPQ3JkS3IzdWc2czJ0ZmFOTHViUzBBVHlEREhQeklyZk96UjR6c2RWT1FvenpYZXhXMWhxOFRTYVo1VWN1K1F2TXEvYUlwdHZKeUViZzU2Wk9hb3ZxM2loSUMxbjRTZ3Y1TGVZS2twbFdJSzZFQm1DajVnZlVVK2h1clRkcFBkM1ZyNkh6OTRpOE9hNVBDbjlwYW9ibUNDUWcrYVZnU1NiSUticEZZbHlRTnZBSFBXdm9Qd2w0YkduNlZ2U2F3ZGZNeVVrSUFBSTRDbnNVeVJuSE5WOVFTOVhTcnkrMUMxanVJWllsU0d4akN6eGhUdzN6YkF4Snpqbm9hNG95K0lGMXF3czlDVllCY1JGcG81b1RhVzlzUU0rWVgyWmNZT1A3MmFOUTVYS3BEZVRWMmxwRzErdlk5a2t2ZE90cks1czd6VWJleFR5ZzBZYTV5cmhPQWRweGdLUndCVkhUdEswbVd3UTNGekE4VTRhUkhoajI0ZHg4ejdUazVEZk5ubm12bjVQSDNpOTcrSDdicHVrWE1Za01WeGJCMWQwTG5BUUNYazhnZDhaNjExbWw2MWVSd1BGTGIrVE1oWU94UXFJdkxKeDhzZTVzZ242RWM1cW5vWjFxbE9NNGU2cGJwTzkvd0FpekxvdmlkSVk3RFQ3cTR1SUxtVzQ4MmVaWFk0QURLVkc3S01PY25BRmRoTnBsMnRuRmIyTU9tek9WUkxxUzVrOGtyRXdCd20vSmFSdWNlbldzRFRXMVRXWWx0cjJhUlRKR0RjWE5sS1lYODZOc0tRNCsrR0I1N2owcGIzUWRQdG52Ym1PMlFYY3FIY1pDSjB1eEVnNEc0cUk1QjFEZFFUU2k5YkV4NUZGeXMzMFYzcDhqbnRjaTBHU0NHU1NKNUxVVEVSRzJpVm50blI4T1paZTI3T1BtN1YyZWpXNlRSVHhhVlpsYnIrejFXTzZXTEcvNThoU0kyVXVwQUI0KzZPYStmYmpUcmR0UHU3dFlKWUVWaVpyUzRUUG5zeENUSGh1U1IwUFk5S3RhMWVKcGZoeXphOHMzdnJLV1lXNHU0djNkeXZPK0pneXQxQUcwNDQ0cTlXYzFIV3JDMFhlVHMxYlg1SHNPdXJyRjdQYzIrdGFkcGx3a0pXUllIYlpqY21XY3N6RFlRUmdaNUlPSzg5aWdsdk5SdDRXMDRRcHVVemlLUUNEYUZKVitVeXpxZVZBSkZWSCtLdmgrWFZGYVcxekNxaGJpU1dJSXlNQjVheHFTMzcxbEE2bml1eFhXOUFOdWJyUy9Hbmx4RjEvMFVXeU9ZbVFBa1JSbzV3Q0IwSE9jMVByb2F5cFZaT1RsRjJXM04wVE8xMDY4bmdqYTBlMDgxUkx0VTNFZ2pEamhENWVWZFYyOGNrOG1uSkxieTZ4SGUybW9HS0pneVNFUkswa2hYNWNHVEtaUEJCQUp4eGlzSFVOYTA3VUlMWVdWeFBicGZTN1lqTmJQSkhMSTZqYXlGTUdQSlhKN2RSakZjaEpIcW1rNm05MWNvREdZdzIyS0F6UmhzaU5wVTgwcnZRNXdRQmtab1hxQ2xLRVlweHZaNzYzK1IzRjdhcHJkbTE3Y1hHb2kyRWM2dmEyemtscFE0QlIyQXllUnlDZllWejF4NGhTM1NaZE1TTlpRSGdBdTRaR25ReWNsVGdIYXB6alBQUUNvdkMzaUVhbmE2aEJEUGZ3U3dNRWRycHd2bU80eVBLQUdRdm9NWXhVa1ZsSERxTnZKRnJQMkM1aW1ZM0RLTnBaa0dNOU1zekEvZDZkNlQyQ3BLU2xGV2FhM2IwMU9HVHhWOFFyVFZiZlR6NFltdkZ0Q2trVFJMSXBXSTRERlZVNWJIb2E3KzQrSDNpdTd0dEhoMDd4Ri94TDRVbmxkTGphc2l5U3Y1bXdyQ1J1UGNFbmpwbXViMUxWUGlISmVMREhEdGpDa0pkQ1pyUVRBbktTSUFkb2tkY2hoeDB4WFo2TDR4dS90QXRkUjBuVlk0bzR5czEwOEMvWjFJSERNd0trL1hyUWxwdCtwM1VwUVM1ZVNQd2U4N3Azc3QzZHV3YXRjWG1qckxIcWozYVJySUJOY1JSZVptTmxHTnVEME9Ebk9heWRKOFVlRHRRZUJ0TGdOOFo1ZVpwYk5ZMFdTRlN5Q1F2bjV0bjhReVBwWG9sdkRwTnV3a3R2RkY1NUwvdW9rQ3JjSExqY1JrN2l3YlBmNlZTZ251NDd6VDdlV0dlNW5LUCsvbHRiZU5rVlRqZWllaThaWHI3VTlFckdIdVJVa29QbWJYTFozc2g5ajQyMHdMSkJZM2xvSTloKzlDMGg2Y3F3YmEyNG5qT2NaNlZ5MFhpcTloZ004Y3hsZU5qNWl6eXJicjViSDVRd1h6TU5ucmdnQ3MvWHJDWVhRaTFVeVBKQXJUc0N4Z2dVczJSSWZJMjhzUmdEMTYxalFSVytvYWRiWDlycE50TEV4T0k1cFdpbGQwWGV4RHZ3M3RuOGFEamxLcmVObTlKYk8rbjZIWDZ0NGcxNi9qLzVCTWxxMDhWeEM0RTI4dkU0VWVheXF4S2orNlJ6V25hK0piblM0b0xmVTVWZTBKOGkxdWJsU3hrOHdiRldUT1d3VDBIZnRYQlc5am9kNWNSL2JOSmEyYVJGdVJJWjJubDNBRlR2RzdiZzV5QjE2VjMvQVBiL0FJV1M2dW9MZTEzMmErV3NkdkZZNC9mQWJ0cm5PU3k5UVNNZzk2VFhXeHRDVGRTVW5WYVY5azlmUXQ2RkRwdXBTWGEzenJjQ1dYeVVYN0RHc0lPTStYdFZXSkF4d2VLWS9nSFNyV2FTNXQ0ZFB0R0tzMDB6N1ZIa0RxcFFEcm5wanBXZDlsczdxVzN1cnF6MUxUWW80Rit6U3BLVWpoOHM1V1haajVTTWRXNDdHc3FPNmh1MmlhZldMaWY3UEpLeTNzVHh5R1JKVjU4MWxKREszWGtBcWVncHJXMnB0elFWSzJyVGV1Nis4MDdoYmFlMm12YlRVNFlpWmhITmRSV2Ztb21lRWlrMkJTVkhHQjJIV3N1TDdCQUlyZTgxZTBrdUx5NC9mT2c4aUoxeUFvMjhQSUJqSFVrRVZ2WE9pNmRwSlMrbGcxcS9nbUpWZDF4dmlqM2c4U1JKdFVvNDdzSzVhN3M5Rk1pdDRXS3dJcklza1gyVmk0TzdlV1ZpUXV6b1BYTlR0dHFiY2xOenBwelVlWnh1Mytmb2VrTExiMjlpR1NhT2VhL2RjU3hqS01nQitYYVZIbGs5czgxMTF4THBrVWRwT2J5T3pYeW80cFk1NGZ0RUwrWVNGVEl3VmZQYzhFVndlaGVJZGExQkoxbFNRQUZWOHlaVnQ0Mmt4L0NtM09TT25KT2VsVk5VMFhVYjJlMnRVbkZ1SnJoRE9rOGErVzhmS2dGa1Z0ekQ3d3owNm1tcFBvaGU3VHFOS043YWZQMTh4MnBhenBsM1BkeTJHb0w5cFJ5ajNPMFlnMkx0QWI1bDJna0hHMEVIdlhCK0ptMDI2dExoeGI2ZkRlU1NyRVRmQVFseWZtM28wTGxWSEhCT1NldGJOeDRSMWVKWTdkNDdHNG5CUkZsVkRDaktoeXliU29ZRnh4bGVDZTNOU1FlSDdTRzN2N1c5MUNZUnMrNk9MeWxmeTBENVJHamRDU0FjREFPVitsWG8yYzg1cDFkWTd2VjMzc1NhUWoybW5ReE5yMDl1eWlQTm5ieXJkUXhTQmNNVUxiK01uUEhQUE9hMWJTMjFIVUpMU1I5Vlc5bXQ4eVErWEhBbTFtRzNjcGlBM0lSeU1kUFN1TmY3SFBwUXR0UDB3V04zRXFzbjJnTkhBbURzYzkyUXF2M1FlYWYvQUdKcVUxcXcxSzRzb1lab2o1TFJ5Sk1kNnNRVlBuQlNHWUVFa0VITlFuMUpsTnRPelRpM2ExN05XOVRvN3pUdnNOeTEzcVUrbjNNU3dqeXZ0TUVaYUpNbkE4eHh5b3hrWngzcm1QdDJnTGJUWGEyTmlqTEdobk51eHQvM2NaeUpGMkhsdDNBSUdDdGRERDRJL3RUVDU0TC9BTVRuVUxSb2xpYUJZbzBqVlNNL0swWnlEOURYbk1YaFRXTGV4dU5LZzBTMHRvRmFNeFRwQWRqckd3VU5JWDNGWEh2bm5rVTNacFdlcDFTaWxTZnY2M1dscnEzOWVSMnVzNmlIMHUwbDBLekYzSE92a3JDZFFhM0laeHo4aTQzS3VjQWc4ZDYrWXZFM2h2NGszTjFhTXRzTENkQWlORWwvR1drZk9VRWNha2tFQWRUenhtdmFkS3VQRituV1U4a2JHT2JBKzBDV05XdDVRU1FKZDJHeVJqREFkQ2F1UmVHdkMrdXkyYXpYMGtWMDhEZVhLSUhqaEpQV1ZjRld5TS9LeDU5Umltck45UG5xT2hpRlNxSzlLRGF2N3oxWGxwZElvSkQ4VEo3R0dPNm10YnRDd1pVdTJEWE1NZ0grdUx3WkpLNHlGQnIwMktIVUl0Q204alV4SkxMNVJqZ01VbG9qTUNwTGxnU2Nua241ajJyaExqdzAxcGFYY00rcnZjU1JTdGsyOXhzbEFRRlVadDVSU0JuTFk1SjYxb2FIcTd5eS93Q2srSHBZR2psYTVtVXpnQStXTm5tSkdEenVIM2p4ejBwV2R0em5uT1RlMGRMcHZZNlR4SHBmaW1ackJUZlhjTXM2N2xPbk04YXVWTzc5NHhKOHNOMEdTU1RuaXZQYnkvMGhFdVk1dkVkbFlhaERLUEtra21ONllCR2ZtWHkwUW5yejgzSU5lbDZ2OXJlOWdPbmFhVXZIbWxadzl4TkhHWThiaXJINWc0T003bElJclB1L3RrUlZKTGpTSTdpUmhMTzZoNGN4c0YvaTR5TUVaenpqa0dtclgyRTV3VWs1WGtsTFRWSlgzNm96dFAxS3h1L3NUU2F6Y2FyZktYUkpZb3piNzFZRW1ZTVYzTmdjQS9oWFFTbWFiU2d0aHFLcXlTN3dzbHd3a1RjQ1ZkWkhBN0hPS3FYM2huVmlzY3QzcU43TkpESXNaYTJuamloVkUrYkJWbXk2bjgrOVpFVXNzRm9aTFBUa3VTekJwVGFJaTQzU0ZVeUhZSVdBQU81ZU8xTzkyeWFzbjdTN1M5N1pNczJYaWpWYjNTcnFPYlh0Tm44cEFraktKWG1RaHVNa0JWTEg2WUZhRm5Cb09vNkpPOFVwdEdaWElCaEx5Ylg2THVWTjN6RURrL01hdXkzc2IyMGlYUGhjWDgwY2FTcWhsaWpjUnNjQjBaZ01ISTZnK3hySDAveFBkdnFkck5xZHRKYXdSeXpJVExPNVVTQmNGQUFQKytzakE3Vk1YWXFVNWMwSjh5YWF0NXIxS3ZoelZsTm5MYTNPajZqZE5ieXVXV1N4U09PTXljU2Z2UVJ3eTR5bzVOYkd1ZUZ2Q3VzdmFhYlBZaXhudHk2d2VYSVV5cWduNUNRdTVDZnZFL25VejM4OE4xTGN6U1c4OE1oVHlKNEFaQyszT2Ryb2YzY2d3VGtqQTcxRnF4czEwNmErdGRkdVREY3d3dkNzTGxwSTQwT0NZd3h4bGlUa2RUMnFuNUdsT2I2SnEybjllb2xoNGN0N0NXTkRiVFRRdGhJa3MyWVBHcDR5KzRuZWVDZDNBN2RhN1hSdEtnbm5tVnhKNVYxR2lORkxBVmpWV1ppeWVXaENiaUI5OG5OZWFOclZuSzZSeG04dHJtREJqa3VkeVJUeWJlWFJvdHk3Z0Rub2ZRMTZaQkpmVDZkTGNDMW1hSXlSczV0WVgvNVpqT1JIS29ZSG5JUGVqVkpHY0dsTDNvdHZmVFc5emxGdUcwL1VScEkxT3hFbjJnSkRETlkvdkFnK1pZeVd5bURuZ3Fmd3FoY2Fqb09xTmQyZHByK256TUpFRFdkd2hrU0luQXg1ZTM1UURua2M4ODEydDk0aDBtTkwrZVp3aFF1WVpyaUoxWUJNRUtoSUFZSFBDZGZlc2k4cy9EMzJzeUkwRU0xeTBubVRQRUltbFFMbDlwUXFCaFNDaDVQdFZUMlhkbXo1SEYybGRwWGpyWkt3elNiRy9qMWFCbnM5TEtSeG1OWWlxdE1pSWR5eVF1cHkwZU1EYmtjOFZnZUpMbXpPcWZiV2lqUjNSVEpMY3pyQ0I1YkJzTkN3REhhUjh1RHdLbDB0dEQvdEJaWTlRaG5PMW9GbGp1WDNHS0pjaHBNa0FPTTRQYXRPTFcvRGNObThpd0ptZTQyZWJNeWo1bitiUHpic0J1aTljODFOdHRUbmRSTk9OMHJ0Nzc2R2ZwMnNhSkxvdDQyblhadm1Od1pJNFVSbzJuWWdsbFFuR1J6OTdqUFdzUzF1TGhQTXVJNWRhc3JXT0tPVmJlSzR4d1R0Y1lrQnpnbkRGdU1jMTBVSGlQVFUxT0lTU1dLckJFcXA4Nnd2REU0UDNXemlSYzRHTzQrbFFHRHhUZFN6UExkd1RSVGd0RC9veXM5dXJja2hXSU9GSEJHN0ZEU1ZpcFhTOXpScHUzZjVtYjRvc2JIeFpwdGpKUGZOQVZ1a2FKb2l1WmNLVEp5aGNFa1l6Z1ZpbzNqRFFiVXBaMjgyb1dWdkFSR1pTc2s4UzdzRjR5NGpCUWpnTHp6WG9BMFhYOWNtZyt6R1o0cEFIbHZwd3NiRUFnYkVpUlNNTU9WWVpGWjkvcUdoZUVyYTVTZlc1N09Fc3F4T1lGbGdpWUVONWI0TDdXYnVEMXlUaXJTVFMyWjNMMms1SlJWNDMwUzFidjBPS3V2aU40ZnNiRzF1N20vMVhUWkxobVNRSnArNTVVakJVQWJ4dFJGOUJ6eFdySjRtc05XdkVqaGdudkVNaWVYRGNpT0xJSXp1a3kyUXVEM3JZZzhTK0VQRVFGOUE4Y2p5U0pFMDF4cDVhS1psR1NtUTNCd2VxZ0dpNnViSFdiRVcwdmh4VU1rckZYbXRWWlhpUjlyRUZ5aEhKK1U5UU8xUzRwSmJoV2pUaWxCS1VYSGZXN2Z5MHNjUkY0YjhTYVpLNzJpZ0xHaGNXeVFiL0tpN2xGTHR1NU80NEdlT2xlaDJ5eDZsYnhUWEQ2aUdpdWxqUjRaVmhUY3c0a3dqQW5KR0R1NTU2VnpzbmdpOTBhYTBtdDduUzdlMHQvM2hlNG1taWxpYnB1MlJOaGdQYkZibDlhYXZZUldkN0JyOE1Ud1JMSkxORFp0ZFJUUk1SeUYrZGp3T1d6bWhKYUdTaDc4VzM5NnR2czdJN0ZUcVVWaURwR291Z1c1Q2xKcEZsZkl3R0lBeVZaT2hVOFZrM3ZoYlZiK2RHYVkyRncwQ0s4OW1xSkpKODNSeGpnZ0VnWkdLODV2L0FQaEhwa2lsR29XK28zMGp0SzVpV2FITU53Q0FZMklCQjdZUFRyWFkydHJEYlhNOGxqcGQ2MGl3bUNRR2FNSVZVYjlqaG5ETS9ZTnRCcDZidlVGOFZtM29yMnVtdnVMSGhqUXRRc3dMZTgxQzV1SVlBUmJUTUZNVVliaGszWjNjNDlPT2xjWnBtbHJiNnhxMDlycXlLeGRGTVVwTnhIS0F4TzFDbUpJMklIT1J6bW5ueGZvV2pRMnNKdmJIVHhJUk5PcUV4RDVpQjVhaGlRckRybk5FVmpHMnBTWE50Y2FjdDdKY3l0Ym0xaWplU2NsaHRERnNBRXFjNVlnazhkNlBUUXdjVnl4NUl0WDNiV2pOUzBtdTRicERIcEdvM2l4UG5lczZTUUp2K1ZsZmVUaFQzVTFRVFN2RXQrakxmYWF1bDJmbk1rYi9BR2hRekVPQXBIbWRDUXZ5K3B4VzVaK0wyblc3dHJ2V0wrVzd0MEltV0sxaWlNVEljbGNIQUxFOStSNzArNWZTZFJ0WklsczcyQzN1MFlqemdUdkRua0JaQ3lrOGZlWEFBb3NhempTVU9WdlhUeVowQnNackszdGtOL2VYOGFxN3ZJTml5eUhQM1ErN2VOZzY0eFd3Tk9Eek1vc0xaWlBzeW9nbWNLRzNaeHVqYmNja2NaQjc4MTR4dTBFQnpaNmhDdDY4MFBuUEtWZkVvLzU1bGk4YU9SMXgxOXExOVIxWFE0N2VLVzV1YlpKSldTRVRRNWpjU3VOeEV1d3Z0SlBVWUk0elVMZlltTnJ1eXZMVFQrcmxuVXREWm9KbG0wK2RvVWtPREZkQkZqV1ArUEtrTVFPcEhPS3h0Q2JTdE91cnU1dDdXeCt6WFVlRUszaXROdVE3QzBiRndvQlA4QXlhMzlNc2J6VXBJWnRNZUM4amp1bWprZU9aNC9uemdPdkozSG5uT0NNWXE1YjZHMWxDbjJpenNKWTR2TVc2TXZsckpKOHdaaXprS2pLUjk1aGduZzA0dmV6c1owbzFGYVhMS0tVdEh1alNmUjJsL3dCR2JWWjd5RnB4TXJYTWZtYjN6a2pjUm41ZWlrWUk5NmdabjA2SDdkTDlwdURJc3Nkd0I4NlJvQmtScUI5L2QxM1l5RDFyb3J6VDdwN09NV2NPWXZLekhERktyeHlScU1nZVllUWNjWkdLOGp2TGZWNExsb0xUU0lWaXVQTGVkak9HSytZUys3S3NNbEJ4bm9TS08reFZXTXVlK3ZWNmJmSTFMTStGTHE2aXViRFdicEFwbHVIaVozaWtoeU41Wm81T1RsVHl5bkJGZEZkWHVuVFhjTWNjTVV5UlpFVHlRdTdlYVNBVVJtR05yWitVN3V0ZVRYUWxiU2JBeWEvZVdvaytRbG9Vayt6QUFxQW9aVklESHIySFVHdTcwOU5VajArVzJuMXA3aUNPQ0YwbWh0eFBMYkJoZ2hrN0JmdmJsendhUW5LbkxvbHpicTd2ZlR1ZVlhLzRhMVY1SXhhdkFIVlhrdDRGdUpDWmR2UkFISU80OGpqUDByU2s4UHc2bnBOckZhUjI5cGVXOFlEV0Y1S2hVc09DaGtRWkdQNEc2NTROZHBaZUVudkxOMGtrZTVqYVozZ2tiSW1SUnptTXR0S0VnNVk0OUJrVjVmcVk4TjZUcDd0WmFVczBGNVBKdXVyZ01mM3d5b1J5L0tzTUhkd0txMHJhTkUwNCs2dmNUdEpOSzM2M1BUb1lybXlzYlNHVzNTeG1hSlhsUzR1aThZWTVHekxxY3N2YjJKNW9yeGw5TzhTQ1VOT3N0NkNpS0k0cHcwVVpVRE8zY1I2OG5wenhSV0h6UjVWU3JLTTJvMDR0TCs4bCtkajFiUzlNbWhpa3R0UDhSUVhWczhpNWhTS01QQ25WeVFOdWM0eGp2WFNhRnFlbGFuZFN5cTBGaGNRd0VMR2tTeFN3Q0g1V3lqQXJnOWVCeFhDV2MrcmFSYlc3RFFzM2tzckYydHBkeENBNUVnVWpMTmpyanRYcXR6cWt5NmRiNmpMcFYzQmo1bCtSTitEMmJkMHo2VnEwMW9kZE4yVW5KSzkwM1o2SzJoenMrdWFacHR4NWtHbTJtcFMzc3FSWFZ6QVh1U2tZWDVTM1l5SE9NWTU3MVZuMXZSME1lbURVM0lLcTNrQ0lvc2JyMExZUHluc1R5S1d5OFJhRlpXa3Zrd3ZHck15UnZERjVCRWtoNVQ1dmxMNTV6MHJFZnhFTkkwKzNnTExKRHRabWdNUldVWU9WQktJVkpKK2JCeFNhWG1SS29wdXlWOUhhMjVlMGE2dDQ0akpmWE5qSWtDRkdMRDdRNDNOdFl1Y0FkZVBhdWkxSzIwTyt1WGVEYmV4TkRpR0NHVVlpNk1DY2tjRWpQV3VBYnc1ZjZzTG00aGx2aytjU1E3bFJXSXp5dnljRHYyNjFpeitEN25Vck9RM01kNVpyTXFHRTJxczh6QlR0T1FEak9lZldsYnM3SExUZndSYTkxdS9NOWJXZGozVzg4UDZEZGFkTkErb1JRdjVTdkdvakJraGZHWEl3U2NuOUtTKzhMNlJxa1VjTXRqNXhrdG9HYVpad2pPWVZ3cmtIcXc2ak5aMXZhd2VITkNGelphWEpOUEhDaWp6RkhuOWRvZVFZNm42OEN2T05XMVRSNWRiMGkrMUMxbXQ1YmVRbFd0d3hqbHlOMlNRZUF2VTFEdjNPeFNoQnBKTmFmWjdGbnhENHkwVFRMdjhBcys2ZVFSUnd4SURMRVlveTNmakF3UjE2ODFSMGlIdzFLOXpkYWUwdXlmRWR5cy96SUZZazVPVDBiMTZqaXMyNThhK0RkWDFtOGx2M0RTT2cyTEt1UVRHZUFDd1BERGpKcjA2U2J3bkhwczE0eDgxaXNiU3hSdU5tdzhnTXZJQVQwTlMzZTI1aFZjcnE2bEhyNzJsMG5wWldPTXQvQzFoZXZPeTZISmNRWGR4NVlLdVJHVlVaSHpIR1N2MFBOYTEvNFkyYWRjMitrUTIwWHpsdGtnMnRDcmpEN0N2b09vcnVIaTFyVU5UdEw2RFVqYTI5dEczK3VoQ2xjREFIWDd2dU9NVjZqREZieWxIdUd0Wk53ajN6SmxWTEp5U29CeG4wL0tucXJma2IwYVNuSGx1N1gwdnNmRVp1TlYwQzJiVDdqeE5hTkRLb0tsWVhkMEdjaFZadU4yTVpKOWE5bDByUjlJMXZSNzYvYTRWblJZMGl1UmJzalpWZHBWMXppUVo2WUhXdWcxTFNkQnZmRVZuSUpSZGlNNzlyNVVMdDRES09OL1BKNjFpK0k5QSt4YW9seHA4VW4yMXlSSXMwek5DOFo2bU1iZ0VEZE9lbEwwMEprbGVjcCs4cjh0ckxsMWVsckl3TFcwc3pheTZWZVhOM2Fza3FQRnR1Q3lDVGJnRjhmZEl4bkdlQlhQYWdQRlVGdWJnYTFaeTVkMFJZMmNpNTI4ak9PQngxSGMxMHVpeGVNZE1qdmt2TFd4Z2pJM2hCaDh4am9yS281Si9XcmVpK0NmRExSdUZ0bnR4ZU1KTGlLYVVzVlpTZmxpQnhnQWtFSHRWclF6akJPOEwya3R0THI4enl2d3pIcU90UHJuMmpXSW12bVZYdG95KzFaUW9PN09Ca0Jld0ZWTEpkVGpnbG1rMWx3OEU0MzdWSzVHY0RhekRrRTlTQnpYcWMzd3QwK3h1TG5VTGEydVh2R3dJbmlZeXh4aGVUbnBqY2VBZXRiMmd2WjM5bEo5aDB1UEJuWVNyZnRJanhjNVpRR0dDdm9LdTVyVnc4WlRiaXVXVm84MHVWTFcyM1UyNHJqeEZKZHhva0FLU0t5VHR1UDd2QzRRQXJ3UWM4MXgyc2FINGoxQzFCMGFlenQ0VWpLM09YQ3lnRVkzZ2daVURHTWRhNmUrMGpWWjdxTzBGdGN4cTBlL1pGTWdoQzV4bG1CQlZoMnhXVEpmOEFobXcxUzZpdUpWdGRYSytWQ0xtVWhYM0FLUzNram4yejFOTFN3NFJsenIzVzdYMWV2UzU1dFkrQ05mRUtMYytKSUxxekpCSXVMUXliWkV5cEtHWGJnK2dIMXJEdU5HdGJiVXBkU3ZXdVdhQ1JsU0ZwaXFTcDNVYkNjWTZxYTkrMXk2dWJXNVN5TnZlM2YraktrZ25SVnQzM25BRzhqZHlCZ2RUWEY2L29ONWFha2phTGJhWVpkbitwWWxuS1NmTUZPOGtCY1p3MVhGdTIyNXBXOXBPVDVaS1BSMlNXajBzN0hSYVJEYjNkMUJPMTZCKzZKK3lqQmo4b0RLNEJHNE1NbmcxRHBOckpwK3VTM05qYXpXYlRnNGN3cm1kUzI0ak1oT0NQYm5GWWxyNGcwZUcvZ2oxWHcrMWxjN21LU1JSbDR3cTlXODFSemc5Z09sWWwvQXNObE5jV01GemN3MzBraGU1dDNkSkR0LzFrYVBJRHRUSEdNRE5RbzZzNXZlZ28zbFozM1QvclEyZFd0L0JQaUc2dUlOV2Z5M2NHUXJIdXRYam1YNWM3Y2ZPcCt2V3VnMDNTL0RXaFMyZHhEcWx5bHJORzZ6QlV6SjkzYmxHSHpLRDBOVkp2N04xM1RvQnJQaHRyZGxYL0FFUXBJbzNLRitXTGVoUHpISE5jL3BudzYxaUVSWE1DeHJidnZYN09KbWxlQnlPU0NNZ25IRENsMTNOSlNxY3JqRjgzSzNMbHM3SjlkVStwMDVFbHhOREhiVFhNY2ZsYm81dktpV0pDZUNYTWdWeUNPclZwNnZaMkhpQzZlTDdTOWtwaUFsUVRCTXVvNnlaNmdub3d4bW9yZXloMHpUR1M0SmppT0paWFZNYy94Wjh6ZGhXSndCVzdyL3crMEhWcndTTGF3QVFaRHM4alpLRUJnU1FjNEhRVTlOU1l3bko5dG0wbGQvSTV1NjBUWGJLOHRKL0R0M0NueVJmYkpubk81Q28rWjloT0h6NmdjMXdXcitIUEQycDNDejZoclY3SXJ3dXFYU3htRUFuNWNTRFBIUE9PbmF2b1dFYURGZGJJbXRqZHRab3RvMGtxS0dqaE8zQ0tmVDJyS3VqNHBrY2d5NmZCS3VDQzZNeUZGYnJ0N2JoM3ppbHMwZERqS0NwdUw1V25kTlgwNkhDZUhOTjhQNkZwTnBwNTF1NGVHSUdTVXp4L01WWTVHeGVDbTcrOVhkYVJkeE03WEVjeVRRZVpJWTVtZGx5cWpKUHo0NHh4eDFOZUU2MTRYanZ0YS90S2E0dkxjeWlScmllM2xWb25kZVBsQkxZUE5MSnBIZzAyMXZhM211WDBLRml2bk9Sc2R5T1R2R2Njbm5GRHNuZTV5ckVOMWJxVVhLVXJ5dW1tbTk5em9aL0hQZ3V6aGE3QzN2Mmx5NTRYZUpsQndSbE03V0hyamlxMDN4TTBYVUlMV1c0Z0xKZHhQTXFzd0pHRHR5VlBPLzJIYXRhUFJmQ3YvQ09sN2E2ZTZhMkxydnRMbmxpQmc3RUE3NHlWcm50SDBqdzFKcHpYTi9xZjd4Z05wMmhKbzhaR1ZLRGpIdFRkbXRpWlNhdEhsNVc5Wk82dGIwYTNOR3p2TkZ1N0tXeldLMmoxV1pwaEcwTUpkMUJYR015WXczT09PQldacCtnWDJsdmMyUWh1cHNJek5LWENJcWxkb0NIR1RJTTg5QldSL1pYZ1NhOGdGcHEwNXZGUmo5cE1pQm1PY1pJa3lmb1JVZXVhbnAyaldoamt2UmRSemJsWlpDMDgvbUFkd3BBd2MxRjIxWVVwT1NoQkp5bDJTdS8xTmZTZkVyZUhybVRUQnFqM1R5bFBJYVRpR0VzTWhXMjVBSlBjVXQzRUpvQmRYVXNiU2k1QzNmbEtJWFlTbkFaU2hHOUZKd1JqbXNyVElkUnVieXgxS3gwS0szaWdkSkduWmM0Wk9SdFI4SDZkcTZLWHcxNFgwbFlOVjFIeEJOYXJMY0FIS0JBV3p2OEFMYmFUem5xYUVsMzNOSXFkWjhsbnA5blQ4TEdIcGx6NHA4Tk5keDNsdmVYVms5MFVSa1krWW9ISUNkVGpQUFRwVjV2RFBpS0RYNGRTczc4dkZleWo3VDlwaTN5eFJyODI5TjJGSkE3OWFpT3NlQ2IzVlo3NlhWYjE3bWE4RnhtRTdWOHRUZ29PdnkvVHBYSDJQaVB4MitveTJ0aGQyRnpicTA4Y0J1Sndsd0VrK1lSc0c2a2RPbURRcjdLeDBVdmltbTQzczlKTGx2OEFmcGM3T1cxOFF3L2FCRjRpdHRTbGVhUDVmTldOQ3B4aktNQ0MrZWV2VHRYdGxwTG9NWGgyK1NYeUZlMHVVQ05ER0NJaU9TUXFad2QzR2E4SEdqNnRIcjFqcWw1R3ZreStXMDBkdkVqckVZdmtaZHVPNTlLN1RVV2drc05YZzB1VnJKR2NDZWRDRlY0MStZK1l4QklibkFxMm5wNW1kTnBTbEwzWGRXMjcrUjJqeUxwVmtza0xQZUM0a01xdmNPbVZhWWRDcmNoUlZlWFNvMXZicGxSSkhaa25XTXlOQmhtQURrTXVReXNSd3ByeXVQVE5JMGVTMm0xRzRFOXFJMHhLQkkza0NUK0VzbWM3dW85RGtWcVFlSi9CMDJrWE52QjRsVzZqdUo5b3RKV2tpbHQ4RUFiR0FKMjhjK3REaGF4dHkxSlhseVBraXVpMlBVTk1zL0swN1VycEpOV0tydTJRWFNoakd3SE1TOFpMWjZWcDJjbHhGNGFrbDFkN3dMS28zSklCTTQ5SEFVYmdCMDVOWnQxNGkxZXgwN1RtVHc5ZXpLWlhMUVFBVGVjTWpCM2RSbjM1TmNySDRuMWE3dHI2M2Z3amUyU1RQbFJkTWpDV1FIbFpBY2JRTzFISzczU09yMmNPV1VsMFRYYTdmbDFQUWJPZWQ3SHlkTHRiWW9weXF6a0lFTDlONm5kZ0hHT0sxYkN6bWZTcFpDdHRiem1UZEl0bDVjdzNweXgrZklKSjZpdm5pWHhiWlF6eFcwWGdQVlExdE96TzhEYkZETHdTV2pCM0xuMXJidC9FV2crSDNMbncxTFp5UExFNWozWlpRK1Z5VHVBRzQ1emo2MCtWN0VLRGdvY3pXdTFub2VqU2VKTllzdFd1YlM5bVMzczd1TkZ0cDVZdkpjdklDUUlveHVCSTk4ZlN0alg0R05uYk5jWGwwaWxBc0FqNEpadXZtQnNZQXg3VmczUGpob3JEVVRKb3JQQkR0RWNaeVpYOHc0Qk9mdWtEdUQwcnkvWE5RdTlWc2JOck94bDBxMlM1UkpvN3VVbEdUN3prTUNTdytwNXBXMTJLZFNFb1N0SlN2c203ZjBqWXZkWTFwb1RiRHhWYWFlUTZOSE45bkxtWGZnRUFaT01IcWFyNnZyOXlvdHJiRnpmUnBNaTNFcjJvU1J5M3lLOGJMOHZ1Q1QwNHEvNGwwYlRiSFRVbHRibWVLU0dQZmJMSExHSnBBNUJLYm1HTUFjZ2NWblhsN3J1bTI4UlI0Mml3am5kR0pYa01oNVZ5T0dCQTV4MHhSYU91aDUzUFZqRGxkbXRiMmQzcjNPczBoci9WQk1iS0dBQ0tOMFJXVllaWTNKd1F3eHVBWEdjNTVybUxyUjVMNjNUU3RXbWVlVzRkU2hqZFhrQVZ0eGtZbFJoUjN6MXJNSHhLdGJUWDFhKzhIM2F2Y3FZa2xXTWxkcmNIam5JQXIzdSsxajdEYUM1U082dDkwTzZGQ1ZadU1Lb1VuSVhwOG9OUzMzK1IxUnBSVVZKeWNiYTM4dTV5RUhnK3hzU04xemVTSUNYQldMZExGOHZ5dGdlM0F6bXRxNnNyQVBidkRiVHVzSTIzRXMwcENLcE9DVnpuNXgzSFRGUlczaSsxZGpHMDA4TTVRZVkwdzJPeUVZM2J1UG1COUs1Ly9oWDFrNnlYOHVxM043R2JoUkZ0a2JKYkkrZVh5K1dJOU1BVkc3dTJUQlVweGNhU2kxdTlkdnZOU3h1TEdhMmVTNjhxV1NLUllSSkRDb0lBUHlFS0FRQVY3anRXMWYyMnRwSktVUlVqUlF2MmkzWlhtdzNVOGhlbm9LOCsxeWFQUzNzd3NDWEVTQ1dNWEVWeGhva09OeFlyeXJOam9PMWRQb0dxNlRjeHQ1ZHRmTEt5eHlRaHk0VUhqYXpsK2h4eUJWZGJvY2FxNXVXNnVySjY5VGJrdjdNenhXejVuT3c3WTR4SnVkd2dKeGs3Vjk4OTZ6NzZJR1picTMwMkpKSUlYSm1uZmJ0TzdhQ2R3SmJkMHgwelZpOFZidGhidzNCc2pNak5HSTVPZ0g4WkpHVkdlY2Q2OGw4WmVKUEZ2aDY0aEl1WHZZcHp1U1dWY3h4a0RuaEJ5emZUSE5WdjZtajVwdDNkOWRMSmZxYTZUYWxERkRHdW53V3V5SnZOZVRsU3pQdWtLS3VjaE9nWWNIT0tyM2Vnd0MzdDVocWJTUDUrOUFxS3p5a0tXQjQya2hSMEE1cTlKNGcxMjkwbUdHYTNOaE5PRU1FMXNqdGhYYjdzaEEybjZldFdOQjFxNHVHdXhIcHNzaFc2bEVjVzBiOXlybGNBWTJna2RUVFRmWTQ3d2NyYnF5V3ZROHJUeHZZZUdaSTdsdEZ2SjdlZmJIY052Y1E0Y2dNVEd3em5qZ0d2WGIveHhaWGlXQXRJWmtTNWxBdDJFWmpMcVFTRGlQSndUNjlLM3A5SzFQVVBEYzczc0VrOXd5RGRCQ3FlWkdwT1NFSnlDUDFybnZEOHRqWnlYa0g5bVEyazF3Nnh4eXRHTGRuSlh1UXZBUFE0eHpUdkZwWE8xU1NwUXAyY0c3dm03K1hrUHU5STFDVzRXYThzSVN5RE11MjdhRnlCMEtiVGdNTzJlMWFWNTRFOFBTYWtsK2RQbGl1WFpaVGNOTTRsRExqR1JrZ2p1YTh2MS80ZmhaM3ZKdkVFVnFxcVM5dTZ2ZFJzSFB5eHVCakk5NjFQQ3ZpS3lNRjlhYXhjMjdDSWtoWlkzaTJMSGdZQUl4czZmaFEwK2pIQzlOcE85NUozMTI5ZlU5eWx1VmhobDh5L2x2UE1BSVNTSlVFYkFZWnZrQTY1d085Y2FDUmZTUlh0eHBQMko0anZVd3NremhnTUZrQmJuUGZnMXVXK3JlRXRodFp2czlwYnFNcVM1a2drOVJ1eU9SMXgyRlYvT3VJSjFOdWRNa2lrWlN6TmNJd0VYVGFpNFVnNTZkYVZqYWJ2WnF6NzlUamZFdmhTNTAyNGoxWFNrWkZlWTdwN1dRbFFFWEd4a0lZRDNOYTFyNGhsc05HUVd0bTEwckJ6SVpuQ01YWG5IN3dmZGJzUUszcm0ybHRMOFBCZVhGc3NxeUZnc2dpaVYxd1MyT203SFU5L1N1cW51WWJlMGVZUkpxRE1qTXN2eUJwVDkwb1NRVnp6U2JJVUhHY21uYjExUzlEaGRSOFZXb3VWdExpMWpWNTlySmtGNDQzVUI5dUZQR0NlT3h4V2xvc2JSYU5GWTMwUGw1bGNxdUZXRmc1SlBQdG5rSHJXYmZXR3AydmgrYTgwNks3YTloSE5wY29rS2tJUHViY0RkZ0hoZ2ZwVy93Q0V0VWJWdExlNm1zN2kxbG5nWEJrQUN4empKTE9ybk93WXhrZXRPMmhwVHBUbFV2S2FWMDBrL3ZQSno0SzhMYVBxdDFxQjhQaUl4eVBKSGN1N1MrWEl1QUhYeXlRcTVJT0NLOUQwTzl0TFdXNXRiYWNMTTBpTThuenUrNlU0REZwRDA5Q09LejlSTGF6WnlIekw2SXRGdmI3SmN4c3FzT1NNS1FUbkhSdXRlZGFOcVdzTmFMYk9vdWc4NVUyMTFhYlkyaWM5STVIYklJSXlGN0dyZXl1WVNxeWpPTGxOMjZYMWZ5UFdkUW0vZEcydnpiM0tMSXJSQ1ozamt5aDVPU0J1eWZ1MDhYMEYvWVcwOW1sMGhtbWsyUk5Gc2VTU0xBTHNHNjQ2NTZrVngrbytGcGRmMHRJcnVSQW9ETEFUZGt2RzZ2MHkyME9vSDRnaXAvQ2o2cHB0aFBiYXI0aWhWYk81OHEzbWxaSFRZVkh5Z3NBZWM0em5nMGt0TDlEZU1XM3E3YzFyYUhYendlSkw2enVMU3ltYXluV1RaKzVtUmhJb1hreURIQUo2RHVLOEwxaVR4N1lXUmgxNXJlOHNwQXZOdmJwSEd4eGdMdUpCVWpydVA0Vjc5WndTVzBWNDF0ZmViY1RFR0s4UUs2T1ZHMVRLVGpkak9EdDZWNWFmRC94R3ZOWGx1TGk5MDY0c0ZoWE1TdXpwencwUlZoa3Jub1QwUE5TbXI3RG5UbDdOcE50NzlMNlBvZWMzbGpxZGpxOWpKOWp1M25YeU4xcDlyYVhla1l5V0dWeHN4d0FEejNyM09QV0p0U1NDMEtUeExKRUhFQUlURGtaVm96MStYOHFUeE40ZnVycUt3dkdkck1DZkU4TWNtV2NrWURMSmxkb0hjZDY4NVRWZkM4ZHUybDNMWGNoU2Z5blZvWGVUSWJobFpQdklDT2NkS2JzN0hGSlZidU9yMHZ1OXV4c1grc2VTOWhxMTNZM3R1Slljc0V0azg5eW5CbEpYSkdEenpnbXZDNDcvQU9HODE5RWxwUHFOcmVYTnN5ck5MQ2JpSWgyK1ptamZCVmNqZ0Q4cSt0dEllL2dLSmZLdDQxbUNrYzhxa1NoWlBtS0hjUVBaU2VheWRUMG05dkxzMzlna2VKWkdFaFVvREFtT3JCeHlvSXp3YzByMjYyTkZ5cFNhdTNMb25hMm5YVFhVNG4vaFhxelEvWjduV2JabFVEZEk2aUZ3VklaUUk0M0M3ZS9QTmQ4c09pNlpvc2xsTmNPekU0RTBoRTJBL3dEZExra0FkbHpXSlpRd1gra1MyTjNkV1Y1T3FFdGJwSCs5a3lkdTlqeVFjSEpJT0s1Vzg4VmVFL0RVY3RyL0FHY0kyam5IbG9VZWVLVmw0WmtSK1FRT01kUFNvdnIxSEI2cEphTk4yMzM3SkhhMmRqcE1yTExiR1p5Z0tzNVo0UklNRDVYUWhzRnM1eU1lMWVYZUpwUEVHbE1Hc2RGemF3WENOSWtOdzB1ZDV6NW5KRDViT0NTRGl2U1BDL2pmU3RhTXY5bmlRbzBxL3dDc2lJNGJnQWNjRWR6MEFxaEphNjNEclZ2ZjNXaElMaHJqWjlvV2N6SkVuUERqSURjZ1lIT0txTjN1aVowNEswWERhVHVyV3Q2bUg0YThTZUtMK0lUWEdrYklGVENHTjBRcmpPd0Z5d0xzRDEvaHhTNjBiVzF2dE9SR3ZoZUZuSXRHRzlwa2R2bmRTUHVzU09HSklJcmFubnNKdFN2YmFYVHJ5NXVMSmw4Nk1XNWRDV1gvQUZrUUJISFBybkJybmhwdmhEVFpyYUpiZlVmTVloWXQ5eks2UXE0UDdzQWRRU3ZLOWFGYm1LU3ZHWE5aZGwwMDliblgzRXh2VXZYbDBWcFlZaVVndUlydFZrbVJRQUUzQTlEaXMvUXZFK25YYnpuN1BmUkdhTWp5NWJ5T1RlQXZESXJCc0hGYkI4SjJVK25pTzAwcVFReVhPNmFFT3NlU1NNN1VjNTI0SElQT2E1My9BSVIveEJwZHFwc1RheTI0Y1EzRnJGYmVYSUhIL0xNTWM1QkhCUHBVcjFNWkthZCtWVzNlbXJOYU82MDZmUlRkZmJJclNTV0lDUjBFUlFFTmpMUEZqSlBjOWUxZExCZmFuYXlRbzFqSmVLR2prVzR0M1RNN1AwRFJsZ2VSeHdUMHJ4L3c5NEtoYTdraXRiQ094dVc4NGJ5QmNRblp6c2tSOE51NTY4WXJVMGZ3cDhTZE52NFdHcjJzRm1KVzg2QVJrQlkzNkZRM0c0OXNkRFZPL2U1Y2ZlYmt2aDd0TytucGM5WDFMeEphcnBpeHkyVXRzdHdrdmx0S20yM1Z5T0kzVFBCYkg0MTR0RDhRUEZjRnhZeFJlR3JlN2hmNVZ1N2I5NGpZendWemxRZlExWXZENGl0Ym5WTEJvWmJ5MUlkZnN5dzU4dEhYNUpQTmNzc2c0d1FUbk5ZV2oyMHRsYTI1ZlJMQ1cydURHUlBueUczTXVCRnQzRUtjRWtMMG9IenZtVGVydGEycXQ1M1hZOVdGMS94UExlYlViTzBEa0JHbldCSDJTa0hEbkh6Qk9Ca0hvYTREeFhjNkhhelJ6M2wyYmVZaGJhT0pGTUJnWmw2b3k0YVZPN0FuZ0d2UUlvTklhWFZMbTFodGJQeVlGTHE0ZWZZeUxra2hjRGJ0QXpqOGF5NGRYdTlWMGlXNmlOazgxdUdsOHJ5dHlPQnlYUXlES09RY2U0cFBjaEozMWQwMjNvOVhiOGp6bTQxL3hzWWJtMml1N0tPeUVQblNsa1pwR2QyeGxTamI5aEdEdTRxbXZnSFQ3bU9HOWs4VXRlUm1SeEdvZFdQbXQ4cFhhV0IrVDM2aXZldkNPdWFacmtRbGV5YTNtOG1KU1lvc0t1MXNzQVJ6empKQTYxOHllS3RDMGhOZGlqdEdpMy9hbm1MdVg4dVk4aG85eW5qa0RENCtVMGFkdFMzSnBSVXFpU2NYRlBsOG1lbjZmb3NZdEw1TkoxbFE4REtUQnFGdXp4eGJzSzJ5Umd4QWIrRHJqdlhkUXhYTFJYRWIvWUlKU0VJWjh6UVNCVG5ZTm1RQVFjY2dITmMzTEQ0eHZMbnk0N2w3UzNlQ040MVZ6RTJXNWZ6R0dja0FiVHh6MXJyUERhV2x0cGtHbkM0dVYzTEl6VFI3WGhmay9NVGdrY0RIUGMwTzZ0Y3hWbk5jMFZlejEyMVp3TnhaTHJOd0x5KzBLenRMaTIzaTBad2pzelozQlVqeUF5QmVtZVRUaDRLTmo0aSsxZVZhdW4yUnBJU2JkWWlHWitFVWdBbGZWaWNpdHV3dDd1R0dLMnVkYWx0cFk3amJJaGpTY1IyNEcwQUFBREo0NUhQcUs2TjlLdGIwRFRvdFFqbHVZdHl0Sklod2QzREtuVXJqUFE1elR2cGJvRHFTNVpMUjlMWC9BQTFIYVhydXBYRjFNczFzTFlRU1pRdzNNTHhDSkJnRTcrVnlPNHFWOUdqc0o0cFpkZTFBV2pDUzdHNlJwUXBZRUVCd0NTbmNnY2l1TnVOSjE2MTNUSlBiRzNpSk1oRUx3UEw1Wk9Fa0s5VGdFY2luYWdzbW9lSHA1YmFPZUtJb0p3OW5NWWQrdzdDakl1NGtoY0U0R094cFcxMEtoTnVOcEozZXBKcWZqbndDSW5rUDJ3dEZFcWxraTgzY3JZMlN2c0lZb01mZE9DS3M2dExjejJWdElOVWdGdkxDUWlUd3ZBcUdJQjBaRVk3bDRHM2oyTllsdnArbTNIMnFLMW44dTRXelc3bHZncVptaWJDbDJLc0dKK2JwanJYSFQybml2UnRFdUZodk5IdXJXUzZhV1dTNmtlWlBLVUFoMVg1dUQwYkZOUjFMVDVwSlcwZlhwb3V4WHVmRlduK0lVdHd0OGJTNkJMcTVjUGwxSTJsRzNOaFZ6eU1DdlRkT1hWSjdHMWVLVVhiV25tcVo3ZlVHVzVPZm1ZQlpCNWJxZTJSZ0RnQ3ZOWXRTMDI1MG5VVGVYdmg1WklWM2lKSWlwS25zdkFJd2VuSE5kSHBHcFdHb2YyZkxiU1MyOFloSkNvb0NPekRhcVNPL01tT2ZZZDZwMnRaSFA3U1NuZXpTMFN2MSs0N0M4ZlZXMDdVR2tzNVJienhHWXhUeUt3SWJqa1JnTU1jRmR1Y1Z3dmhhenZKSXBiWFRienlJMEFhR09TZGdIY3FGYnpsSTNESGJxUWE3U3kxVzFtUzRoaGVDV1RSMkRRdGNMOHNIbURPSlhiK0VrNEdDYzVGZHZiNkxwdDBxM1F0SXZNVXh5dE5IR2pNV0hMUm80TFl4MjlEVVc4elRsVG5GSnQyMXMyZUoyZGo0cnViYU95djdUUzVva25WWlFiOHlTSXBCeVhVbmF4SjZLdzVyc2RldS9EMm5YOXBhNXVMT010QUZuU0h6WUdLS1NZaUFSaGszSFA2MW02ejRoOE1SZUpKWXBkSGt1QjVRam0yOGVYSXB3eFlBQXNkcEdDcDZWRmIzL2c2U3p2YlBUcEZ1QUNyUytZK1dZZ0ZXaWZ6UWZMR0c2am1xYTBSbzJrcGFSaWwyYjlGOTVoYWhMWVg5cnFOczFxdDFhMjdPOENRQ1ZWRy9sWmNyampJNlp4NlYxZWlRNmpaV3JUdzZocE1WMWNoSEN2QTZSbFpDTXEwb0pQbWNjNXJ6WFJkVDhPNmpaM1QyZWlsaEZKNUJLM2trZmtvUG1aY24rRmoxSTllYXVheHBscGNTbUhUVFoyczltcXZOWlM0TnNTUXUwa2c0M0E4YzhZNXFJUzVvM1RadmlNTGljSGlKMGExb1RqWjhqZDB1WlhXcThqNkpPcWFLbHFqYWpxbHZjM01rYkl5Z0kwRzlzc05rZVdPRDBJSjk2ODV2TlZpV1NHQTZYWjZmS3NSTWNnUXRiaE1FRWhvY2VYZ0hrc00xd2NWanBxU2FEOXNnYUtaNUpnWUpJMWpTUXUrNWhFZWZsUWpDamRYVjY1Y1MyV29yRmJXazhqaFdtVjdlK0VmbG9lTm9YQkdGSExBaW5HTHZxY3JyVmJKcVM1WHAyMU5YUjd1TFMvRDVXZlViTkZXME95QlN5dklrUnlKRUlPU1FEa0FISkhhdWl1OVp1OU8wNkthRzNtdWJHWlVqYTJsakorL3dGS2tEQk9lTzNTdk45TzFHODAzVHJSdFdoallzWGEyaEd6N1FkbVF5b0VESXJIZ2tmaFdsYVdLNi9ldEd1clNRbTVnU1R5U05td0x5ckNOMkpqRGNaSEk0NDRxdEd5NHluWnE3NW50ci9XNW9lSm9McWJUaFBwZWs3WHRXakZ2SEdRRWtRRW95dVZPTWpuSVBTdk45QzEvU0k3c1JYbHRlNlpJMGJNMGQxTk04VW1BUTRpT1FSNmdaejJyMUc1Zlh0QzBuL1NKTG1PT0kvdlFzalJoaS93QjBxaDNLelpIQUI2ZGFvdGZEVUErbkMxdjVKVVJFbWxrdDB0NVlXR2ZtUG1ncTN5bnRucFUyc3liYU51RFRhVjN0cWNGZVdGaDRpMUd6azAvVUxhS1ZXa0pqRXp5eW5lUmphcmJRK0ZCNEhJNzVyMlN6MFYyWlFzend5dEU1Unk2cDVqcVBsa2NZQlY4TGc4WTV4WGdjSGdyVkk1bGowL1hoSFpUekYyczdtMVM3anl2SUkyQUFaQnp4eFhxK25CVnRGR3JwZFRMRGNHRUpKYk04Y1lWTUYxeHVKQlBJSEpGUGxhNm91Vk9rbkY4NmtucG9tcmVUME5uKzAvRlVtYmE4czVJemtvck5JSnlHSXdHazh2YXpJMmZVN2U0cTFjNkpEZXJQSGNHT01XOXVHWGRheUl5ekpobmtnRGJ2bEpPU1EyUFVWSmVSUVh1bWhMZjdMSkJKQVgvMVc2S1FKZ2xnRXhzWWtZM0NzMkd5bFRUa1hUYjRUbVIrUkdXa0F3TTdsRXArZFFldlhGVy9oMkU3SnBPTGZ6Yi9BRE9KMU8wMURSNDQvSTBzWE5qY01aVExGSUQ1RXpZUVNPUncyN3Z4OUJWMjAxOUxIN0piM056SSt5TTd3cmVkR3hIeWdCWENzdVc0RzNOY0xQWTZuZndwWnVUYk9rKytjb0hXSjl3TGZJVytVSDA0SDBycVUwVFEzMlhFMFdyWElhQkZ0MlFKTmJ5c09TbzJrbFpGSTRPQVJTNUcwY3p0T1Rhc21vNjlYdnVlbXdlSXRTMVhTWmJld1MwdHBHWXJKSExPeDh2SzUzN2VjK3c2VnhWbFllSnJtVy9qa2lzcmh2STgwZVF5dEk4c2I1QTh4aGhWWUU5dWxWckhSYk50VWFaMW1XMXVKSTVWZWFLUDVwVkJ3WkQ4cDNMbkJQM3ZXdWdnZlNyTFdKTCtPSzh0cmVFaUs0amdtUkVXYlBsbktsUVdKSjV3UmlvaXJHOEpTbkhsbTcyZG0ycmZjYVV0dVlmREJ1cE5Fa2trV01raEpsdUJCa2ZkRWJrcmhlNEhXdkJ4NGg4UXp5UzJLYVhxbHdyT2dqa0VIMldQZStNa3FRQ0h4MHprZDYrcE5KYTJtMU9lZURWSkh0WmwzUnhHT0lsdk1YTEtlN2hSOTRIbml1UHZQRS9oOXBWdGdJNVlvRkR1NFl4d2xjbFRzMm41anh5cFBRMVR0ZlUzNUkyK0ZYMld1bnJvY2xvZWxYZG1zWm50NzdDK1hHdmxUK2RtVEJERjFHZHZJK1l0d0syN2k2OE42aWdnMW5ScExXN1dCM1dWdHBKaFFnWWQ0eUZETjJWaDA2Vng5akhvRVAyeDdPTjlPdkpkbXlTRnBVTFJ1U1JneUNWUW82Z3FSWGJYdWw2eFBOYVR1bHBlK1dZVGIzNENGMldWQ1dXZmFGVjhIQVVqMXBjdXY2bUVZS0xuYTBsNTZhbDlyMTlBdHhGcDluWWFnMElXVnJjajdMS0VJUFF2d3crYnFEM05kaGJSUjNkakNzQWd0Ym5iSE5ORkVxU0p0ZDgrVytBUTRCR0RnakJya1BDMm54Mm1tdE5Ob3NsdEtrTTBkeEt4K1ZRQjFsUnk0ZFFlZDNCOWFnMGg5RjFXMmsvdG5TOXN0cXJHRzU4dDdaVEVuN3dzWTBJKzkxWEFPZTFOWE9pRjFGS1NTdmUyNi9FMDdHVFgxbXZHMUM1TFF0SzhiUnp3bUdJUWpPN2JsbkJSaDJHS3RhZTBmMnRKYkpQdFZwSVRISk5hZ09JMFBQejR3ZDNIVWc1NlZ6MFY5cE05cTJtMm91Vk04U1p1SmxYUGxKaGx3SDNCazdjakk5SzRiVi9oeHBGenFSWVg5N3ByelNpWkVSaXhrOHZxajdUem5HUm5tcnZGYVhNNmNxY3JYbGJYVjcydjBQUXRJR3ZhamFYTU9tcFpXOE8xbzF1SWcwYzQyTVRnZ3F2WEhQQkhYTmFzdW9hcFl3eHBKZFIzTHl6QUlZeTVaZ3ZYOTJVT0hVRG9NQVZMck1jTjNEUGZKYjZacU1tUTVXZWFTTUxKa0tWVWxSei9BQkVIa1Z5djIreDE3U2IySFg3UVdVMW5JY0NHL0VoallOaFRFTnVVYlByajhhYWU1dkZKWGZ0RmJhOStub2VtV2tXclcwUU1lL3lkN3NzYnNKSXl4N0FZRHZ6eWM5K2xmTzh2aHJ4akJxTjNkNkw0a250TGxMaVJ4RExib3RwS0NmdWs3ajh4ejlLNytLZlM0ZE1XVzRFLzJ5SHkvS0Z6TXZtK1crUWpobEJKWmNISUorb3JlbDFUV05TMGFLT0pyZDVvNWh1emNaMkxqTEtqS3BCUmgwNmU0cHJicDgwT25XbEcwbzh2a21sSy93QW5zWGJlMjF5NGkweVhWRExIUE1xcmRxREU2Rm94aFhBRzVTU1R4ejllYWp1dERlNTFGNVpMNFBjUXpia2lLL0kwVGprU0FaNXdNQThjMUt1b1dMU3hhU2wzRkRkRGZMdWpqOHVhSm5JWmlnazZoaDk0akh0V0hxRnRyY0Uwald3RTFySUZNRTBVNVFxVGhTM3pjN2ZYbjNwOHlhNkVTY1dtK1Z5N3BNdkRUdEFTd25sZ1NlenVDa2pHR0tWa1lLTWJ0eFVBcnR3QVZiUEhGYzNEcFkxcXowaEo5SnRialRuall5M01jeXFZV1RsWkEzWGdIR08yZVJXMmw3NGxhMk1rNlc4c3NaTWM2bk9Sc09Bd1FZSkF6amtmU3N6UXJ5NDFCcElETkRiTmNibmVXMHR6Rkk0YjVSSVVaaGtxQmtrZ25IYXBUME1sT2x6UWFXK2kwdGRzNHpXYlR3NUJvNHRMMnptZ3QxQVI1NG9XajNTT2Vmbkh5aGhqREEvZXpXbDRmOEUrRllydkZ2cWR4YlNHTUNJU1hQbmlOVzRWcmNzRnhrREdPZ3FMWGhZdzNrLzlwVFhlcXd4eHFrYXRDSkRHWXhnTmhTaWtrYzQya3I5YXU2aHJQZ09LeXNYdHRVdE5KMUJrYU95bU1ZaklKd3JLNDJuanRranJ3RFRhYjZuUXBUL2hxVGt0YngzVHRyMElKUEQ5amFTTEREZFBkdkJMRXNjc2w2Uk1zalo1aWlYR01qZ2Njbml0MjZ0TE84c1dnMVZMMGYyaGNueWkxb0xhVmpFQjhtRUNobUJCMjd1U00wOWRNMVg3RFp5dlBwZHdVWUFYMGUxMkk2QXMzMytUL2RQQjVwYnE5OFV4MmQzRlkzMXBkdkg1Ylc3ZmFKWExBTnlXeXBHUjBKQjZkYWlOK3hqZWFrN0pyYTNSTDBPZWdzdEkwVzBFVnJKZVRJRzIyeXNFZzN5bVFzVGlUWTNtQVk1STlLaHVKdE9hTyt1UDdTdkpVdXBRSmJPVzI4NzdKTGprZ0tEZ25CQkE2Vk5wV29mRWErMWk4aXUvRFVkdDVhTEswMGx3WjR2bUdFRUxOdkhBNXd0ZWdRRytzQkdSbzEvZFJBQU16enJ2RzQ0eUNBQ0hVbnVQYXExdnF4VGhWVldVV2w3Mjl2ZSs1cTU0eGZhRm9kMXBhMnllSW9JWnBpOEliekNWZFplVGtQa3FweWVCOWFpMER3N3FPbnZiMjJsNjJiYVcyV1NKUk5iL0FHek1QWEtNNDJvM0hDZ2tkd0s5NHQ5TlAyc285eWp4dVdMTDVrY2N6UGtsRmZJd3pZKzk2bnRWMmZTMFJKVnROVmpFQ3hqQ05HakJHVDVTamhTTUZleEhzY1VONkxZZE4xVkJhM1Y3dFdXL2ZVODZsOFI2L1pXK20yMDl1MTdCc2VIRE1zYjVYcEl3QXh0R2NaR090WFk0ZEttbXVaWld0NEdXV09PTlM0a01hTW5FZVd5d0lBUFFrR3RMVXRBMW1DOHZaNGJ5SjBraURHU09JeXpsaU9FWitjcG4yK2xZM2hpK3VMYVo3WjlNdUVpaE1TclBISjVtRENDc2pNMDZxdlhqanRpbW5mWVhKZU1WUHB2ZnFTMzEvcHQ2OGx0SGM2VGNmdUEyTG1SWGVVRVpJQXhrcVA4QVo1cm1aTmUwSzBzWCt3cG8xNnlxWkVzbzNhM2tMWnp4SyszSUhVTDF6WGQzdWpXRU1FVTBXa1cwbHlBWllBdG9USUpRYzdEdEpBT2Y0c2JmYXVMMEM4dTcrMSt6Nmd2N2kzVlJzWmZzNkdSc2dGREtxdEV3NmR4NlU5YkY4cmlrNVdiN1gwM09lZzhjNmhjVERUcmpTb2RLbnU0RW50NW9MbFdjT1NDV3lRVkRoU2Noc2VsYnVyWEcyRzZzN21TN3hNWkRIRC9aK1kzZGNydU0wWkxiWDY1WGpQRmVpektMT1MxczQvc3F2OHNsdUpUdFg3dTdsTy9UdTNKcm5OVmJUN2Fka3RKWnByNExGTThYMnQ4U2JXNEd3cXdkUVNRU295dnBTU1NZWFVuZHhzb3BKeFRkcjlkOVR3cTVzTkxuMDgyTVdvV2d0M3ROd1JyZVJUT0Z4SXdCVWhRZW00OEgzcDNoRHhkck02ckhjYVhiM2RyT3FCRnQzRndzY2U3K05DU3dIb1R5SyttRTFlMWE3a0Y5SFo2WE5ITkU3Skk1VGU1QlhFYnNpN2gvQ2NmTGdWWGh0OU9NYzEzYlhleUc1dHR2a1J4bzYvZjM3MlU3Q3h6MTdlbER0YmV4ckhsVVgxMWJqZmRlYTI4amhXczc3Ujc3enJDWnhiZ3ZGQ2p4aGwyWXl3L2RqbHhuS2h1U08vRlkrbytOdkVmMmFlQzcwd1N4QWJtVnJXU1Jab21ZYlZPN0dNRG5DMTNjSGg2NmpVM2o2YkRlRnBRd2RaOHhKdFhJaytiQjRPZU9vNlpyY3VyUHhFNXRwYmFhelN6V05STkZLNVZnZnU3bEpKSklMSEFQYWwyTUl4bDcrNjB2eXJTL29jRkhyWVRUTEI5R3RMcTFWcFdpV0o0SlVoTHlrc3c4c2J3cEdlcElGUUlsdGR3TC9vME0xMHNyRHliQnpienVjYlNTbHdWVThEQkhJTmR4YzNVT25YTWdhemlsY3dqZTBic0ZZYlFwSUxIYUN4d0RnODk2bUY3ZVNYWW1QaDZaVmdnVk1SdW82anFvYkFjQWNFRTl1dFQ2RUthZFRtYVRkOVl0TThqdXRGdE5SVzNXOTFVeExHVkFTZEVrdUZRSC9WbERqSlg3aEF4ejBGYThIOWk2ZEF4MGx4OW90b3dyd3BJOWt6UjV5R0NzQXU4ZHdDTTEwWThRVzlzODA5eHB0L2JSeHZJQ3NjWW5KNHpnbGd6S0hJR0FNSGl1Y3VQaUhvYzJuUytWcWh1cmk2VkpyZU82aEpWZ0ZJWlNTRjNMeGo1aDE0cWI2N2VoUHZUZzJ0cnQ3T3k2bHE4OGNhUERkUVhsem8yb1J2TkpnK2Zha1psSXd5U05rOFlPUXdIMXJPbTB1YldIdllyM3k3cXlSdzhjN0lXTWFiTTVIQzRBSnhuRlozaVZiMjFzYnUrazArMXVGdUk4WFZ2QVhPQThmeWg0MVk0SVBVakhTdWY4TXI0Y3Z0S2FSQnFPaHBIR1B0MXJMSks4TW5melkyWTVDanBnOFpweGRrM2E1Vm02YnFSVFZudHBkMytab0R3NWVTTUliWFVFZllENWNKc2ZLTWNhbkhEdWYzbVQxT1RSWHJPbDYzYU1qUndheGJ0SEg4dTJhT0ZjRWZ4TDkzaGdjOXhSVVM1YjdtRW9VWnlibEdMZitGSGwwbXBlT20xTDdQWVdjenBDM3kzZHpLb1VEZ2hJd01mTDZmbFd4SnFYeFZ1SDJUM3RuNU1US1pkcWlXVEpQM1NBTWU1cExuTThjcjJkcGV5eGI4d3ZzQmVNcWQ3TUFlY0hvUFVWNXBwZXM2UmIzYVhNMTVyRnhlZVlTWXpsRWlJT1FvUk9NSHVhZXRsb1pSbmRTdEZyM2RiSnUvUzU2VnFmaUFzc1ZsUHBGMGx2SStYa1V4aFdjbm41QjBVbm8yYzFwNlRyQTBXRzZld1M3MU1OKzdqdFNSdFJpT01NQmdiUndTVG12TGRZWHh2ZlhOcFAvWUQzVEJTeXFWMkU3em41Z3h4aGM5VFhvZW02cjR5a2paVzB6WU1CWHQxN2Y3cDRVNHBTdjhpTlZ5VGNVbHNsbzNwM1Y3blFhVnFPaUNPRmJ4cmF6dXBWSjhuTE5Fa2g1QkRIcXhQV3V6MVdHNnRyR0pOUFY5NVZUSjVad3JobUc0S09TQnoycjUvMXk0ZVdXNGgxVFRJa1dDTUg3UkJHQVlYWS9Ld0ErWEo2Y1Y2VmNRZVY0YnRmc3R2Y205UlY4aTdrbFlLRDZrRFByZ2NVazd5TTZWUldjYmNyZDNvcldPeDFuVDc3UWJScG9kUldSVWhWVEhjTVJ1SzVMWk9PU2VnWHZYa01PdGVNdGFzN1cva3NybDdYelpJNUZoaUJaa1k1VW9oL1UxQm82L0VIVFpiYVhVTlNpbmhhNVpXdEVUempncVZKREhrbkZkQnFuaWZ4eGFYWkdtYUhNNkNMeS91RXhEY3VTK1I3VTJ0YkdsUlVYV2NGSzkycnhUZGwzMWxaSFhTeStGNVo3NkthempubVF3T0ZrZ1FsVEowYjFLcDNQYXZHNzc0ZjNOaGR2Y2VHOVZnTUxBQnJkOXdNaGZsOTBoQkJHZWc5Szdhd0NhN0RFdXNhWkxaVHlSc2l0RkN4a0tnN2lwUFlIcWZXdWkxUzh0TEo0L3RlbnU5ZytJNDVVaE1mbGtqYmxnM3R5RDJwNjMwWHlOWTFWR0xWbHl0dFNUVjFmK3VwMEduMjEwazF2WjZoWk5LaTJFbnlxZjNUbDJCSTY1M0Fad0t5dkZ0elk2Y2hzSnRHbGF3aWdpdVkvSk94SVN2M1I3ODlhcWVKYks3dGROc0xqVE5WU1F5eXJHR2tsQ2hCR01CZHdCSnpubk5jL1lmRVc2R3VHMXY0clkrWEdrYzh5eWZkT01BQWR4N1VidFBjSEtLVW92VGJYUjZlWjFDYXpaUTJGbGREN1ZIQklWZFhXTXNGUGRTVzUyajJGZVY2NTQ4dG9MNkhUa3NydTR0Wkh5MHFvK1hMTHdtWEhHRDcxNkxxbXFRM0ZnZ3N0WFdVMjhnbEVLZ01YQU8zT1JqYjdIMXBkQXVQRTF6TDlpdjN0aGF2R1VJbFYza2RYUHluZVBrSjU2MUtYVTU0dW02M0pKY3k1ZEZlMnA0L3FOdSt0N0wyTHhOWjZjelJDTUs2TTdFSG9qWUoydCtkZXhlRzlPMFkyRnl0bHJJdjNSRkVwUmNsWHpnSEJHU0Jub2F4dFMwRFNQQ2VzdmNXL2d3YWpNa2JHMmFHWGVCZ2hUOHZSVDc4MWEwZUx4VGM2aEpkand6YmFXMHlCbXQvdFRSbnI5NWtRWU9mVTgxZmtlajdOS21ra3BjcmFsc3BLK3ZxeUhXbzlaMGpWSTdpMlc5ZWVSMWg4NDdUYk5Hd0FiY2lISWZJNm10Mno4UmFwSkZjbzF1Sm1pSS9leVpWUzJNOHFRVGtkNjZIVU5JOFRUeks1MW1PMlFSaFpMZU9NeUJ5T3UwOVQwcm00OUF2SkRZc3VyU05HSXBJcndvcFE3SkFkalpma3QyUHBTc2pscVJxdXJhTGFYTC9BRnVlZWlmWHJxNml1Ylh4SkxONWN4U2VIN1BzaEtzd0piSnh3UFN1MjF6VDExTzd0cDFoUloyZ1VHNmI1STBQSUJEWTViMDlLdExwK21hUHFrY3o2ZzhNQ05GYkNCbUJLNEdjdGpPYXJlTGRMZTl1NUpyVHhVYmRkaUVRdkdKbFVodVNtRGdlNEl6VmFhYWlpcWpwdU01eDBkdGROTytocFhkM1BEYVdHbTNraEMzRWJ4ajk1dVpzRGh5VzVBOSt0VnZFWnNZTE8wZUx4SlpOTis1U1NPSGQ1WmlqSjZGYy9Objg2NTYxOEthaEJkeFJhM3JrMTRXM0NPSDdPb2hYY01rbHV3SXJwblJQRFdyZ2FVWXBMZWFOUzhiWWNMdU8zOTFucnpVeGFWeHpqeXFmTmFTZGx6SnU2MDdhSEcvOEpoNFpudUdLTFBKOW4ycTBXWFF4c3A0S0VmSjN6azgxMmVrNlRmV2ptRlpOUUltTWpQNXBEcUZrSk9FVmVRZlU5NjcvQUVxeXN2dHI2Z1pMVzRMeUFPVml3VUs5bUs0SEE3bXNtNjFPOVM5WnhCSk01RFl3VlZ0cE9Cc1lIK0VIak5NYnB4U3ZKdXp0WmFQVDVISTZqOE03eTZqZU8zMVNCcENDNlFsVEZFTTVJSktkVzlTYXBhRjRPMVhUYkc0dExmVjBrdGp5VHZPZk5JK1liaGc3YysxZXMyY2wvSDVpeDI1aUczY3U5c2x5M1RlZTJNMXdtcFBveVhyM2R6YTNJWEs3WmJZTXJGVkdDU2c0eHUvT2xkaWNhQ2hzMG05VmQraHkybWVETHFTMHY3ZlZibThnaUxnUlNMSmhaQnR5Umh1U3BQQTdpdGE3WFQ1a01VR28ya1FNWGx4L09ZWFFvT1VZWitjWjZHcVdwK0o0bnRWbnNOVXRvenRWaWwrcGRZSXdjRjg0Nm4wNjF4czcrRTd5eFVOREhKYlRHUjJaWVdBVWpLbVJkcEp5VDkzTlZyZmN3bTRLbXJYVWVibGJ2citCMmVyNlRwN1JwZU1zYzJvSXF4dzNHd2JWR0NEc1BJSUhjSHJYTFhIaUVDR0ZielZJWW1odG93WGpVcTA4bTdPMElPUGJHT2xkcjRaOE8ybWp3R0dLUVNySWhrWGVDa2hRRGNDUWVCeVByVkcvMXlLNGF6Z24wcG9Xa2tNb2FVa01YQUlqSXlNQW4wcUczNmlxS3A5cWI1VnNsdS9ucWVYMnZocnd6cjF4TGMyK3IzOFYxdWthV3pKQWpZazg3Umo1ZU85ZDliL0IzVGJ0TFkzR29lWnRjeUNNNStiYi9DY0g3cDlSelNYSGg2NHZKcGZzVnhMYlhrRzJPNVNOOXZtUGpKQVBvZXBOV2JmU2JxZVc3dFVXNnRMdDBWRnVJN2p6WTFVREEzS3YzZllqOGFFbTlibDBxOVJ6cEtVWG9yUmFiWHl1dXBlMC9STlIweWVWSTdYUzRua25mYVkxUHlqcnM0eGhhODkxMjk4WHgyNlE2TGNXUXZZcmh4UGFDWlpKQXI4aFZWd2ZtNjVBT0swSlBBVTZLazBlclhrczltZ1ZwUUFyU0RPQzZLK0NBTzVQWHRXN2N4YUhwWjgyWFZtZFltQSswMjBNWnVDcmZNV09Na0JlNXJUMXN5Ris2clJiU2w3MjB0VnYrSjV4b09oYXI0aGU5dTlSMHhiZTd3emVZbTJLSW1QQkc1Y1ordUs3TTZEcGRwcUwzSDJhSjJrVHpYdHZ0RGx3eWo3NHlwMmozRmVsMld1ZUZZRERPdDdKSEZNanJEUGN5YlhrSzhramVja25QdFhIYWxvbmlEVUkyV3p1N2lhSzVCTFpuV1ZXVld5cU4wWUllLzYxQzFsMktxUWk3dXo5NTdSdTBsZnMraG1DOHZaM3QwdnJLQWdKSVlpazI1bFovdWhtSFZSMVByVE5Fc3RTYUp6SkpZM0tNNmVZamJKSTBtREhHNVNNcXdxa2ZEaDB2VXQ2V0NOTE83dkkwZ1dSUVR3UUl4MFhIUWpwVmU2OFNhQ3VwaVNQUzRrYUpmTy9kUHQ4eHZ1Z3N3NjR6MElxdGJvOCtFWXFjMjVPL1RTMGwrZWh1ZjhBQ1A2aERmeTZoYzJNQ3VKVmpWb2tYS2hWUHlLcThLcDlmenExcUdpYVJxMHp4THBVcHVJaXNpU0xHcGx3RG41bnp5L0JCRll0MzRtMWpUamN6M2tTM0ZqZHd1b1prSktmTHVYZjVlTm1DY2M5YTZQU0x1SDdLdDAxdmEzTndzU013aTh4OEtCbnJuQ3RqcmluYS9RN1lLTVhHemxaOVh2OGpBOG54VXR0S2JPU1hTa1dUZW43dEZDRjJ3VkJaandjY251YTYvd3hpMHVqSHFXb1c2WGs4ek1mczg0WTNIOElhVU1PcC9LdkxOWS9zWXJPOW5hdzIrUUpacFpmTmtVY1pPNk05V1hxTTEzMW8vaHk4bHNaVGRsWnBCR0drZ1VSdXdVY0x2a1hvQnpnVTNGV3VhMFdrNVdrbWs5UFgxTkRWZkYzaEhTcnFYVC9BTEF6dElNWFRKdDZLTS9OZ0RIWFBGZVlXNHM1OVd1cE5IMVRSekpNVmRFbGlRRW92SlVqakxIT00xOU1lYllYdHRJaW9seENzZUM0Vk56SG9TeEF6aXZtbld0VzFDeSswMitvZUNMT1MzbFZWZWRGRUpkRk81anhrZ1k2YzBrN2RUcTVlYVMxanl0THFyYVB6T2dzZkZUZUdvYm0yMXUvdExRTEw1cXcyaU5MNTRQN3hjWTZIbkhXdlo3SHh6NGYxclQwbWt1N09ScG94aU9VckZJQzNLakRrZ252WG0yaitLUEJXcjJzb3N0SmpVUnFzZTBwNWlJbkFJVTRPVDYrbFg5VzhQOEFoeExadko4TVdZZVpNQmxqdzdJd3h1SVVaSFBQclRTVGZZN09lS3VuZFBxdGJlV2x0RDJlM2JWSnJ5N2pqZXpTd2EyYUpaSXA4eitZQncyMEFMZ2RoV0ZwZWlhVUx2OEFzKzl2UHQ4d2lQbVc5NHl5TkloQjJ2bnJ0eDBBcjVUME80MG5UVkxhWmQzRzRlWDU3YlpQM2JxU0FDcC92WXcxZTJRVCtDTlUyWDA5dklkUWphS0VzSGNTUjdEdUd3QThEbm4xb2FhWmxHclRsUDNveVRqL0FEYWFuUW53VjRaVXBHSUhWSGlLeUlOeklxOWQ2czNPUUQwRlpyMldzckM5dXkyNnhBTVlXWTVVeG9SODNsOWllNTlhNkMzdFdzTlFXVVgvQUpJbFhFQ3JNV2kyam5sUDRYUGVtM0NKcTR1cnl6MVBNb2hraGVHRVpWZ3h5Tis3a2RPMVpPVHVPU2hxcldhNkovTTg5bjBLd2s4eEd2Q1JjTVpjUERIS1ViYmwvbVlqQ3QyelhZRFRiclRvNUlkTWRKRUZzU3R2S0l6RUdYZ3I4bk80OStlS2wrMGE2bWlGdEkwdUM1ZHp0bGl1TVFzQ0JnbnJ6a2M4bXZNSWRIMW0yMTRDUzVpdGJTK0FrQXRlQkcwWTNTSUFlQVc2R2pWbk5Ia2hCdFJ0elcxdmIrdHpkdnZEZDllMmEvWnRYdGhkUkhmUGJ6eWZJcHpuWXhqNmdaNEF4a1Z4V282ZXl3RDdUckNnT0JpRzFtYVdHVjFicW9reGdEdUNjaWk1MGZRdnQ4OXZwa1VOaGN1N0Jibjk3SXJPdnprRmxPNFp4Z0RIRmFWaG9tcG1GTHVieEZmVDIwbythR0tJaVl1ZW95dzRiZHdPTTRxdGJJd2NhVTFKd3Q1dDcvcWVrYUxaeDJoMHo3WWtiSVl3VmNoZHluT1ZPNXNaQUhYRmMxZmFmWUhWSmJPQzlsMDgzdy9lVzhjakJGYlBHd29CZ2tjbkpyai9BQkJkNkpheEtoc0x6emtkU0JPeGxad0RsaUdKd3BHT2ExZEo4WGVLZFJzTC9icGhtdDdVSnVYNVpaWkFYKzZveGduSDQ5Nm5YZGJFd2piM1V0RlpwclJ1MzRuRjZWOElJSXRmbGU3OFFUa0c4Q3doRmZBQk9WRzVzZk1TT1FSMHI2ZXQ5SDAxTGE5Z1ZJNUpaVmZjb3VYRHRKSGx0dTNPT3ZwWG5YL0NWV2MybnczVFR5V2lRVGt0YnRHUkkyeHNxbURrOVR5YTYrNDB6UjdiN1RkSllQRzFvNWZ6SXlVSU16QnllZW95YzgwbTIvSTc2bGFWU2Q1SzlyTFh0WThuMzZFTDNTNTB2R3N4Tk83U05kT1RNQ3ZIbG9Ea0ZWUEdhOW9zN2ErdHRadVZqdW9YU2FJbFJMS0ZLOC84czBUakhQVW5tdk9aZEo4SFhMeVFTV3FUVHhZRytaU3JGcGp3cUZEOHZVNVBhdk43UzA4TTZWcWtqUXdTeVhhVExHcWZiREpHQnpoUmtEYjdaNHFrcnV4eFFjSXB5ZTdldHR1MWoyeTluOFcyUVdCZGE4bDQ1MWt1TGNScE5IR2toNFlzMkJ6MXdUV0JyUGlIdzljelRsdFUxS3hZUk1QdEZ1QThhc1d4Z2s1RzNqT0IwcmIweXd1ZGNQMnpVdkRrY0syNElqZ3Vadk1mWXJET2NmM3V4OUtzNjc0VDB0dDRuc1piV09SUTU4dVhkRG5PMzVzOERJSTZWVmwyT2lkT3JGS3k1a210Rzc5ZTVrNlBxOXpQZm1LMDE2N2tsaFFtTmZLUUNkSHh0WWdIdFdqZGFyOFFMTjlTbmtoODZSWmw4bUo0MWxSb09tMVhCQkRaNU9lbE5qaWd0YlJ0TTArd2wrMGFaQ3hKUTdmTWtiK0VQeWNlMVpIaERVdFZpYVdTK2tpdDNpbVl5aTVVeVBJaFRoSTJRZ0VMM05KMnNYQ1VuQlJjcks3OTVQUmZlY2FOZDhid2E3YnRwa00ybndyTXkzY0YvS2hnalp1Y1lISjY5cTkzbDB6VU5SdG9ZN3pVTENTWmxsUGxOQVRETEhJUmxXSk9RQjI5YTRueEJZZUJwWC90UFZKbTNYSlMzdDQ0UzBpN3lDTjR5T0JqZzEydmhpRHd2bzhNMW5ZMlpsOG1QSjg2WnBONVRra2JzNUhQVWNWUFk2b1JqWlJtNDI2SlgxVjdsYVR3dDRRMUhUVWkxSFRJSWxpSmhSSW54R01mZDI3Y0RkMzJtdlB0RitGbWxhRmZUWGxyZGVXa2JpU0ltVHpsZUk1K1Z3NHluNGNWRStvNi9xRUYyUDdHdHBvM2tJSjgxRllsK21FR2VFd005S2gwR09mUzlKbnVVdVlDRnpGSWczeVJvQzN6THpuQUhyMnEwMm83bUx4RXVXS2pUazRTMWRuYmJxMTFQWTRiT1c2MUdPZTBoZ3ZvTm9QbHBLUUVZbmxUbmdqamsxUzhVV0VyK1U2M00xbGIvd0RMVklHakNGaWVqSzNBSHVPVFhMM0dyTkJOYm1mU0xsWW1oWlVqdE1HS1lIcklDdk9NZGlheDdIeFZETnB6RzQwMkR5bmtNY01LakNvQVArV2dZWlU4WnlSUll1YzZmdlJ2cTlkcm16TGJSYWhhd2FaZDNLU1NHSXgyL2xqTDIvOEFFU3BWc2gvUWQ2d0JkM3E2OVlXdHRCS3dsUm1oYVpYaklqajRkeTVZL01DUHU0cUczR3V2cVA4QWFGbWx0TkdwMm1DRnc3RnR2TEF4N1R1SkgwOTY1aTUrTVVNV3NKWjNPaFN5VGhtU1h6eGp5ODV5d2NaeXROSjlybk5SNXBxU2NKZTdkcmZaZGRUMnZVOUUxUzZnVm9iNmNHUzRSbUlhTkZqVW5hL0FYQngxK3RSWFZyNG10TFpyYVdlUGE4VGszQ01jbzYvZEd3RFBmcU9sVXJmeERMcXVqQyswRFRtRjE4dmx4UExzRGhXQWI1WDZBRHZqcFY3VUx2WEo0R3RaWWJSeERJRGNLYnJHSXBDTWtGZ3AvQ2tuM091VVliMmx0YTZaeFdtVGYyb1lMaUxWSUxtYUp3UEtZS3J4UGpHV3o2NE9lTTE2SGVYWGh2TTl4STBCTUhFbm1BeXJ0ZmphcW5BNU5mT3ZpK3kwQ0hXUmMzMm16cHk0anY3U2RvbG1VRDVWRElHQVBPRG12VGZEbjlqV05pazFyWVhpS1ljS3pGN2dTcWY0ZDc4RVo0QlBGRnJHWFBHTVVrM3E5ZVpkdXFaTHBsci9BTUpHa2gweTJraGhoV1dOWm9MaG9JOHNPVEdrbTVXd1J6amppdWMxYncvOFRMWFhiZTQweHJPUzJqMk1EUE0wYi9LTUYzR05wWStvNkNvTDNWdFBzNzZPVzMxeTl0N2lZcUlZVEdURUFwNTJncUFxNTRJOXE5SmgxTFg3NjJ0M3U3aTFsdFp5RVdlT1ZnN2tnRVpDZ2dGdXc5YXBiYkRvMVlKdlJ1Vyt1M2JkV0gyUGlEeFZlMnRqYjNscnBxdTBySk52bkw4ZEZ4aGZtM2RSVk81Z3Q3anpQc3Q4ME4xYjNYTVVOMFpNNEl6d0J4anNPbFVOTGo4YXlUb3FOSEI5bGFWR1dWZzhjMnpPM0czbVBqcXB6VXRucDlwSmV6WGVweVc5dkpNcXlTdzRZWktMdFhHd2pnK2g2MUR0YzByYzA3WFMxZm9sOHpuNEJmYXFqcGV4aWUxWjNYZkxkYkprUUhQS29TV3dlK2E0dWJ3anFVbHpGTkJMOWlTM1lxREZNeDNqc3NwT0J0SjYrMWUwV21yRCt6MmpqdFlQTmdkalBFcUdObUFPQXFaeDFIZGpXSGYzT2xYVmhHczlzQXFnTUlJNXRrcFpHQjJrQWplZTRJT01WRHZmWTRwS212ZVU3dEoyT0g4TjZscjZhbGNHNTB6UnRFdkVTUExoZzdzUjIyS2NzSkJrNEpIdlhkejZiNFMxUjRiNWRRU1MvVWVSYnpUSzRXTTV6d0J3T2YwcjVmMXE0MTI2MWkwdWJmVGhNcUt5dEx0YUdYYVFkeU9YQUQ0SFJ4WDFCcEYvcStuNkJNTlEwdTFzd2tUSVNHODBSdGtCdHlxZjRoejE1cld6c21iMVplN3JHTVlTaTIwbmUxK2xrNy9lVFROTnBrVUVjdGpBMWtrSmttdTdhWERCbFhZeVNMMVlzT2hHZUs4M3R2Rk90eFFEVHJLeHNrRThpdUxhVEhtYkJodDBjWEhJQTc4azgxN1RwdW9hZHJtbC9aNTdsR2pNcUV5V3FtTXhOSC9DU3ZUZ0Q4T0sxZGQwelZJcm1PK3Q3R3p2WmtqMkJkb0JNZWNrNWJPNGtWbmRlWmk2VVhGVGc3TGx0WmVaeG4ycldielVGTWlSTkU4Z2E1a1VyRklISzdBaHh6dkE1NTR4Vnk4czdtRm9WdGJrM2NrVElxck02N2dOL3dBMDNJd1FvUGJtdUJuMTY4UzdtbDFMVGxodGdES0pKQWJaMFAzbEoyazd2VEJ6VnEvMVdUK3pOUDFUdy9kdzNrTm9RR2hXZmZJNGtIekw4K0NCeFMxTTRMbVQrSjZxN2VuNG5XemF0ZFdsNWVSenl3U0pFL3krVWhNd1FqSWNFRS9QbnQwcnpiVWg0c2E0aTFEU0xoWnJDNHRsZTRGMnhIN3dFaDJLTGtnais2TUd1NS80UzN3L3IrbDNrMm9hUzdDVXBISDhnTXJGaGdCU0R4ODNBUEFyenlMd3FHOE1XbjlrWGR4Wlh0aTAzblJ4WFA3MlJGSi9kbmFXRzlqMzZWZGsxZXh0ZURrbnpLVnIyMDJNN1RienhUZlFLbDFydGhGQ3pGWTBSMmE0L2Q4NEFjQWtuZ1lMWkhTdFhVZFExNTdWL3NtdVFKZUpMRVpCY3dzSkFyUjRkV0hLbHlBTUxtckUxZ1pIczczVXRCMUM0MUVSYnpGRVZWaEhqQVp0cHd4NHlSMXJqeDRoOFZ4YWpiVDZmYnpXMXE0WkZ0N3NEY1YvaFh5eHlTZWR1ZTFKTFhZeFRsZU11UzNkTjdOYTJ0MU9pMEc3TjlkT1o5TDFHQzQ4bzc1VWdsRUFrSHloaWlrQU1SOTZ2VExUdzlxYjJFQ1hGMUNab3Jodkx1VVVSUDVZR01BRVlBQjZEclVPaitMRk56UGJhdGUvYWJzeHV3VlVDcU5vUEdWWWh0dUt1Nm5KcGwvY3dTQ1MvbmludGk4THhuWU00K1pNNXlja2ZkQTROUzlMbHYyVGczSFZ2U3owWnpPbEgreGI2NmFIVElwWkxwcEZtU05oSUNKRHVPd3VSbFQvQUhSeFVXdmFYcTEvZU5jUXl0QUdSTmlXeXhJVUM0QURTbnFEMkJ5UjByTVhTZEttazArN3Q5TmlRelF5b3hVNDNnOHJKS0NWSUk5UnlPNHIxS1B3MWJ6NlhIYTNUSzRmWVlJbzVSRXJPZ0RFRW5sam5QNFUxZjdoUlZTVjQ2dUwxMjJ2Nm5tSzM5bG9VZHhCcmw1ZlhFTWk3bWdhR09Gd0hHM085R0ladllIQXJTOEwyUGdHYXdtMHlDMlczaWdjeXBKUE50a1VMeUdKK1YxWTU0STRydnRWMHBkYnRRcldWdGJ4aUJWdUk3cDBaWTJVNE8zYjgyU0J3VDByeHFUd1Q0bWhoUm8xdFhpalNVUlNtUlo0bGpib3BMWUpESDhqVGQwalNwS3JCcmxoekxtVjBscHNkVHBiV1dwYXVIdGJacmdxTUpjTGRreXFISkM3U1Rqbm5rNUhOY2t0cnFIaDNVNy9BRlV6VGkydDRkN1crNVhLcnlHWFlNQUZzWjQ2bXNaUCtFejhQNlkwaTJhU1JLcU9QSlVSbVBBeVl5akhMWTZrWTVyb3ZDT3Q2ejRnbHViVzd1WG1nbGRkMHB0eE9zUlBPMWxQS3VQVEdLbHVWN2REQ01uWk54ZS9TeEF2aUx3dDRna2t1am9kNWR6K1lJR2tnOHlLUkNpaHQ2WklJd3ZUSUgwcjBpKzB2UjladjdhNHRMa3hYRmtqUnNMb0V5K1ZuYnVjREJKSjdIZzljMTJGcEplMjBNTm5leUM0dkdiNVdlQkVZb2hLNWoyY25qR005cTgvdTdueEg1TW5sNlZjU1NUQjR3MjVES0ZIM2cyZXcrOWdHanE3SFZLY1VtdVdWbjA2cS9TNnNPOE1hbDQ1dmI3VXRMMTBXME1kdkVHdHJzQmhESXArVUhJeHp5T0Q3MTZOcHNMMjl2SmFSVzJ4UjVqeUcxaktJK0Q5NURuSUp6MnJ3RFQ5ZXROVGsvc2ZXWDFLYUptV09HOE1SalE5MUdSd0NEL0YzNzEybHpaMnVsNmMwVmo0amxlYTJiZ1hFb1VsbGJsSFVZQVBPZW5JNjBYVit3VHE2T2ZLbzZiWDZmTTRueEpvMW9iK3hVMzBscHZTV05CRmFtUWhYY3VVWms2NUp6bkhIcFc1Ylh0Z2xyQmFXOFVxVzVCYVkyT1l5dXo1Tno3aGtqajVnTzlkZmNYK29udy9KZU0wVnpkUEFVYmFwbFNRNTNIa2RHQjZnZHVLOGJ0dFkwM1hMbWFTTFEyRXJmdTdob3N3ck8yUG1DLzNCM09SZzhWYlRPU2R2ZGxyeTJYVG85RFcxSFZ0RnUwa3Q1MTBOZm1rTE5NalRUVEtxYmc2dUZYYXlqa2cxbE1ta1g5c3RycG1xYWNrRThEQ0lSZktYWURkbDQzSUs1Nk50UEo1eFdscWZoRFR0TGcwKzdzcldPZVhaSEkyWmcwakhQem9BdkRlakxqR0s3bXdUdy9mYVBjUTY1WmlRckVWbGVhTFBraGo5ME00R004YlNLcDZXWnJLTk4xS1VaWFhtblphZVJ4RjVvdmphQ3pnRU4vWlNKczh1ZTNqUm5pSUkyamFBcjdsWDh4OUs2SFQ5WTBIUmhieGF0ZnRaWFZ5UVJKREI1Q3VJU1F5NElYSG9jak5jN0JmNnpwUzIxbDRjMWkyOHFLTnNRM204T3U5dWRtQVNUNkhtbWFyYitQZFMxS3gwN1VZOUMrenloNUltVnpMS3g2Y2dMdUc3b0J4VThxZXh2VHAwNUxuVnJSVGZ4SmI2THFkZnFPcytERXUwdWkwNlI3SFdHN2pSUkE3UzU0SkFESFBwWGpJOEpXVGFoTnFXbmlTN2k4c3FMZU5CQkZuY1NBd2ZPNDkvVVY3a3VsNjdwc0JqMURSdEx2N1pVSkd3dktJdU1BQkc1SEhmdDFxL3BPbjZBV25taHM3ZFZDZ3k3cEpISUNmZVhhY1p3dlVuajNwdHRYMU0ycDNsRmU2MnJTWGtlTitHZEs4Vk5wVUZ2Sm9FOXZKTE95T2oyKzlBc24zWkFXWlFWNmdrZk1CNjEyTVhoNjB0cGRpdml6V1h5NVNrU3lzeFVGWkVRTGtvcDdCZ1JYclIxNjFXQ00yOW5mWHF1Sk14eHVySkdBU201TWNqOGVBZWxjSkZyYm05dmJQVDlIbmhnalRiSTl6Q1lvbWRVd1VkaG5nOUFRUnlhT2ExN0lxb3FUOTdsVyt5dS96WS9Sb05HU3dNVU91SFVsaFV5Vzh5bEZlTjFiQVJWSTJydFAzYzk2MVk3eStpZWROUXRMSzdodUJJNnlzaUNSZ3k0SlBsWUljRDcvclhMcDRWdGZzTTl6TFkyVnZFV1Y3bThqZDBlSnoyaldOVHVYSEdXcDFycTdXL3dDNXRFODFGY3FseGNiV1JYVmQ3aUhZcXVkeThuc0tTdjBNWEtvcldhVVhxckk0UHhGRnFDYU5weStGNDVHZzgveklyV1BBOHp6UVczaDJZT3JqUEFGWDdIVWZGTjBzWXZiS2FQVVlXaWhDdVkwbkN1Zm1hWU5nSEFHQjI3MTI5aDRidkRwY3E2YmQrUXNseWtyZ296aUh5OE5oRmJieHdjc0RuSEZjbHJDdXM4c2lYMFRYMkZML0FHYUI1VlprT1ZrSWhESG5PQ0c0cGFhYWE5eFRjblJpbFRUazUzNWxlN1huYmM3QnZCR3B4V3NmMmp4YmVrc243cWJ6bFVJc2JidGlna3I2Z2s1d0RYZVJXT20zaXlYTnJxTXNzcXkrWURLUE1qSUErNGgrYjd2UVlyQXRQRy9oMjl0cld5dGNUU0NFTktrU1lTQUJ0cjdsWUVnNTdDcE5ZMVRVN1BVQk5CWTJuMks1dG1tUmhLWW1MQUJXRXk0engxQlhCcWxydWpxbnk4dDViUlNiNmJtdHEvMktDRmx1QTJsUkl4U05vMml6SUhQekhCejh1N3Z4elhCeTNONEVqbU9xWEdmbFpZZkxRUnNpZktHOHJPNEJlcFBIMDRxRFNMelE5VG1pdmJ5eWh2THFHMldZeW9ubUlpeUFxRmFTUmp5T2VOdWU5WXQ5ZWFFTG1hK1cwdGI2Y2JYZ0MvdUdYeXpob3BDZnZFajJ6a2MwV01wcFNXa2t1NmVub2VuMmNGdk1MQ1FMRktuS3UwY3oyTWdEQXFyb0NSMUp5YzRCNjF4MXJwa21nMjBjZGpkTk85MlNiajdRL214U2JIS0gvVkZXSlBYcCtWWDlJOFA2VnJHbTJrc005NUI5OXdra3FUdkZ0T1F5dXZ1Y1l6akZkTkJGZVcrb29ieHBHdUVaa2pXQzFFclNxVjNlV1pUZ0xrY2NZNXFrN2FQN2hybWNiVzA1dmlUVzV6citNZEZ2TE4wYTRGbklXSU54RWozQ0tRZUczRlJqR09BM1Rtcy9TTFh4SGIyZDVMYUFhaUhtRW5ubVptampEbmlNTGdOaCt1OGRLMk5XMW9XYXlyZVEyMWt6c3dkSHQ4dWRwd0NTbTVjcUd6em1xVnRxVnVrdjJPd3Z6SmRSd28wYkMwL2RZVEpJakRZQVFrL05TdGZjY3ZadVNUYmRyOXJuRS8ydHFxYTFKYjZsZTJ0aEEwcGxoaEViSmNSTVA0aXdBWGNjZmVIQjcxMEtlTGZCcHNZckY5ZG1IenFjU3J0M2grQUhMakJ6L2Y2MTJVZC9hYXJDR3Vmc3R4SkdHRHdTV3pkR3h1Q3VUOHZCNmMrMWVPK0w5SXNMbWFHQzNzN2NPYnA3eTNqZEdOdUNVQ3RHeGkrYk8xY0FZeG5OYXJsdHBkRnhkRnVUYnNwV1duNm5vOGxycFdsejI4c1VkMmJLVmpFOFVZREt1UVdSOTZiWEp6MEpOZWphTm9mZzZDM3VsMDZ4dUk0cnRsZGhiVFpWbmNsU1NNN2dUM0pyanJIVHJxejBGdFB0MWljUXh4dkNxRm9sMnY4QU15Yld5ZHE5ODgxeTg2V2QwNzZsYmE1T3JOQXNjOWphek02b0ZPQ1FFdzRCNmc4ZTlRNzZqalU1RzBscFpOcTI5aWZYZGM4SVdHb1FRNmFFMUpMU1FpYU5Mdzd2TUpLQk10aFNUbm9EaXZRZEluZHJWR0szR2x6SkpsV3VFYTdJSFRKZE9PZXd6MDYxek1maDN3M2M2YThxNlhCTE90cDVheU5FWFVsY2pMRE9WNXJXOEp4UVdTNzdTNXRibGpsZkl0WlhJajhzS0NwRHRodHZadnhxZExsUGtjbzJpa3BXZW02MDhySGx0ejhRN2l5MW96WFdsd3p4TXJJdDNidXhlWUZ5Z2ZnN1Jua0FubjhLN0s1dUlkVEVraDBqV3JUZEM4WWxYeWxFVzNHMEkrUUFBT0VQVEdlOWFYaVk2Wm9ta0RVNWRHMUNaV2Z6WmhGZHh6RURPRUJZY2xCMnh3SzQyMlM1K3p5UjZlOCtqdGY3NVExd3h1RHVKM09JMlE3V0E2YlNBUlRseTNXNXBWbTBsek5SVGF0ZFgxSWhiYXphWEpuMFdHSE9Oc2tsOC9tdTZ4ajVsS1E1WWs5bXpYV1dkcjRwdmtIMnh6RGFCRElua1RHWnBFYzVWa2ttWThMNkZRUjNGWUZwcU9uNlpwOTVOcS9pRFVydDRabFpnRVdBRWcvS3lJdnpZSHIwR2NWV2EzRFgxOWRhUmRQZnRkUXQ4MGM2dU9RQ01CaGhpcDZqZFUyWGM0bkpxQ1hLcEp2UnJyL1ZqMExSdkR2aUVXelBhYXFZZmtJUXp3Z3ZLcDUzTVRrTXc2RTRGZU5YbHZycDFtNHVZdnR0cjVnV0s2bWlzb3lNQWNURTdnQm5IWEJyYlRRTlluczRqUEZmNmZNa204engzZ2xjUDk0S1JKOTBuL1p4aXRQVHJTUmRSbm5TWlRDa3NZa3ZwSjF3NTVCVFpqRFl6aGlLVVd0TGxPYlVGYUZucXJkUFd3NVU4Wi8yZGRNK2tyZVdDeG8xcUVsRHRHTS9maksvTU00enRCem5pclV0aDRlMUFXc3QzWmFoYno3Zk0zQWdlV1lZK21kMjREYnh4WFhhREhvdW4zTWxzcy9uQi9OOGx6R2RvREVCc09HT0FlbURnbnRWZTIxanczRGYzRE5GcEVDTi9ISlBINWtoQUl3b3prRTlPVG50UW1pNHd2eXRXdnMxdmIwUE4vOEFoQS9DNW1uanQ0cFZjZ3oyOGxteitZd1FCbGpiZVdJeDFYR0tiWmFiYzZkcDl5OTY5L2RhWXFnUVF5c3U2U1J1V0RlWHREblB2K05kYkZjMmNra0V0amFOYVBaUnVZaExNTGRGbGR3Y3VHQmJaZ2NkQWVsUXBQNGxMK1UwYzBjcDNUL2JMWUY3YjUyRGNndDh1RHlBZUtyVFVUYmJibDczWHY4QW1OZzAzUTJTSDdOWmFuZzNDU01WRFRNalJnRUJ6a1NLdmNBRWc5SzdlTzdzSXAvS2h0RWpSNHBJdk5paVp5U2VUdUxydFhjZmx5ZTlmUHV0NmQ4UTdxNXVCcG1ySXhnbmRmTk1TamV3QXlwVmM4bnNldmF1bFFlTm8zai9BTGUxOVNIa3dJbzQvSVZuazUyU2hoOXpCR1RqNWFkL2QzK1JVVkdOTlRVb3VWL2gxdnA4ckhSVzlwRkhCSnMwbWEybDh6OXo5b21hUW9vNGtZaEh6NmM1NEZjQnJwc2JtL3NYanRMZTF2WVMzbVhrbHFzNk91NzVRN3luS25QQkpIZXUvdTBXQ1N5bGc4bUMzaFF0Y05IS2txeG5vSlZsa0dCSHh5T3VlYW11L0dkaEZhTnVVVzl4UEc2MjhwVGVKR0h5NVp3dXpKSFVIMnBYZm1ZZThwU2NaSmQybDgzdVhiUFZyejdUYVFzdWpvdHdFa0U5a1JuYkdNbFpBeEhsNVByNlZzV3V0WEY0bDNQTmZ4WE1BZG9vdklhVzNrZlBCWUhnTjdjZmlhNTdWNUpyalRyTVNSd21hUlNJcDVpMEFja0ZRcWxDNEo1Nlp3Szh6MC9SOWFzYmdzc0tXOXhEY0tDbDFidEtyc1I1YWxYREJOcmRzOSthU1RLNTJwYWFKdGF1K2pma2VvejYwOWkvelIrUVdqWVJUM1p6RWh6OHF2dVB5YnV2R1BlcWV0VDY3WktiQ1BUclJyZ29OellrTWN1LzV3VVhQem9kcHp5T25wWG85MWYyY0NHU1JMZVVFckd4OHRWVE9DZGdrbnlEZzl0M0ZlUmFwWWFaUGJRenhhcGM2Vk5Bc2NrVWF5N2JmSmZxWTFMYnNNY0hwVnJiVTFVcFFsWlZHbjBhTGVsWE5wZHh3alhCcDhjRFJsbzRJRUlETWh5V2toQUpLZ2pxY01LOUc4TzIybmFocGwxSGErSDdON1M3WWx6RzVtODg3dDJHVnY0VlBiSEZjVUxyeERQcWtGenYwWXlKTEtFODZKd3BQMytxY2dqUHI4MWRIYmFqQkJaMjF6ZVdjcVRHR1NReFdzTE9wOHMvTUY4c3lEYWVveWMwTnJZZE9wcW1tdCsycHJhbGFhYllRMnhtc0w2MjNTTEdaWUhXQ0lFakdNSFBCNkVQd09sWlY1RHI4RXEyOGR2ZmFwQXpmdkFaUkhLaEpMZkxra0hhRGtmdzRycTRwcmsyd1MvMU80RWQ1ODBrYlIrUzhDZWJ1VE1uSk8zZ1pQME5ZR3BybzBsL2F4V1YwaHVaWlJMRWtMZ29uMmZrcWhRTjhzaEozRmpnMDlDNVU0dE5wcGJhWHMvdzNLdjluM2VsNnBIUExiM2x0QkkwSVY0NXhrdTVKdzhlQU9NYzllRGdWZjF6U2J1ZlVXbEdybUpQTElNSks3ekx3eXU2T0NwREFZOWdPYTQrZncvYTJOMWFsOVlrYStlYU52czkxTThpZVp6blloSTI1N0VjY2NDdW4xT3kvdGk1c21ranQwamhrWkxoeU15TnRIQ3hxUU1MMzU0RkxYb2FjcTVaUVNiMnNtLzhqbEhrR216MnNWemJwTzBseEhpejJxR21qZHNaWkN3UlQzQndBQlZhVklkUThOVEMwOE5lY2tFeWxZNWJaNHl5bzVQbVFUUXNGeGpCNEFQMXJIdlBBMWpiNnpwMm9qeEc4aFVNV25ta2k4dVFZSVh6Rlk5ejI2Y1Y2Wm9WOTRvZ2pTRWFmYld4bFRaS2JlNUN4SkluS3l4OGZkWlRrQWZUcFZOUnNyTjM2bHRVNFdTYjEzNzNmWTQyTFhvNUk1NGpZMzBNUnk4VnNZQmNGR1hHQkd6bklCSElIQlByWG9HcFdGbmV3SkkybHhYQVZIakZ2Y3I1VndtMzVsNGZienp0SXlSbm1vcnpVOWRXMXVudXRTaXU3ZGZuZU9DQUI4S0NkeklNbkNnWkovS283elc5T2xzaGVXZWsvYkxpM2lSL2szSzBjVDhoVGs4RnM1R000NzFLdmE1bGVPdk5mVmR0L3dBenozL2hFbmVlNWFDM2pFQm5CYXo4eVNReENRQVB1YUlxVHV4eUFTSzA0ZkRqMnNFY0NRWDFsREk3UmZhbmxMWVIrVEcwWjJsc2RPbkF3YzBhcnEzaU82bUkvc0tXT1N6T1RKZjdWaGFMT2NibDJZTGRNOSt0VXRIOFYrS3hhd0UrSDJDR01ETUZ5Z01ja2h6dG1YbkdWeGpQV3BkOUxvbDhsMjN0ZDY3ZE8zK1J5OXY0UmkwbTZuYWU4dXphRnRoaDJlWkVRellCeW4rckk2OHJnZDY5QkdrelEyOXdEcXJxV0xNc1FoTFJ2djhBbER0R1N5dVBVTDFybVpmSFpld01GMlVlY2VZcmk5alZKRzR3ZG01UkdjRG9EZzU0cmc0WjB2bzlIYWFHZXhJVC9qNXRwTnJ4b1BrU1NNRWhRTUQ1a09TRDBvYmZZeG43UG1pOWVtclZ0enNkSTA2NEYzS2JlK3Q3cmNXak50Y1c1Uk1vY2x0aEpQSHFUd2UxV2JYd3ZyTTh6U0sybTNkdWsrNk9PSkFOdlE3U1U3LzN0dkdjVkFCNGowU0s0dUxhM1dWWnBHVmxMS0E2bHZsbFk4YkJqaGg2OGl1TDFieUh1VjFQV0xXZk1WeXNTeTZkZE15bGtHZHBBRERCeHlSNlV0VnNZS0VFdVZ4YmJmUko2K1NQUzlGMDIxOE9YZHpCcHNFSlNjbVV4M0YyQkl5dno1WTdGUU9oSi9XczJhOGhuUG1UT0xhNWJBK3h6emdtQURrZ0E0M0JnZmx4OUtxV2NPa1NhZGVSV09vUjNTWFVzNHRBSkROa3F1ZkxrODFWSWtPZUN2Y1ZmR2dhbDl0VnhweGphRzJobVM0amtFVXBBK1ZvMlNVT0NjODlCaWt0ZHk1S2NtMUxtdXRYM3V5bHJQaHExMTJVTFoydnoyMkU4Z1RRMjd4b1JrQlE0ZjVNOVFlUWFLeDlXOEVXZXBYSjFJLzJkTkpMOHJOSVpOb3p5VmthMEs3cFY5VHhqcFJWYWQwajA0S2xHS1RyUDdrdi9iajF5NzFMVW9JbW1ZeHNJWTFqYUJKRlZXQzg3eDdqdDYxd1dsZU5OTjFIVXBFZ3RaWWhMQXdhY0JlY2RzZFMzdFhRNmQ0VDB3dGh3MTJwaFVTQzQrZmR0NjVqSjRiMzYxeDJvMzNnNnh1YmZUcmZUWVpaTHR5RU1JYnpBRmJuNkdzbjZuZzFKVkhGYXUvYmZiVjdIcEUrblhFemFWY1FPWFR6Q3M2VE50TzNxRHRQUnV3RlVMN1UvRE9tWDRsODZWcDFsVXRFN3RLc1hmQ0FZQXg2VjVMWnkzdW5YVWJtOHZaSURLNnladzI4bjd1RjVLNEFydWJpYTBrdHhjTGIrWWtqYmxpRVFieXl2QkxOd0FhZG4xL0F3bGlxYmhKd1N1dDN1dXgyc090Mi9pR2UwTVVLTmF6RjR6S1k4RGN2M2ZyOWE4NjFhVHhacDF4ZFc2M0FsSDMyUVc3bmRISDFBUFFnRDBySnR2RzJveGZhWUxiVDRZVWpYenZLTEF1eXFlUW94WFRhYjhTOUlXUUc2dXlHbFg5M0F4RytNRUhJNDRBcUVrbnFpdWVuVXRkeXU5WEphNmZJcmFUZmFyZjNFa1VlblJHM2FOdzhhc1l5QVJuS0Z1ZHg2NHIwYTI4TS9aQ3JSK0pMdU96bTJ6cEFEdEM1NEs1Nm5GVjlNOFVhQmR1cXBJSWNBazRJMkVuamN4NzVySjhVYVZxOTFEWmVXeXlYTUxOSGE3SDh1Rm84NXl4OWF0T1BNK25xYlVPU05PYlQ5cTd1MnY0SHFlMnloa0hsM0RTVzZLcGRJM1lPelp5T2VlRDNyQThhekxIcE4zSGViWm81VGdyd3hTSitTRHQ1eDc5YStmTFhTYnZRYlVQZnhRRXRjeUM3TWNyeWxZeU1BREhHUWE5c3Q3blJibEhqaDFsOHRFUG1mYUNCakFRay9vS2UzVTI5cTJwd1VWSHRaN0htV2tXL2hPRFVvdjdLZHJpSzlPSHRXY2hGMmpCMm93T1A1bXZTdkR2dzY4RDZYcVRYTWRwSFBkenNYV1NiTGlJanJ0QjZZOXhXTGJhVHBtbTJrVnRGQ2s3eHk3elBLK3hVbEp5TXVvNStwcnpLODhOZU5aTCtiVm85UnM0MmFWMmVJU3NSR3A3b0IxeDcxWHozS291cEJ6bHpmRnZxOWwwWjFuaWJVYkMzdlJaVGFPSXRPWUlkOEpSSERra3NUakJBNzRyb2ROdC9CZDVvZzAyTzdaL0pRcUpaQ3haa1k4ZlB4Z0RvSzA1SmRDYlVZWXRUdlR2dTQxT0hVY0tSM3lNZHZyV0JEcVhobXgxZVN4c1JlVG9Fdy83dmRFQzNCREU0NEhjVWtsYmN5U2x6eWQ0MmYzbVpkK0ZkYTB2U0lZdEkxV1M0akkzU083N3c3c2MvTVJrcXY2VnlXbStPL0hpRzhqazA2QjNzekVobVpkK1ZKSmJCNEhTdlFkU2d1ZEx0THFOTlRmVGJhTGJJRVJNT3lubkFicUZQcGppdUUwcng3SmR4dkViTU5Bam45OUd1U3pOd3ZMNHBiOURHcEp3NTNHNmRsZHU3czcrVFBjTkQ4U2FacTdTUVEzS2k1V0h6NWhrUlpWZnZEWTNmdDFwbmlmU3ZDOTF0ZVdWN2Raa1RaSDlwWUdUNkFkd2VLOFNrdVV2dFZNa2VrM1U5MWJ4eVJyTWRqRmNnWkJ4Z0hGZlJ0cDRtc0V1SkxTNjBlL1dTU0NMeXB4RHVqaWJIM1Jqc08rYUVqdW9UalZpNHowYVh4TTh3aStIbmhDZWUxbmUxbWsrVERLQ1FoMkp0STY4azQ1UHJXSjRvOEorSHRJTnBlQzFrY0tHVlJHQy9ra0RPRy8zZXhOZHpiV25pbUM2bmUzMU93dTFRaVFRWHJDTXhaUEpWaDJwTlExKzdKdGZMZTFpRXptS1JvQTh3eUR6ZzRINjlhYXVtUlBsOWltMDAxb210em05STFUN1ZlM0Z6YXdhaGZRVzl2dlpKUis4WW9PZUNCMlBHT3RSWEs2ZGMzVnY5ZzB0OVB1R2k4dUJiZ0hkc2Jrbk9TTWpKNHJwTkl0THJUZGVtdnJqeERDSTNnTFNSdHVXUFBvZXVGQXFkL0V1bU9ZekZxZW5OTERONXNrc1h6L2UrNmlsdU00OU9SVk5LNUhza3FYdk8xMjI3MnV2bWVQUmVNdFA4RzNFdWthekJlRGVyRkpSOTBBdjh1M2FNOU91ZXRlcnJyWGgvVTlDU2EzbURSU081anVsTFJTcXljZ00zWWs4WVBGYTJvdytKTG02dUx1MFczSENrQ2NDVk40UDN5Y1p4aXVNbFBqdU9TWkxxeXRqR1FKSlZ0N1lCWmNuYUF1VDE3azB0R2F0UWpUU2pHZDcyMnVtdnUwKzg3alR0V3ZaZktTRFdMU1dSRXhKQ1JseHgwM2NjNTYxYW4xNlNLSzRTWFRvb3pIbG9ta2w0azR6bENjNE9SME5OZlQ5TWxrdDJGdkhIY3RDNnV3VUZnUFJjamttcTBtcCtFYldMeUd1Tk5FMFJSRlZtd3hPTWxOb3o4MVJabXFqVXMxekxicTduSDMvaHZUZFJrT3AzZ3VMUlZVU0VLZDhNdThaWlNEd1NDZUNLd05QOE9HMHRyaFZ0Vm1qbks3RE8rOXdoR1FxaFBROWE2L1VQRWw3ZndtR3gwNjZRWWNKUE0reElYWDd2VUhnL3BYbHRscnZqRzFhNSszVC9BR3lhRjQxZFZ0MWpLeVNmZDh0dU53SGZOV3ViVkhKTlVYWnA5dGJiM1BRUDdKOFF3Mmw1Q1lJNUZ0OE5HN25MUmhlZUF2TEJlb3EzcGI2VHFsMUZaemF2YlNUWU1wUGtOYnpLY2NNTThmV29yclYvR0RxMHhqaWpWWTJqRnVrZ0Vrc2pBZ3VUMlBwV0xwMWhkcmZzcjN6M2txUlJ0NVYzNWNqL0FEZndKSU9mbFBVOUtlNWt1U0xUczN0ZS9iNUYxUEIyZ1dkM2Q2bkRlWDEwNWtNY2llYVRHWk9tU3crYkh2V3pvV24yRnQ1cHRZNG9ZMkxDWnZNY1RBbmtoMko1WGpqTlIyOXRlRFViS1ZOU25BWm5XNWdXTEVTc1JnOEhHVDZHdWZ2ZkQycldHcjNja055OGNVK0crMUNFZFg2aHgzQW90ZHMwbk4zak5SZGswblk2VFVBYnUxK3lUVFRQSWluZkRMSUk5OFo1VWdnQWtDdkhvTk9YUUxobjAzU1VNOG0xbzdpU1hjekszeWtoU2NBSDBOZTAzSGdxdzFON0s2dWI5Mm1oVlFab3BTckU5dDJjNUhvS1hVckRWN1d3VmRMQmFXTzRSNUk1aUpQTWo2N1NlQ1BiRk5XTTZ0T3M5ZWRwTkxydmJ2WTh6MVBTNzY4ZDRiMkxUSFdWMWtTQ1JWamtEaitCU01qSTlhYmNhZGMzSnpiNmJJMGRoS3NUL1pwakhNaFBPQVZ3SEg0VjZaY2VJTGh0UWhpaTBGZDc0QmVmOTNKdUp4bFJ5Y0QxTmN0ZGFYNGx0cFFsblBEWnlHZDVIUmp0RWhmZ3RrYzUvdTRwZWR4T0ZPT2lsSjIwdmJZNGVQd1pZWEYyMGlYK3EzTUt5dHY4NmRvekNDY01uQSthdWlrOEl3YWRjVzEzYVcybmdRN3pGSzVaWElJNnlFNURZNmlxVnA0cDhSMkY1TXJQYUxHeXRHM0xNd2xBd0dPN29TZXRjUnJXcGVNYjk3ZUs3MUdDVUZkdTZLSVNGWEdmbDIvZElQdlFyM3NaKzNwemkvM3o1dTEybCtCMTJsUmVHcnBvekhxRjlkcE1qdmZNcHhidElUODI3ZU00T090ZFRQZVJMYmFoSEZiT3RxaWxZRXQ1MS9lS29BQ2p5K1FQWFBXdVI4TzZUNGorendTL1lZcGkrQTBKaUZ1cGpQQmJBN2sxelhpWFUvRWZoMjVXYURUbmtsUXNBa1FIbHJEdUFDaFNDVDB3U0tyZlMrcEVWWHFWdVNNSXJtbFphN3J2ZDJQVnJIeG5wTmdzTUUvaHQ0cG15SkpDREtjZ1lEQUVuZUNPRFJvT3RhekUxelBONE1ralJweXNQa0l1Q3ArNnpoajh2QjdWaGFPMFYxS3Q1cVdtdFlwY3MwcXNHS2xTMlBsUWYvV3JvZFgwMkc4YVZ0RDE1TGFPUGxyZDduSmVVOFlHL29PT0toWDduVlNxelVYemNudXV5VnRkUFE2WHlwWk5Sa3ZqWVJXeXVpN0ovT2FPVlZVL05nRGo4TzliWGlDeTBxNjBxUm0xY2hZM1pneXNXSUxqQUE2ZkxrNUlOY3hOYStPcExLM1JkUXRJM1ZnSDNKNXlPbVBseG52K2xQdU5ac2JwakhkUUd6dW9WSVZ0Z0FiYW1Dd1UvTGp2ZzB0ZWczT21vMmx0TCtaTkhOMjJ5MmtsVzNpdHpjVCtVUE1SZ29ZeGpsekhrWUxEdlZHRFd0SDArNGhkdFVuWU1XV1dMQmR0N25Ja1VxRHdLNkNMUUV2VXRsbnZvbG5lMnp2RWFySklvYkFZZ2NZcXMramF2WlJQY3Y1TFRxcGlqdUpDZ1o0OGtnRUpqcmlxYlJ6Y3RWUG1UYml0cmZlYmVuZVVMU2UzZTJzbGtTUm1odW5ReUswUUhERUFaM25QSXFpUERkcHBla3pRVDJ0dExiVFRlYXNrRUxzd0xqSENaNFBQQnowcmUwcUVTNk41Y3R5WWlrWll5TkpncVpQWEhCSHBtdkNiL1ZXMG1XQ2FMVUpaMG5kRm5ra0xBS1Y0QlRBd2VLbDNaMHlxdFFqQzEyMXByOStoNkZEYmFMcGRySERIRmRRbTdQN2t5eE83TXc0T2NGdVNPbnBYVDJXbmVJaHJIbnBiMk1kdCs3V1ZONTNyR09TeFBBNTcrbFdMYnhycHNDV3NFNGFEY3FORUpDRmNrNUc3cGpuMHJHdE5NOHU2bUduYWkwZDdPNGFaWnBHTy9waFRuanJ6eDFwTFc5eFV1UzZrcnkwdm9yYS9NN3U3ODZPZTFsdDlSczErMG1VamRLRzg5Vy91NDZNdmIwcmdOZjFVeFdrU1BvRjFQOW5MRnYzMFpVRmx3U1FwSERkOFY1ZDRoOGJhVHAzaUpyRFhkSWdnbGlBOGw0NHlJd0g2dHQ0em12U05PZlQ3dTJ1QzdXOTNwNWpTVkxvS0VrNU8zWUQwNHgwNzFadlY5ckhWMG1velY0OHlkbm9jQmVYSDlyYW5iM0dsd1hGbEpPRmVlTk1oUXdHMGZlN3JqdDFGZXUybHQ0dHZMOVk5U3UvSmplNEhsS21HV1JVL2hMRGtNZXY2VjJsMXFsbEZwaHZRb2hYY29YNWQyU2VvSG9hd1I0ZTBIVW81WmJpN2FCcDNESTBNN0IvM2ZHN0FQR08vRlJkMklwVTFHbzF6OHpscmJSYUc3SlBNcXpTQ2VCRTJ6K2JBMFM3eUl4Z2JlcGIzSGV2QWJqeEJJYjZ3YTJ0citLM2thSjNWYmNCbVlqYjB3TWpQYXUrOFUyK2phWnFGbGVpNmU2U0FZYVBmNXo1WDdwQ3IzZnZtdW4waTQxQ2UwYVM4bWpTT2ZtRkhJak1TNDRRa0hKT085S1NTUzh5NmtKU2xKTjJzNzZPNWUxWnJPZUdaZnN5Skt2bGVkdlVJZGlrWU9leEI2aXN4cjYyalM3dGJWSHZJZHBpWmltVVZnTXNyRnZyK0ZlZGF2QllXdHhKYVhtbzN6VzdEekVWQ3p5TVFkM2xrNE9SNmMxYVRXN2FHQmx2TGEvdExhNGxDN241VURBR1RqMTcxUFk1NVZuZHJadFd2MS80WTVQVDlSOFRhZTF0Qi9ZbHJGRk83L3VwNXdWREx5WkVKejhwNzVyMG1idzgvaUhSWld0cit3dHJ1VEtTem9nQ0ZZenlvWVl4OWFzd2FwcE5waVMra3M1SGRDaXh5THREb3A0S2x2NHZXcXVuNkxCZjJubVQ2WkZiM0V3SldIemdrTExrc3BNWVBYSFgxclZTVnphTmxhMFZKUGFOdSt2VzV1U1hsam8rbjJpYWhjZ3h5UytRM2tsaW1XSFI4WitYMFA0Vk5CcXN0dEpDSUpvWnJWWE1RamtqM0U4Zndja2R1aHJ6anhENGoxZncvck0ybnBveHVMZTRLTGhFQ2NiQmxWR1NDdnZYcDR2ckNMVEl6SmJTUVJTRlEwY2IvQURLeEgzU0ZIOFFwWDFOWk96ajczS2x2cmUxanplMWFLNDFxU1Y3VzZsbWlua1lTQzUrelJrTWNoQ2dJNUhwME5lcnRvSGhzMkdwZlpqTGJ1a1JrVllad1ZWM3dTMnlYSUdRT0RuRmN0cUhoUHdqcmNLS1h1NUNBSklpcnNIalZmbElSaDE2VjUvcG53eDB5MXVieVcyMTdVbWRvMkVLWExqeWQvSUFjRExNQm5wVkt6Vy8zblJSaEZVNVhrcGJ0SnE2ZCt6T2cwV0czZ3VSRGVhbmNUWVhla056YjdwSWg5NE1yeG5hdkhUUGV1c3RMcTB1YjZHM3Q1V2hpbWdaVW4zN1pFWXRuWWdicmtEazE0SHB6NjNvbDYxbkxZMlVSakNCL0tKbE00ZHZsWXZ6dDloaXUzOGNhSnFMMnlYRmp2UzV0Rzh4ekxOdFFCZ0RoUzJQODhWTGlybzRrNVg1YlJYSzFmcHY1bytnMmp2dFB0NDJ1MGpMTnVYZkV3TGxWUDNwRzl4MnJ6enhEYzY3cDY2ZStsUXBhUnk3b3BZNUVpYUtRRWNZSng4eDlEMXJqN1BVUEgrc1EyWS9zNjMrMFd3Y1NCR3lYVXJoUVR5TTk2MzU5VjhRQk5RMDhlR1NIamczUVNseU54UWRtWVkzYzhDa3JuVktxK1cwWEpLMWxMZlgxSFhkenJGdGMyVHpTb2xpeWVWTEY1U291NXh3Y2c0QkIvQ3NmVDVkUlNDV1NDS0NWTHFVeHlUeVhNY2pieDhwVUtPT1Y3ZDY4MTBid3o0cDFPSDdGNGtTNG1DZ3NrRXg4c1JOdUJMSzZaM0FqZ0U4VkplRFJ2Q2x3a1VQaHU5dDNHOXlrWG1UUnNoUERCc0hIdlZKUFF6blNsR1c4cFNVdE9WWFhuWm4wakhQNGVqbFRScml6ZFo1STJqamhWQ0daYzk1QmphUHg0cmpkZjBXRVhxUm9ubENGSW1uaUJhV1l4bnNvWVpaaWVoelhqTUhpSHhiTHFGamJYdXFwRGFUU3U2czBtdzQ2ajk0Ung3Q3ZjMDAxMWxSN1BWbTgrUWgvTnVCNXdRcUMyRXlSeXc2VkY3UHNZeXF4cTArVGxUV211bm9jUnA0MVJwWVhndHI3WTkrRWRaN2JEUXFCd1FlUGxKUGY2VjZQcW8wdlVyUXJjaUtDTVBzbERBWjMrcXZ3US81NHJ5S1RXZkd1aGExQjlza2x1amR5RlAza2hoaWhTVUFieXA0SkhYclhzVWxycU52YUpKT3NWNkkyODJSMjJrUm92R1Z4em51S3AzVFE0YUt5VDMxOHJlUmIwaTMweGJXNGpzYng0MEtsWTBZWkRZNExiVzRMQTlmZXN5MDhQeVFUWDBUZUluZTZrY08wU09JMFNKY0FBSzNRL3dCYTVDTzgwQ0s0c1pyTy9udFk3dC9NZUVxdTNjcDNFczB2UFhzSzQ2NHRXL3RDUVQ2eXlGcEl0eStXdm5iQzJXNUhDaHZYcUtwYTNLVW9KUnZGUFhWMzBPeWw4TmVMclNLK3RMVFVJYm1Kd3kyalRScTdoVzVJa0xISTY4R3ZPN1h3VmRXT2xQWlFQQXNycTBsNmozZjJaWTVGd3lMRTNPTWRjbXR5SHd2cHVtck05bGVYT29vMm9DZjdHSjFkb2p0SzdXblU1QXh6anZYWjNPdDZPOGNhM25oUzl2NVk4TGpDbmNHWDd3WWNuQXA4MWt1dnlGelU0eWxGU3NtMDlkRS9MUTlYc1VtaGdXMGx0MHVwWTQwWXhTVEJ3Z3dGNU9NOG52M3J3WFh2REY0dHRISmEyc24yb3U1bG1FSktJak5sU3BmKzZSeGlxdW42dHBlZ2pWSjRGdkxKNTRYTHBNaGNSTURsWDMvZUtFY0FkalhvK2hlS05XMVRUb2xmVHplR1JXT3dNVTNLT1NkeHlPaHFWZTkxc2JlMG8xVW95YnYwZTlqaE5LMWRaV3ZQTTF2TjB1MkdSWGlkTjc5dHBYT1I2a1ZtWE9zNmNMcWE3MUR3dkRjYWhiVFJ4MnlXVWo1OHNqRFNTRThBRHVUelhVWEdrNmRxeXpRdFBMRWl5QXgyMENiVENjWUtzMk0vS2ZUdFdQcE5zbWc2aUk3NjR1TGszS3U4SmhFazRkbTdFY0Q1Unp6MnAyUkVJdUxWclNWN052OEFHNVhuMXRZSTVZN20zbmpoWkI1THM2dEVGRDVLa2RmWWtWMFZuRG84L2grOHZQN1J0eHBTS0JjU296Tk0rT01zeFBRNXhuclhtZXBhcDRvdEpraHU5SkY3RThzZ2hqdGt3OFI2Qm1VZ1pERHNhczJuaHlDOTBHNGdMMzF0TjVDZzJRUlRFaTdza3lrQURjZW83aW12aDJ0Y3doZU9yMVM4MTAzME9zc2RCOEtYMmxRTkZmTkpBcEcyV0NjcTdwMEhtcDFjRHBraXJkN05vVmhMYVdMWGZuaVVMTEEwdHdZUkNEa0RZNmdaVWRTT21hNUMxOEs2aHBVa0w2YkZhbERFUHMwMjhxWXdmOXBnYzQ3QThDcW5sV3pTUy8ybnBMM0VpRW9URkp2aEVZSll5ZzhBam5uSGVsYnBkR1VaWGE5eHBkSExleDZGWTZYcWVwMzE3RnFrZGxKcGVDaXRLRW1kMEk1MnNtR0MrNDVybElmQmVwNlZZM0M2TnJ4T251c2ltM2UwVzRXUkJ3QkdWTzQ5ZnJYbldwNk5wYjZkWlh1bGVLNysyblFyR2lQTHVXTnoxREJRQ3VmeXJ0dEgwTnJaOVB1TGtTM0xJMytraUdiWWtNcloyeUp6OHdmSHpVN2RFMVk3RktOT0VZeG1wTnE4b3ZwcHY3My9BQTVxZUZOQnR0Rmt1ZnRlbWVWRWlpUVRKSjVvSlp0eEFqNmdkeHVPUlhvTjk0RzB0b0Z2dE1rTjBaR1Y0bVJ2TGtHL25hd0dGZE9lUjZWNTFiYVBvckc0dTRYa0M4eUdHYTRkSkVsYklMN1grVmtib2VhOVIwVHhqNFNzN0dQZkxIYXF3ZUtGRkkySyszTzBjNEdQeXBhbWNGVHF5YWZhNmwxOWJuRDJ1Z2F6cWEyNXVZaFpUV2tza2YyaUJzdEtCOUNPQWVuQnJxTlkwazZWY3pLZFVpdlJQQkcweXh6cHZRWSs1Z0RjTWpqSGF0V1BWV09KdFN2b1VVUHV0Q1lXS29XSEpCWHJuM3JHdGRVUkx3eURUTFpiemM2ejNhMitJWmdlVncyTnlOZzgxbmQzZWdOVW5HU2VqK3pMeVhrWUdtNlhwNjNzZHhid0czbmRTcU1WSWxNYUhPd3EzeWx1T2VuSE5RYTc0MWcwYTd0cks5MHVLNEIzekNlZE5pSjBLT2pIK0wxeFc3clI4Vm0vaVdTQ0RVSWx0TnJ5TWU2Zk1GVEJCWjJ6Z2Jxell0WjB6eEhiTFo2aFozRncwa2lpS09XMWNHRXNlVk9BUGw0NjAydXJXaHJHTUZOZkZ0WlAvTThhazhSNlBxTnRkVFJXNHRvWDh5TkwyM24vQUhnYVRrN2xiZ0tUNmpGZEJvM2crOXVyQkxpNmJVNG9FVlhhUjQvM2NTeGpHVUdUODJmbVVqNlY2UHFYZzNSTDIrRWRob1VNTWNVY3NieWxpY1k2TUIyT2ZVVnpHcDZSOFZyUFVGaHNibTBtdDkwY1N3L2FnUktxcjk4S1NjTVI5NWMxWHUzMGYzbWFveWxPYWc3SlBTOWwrSjFtbTZ0RnBjOFJiVVpkVm44eHd6WUFhTkR6dmM5d283SG1wOU5sOFJTUXpTNmFsaTFuZEl6eTI4cjVhUjJrNXdvNFhjUHZlOVI2ZUxxSzRQOEFiUGhtYUs5OGhFVzVoa1lvN3AwNFVFQVlxeGN5YWRwVDNzR2dmWjB1NHAyZDFuVXVKSkd3em9ybkxKNmp0VXZSb2hPVk50eW1rcnY4ZlU4MVR4TjQzSGlXNHRKdFBOMHRxclBiTVVSandEL3JDUU1qdG10enc1NGpiVmI0U2FIOW10cGJsMkYxNWFONWNqdGhzWkJCVG9RZlExdlgydTZ2UHBDbVVySHFEeXJEc1loNHdRcGMrVzRISUlIUTk2cmVGL0hIaDJ3bVV0YW0zWnAzSGxKR0loZ2ZLVnhoY2tEbWg3Tm1uUFM1NHlWNHJUM2x0cHYzUFNMZ01kWTArM3ZvcDEzRVRSeSthc2doZHVWVm1iSEdSMjZDdkpwSnZFN2EwOTFhSVhodm11aGNSZkxJWVpndTNlQ0NDYzQ5S2wxdnc5ZDZ5c3QzRnEwcVdzcnBGRmF4eDc5MGpNY09weDhwSlBOWk9nZkRpR3h1cnRrdmJxV2FKdzZiMXc1YkhDZ1p3VG4wL0dwV2lSRTIybnl0TytxVnIzdjU2YkhiNmI0a3VySkxpUzkrMFNOaFNzWnRXWkFqSGJnN1J5YzlUK0ZXSWZFdWh5V1p1SkxaR1dDRnBCTmF4TUUySVFmbUVvUHpEb0tsOE80V1pZYi9BRlBXUkx2WGN4QlJQTVZ5d0FQekQ1Z2NNT2xRM05wcjJxeHhwWjJSalpsZU9Sak9JR1J3MjhxaTRJNXdDYzhITk5MVXFFVzRRYTFldW1sem05VStJZXQzN3dOb0U4OFU3VHJFYmVTSkpJWkNlNWNES2taenh3UldOcmplSjdLNXR0YnZaSVkzYVJoSzl0dGtramk3QTVBNm5zZTFXYlRTYkxTSnJpUVcxMjkzSVdNc2M3OEFLTTVRcjh1MVQzSElyUDBEeFZvdC9GZFIzdHM0S0hhdUpqNU02azV3WFlaQVluSHBWcFcyMUluVmM0NnE2VFdydXJIWjJIaTdUTlNzNG9MK0NDNFM2dkZWbWdnWkN5WXdONjVCREgwSFN1bmp0VW0wKzhoMHhrYUVzVUVia3hTUkl2eWxSdkJHQnp6eDJyakkvTlJZb1Z0TlAreFRNSkZ0dzd2S1dUN3E3dHVXSTQ5c2RxNEN6OFIzVXVxWEU3UVhWak5ieXJpUEFLdHlTVitiZys0T0tFazltem45dStXOGttbHUrcVQvQURPNVdUd3haK1JJMnMzczB3Umw4cVNiZVltRGVXUXBBWmlSMDVQVHBWVFYyczlYbGFiVHRTMGhKNHJkbDMrVzBib2pnZ3hOSU92SSs5eldoL3dqMm02cWJTZU9DM3QzSzdwN2lRaEF3SEcwZ0VaOWlPbFpPcjZYSkw0dU1PbjZLMW8wTElWdmtWVEMvVGRsR0RLVzlIWEh2UXIzMFpwVG5LY1pOYk5MeXUrcHdGdHFqNkZkd3ZxV3RMYVNvN044d2E1M3EvemNZNkFIb1Q2MTNsMzRzMHpVOVBtdmhEQXpDZUpDenUwTTd1cDNLNkVqYVY5YzlSMXFscmJ2Y2F4RGFOY1NXa2lXaU15Mm1MaTJtYmJpUUZRRGc1NmpwV1pFdmdKOWNhenZRWjl3QmJ6bEN4NXg5NVNNQUVFWUlQNTFWbHZ0cVg3Tng1YktWMzhUdm92bGI5VDFqUnROazFhL25uaDFsSVpsR1ltRXNaWXEzTEk2b1BsVWZpTTFvUWVGYlc2UzV0ZFIxOWJ4a0Rva2hsSUNySVBtQVZId1pPMmNZRmVhM2VyNlhwZXJvK2xXT3JXNkFqZEpGQXNrTHJnWkNnL056MzdWdGVJN0xROVJOcEpITmIyRjNKRjlwODd5QWdHMC9OMElET0FjZ0htaDZNdWxOUWhia1VwYjN2ZS85ZFNuYXlhRnB0NXF1bUxjWGN0a3U1aE5jUElzY1c0QldTTWhRUG0vSTFwYVEzaGUzMHlheTA2NWFlS1czZUYyRU11M1o2RXJsbEovdkRxSzNadkdQaWZSOUFnWjd0cm9SNEV0dzhLSUpJeWM1akhSOGpnWjZHdWd0N20zblZycU9DRzNtdUZMR0ZZRVhkR3crVVN1TUFjL2lLTFc2c3VianpKcHUranRhMzNmZWN0b2YyZlN5OXBhV0Z6ZFJQRWp3eHRJQkcwWnpsRllFRmlwempJQlBldlE3YlhSTGN5d0NDZTBlM1pTa2NVcFIzNHdkNkxnL0xub2V1SzQrN3M3alc3UjFYVkwvUnJuSUVrTVJjWjIvSVZRbGVjSDByaEgrSHVzWEY5TGN5M2tzY2tUeHlQY3RqWXhqTzNmZ3R1Skk5ZU04MU1valRueUxrN3ZwYzdyeFMycjJkeFBOWVNhWmViMll5eFNiWXBDakVaTzg1K1lOMVVtdUk4VGFQZVhKZ3VwdER1Ym1ienhLSjlPbFc0OHAyQTZSdGpnZ2RQeHJwYmkwOE8zVThzbW9XVnhOSUpPSjNqYnlISkdVQmVKU3B3RDhwUFR2WEtTYWZwTm5OWnRKYTNDUEV1eHJ5TjBCa2l3U1MzektRZXdJRk8xaVpTNVpYY2RIZlM5cnBuYVdlazNGL2I0L3M2V1F5QXlmYUx4VlVEUE9HSEJRRG9RT2xUeWVGckxVb0JjWHNGczdCSklXblViV2hEZkxqSTZrZFZiOGFmTDl2bjA3Zlo2OWMyUml3SXA1M1c0OHdOZ3FKQTRCVUQrNmVDRGlrMU8xYlJ0V2gxQzhsaG1RUXFiaWFTVXhvOGhHMVhST2NCanhqdDJwOWQwS01ZUmpGeGIzcytsa3lXMjhJNjFwc1ZtNHZJVWpqamFOb1d1SEliY3hiY1pDUDNqanVBdk5MRnJYaDlMMXJPVFdMZHJrcnYyeXh1ci9NTnFSc0RoU0NlbklOVU5UdjdEVUxhV1dUUTVMNEc0YVNaNHdra1laT2R3S0U0SUF4bkdmV3VTc3ZFSHdvbGdudC9KZ2dtbUJCdHBFU0J5cElCS2tqYXdIVWM1cGJ1N05lVlNjbkJQYStpZjNuYzZmNGw4V2F0WXZGSGFpRlMyVWx1SmttakNrRDVZMVFGeHVISTNEaXJ1L1ZyeWN5V3Q2c0pIRVlreHR5cDJ1cExxcEJ6MHdjMTV0SDRUMDZPdzFLU082eGIzQVh5NUl3TW9HWUtybmUyUXFIbjVlMWVRUGRhcHBVVVVnL3RlOVFTamlaV3hoTXNOdys2eXN2ZjA3MVQzME1wU2NsSGQ3V1NiMTA3bjA3RForSjlOdkkydjdxMGp0SDh6TXF3U0tRUVFGd1FDR0pKNkhyelZxRFU3WjdqVDNzUXBqMkVYa0U5djVKQ0FuSkNiU0ZKSjQ1d1JYaUVQaWUraW10cmhaUkhHQkdMaTNZR1FwdUdRN0tDZU1OZ0hzSytrdFkxSjcvU0lMeUpwekVFaktpQzRNT2VTT0dKeGtZNjlUVXFXdXhOS3BHWFBGUmFjVmV6L0FNMGNoSnJzeW5hdW5QSXhJazg2QXlObUxuTWgzQWtzdmZ1UFN1ZDFLNDFFMlZwRlBQTEhjWEc4aTQyTDVrZ0s4b2dZL01yRGs1d0s2a1QyOS9wTjZrRjVKR3dDdnRsbGpsMkRnaHR5SGNDUDRlYXJlRHBkVXRySjRJciswdU41ZG9GU1h6SlpkbkxLcGZsUzJlUWVCVXRwRkthdkJYYnV0TEhLNnpiMjE3SEkwdW9TV2NFWWxpdUk1WWZra0RKOHNrUmo1VmdUbkI0TlVyWHdaZWVIcm13anRkUnNoWXRDV0p3eWc3MXp1QitZc3d4bm5IUEZXWlkvQzhHb0xkeTZLOXJkNGRXbVNXYU9HWG5EbzZ5YnN0ZytsYm1peFdXbnJZMzlyZGFuY3czRG9uMmN5UlNFeHFOdkNEUEc4RGs0STlLdTJtNEt6U1RuZEszUnF6ditldTVpYVpGcWQwbHpQbzVsUkV1akdVMnJLa3k3Y3NwQVA3dFFmbUREQTNHcjFsbzF2TGFYamF2b2R2YXlRVFNIem81Y0Q1Unl4emtCbTdIdlhTeWVJTkR0NDVyaTdnbHRkOGtiZlo1TUs2QmlkcnFTTU5nakI5T2xjYlkrT3RLZlZyVFphNmt6Q2J5NUVrZVJINXpqbHlZMlFkK1JtbWttYktFV2szMDAyMlhjN0czdjlCU3hrbTA2WFN0VEN4aDR4Si9ySXdweXdKVlg1SGMrbExhejZWUEZjU1dlbGFXa1JTVHpFdHJnNTM5U29qQ3FTVzl1dnBYTzZoOEtOUG4xWCswOU12M2dhVFo1MGR2aUpnemRRMndnTGdEM3ozb3M5ZHZmRGNWOURkYWJjM0VTM0oyM3JiQVdUaGxZbUxvVjdaNUZEOGpXcEJRZGxwRGRlN2JyOHpuN2ZXSTRiYnpiRzV0SWJOM1lTanl2TVNCajJDekRKYml0KzA4cFh0cnM2bkFFbmhCVS9MSnZMOEZlUVFvT0FSdlVIUFEwZU10UnVMMktSNE5YdDE4cVJIOGc3cDVaTFl0d1FzYTQrWnU1R1JYaStvNno4WFp0Vm5mVGJlMXNaSEJqbENtTVNaajR3emxSbmpuR2FWcE8xdnpNNFlmbXFLOVZMWFJ5YVMvcjBQZUlkRDhVV3NqcnFONjhsdEorOGpVNFoyYVE1eTJFQy9MajVUa1lwNDBhZTVzRk56YzIwOTFIS3kyOHQxR2tTcXVPUmc4TnlPVDE5S3kvRDJyZVBXMFZJcGJpMGtuOHh2bG5rOHlaL0xHL01iSVdCRGZ3ZzBXM3hGc3I4ejZSNGswMmV4a01XMHhUbGtLNXhqSlhKR2V6Q3MvUHFKeGpKdVQ1cmJYMHN2dUttcUc4dmIrS05QRVdpaVMxaFZaUHMwV0xvRVpZQXU1WU56MEdlQjJyeUx3ZExlWE04TTlyYnJlcFBJeVN5VFpDTHVHMGhqakFVNE9RY2l2cDJ5MERSOUhoaGJUdEwzUVNzUXR4SEtKR2plVVpVRldCeWNjZ212UGRVaTFjaUI3MXpkUEJKanlVdG1oMlJ1T0hqVWNyMCtZSGp1RFZmZWMrSWltcFM1ZmVUankyZHRFdDNjNnpTOUVzRW4xQklWamlPQTVDdG1GU09CNVJjS1YvTGFUV1JxR2lobGtXL21rOCtKVmExUlpUR0ZCUHpEY3U4WWIvQUd2d3JEazFKWTlOaWtaVnMyS3VqL2FaZUpvRU9HWE9mTVZmbXlyZDZ3dEdrMHV4Z2xobXY3MjU4Mko1STN0cHhJc1NNY0FLSmxCWURHVG1tazBMbVhLdGJONmZlVzlhc3ZFVjNBSW9yeTN0bGpjTUFZMDhtWS84OHpoUUF2T0RsUm4zckNPcDZucFY5WTZiUHBGaE5INTdGeEFRVWlmYjFrUmx3QjdyZ0h0WE14cm9rdHJkV1g5aVRQTWJlVjJ1YmVkcGw2WlZpRktqci9DRGxjVkw0WFRTZE9tRVdvWGR1WGFKWWthRytEN2R4d1NFNnIxdzZrWXAvZ0VHK1Z0Mmw1TmJYNjNXNTdGWjZ4SnF0cEJiblNMTkNXeW90YnBFVmpqaDBLa25PZXVPU085Y25xOTdjMjJwd3hMYXpXUG1TUnl0SmMzVXZ5b2VXVGFweVRrZFIyclRsdlBCazExYmk0dmdMcUVFYjFSSWt5UG1WSEtZSFFjRWNWeGkrSU5FdW1pdFhNZ3RIRzh4U1hqTkdoVnR4Q3lNcGJBSFluQkZScHFaKzBiVHUzcTlHbGZUNUhUM1d0ZUF0ZHRuRnByMXBGY2hsV0szbVpoRUNXeXdqVUFCU1dKTy9IUGV1eHRHbXVrTUY5ZHJGQ0g0U0VTQ01yamFNa0RKSFlZNzE1UGIrR3JqVlh1YmNXK202aHA4VVR0YVd3V05aVlV0L3JGbWJiNWlnazhaRFY2UG9XazZONVN4b0xtRVdiNGVFWkJkRmJlQzVIeWhsOU1uaXRyUCtiUTdxOFl5NUhUZDdyM3I3ZWplbjVETFh3em92MlV4UVdGeHVhUlZsYVpwb2NuaFE2T1hPMXhuSzFYMHB0YjBuVW8wc0d1cDdjaUlUdkdtOUdraUozRmxCeXF1QmpJNzE2UkxJZE1sZTIzdnFGcklnajg4dWhraURER0RDQVN5OTl3SEZjcFozSnM3WjdWL0RPcFQyd2w4d1NpVUVwMitUQkJBNDZaRlo5dXBDaXJ4MXMxMVROdFk5Wmp2SkxpVWhJL3M0WXN3Ynl5N051TGZOeXJLRHRBSEhyVzhMblU0bmkrdzJNVU55dUczSWdCK3p0L2RLcnk0ejBKd0t3L0VPb1dzRHRPdDFaUENxNHVMWjNrTXJsMStVNFRPVzJuUGNZcnh5SHgzTm80dDBGckxEcHVKRlM1bW5ZaVFLTjRWU21XR094d2ZTbmE5emRSazVXaTIvUm5iTGJYYmFqc3Q1R3RyeTRpM0lKNEE4bThua1NQSWo0OUFveDF6VlUrRjVZc0MwdXAxaHVDVGRXcHVNcTBxa0t4SUg4T0JqZzg5RFZxWFg3UFViWFFKaEpiTzc1bVc3M05zUURDRldWd3AzRVl3eEJ4N1YxT3I2cnJFVnRkSkUzMnEyYVczU0h5WW1pa2drY2todDBRSVlyajd5bjYwWHRZWEp5T2FiYlZyTmRUQ3R0ZnNJSnByZTR0SnJka2lLbno3U01STUZZL3VodkdkeEF5T1FEMnExTG92Z1hXTGllSUtJREM2U1NRUlhMUnJOZ2ZLenhra2dqUDhKQnFub2w1cWQ5ZGFoTnA5ekpJc3U2R1dTL2h6QU1FNzAyeW5jVk9PTURpc1h4THAvaGhvNXcvZ3FPOXZZcmhFYjdJR1hJUHpLY3R0RFk2WUl5UlRTYUtoRnhhdTNIVnBYWDNiMk9tMVhWZE4wdThSMHRFaWpqRHh3Ymk3Tko4dUN1V0IrWGprazgxaTZOOFhOT1N3bG1sdEpJSVlKbWdkVlZWVzJ5TXJoK1ZLRWZkSjR6Z1U3KzNkUTFleWp0azB5MGp0eTRobXRtRHM5dUY0RG1NRlcyajFYTzNQTmVYWGVvYUxvOXpQL2FDWHRyOW9TUllGVUF3TWgrVVlIM0J0N0J3ZlUxbm8rNWhDcCs4dEdNbTNxbEhwYmZTelBWeDQzMEs0dC83T3ZyNXJoNTA4dFV1ME50TExGSXBiYXNuQ3NTRDN4N1VXOTU4UDN1ck9hQzVsMG01YTNDdmJyS3liMFB5cUhISUlIWUFidlUxOC9DSFRMcVNObjFVdkc1YVNTUENYVEtSa05oVDBkc2RCeGl1dTBIVXRKaGltdUp0V3ZQS1ZwQ2l2YnBHWkZCQ0hidUJKSElCeDBwdE5HU3JWR2sxRnV5cythKy9sb2UxeTZoYVdVbHpiUU5FN01xK1NKMDJCbVhsZDhoQVlnSGpQYnZUdGIxVHhkcDFxWkJvdWxKYnRMa3FKRlV4c3Fqa0hvMjQ5R0E3Y2lzSzA4Y2FaY3N0emJ6WGFmWlcybEpTUExPUUZPOE1BV0dlYzhDdEtTKzF5WFdYaFN3MG1UL1EzTU55MDc3SFpPQjNiQUdjZENQU2xHNzh4MDVYbE9La2s3MlY5RWh1bytJUEZmOWdlZm15SXVJNFF1R0dReEpCUWo1UVZZZmRQWGRWSHcvcU92U1gwOFdvMk0wVnFVWjFaVmxqOGtyODRCSnoxNkVZeWUxWXZpZUw0Z1FwYUxaMjFrdXlDQXlYRTBVUWlsdUc1WkkxQXpoUWVuV242SlByenh4bTkxWXl6MlRabUNYR3hmUUkwWXlXVnM5TVpIZXI1VWtYVWkwNmNwVHU3YXJkMjh6MHJVTEdXQ2ROUVc4c2RSRHUzbHhYSUcyTGVNYlkyQUdHejI2K3RjanBsanFzdW54RzV0YllKTnVra3RubUl1a1I4NVlNb0E1eGpnZld1T2krR2RrbjJxNE92M0hrU1FTN1kxdUZmeTNia2dFYldPekhVZGEzOUQwcWRmN09EZUlJcDVFaENXeG1rZ1djY1lJeXlrNWJwelJaMmEwQ29vM2hyZDZOSmIvajBKOVQ4UDJWZ0F1bVEzZHEwamJtTXJTUktRRkJ3QVE1T005ZWxGV1ovQzNpTjMyM01zdDNqbFV1SkhoTWF0MEcxV0J6anYwOUtLVnZRNTNCY3p2R1MxNks1bnlYMTVlMzk5UEpvL2x5MmFLc2t2T0drY1pWVko2ay9wV1lodmJxMnV5MmtRUWFnNUNSeng0M2xWR1N4SHA2a1ZyYS9jK01ZZFlXNDBxeWtlMlJ2M1Z1SFYvbVljczZucVNLZ3VQRWZpMnl1ZE52ZitFY25BWldONjZvRVJTUmpIUFB2U3R0YnNjbjFkTnk5NzFidHIzWmoyVnhCL2FkOHp5UE9zaXFzMGNDc25sbjBCY0FrKzRyU2sxTHdoYjIwbHJheFMyOTJYd3JYQVlySjdzellITlc5WjhhUVJyOWg4eU9lUVI3MjVPUXpkVitvcnhmeEJaM3Q1cHFSTEZQSklyaWNMdE80OGNBYnZ2ZXRUcjJNTDAxVWpDNjVYYThtcld1YzlxM3cvd0RFeGx0N3FLRjBsaWtabW5SOHJzWThBOU0rd3JwTFR3YnFkdHFodWJqdyt0N0k4WUN6OEhhMlNOekRJN1Y2M3BkMVpRaXl0bHY3cWE0ZTFEekc0Vm92SjJqT0NEd1Q2QVYxbHJmNnI5cTNHNHQyaDNBSThqSGM0SXlkdTNqajBxN3lUNk03L2JWT1hrazJyUmNWYmZsZXRyOXZJNEdOdkQwTnBBUnBTL01yanlJMUt5dTNmYXBQUVYxbjlzYUxjYVpiN3JxNHRJNVhBWUJnR3QxUVl4dDVQUGMxeUZ4NHAwaUhVNW9aNVkwTVpJU1hmOXhtUHJnbkpxSHhEZHo2amEvWXhwaTI4MXdxdmEzaWN4Z2pxenNveU4zcFdiV3A1OEhMUzFsZDd1TDE3bnIxb2JIU0xTT1MxMTZLYTEzWU1jcWhuVnBPakFqbkJQVUhwWGpQaUsvOEVhRmQzVnJmMjl1WkZpK2RReE9keDNqZ2REeitGVjlIMUxUOU5tanQ5YnM1MnVMa29ETkhHelJ0bkE4dFdQQ2c5U2E5STFqd3g0WmkxbGJxNjBYemJWTUZGMmx5MGg3TVJuSUZVN1g2L0k5T0NnNHdjMWFHbnd2OHIzME1MNGYzbmhXOTBkcjZ3MGc3b1p2SkNQTVpRV1lidHdMSEdLN0s1OFJYTm5xYWZhMHRwTFpvd1A4QVZsMkhxVGpnWTdtc0cydjlBdExxWkxhTk5PUUt6S3MwT3lKaUJ4Z0R1VDE3MXl0M2Z3VHhyYnZjUnhUWEJLTzBUWkc3cmxBZXFtaDZzenhGZEw0Sk5lODN2Zjd6MUMvMXZ3eWwzQ0xlZUV1aERsSGt6dnl1QVFUeXRQaW12SkxkdnNVOXhLcUx2TzFWeGt0a2pmd1NSMHJpYis0dDdmeW83dlFJdnRFV0R2VmZtZEdHM2U1R1JqMnIwSFRmRnVob0lMYUJyaHJhZHNKY3RFRVF2M1hMWXhTZWlXNG9SY3BjemZMSGZUVFViQjl1bGthTFVoSTIxektrb0J5M29tT1JqSGFwTG5XOUppdDdSZFFnMDN5aXpQRXNvQ2dxRHdUaitMUFdvOVE4VDJla2Y4ZUVFa3M0Ykx4Rjk2Qlg3akhRRHZYbituNmg0YWx2TnVJYk8rYVJTRWFNdEN3a09TUnY5ZmFrbHBldzFWaEdiakdTbEw3WG92TTlGc2JtenVMMXBGMHhyVjBHME9yQlkyVi9temdjTW82ZzFVOFE2d3N1blFRYWJySUc1MSswTXo3WFhKeGpJN04rbFhMNjEwYUE3cHRUVkpMaG1qU0V5QmtjSHFkbllkcXlZN2JXN0s2L2VMYncyeDJtSjRFTW0wamdBS1BYMHByYzY0eWNZdGFlcU9kdGJ2eFkycFNwSnArbDNkdkRDU3pCREt6REhFWlBISnFuYWFoNHlGb1Vmd3UvMloyRWtaaG5WU3JFOTE0T094cTllZUlmaUJEZUpEcDlsYnd5eXVmbGtBekl2OThLT2VuV3UwYlQ0TDlMTnpLc2wrckFUTGtxQXk5dHVlQm1tMXNYQ0RsRjh0NVdXelZyRU54SGZ3Mm9ZMmtlbXlsdzdXeC9lcVEvR0hBNmswN1JQQ09pMjBWekkrbUo1MGN6emtLcWtDUmh1eXVPQjZWbCtKYlR4Wk5xeW9kUmFDMU1XMFFRUWdFa24rS1UrbGRicEdteFFhRXNhK2JZZk00WjNVc1daKzdEbmRWYXErb0plKzFhNlN2cm9Odk5jdWRQOE4yMnFYWUdubFZaSjBqWHp6aG0rWHBuTmVUMkh4VjBlNWtoczRyUFVKSDh0eXNnakNlYUZiT2R2OE9PZ3IyclM3RFZJck1KSElianlvQ3VXUUZOd09SOG5YSjcxSUxMWFZ2NThhWFp5STBmenpaQ096a1pJVWRkdEpLTFROMUp1bW55eVRhMjNTMEtkdmRhbmR0RGNDMGszN1N5ZWFnSXpqMEJ6a2Q2ODkxbnczcDhrN1h6YWZwb3Vaa3pKSTBMRUt5ZDhBanIzTmJIaUZ0UXVyRzBoMHJVTFMwdU56SzBrc3BYeWdDT0Z4MU9hSUxmeERkYmJlKzFpeWRsWm95eHc0bTQ3OVB4Tk5lcGhMK0dsZHR5MHY4QTVubjl2cmR0Y3dLcDFTdzh3S3dSRVV3dGt0a0FBa2c0OUs2L1RyVHhWclQzYTZucU5pM2xwaTI4aUxPQmpHOXVnWWtkcTRMV2ZEMFZneVhzZHhwbHhCYnRsblJRaGpDbk9DVnlUa211bGt1VHJXaVFQb09vTERlWjNlWEV5N0hQVG5keU1ldEozVDBPV20yMjRTMjA4ci9jZDlxSGgyM2xpaGxPb0xGSnRSR2NFRExZSXdGQTRPSzhudlBoL29jdWlXYzhOdmV3WEcweGhFbS9lT1hPMHNHejkzMnJ6eTF1UEVkbGVpM25odU5SRWpiV25EbC9tRGNzRkhWUjZpdmZZZGR0N2ErRmpOZXhXczRURWU1TXFtZW5MZHoyRkdvbFVwdWNtbzh0MVpTVXQzMzhqR3ROUHNiYlNMVzNsMWlPT2FXUVJBeXluY3hpNEJCSFExNkRjM3N0cHAyMjk4MmVOanMyVzhtNW1BNlpCd1NHN211TmJUYmQ0MWtsdUZ1aUc2aFF5NytTRGc0STk4Vlp0a3ROVG1sanU3U2VGL2svZm94aVppdkF3ZWVCVGJpa1ZUbFpLMGRiV1R2ZS9xY3hvWThIenRkbTN1TG1EYXZ6dy9hZm1WaDZxM1RIdFhTdkRCWjN5Q010RXd4SmJTTXpGSlBWSGJrNUk2ZWxlTDMraitCNE5jVko1dnRNNGxjVC9NMFpUYjNKWDczNDE2OWJhZmN5Q3hTMjFlRkZpamNLOGloc2JrN2c5L1NrN1gzTVk2TmFlOXBmYi9NM3IrMzFJeHpURzRLK2NxbUtPVjhDSTVHUUdYcmtkQldLV3ViMlNTT2F4dDd0bElKVXZoZ3ZWVGs5amprMWVpdHRRdExhR0dXQjdxT1BZOGs0WWJKSlc2Z2h1UUs0SFcvaVpiYVZlWGR0SG9VODh5b2doanhuZ2RjQURPTTFHdXlWenFqRG5tbCtHK3BPMGVpVGZ1NHJPeGluTzhaR1gydDNDa25HNGVwcms3dTRTeElMVzEydzNCcEpMWk91ZUJoQjM1NmlyK2s2OTRrdmJPYSt1ZEh0REVjcDVJSVdWR2ZvQ01jY2V0WDlMOFoyb1JMQ0xRTDR6eEFiY3BoVUE2NVA4V2F0Y3lXeDVqb3hkUnQydEhlMnVsKzZOWkx5eDFEU3hhMnVvM0ZsY3psQ3BtR0pjQWtIZG5rTDlLdjJadDlCUzVhL25FYVNkSk9aRGorOE05ajNGVnIyNHVEZHVaUEM3dkswYUJwMVVDTUJqdUsrcElIZXNYVW1pMU9XQ3h2alBBLzNZUVlnNktDT0E3ZDhmblNScTdSYWRsZVB3L1B1ZXhDOFpiWjc0d3dhaEJDbm1MUEZJVDVhcU1rN1QzeFh6TG82YTNydW8zc2thTHRXNWFXMWFhTlE2SzU5RDB6WFplRXZDV3Q2UmRTK1hxankySE8rTkpQbEhyOHZQYnRYZWF2cDFtbDFGZlJUQStic25XMlg1WkpBdnloZzNYQW8wMU91Y1ZPRjQ3SjZ1MW42b3RhbzJvMmtDS2JWcEF3eElCSnNJQTZCY2RENmV0ZVVYRjVLTlV1SWRTaGVDd21SSkFyeUF4bkE1QmJISHVQV3ZRZFc4WlJUaUMwc05QYTd1WTBPNVplUmtkVmtJNlk3VnkrcHk2ekY0YWt1YnV5UklTRmxmaFhqY0J1Z3gvZDdVb3J5M09LY3RXb3B6VzZlNzBHbnhINGIwM1N6ZFJTUnp3UlhTSklvYjk0RVBBWERZK1gzcm9kWTFxYzJGdTcyYnRDZVRMYklybEVQUmxKL2k1cmg0TGp3aFBaU1hsekZBUktYVTVpeUFrbkdUanVLN1hTOUEwODZZd3M5VlJJRWNoSTFKMjRBd0R1UFUwckpkOXlWSzFPeVR1cnRyVHAwTXExMFhWclFUbUpXdnJhNFhmR3BVTEljcUFOL3Y5S3diYVMzMDdiWnlrUXhsZ2wwazdoeWpnYmh0Qjc0NlZ6K1pEYXJZMjE5TnA4OXZkSzBqTzdPR0grNy9oVlR4YnFqM0NRMlY3YWVkTkd5RjNpNU1xRTh0THVBT1JqZzFhVFp5dzVKUFJ0TnJWV3RZOXB0N25SZkVSUzR0YllSelcwZ1F5T0FkMFErOFFoeU53UDQxWjhSK1hKY1FXODFySThMSUhoa2habGtVb09yRDAvSGl2QXJIVU5GMVcrUDlsYWpkYWJlUk9kcktSOW5ZS1A0eHhYcFVtbytKdE0reEpkUEZxaWtHNSsxeGh0a1htSEJVNDY1OUtTWE50clk5Tlg1Slg5MmYyazFaMjZhZWhTOFI2bm8rc2FSWjI3UVdWNWRRdWtnazNlWVJqZ3h1WDV6WGtGcy93QVF2RE9zYWhhcHBVZHhiWFlTNGp0aU1vd3prZVNlbVJucFgxMG5oL1JMeUQ3WkRaMjFzSkZXVXRIRU1zZ0hJUGMvenJnSXRRc2RZaGUyVFU3ZVdTMHVoNUpSWFY0RVVZNm5vYXFNbGF6UjFScVZLVHFPU2pVaktLU1RXMnE5Q2pwR3RhdmU2WGNqV05IazBxMVdVTG1UZDVra2g1K1hBT01kelUwR24yYzJwcGY2UnFKYWUwTE02WE1URlZCNjdNalBQU3R1THhMcFNXeGh1dGZhYVNPWEJRcUFvYkdBTWR4NzE2RmV3YW1iYU9iVC9JbHZKWWxVWk94TWtaQlBYTlpObk5KUWxVdkdDU1Zta3RiZW1yT08xdWFDUzlTQXlRYWU3MnpMSkNvNElZWjNnanArTllDZUVyTFZyVEoxZHBIaElDNzVNUkRiOHBVZ1Z5YzFocnFhcGNYR3F5V0ZwcUxFb3V4OXdZZENHN2MxNmpySGh1emF6aXVsVnBJSTdaZzhOdUFFa1poa25IVWttaXk2c3g1ZWF0VXZIVk96cyttMmxqaE5UOE42OUhiUngyRVU1K3l5bGhNN2dnZzhIM3d2VVZ6a091K01iRzFuRi9FOTFaZWJ0SlJDU2pwMEpCN0gxNlY1OUI0MnZ0QjFXT1dIN2FOMzNyZWJoSXNIR01ITzdJcjZGMEh4WmZhcjVSaGdqaGVXYkVvU011Tmc1R004RFBjMFdrdDFzVzROT0VuQnhVbFpiYmVUTWc2dm9PcStUY3VoTFJxVWFKcmJ6SGJQWUU1Q2o2YzEyMDJoYVBNRU56cDlyYUtrMGFvWGZCZE1aSkhPUmpPSzZIUzdTNFR4UExPVldLTHl5TjR3dTk4OU1BWUdQMXJsUEVWenIxanJrMHphWXQ1RWpoL05lSkNBbU9xblBwMXBhOUMvZWpCdVMrM2E2WFR1YlY1cE9nUjZaYVBhMjhWekpiNVJZR2tCREx1eUdCYzg0clYwNjJodDlLazhtelNlNGhsRDRSZ3dVc2VUanJ3T1BhdUUwclV2Qi9pbUR5cnExVzJ1dDdJaFFFYm96emhDT21hN2U3dEk3QTJ5UXpSaEhnUkFBU3JNb09QbVlkOGZyVnR1eXVkU2NiT1NVYld0ZGIvaWF0cGZwRG9VL25hTE5DbHR1TVJqbVVGbEp5U01IT0IzRmM3SXFYdW14UGJ0QzBjd1dXR1J1UXJPY0VrcVJ6azFyWGw3Yngya2tqNmNQTGdpZnk1SEljc3A0STlEWEY2WnFuZy95b3BMWm5PMkZROGFEaU1PYy9LQnhuUGIwb1dwZk1yS0xrdElwYTZIbUV2eEJ1OU0xbTJqdU5BYzJhUDVTVHdIYzdzQVNYejFaZStLOVJUeHg0Q3VMb0pkbUozbGtCSlpTNmJNZmViZG5BSjYxRmR4MnRsWkxlUjM4MDhVVTMzWTFXTWlNOVFvUFFudmlwN0h4WDRXOHVPZGJlS1dTSmlpeVNxcWIxWUg1WDI5Y2VocXRIMFluVnB4VnBjcWFXcjNUODliamRNOGE2VmQzRndzRjFKR3N6LzZOQkdxSWRzZkJVRVk0UHZTNjJmRXhtaGdmVVlKN1lONW9VODNVTDV5b0lRNElIVDNyZ2JyeFA0YTFXTzRTMnNoTTBLdDVUZ0tvRGtqaFFQNFIvS3U0MHYvQUlTQllYdVdzYkdjQXE3S0ZJbXpqakRkQ1BlbmZxWWUwbStlSGJkNnUzcWpmZytJTncrbTNFVTZOSGNCL3dCemIzTUJpZWNkTUJoMFQzTmN0RjRqKzBDYVJicTZsaUdGdWJTTGRNOFV5aklVbmh0bnJqclhBWGZqTHh0cFNqN1hwUDJ0cmlWL0tpWWI4Sm5sTnk5ZmF0WFc5YTFHMGpFMHRqTHA4VjFhL3ZWOHZkc1lISy9PbkpJSHJTODJkUExXcUtLaTNKNjJYWFE5TzhqUjlaQmoxQ0tCVlZneE1ad3g3cTJ4eHhqT0RXSG9PbmFacCtyWGRvbG90eVltbVpaeUdkWXdSd29kOFl6NkRnVjRwYmVKTFhVTllhLzB2UnJpN2x1bE1jd0tsVVFSamtxeDRBeDJydGw4UzJxV3BnMU43dTF0cFl0Z2lpZ0pJSTdod1RnZlNwKyt4bFVwVmFjMUdwUjVaZWFzMmVsNnZwZGxmK0dwV3U1MGE2S01xUjNqYmdxam41R1RuQS9oelhpWGdPempzZFJQbVdHMmRGS2VkNSsrRmdPR2pHU2VvN2RjMTZZbXJhVmJKQkJEcFY1Y1FoVWZQelpja1pYWWNmTitPTUd0V1IvaDkvcFl1YmRJWFlxd2xNWmpkcENkNHlPN0R2VjdxMWlmaWpGUm5HTGFWOTlXdk04MzFHVHd6cDdNZFIwUzV1N2VPVGRCa2t0RXhiRzVHSXhnZWhOYitrZUpyUzh1YnpUTlFzNDlzMll3R2lKSmpJK1Y4amduMXhYcEZwZTZMQnA1MjNjTWtjMXdSSEtybGc3c2M4THlNODR4V0ZvK3QyME1Wek1semE2akhITVQ1VWFpSjRvMlBRaHU1UFUxbnJmY1VZTlJoSG5TM2ZwYzQ3Ujcvd0FIK0Y5UW10UThsbmJ1aVBJVnQ5OExuZHR6dXp1NHozNlZpZkV2VHZERFhlbTNzR3J5b1pFQ3dtR1JrREJlaHlBUm5QVDFycDdieFg0UXZrbmd2YlpvZ3dsVm1kOFBHR09RTjJPVkp4V2F1ZytGNTVwb0xuV3ovWmNvQWl0SFpjUnlMMFpaQjB3ZVJWMjJ1ZENxUlgyK3J1NzYzZnFiNzNWclA0Yml1Ym1CWkxpTmZLTWwwQW1WSTZzVzVaVG5tc1B3bC9hcXczYXJabVcwWnl0d0labGtqVWVvVVlJSFRGZGJhK0FmRGQvb0t3VDNkemRSSVR0TFRxMjFXN0J4MXhqdlNybzZhV1lZYldTNit6eU1sdTl6R3lzWXdwM0tzdUIwUFFHaGJmb2M4YU5uR1d0MHRHdXVtNHEybmg5NzI3dFRxZW9hZmRRQ01DTmc2YjkvM1FYT1FRVHh4VjN4R2w1SDRhZ1c5dHBaWlczd1FTUUZpSWkvQWZqamNQV3V0dFdrdXByeERkUVhTSkdOZ0trT0N2VGNlQitGY3hydXUzbWw2RElxTGNXY0VjcnV6S1FRR1k5VTNaK1VrOFVrMDJicFJ0UGxWbFo3SzkzK1FsbG8vaUdMVDdkZFFLM2tjYXE4ZHlzeGpreEhoZ1d6d2M5Q0s0dlhkWDFxN3Vyd1dlbU9kTjJ4Q2R2TU1YbUZPQ3BKd2ZsQjRIZnJVTnZwTS9pRlpwZE44UlhBbmlRTE1xeEJvaktwM2JpRGdBbjJycWxodnBiZVMyZTVnbHVZb0FDM2xFeGxoajVDbVR5ZTlOTlhNbkZ4aGVMMGxmYzRTYlFQRVMyZG15M3NZaFdTVmx0cHkwbTZPVTR4S1BZY0R0V3JxMTlxRnZheHJvMDlvazF2R2kzTnRFQVk1TXRqTEtSamQ3Q3UwaFhWL3NGN0JxS041c1VnTWNsZ3VXV0VqY3UvY2Z2RWRoV1hQYVF6UDVzV3NUUm9yRS92bDhsd0d3Y1lmaGlCMXB1elpsS25OTFJyUkxjNUM1MVRXSklJQmMzVU93b3p5dWxrQXJvT2M1NU9FNlpOVTlQOFFhVXMwbW54V1U5a1ZJUjBuQkVFakE1OHpkL2V4emdWNmpIcHR6YXd6R2E0UzlBVStXaVNpUDhBZHI2RHBuSDRWenVuK0ovQ2x2ZVN4V0VrekVFdkxHem5LdXd3ZnZESEhRZTFLNnUwY3lwcFNsS2JzN0w1RzFkNmRjeVdiUzNrTnUzbGt1QUpzRkFmdXRrWnlvUGI4NitmUDdHc3RRdmY5TjBPMHVHR1dpQXZtVXR6ajVGR01FOVJYdHIrTmJHL3VFaWpnRVZ2RTZNRmxoSmVTWG9WUmh3U085ZE5kWE1sekRFOGRuWnRQMWpTYUlySmtBbFFXWDFJNzBhcEc5MTdiOTNPelhWWHY5NlBHL0U5M3FscnBOcW1tNnBHdHk5eUlMaU81WXkrU0NNb21UZ0xqcGs5YTVleTFyeC9aVzF0ZVhHc3dMYUljeXdRSmdoVkJHQ1RrQU1SalBTdm95NnRMdVd6dFcxWFNZSm83aEZXWjQ1TnNhai9BS2JNT1RnOU9hNXZVTFZvanFFdjlqTmJSN1k0dnNqR0krYUJnWlVrNTJBY2c5NnBlYTFLcVRxUWh5eDVJcnE1UjExODNzYzE0TitJL2gvVzVvWTdwNHJhR0FLK3hDQXNiazlYYzh0NzE5R2EyMERXc0txMExJQ3Nua3F3RzVCL2NLbk8wOTY4RnR2QWZoR3d1YlpMblJiR2VLNGpMcElKR1ZwV2ZnN3R2eWdqc09sWjdEd0Y0WWUvbHQ3alUydkZpTnZ2ZmZNa01iOUlrRERCNE9LWHV0NzZkajBsN0swK1c5bTFaU3MzcjAwL0E5RGttMCsrTnhEYWFoZlcxeXJxZkxaQXlGaHdXUXQxR1B3cm1MblFKRWxsWWF6ZE1zRXpTeWJFRVlZa1kzSU9NQTU1L1N1ZXU5YjBIVGRDVzNodUw2eDhpRGFsekpiUHZ6S001SkdkM1A4QUQwRllXaHJxcTJYa3k2bEpleDczZnp6Z0dOV0dRckl4RzVHL1FWbmJVODJxb0tON3B1OWtsZXo2K2gzcWFCclZuWk8xaHE5N3UrMGJRcGxhUkkyUDhaRDU0QTZqcDNyV2lzQzl2djF5K3RaNXhLRkR4d2gvTWNqZ3U2ajV1QnlLOE04SkhYTDdXTHl5dUliMlNLV09VUlN6TmdNRlhLN1dHRGxjZGEraGJhSFVkSnNydWNUU3N2a294aWtRTUkySStiQkdNNVBRMUwwc0tFazNQbTFXN2ZOZGJYT2I4SldVWTAySzhXR0FiTHR5a1NEZklOcDV3VzZLTy9wVTJvcDRXdm1sanVZRDV2bmxYZ215T1dPR2szRThBOVFldFkxanIrblhMWHR0RnFGeFlTUnVIU0tKRWRnc1lPZTN5N3gxSHJYbldxVzJneW9sM0Q0bFdCaXBMdGMyN0VMa0Rhb3ozUHAwclJhOXpsVGZKRlFVVzI5M3JxOW4zMVBWUHRPbjZIcURXMXBmd3ZhbTRDM0JrbWZDQlFUOGprSGordGVIYXg0ODErNXZ2SnRZTmkyMTVJUTRaVkVzSnh0M3V2QjIrdmV2Y3RGMS9UNTdXR3puMDdNNkFYQzNCZ1R5ajBKd1BWaDNyZXNOTHNMaTF2WVpkQXQ0TGlXUjNWVlFQdUV2QklZRDVTY2QrOVNvcE83T3VrN3BxOFh6TFJhMlhrZWUzMXl0K1hrdHZFSTB1YTNaNTdoWGlZcE1yZ0Q5ekllQ282ZTljamRlSU5aK3dKYjJ3VjVoSXN5T2tvM3pQOXdxd3prRWprQ3ZicnVHNjAreUF0Tklsbmh0a1JWbUNoblJlL3lqcjA1N1ZSMDd4SEhjMjh0MTlranQ3Z1NuRFNJclpRREdXSFFFSEF4MW9Yb1p5VGkwbTRxeWQ5UGkvSWQ0ZTFEVUJMaWFLNEYyMXVxM0tKaVJjQTdUbFQvSWRhNS9VOU8xYVcydWJGcnlHTlhJRytlM0Vha2J3eWlRQUU4WTZZL0d1RHQ5UjhVNnRmeUpkM2ttbnN5R1MyTGxZNHdCeUZWVTdIOUs5bmxqOFV4Mmx6STQwL1Y1TnlsSlVtOHFabzJBQlJXWW5CT09jVnJ0c1ZGOHlhdjhNdEdubzB6eUhWTk04ZmFZNW5uMVcxaHRJR0FXUVJoWkNoSVVBN1NUam5qMHJWdE5OOFZycDk5YndmWUhhMmxZdktRMHJNSHh0WlZQVW51ZnhGWWVvK0t0ZmoxRm9aYkUyMGNUeHZOa3BMeE14d3l2a1o5Q0FlSzlHMDN4cEZkV056L29WNUZCR1kvT25TUlRnSzJRM2xrWkl6MXhVTmVSZzR4VlJLVVVrbHBvdGRQSTgwaVBpUDhBMHVNU2FXMFJQellZbUFpUDcyUE1CQUI5TWZRMTJPbWF0cEowVkxxNlZiYzJTNGlOc3pNWVd6OHJJZUNRUng2R3RsYldPL3Q3cWV3MUtlUjdlWm96NWxwR1YyTWNsU3krcDV5SzV5THd0NGRlNW4xSzQxR0dBaHpETkdMa2JDZUQvcStCaGdjMEt5UTNUOTczYmFYYVhSK1dyUFF2K0VxMGx2TThqeUxhRzlqejUwY1NvZk5ZWmZjTThNMzA2NTVyakxYdzc4UExtWVRRYWFaSm1EczkyRW5LcklySEtOMUczMXJiVFd2RFQzSzJJMG1DL3RvUWlvOEorWEFQTFNlWUI4eWpvUVRtdlViTzgxbUp6UEhOYWp6QVhXSUJvMUNFWVZBY0FvVHh6elR2N3AzVTUxRzJwVkZkNk95Nk04ci9BTEQxR1RVcElJdE90emJGRVZ4STVQbUFjallWNVVaNEEvT3RtMzhNVDZhckt1bVFxcnFHazNLWmdwKzcvRVRqajczcjJOVzlTMWJVcnZSSHROUHVVZzFReXB0ODltVUVxY2xYSjRPY1l6M3JrSnRJVzd1REhxdXVyYlgwUVZua3RsUkNXejBYNXR5TU1jOWpRbm9aS05CSzhKcDNsYjA3bC9XZGUxVzZ1ckN3U3h0NUxkUUE4c001VkgyTU1CZURzRERxR3EvcmVnMlQzZjJaZFVuMHk4bFh6RVNFQ2RVS2dFS0JqN21PNTYxelZ4WlFhTHFWMEgxVzQ4cTVpS3RKY3Y1d2QyK1lsdG82bnFLNUMydC9FbWx6Q1RUN3l5azA1ekZHazNsczdMemxRNTQrVWs4Z1ZWL2QwM0hlK3MxRnVMM2ZhUGtla3dMOFM3Q0NlV2ZVN0dTR0ZncXN5T0kzM0VaYjVPY0RQcFhVWGZpTjdHV0tDUkE1dVlTa3cyczRZbzJGK2M4cng2MWlSNmhya042MGNldVFRMjF3aEtSTEdDdHdDTUhibjd1R3J4Zlh0SDhaYVRjV2VxYWJlM0dveFNHUVQyNnM4TXNRazZEeStjaGZYdFNWMit6TktjNXlrMVRseXZsZTdTMVhSWDAxUFh0VDFCeExxTnEyazI0dVVSWjRGTWd4S0dJSlVJeDVQR1Rpc0swOFNDemcxU0I5Sm10bFNRTklmS0xzMEI1d1ZRRUNQSHJ6WG9XbmhMOTdlNXViZFRjL1o0MmlSb3d4UnNmTUNTUitkYzVmM0d0YXBZaTNzN1I1SHQyWlpveXZrWlk4QThPQ1ZBemtkYW03Mk1YQjJ2ZHR2Ulczc2NTa3VrYTVaM0thUmN6VzB0M0c2Z1BINW9janF5WkJ4aGVPT01WcHgyRnJEcG1ud2FuY0hVekdFU2JFTGZ1MGI3cEFJQjRZYzFocHBHbjJtbTJscHA5ek1iaTNEelFKSGdKTEl3NWVOajNHQ0FBYTUvVjljbHUxaGx1eGNyQThSODF2TzN1R1hqRW0wZ2dqcUt0TFRSbkhLZnM1Y3FqZlhUUlhQVGRVOFJhYjRYaDNXM2grV1dHWm5JbnRGMnRGdTV4SU1aQzhjWjYxRlphL3BldFhiUkhSYmViN3pXOGtqbHhJQXVkekRHQVMzSHFLOFVuOGJlSElvYmRrbHZMdnpnMitWWkdUQ3JnYmlNZHNkRHpYZWFCOFFkTjFGcG8wczR0aFpraFVrcWRvNEFMYzhOV04ybnEzZTUxeWxYalRpNTBIQ01YWnRwdGI5cmFIc2ZoSzZ0azB4b2J1SzFOdzVjeHdpUXdpRmVuN2p6QVRqdmoxN1U3VlZsanRveHFXbnhlUU5tNloybFhLRHBrazhrOXdRT2E4VXZOUjB2UzVSSkJvc1NQSkYrL3QzbE1wVmxiSkNLMlNSbm5JcnFZZmlwZlhCMUZvbXRKeEZIRzVTNGplQlFGNEIvZVk0SjZmcFdtdXBkT3JMa2NYZHBPeWNZNmE5eXI0bDhJNmRmWFVVbWxhVmVYQVZ2TFlvd3RsQUNibFJkeEh6ZjNSM3FHVFc3M1Q3SmJxVFRybEZzWWJmejBkQXJyRys0K1lZbEFWZ0NPV0lyZXN2RStyWCtvR3gvc3k0MDY2OGt6TFA5blhFaEkvNVpCdUdKN0VuaXFsajRmOFd5NmhKZVhGN2FNVmdXT2RwR2JmSUNlQktvSnh0emc0cGRCT0xWMnVhOTFvbmJUZlRleDUxcU91NlRyZW9XOEVZdWJPM3YxTU4zSXlReGpjb3loV0hPUVFmenIwUFRmaDlEWmFhMTVOcWJtUmZKQzNGdXJSTEdoSDMrRG5hMmM0eCtOVk5SK0grbDNreHV0WGhRa1JCZnRNVW9UeThIYXArWDFIcU1tdG13VHhTOTVZcDRYdU5NbXM3U0h5bVpuTFRFS2NsWmQvYnNvNjA5RmRkeldDaE9LOTEzYTFUV3FmazdoNGo4VmFocE9tVHd2ZUNGeDVaUzZlRmdwRDhESnoxWW41U2Z4clBUVy9EbWk2THBjelhqVHMxeWlLc1RRcThlLzVpV3dNa0FkK2grdGRYY1d1bnRxY3R2cTB0a29tVHppaGJ6RUJ6eVAzdlVlZzdIcFhLZU12aDk0Vk50TmR6dzNFa0NJSFc0aXgwQTVZQkFEN0VmbFUzUzAyTXFVUGZibnpOSnZzMnRyV1QvelBVYjlKVTArV2NRV2x4WVRrckRKR200NVk1QWNuS2puR01rYzF3Y1dyNnhjYXBibTVzUWx2TkdZdnRiR0oxTFJIb3hsSEIvMlRrNTZWeVBodlRKbG5YN0JOcWtObmRlYTdwQVAzUmpQQ2pZL1BHTTg4a2NWMkxSMkdreEphcGVXNGNzMHJReXFWakJjNFkrV2dLNEErNk04SHJXbWxsM0NVNmNvcVNrN0xkYmFucUYyMmp3UndMYkc3R1I1N0MyRVpBd1FNeWNFRTkrSzgxMVNmeGlzc056Yng2VmYyTXM0ZWRaSVZqWlFPam5IRFlCNy9BSlZ6RS9pQ0d4dWxzYnEzbGpnbGN2RzhNd1pHakkya3J0SVlBWjVIWE5lcVRyTzFucDc2Yk1MbXpWVzh1Q1ZjU3hzdlFzNUs3aGtjN2htcGQwMTVtOU9zNUo2SkpMWmVZdDNhVzR0REpPWEhsdElyUEZENWpFdnlDck5obFZUMkdSMnhYamMzaUR3RXVwMjJsNmk4b3Rianl4aVNSblVTZzhFN2lOcTU2akZYTmRQaUdHMENDT1NlMGtTUVhnaVF6U1c4b0lac0hJQkgwNEZlT1cvZ08ybmhqdVk3Ry9ublJrWXE3ckVKV2FUR01PV0hROGpqSTVxbGUrcEVYU2RTSFBkSzJsbHEzNXQ3STludjlPMFRRTmFNenRiWE1NcmJsa21uK1FSajVOdUJsbVlnZW1EaW83ZUh3TGVUZVpFV2hkbGtMUERJNkxFSStDMkpHK1VIUDRpdGg3dldyQzFzRGJhTGMyOE52KzdqbWl0dlAzQ1VsdkxDeW5PVUk1TlVaazhKM1VieVQ2TEhxRnpKdVh6SlF5U0lTdVBNMnQ5N25nb0tsTHpPZGV6VzdjVTlXMzZiQnFtazMvazZRbWw2MEFFZ0dGODl0MHJBbDh4ZzR5ekRwdU9NVms2YnFlcVR6M3NNMmd6WDFzWVdrUnBzSXlNcEI4bDlwMmdBOGp0Vy9Ebyt0WGNObFpFMmx2YVFxREhOY1d1NGh0dnpMQ1ZZakk2N1JnZ1V5QjcrMnQ1NWpwY0Z4WkpGSjlxakRwS3U4REt1cURrN2pna0hxQ085TnhYTTlqWGxrM0cwTkhxL0l4TDM0Z3huVlpZcGRJV1lBUmg5MGJNWVpISHlpUjlqRGovOVZSeVJlSDVQSk0zbTNXQzBnczRyVkpFQmpHQW9sQzhLZTZrVms2eDhVTkZMYllCSUw2U0pESWpTTkdWWkFNSmxkdnlZNkVIajJGZDU0VzhVMm1yeTNSZTVGdk9zU29xUjNMdUhMSGI4NnY4QUtUMjk2ZHBMdWFWS1VsS0xhbXJxNmI2MzZyWTR1NjhkeHdhZmJ0b0hoK05iaGk3VzRJU01HVlFOMnhCZ044dlU4bk5WdEwxVFVibTV1WjlTOE9RTkhQUHVubHRpdm1Rc3crWHpQTEc3YXg3bjZWN1FZWXJDU1dJZllJTU1tSVhUYXVHK1V0SHRVTWpkdU1nVlJzdEZhT1psdGRjaFpvNDVHRHJOaGxEZk5tWGdid0Q2ODgwS3pWOWJpbkp0S1BJcFhidmY0bjA3Mi9BSjdYdzFyZG5LdDNhUnhCeWpUM0NTL3Z4R0I4Z2JnOEE4Y2pvYTVkUEFtcGFSYlcrb1dXdHdwQ21WbFdjSzZHTUQ1UnZYR0ZBUFBISFd1dTF4OUptVklYbnNieThFZUJjc1VWUThlQ0FEdURzaDlhOGYxWmJxRzVnTW1tU2gzdGpjUExZczJIakdRNUxaS3R4MVVETlNwSXpwdXo1WkpOMjBzbGUrMXk1NGd0VmhqMG9yck9ud3pTaVNXNmduRWM4TWp0eUpGUURBVXFNRHBtcldrZjhBQ1UzOWxmM09sK0w3WXFyeG1LMGpzWFZWT1BueUdadGdIVUtPTTAvU1BCZmc2N3Q0WmJpMENXOGVGdC9QeEZMR1NOdXdsSEJLSGpPUm10ZUs3djhBU212b3ROMDJXUzJobXlSYjQzUm5Hd3NBQmxsUFVuSjk2dTl2TTYzVWpUZ25GSnA5T1NOL1ZHdHF1amVMOVFzN0Y5SzFXT0sra2oyUzNFaUxDOFg5N2c1S2o5SzRpUHd2OFdiUXNzV3AyOTlhdEYrOFJMcFpKR2ZvKzFYd05ybm5IYjFyc2RJOGNXOHVzR0FhZXN0LzVUckt6b0xWTnZHQkx2emxobmpwWFpheEVsM3BLSkI0WXRyOTR6amJIS3NUeG5JNU83YmtlNHBkRmRIUkdjZVJ4NUUyMTFqWjYyNnM0dlJOUHRiUFVyT2U2MDlvTlJ0MktoRW1NQUJaY1krVmlyQXFNcXBPZmF0RHhBbmh5NFJwWHNiTzZ1RzVrSG1zSlpNTUNzaUNSUUR4OTRrOUs2Z1QrSVRwMzJpSFI3SzN1MDJ4UlJ6M0NNR0F5Zm00SUJRRGc1ejJyNTM4UVEvRVRYb2Jzd2pUSXd5Ym50WUpoNWpibHhuSXlEbkhIT2FTYnZZd2hCMmhGU2pGWDA1dEVqMkJmRldnd2FTSDAyVVRXd21WR0tRQ1V4eU1jS3BYT1Z6emh1Yyt0V1d1dEdsMUZMdlZOWElXUlJHbG9adklVc2VvY29TQUIyT0Fmclh6cjhNOUExN3d2cWNiTWx6UEhjd3UwelJJazBEYlYvMWZYSllFOEgxcmE4UjZYb2VzNmxheFQ2bERiNGRCdGpVeHUvT2ZNQnlWRFkrVXFjWUlwV1NlOS9NZGRVWVYrUlZ1ZW4vTWxwYnZZK2pQN1lUU3AwdHpyRnhleC9hRlpVRUFtY1F1TWlNdU1EWUIzOWF5OVQ4T1crdWE1RHFNb2EyZTBtQVNaYmgwOHlFcndDaFVqY1BiSXJsZEJrMUsxODYxMHpVYmE3alcyYmxsSTh6SHk4cmpPVDNIUEhTdW91dkV2aUt5czVJOVUwMlZZTmlyNTFsSDlwRy9HUVZTVlZKT09DUnhuclJmWFRzWjBKVGszYVRWM2F5MTE3THlLK3ArRHZGRWM4Y3R0ZHBQR0dkbFI1dkozWkdOdTRydE9RTURiZzRybXJTOTFxNnVWaGtzSkVqaG1DU2lYRW9jUnFma1pYNEtFL3hjY1Z1eC9FUzZON2FXeVdqd3BLa01Va3dzM0VHWFB5aHdUaFg5ZjRRYWloMDNWYnE1bnVXczVJN3Y3VXp3cGNiU0VWUnRFU0FFZktlY0U4NHFXck5JenJ4cHRSY2JwM3Y2M0xta3dMTFpTVEpwbWxJMFRTeUxMYUw1c2hra3lycVZRRGdqSXdUelhKWCtzVDNHdFdXbXdhWTRndGw0ajhxSUVQa1lPeklNWUJPVDNOZDNiK0dJa21rdVk1aFl5eVB2bGtFUkpZNElZWURDTW5KR0dJNDlLNDdWUERldjJna2xPclBkeExDKzV2c3dFbmJhR2NqSndPZU9QV3FkMjdYUlUrZHdUZmJiWDlESXNiZjR0MkYxSkszaHpUbnM1WTM4N0x3Z3hvNU9BNVRCd1IweUs5anQvRDFrMFlGN2NmWldtaFZvYmRKd3J4N0JzQWpadUFtUDRRTUd2RDlOR2tXTmlidVh4REk4aXI1Y2d3WW8vbmJJamtHNG9XSkdWQnhXK0x6VHRjMDJTM2cxZnpaMW1qazhxNTJSdEZHbzVMTkh1NDdxUmdpcWFYUTNrNGMwYlJTU1dsbm85ZDlUYW0xelRMKytOaEZQY1hRZ2trWi9LeHVqRzBiQUE3RXZnanFPUHBWUzQ4QmhkVSszMksya1VyMkpWSTcwdTBqdWNvN3R5eTdoMUI2NXgxcmZoMHFMVGdrZDNiSk5CczN4M0x1eGtpZGprTEhOZ05rZGpqSHJYTEpxK3ZXOTFMUFoyYWlOVUVqeEIxa3VBVTRMYjQyd3dJNUhBSnBKdE14OXJ5M2JXc3RHdkloMHp3enE5akJGRnFPcDNCdHJZbVdSNUZpTXFDVHVwWEpFZWZvS2ZyZmk3d21iSVd0enFFRUVqS2lCRmsyTnRjN3R3ZUZTQ3pEcUJ4V3RkYXBjM2VxU2ZZZE11N2d0c1c0bEVySnNESnVBWkNTQ1c3cmpuMHFsNGx1TEY1TGVCTktzbGFWV2xHK05JUkhuNWR5N1FTMk1jcjFxM0s2Mkw5cERXVnIzWFN5ditCcTZTSVpWamF3OFdNaUpHMGJmMm15emx0cmNZWUhBSzlNWjZVVjV2YWFiNFhZelcxdERxME1VTER6QXRySXc4MGo1aUZKREx1OTZLUGRIN09MYmR1dlZ0UDdpL2RhdjQ1dXZzY09sV2F4eDdRN1RvMjRNdjhKUGZQdFc3cU9zZUw5TzBTVzQxWFJ6ZXhOeTNscVVmY2U1QlAzYTVhT1kydDFiUWkvZUtRTUZVUWpNTzUreHgwOWpYc2VwVHpMR2hhN2VaTjVFcU9kNDJEKzZSNitsUzFxdER4Nk0xS2ttK2IzZDEzWG1lQWVHcFBFVnlJNVYwRkVReVNMaVFyODJmbUdXUE9SMnhYcVdpWGx6cVJrZTZpZUthQU5FcUFDVGRKamdwanFRS2thYndkTFoyc2xuZFMyOGxsSTdHT04vbWZkeWNoc25BNlZxYUExak5MZExwc015dkVDOEx1ZmttZHVvT01ZK3RTM3pNZkxUOXFrdVJYczFHTGIvQURGdjlUai9BTExkYjYybSsya29FVlZIenNlRkpQUmZwWEV4ZUU1bnVGZS91M3lvVDVGY1JBQWM4RG5QNFYwNTFpeG0xYTcwL1dZVmE0Y3JzaWlZNWovdWtuMStsTFphSFlhT3VvbWU5a2VLNllBUlRwdTJ1T1ZWRDFvaWxaM0thaktidTFaTHJvL21ZbDk0SXV4cVhuVzZXVnZBd0dWa1V5a3I2K3hydEwvV1k5RHRJV251WnJoWlB1aUtNTWlqMFkrMWM1cUw2dEpZcE5aWDRTV05oNWl1UUUyZzQ3ZjByRTEzVlpkR3QxdVliVlpEY1RBQXhqSTVITzllZVRTVGJzakRuU2RvUjNhdHFqQjAzNGc2ZnJOMWNGdFQzV2FPV0ludCtTNDUycmpnZTFlaGFWNGxqV09XV3lzNU56U0Fxek0yMVNlU1NXNHdCWGp1b2VJcmZVN0l3eFdxUXZjT3FTUnJCNWJESGNxSzdiVElJMk1VRmxBSkxjb3FsZ1dJM0RuNWczVDhLdVNTUnoxWnFOVzlOVGkyMmtwZTgvdnNkRnJuaGJ3NXJVcjZoZFhrcVFzR2FTUkhCVkNCZ2tEMFBldXowZ2VEN1U2ZTBMUTNFS2JGZzRCT3pQM3puMVBlc0EyMmsyZDE1RVYzQzd5T1BPaVE3Y0RHRGdkRG1vYjd3Um9tblJ4WEZsR3NuenE1QlppNFVOdUFVRDM3VkdtMTlUMElTbnlOdFJiaTc3M1h5T3UxcnhMb3R0ck05cDVrM21SeWZNN0Q5MFF3KzdrZGNlbGVjM2V1V1Y2eVFhcGN1dmtUanlvNDR3Y0VqaG1JeHhYVDZCcDJqeFdzb2E3RTE1Sk5JMHhuSEkzSGNFQTZaR2VLeWhhVzBONTVhUlMzazZ5bVVQTGdvakR0eDFIdFFtay9RbXQ3VnlUNW8yZjJlajlSMWpaMjBhUk41OGM2amR2dVpBZDVCUHpFaGNBRGpIdldycm1uczdXOGtSczdtM1locFMrNVhqVWROaDdZTmRKcG1vNnMrbnVMelRsRVlaaXV3QmNqMlUrdFlrM2lDelcxbWE1QjAxb2NZRWlBcVloMCt0Q2ttelNNYWJwMmVsKzZ0WTVhSFFQRWR1NHVZTFN3bEt1NVh6Wk43SHVEdVBJOTY2N1RyKzV1VERMZmhMQ1lnNFdLVGNvQ0gxUEZjaHAzaVhUeWJ3V1JTOWlZK2I1cEpYcjFWVndlS3pFMWV6bHZiRnJreXRheXh5aUJKSU5rWmxQcXc1d093bzBaVFVJYVJmVjMzM1I2bHAxOXBlcldUd1dVazdTUlNHTjduQURqdndUeVI2ZHF2M2wyTkYrMVQ1bG1qVkVjdW9HNDQ3TmdkdTljNHNVbHdrb2kwdFlXdDBVbzZmdTQ4Z1p3Q2VhbGswblc5VjA2QlZ1bHRKekgvcENyOC8zK1F1YVBYWTZJVG1sb201VzB0b1plaC9FWFNOVHQyam1zeThBV1NlV1ptOHNram5Zb1BXbk5lYTFMWW0vMGJVV21nSUxwYTNDWlpXSTRBWTl2clZqVi9CVXlXa0RDTU1ZOFNGMVZXMjdCeUFwN0dzKzU4UUxiK0t0T3RaTEdTYUdhMkJaMVFoQXo4QlRqakhyVlB5S2Z0cjJrcmFhYTYvZWgrbGVMZFF1Q1lydExjU3lxRkxRU2tNcm51eEhBcmJYVXZFRitKYmFHN2pzcE4rTjI0U1ROamc1OVB3cnl6WE5QMTY2dDd1V3h0dFBzN2NUU0FHVld6SVZPTW9SMHpYakhnenhicStoNnZQSFBvanlYRXplWHYzRUZSbnJ1YmpOVnlQZEVRalZrcFNkUkxsMWE1a25idjBQcmF3OEsya0RUWE40RGR6TElFRXM4UUpVZGNnL1d1WDhTZUVJNXJJeTJxUnRPcnFGaGx5cXVDZm14aitJMXIzUHhYMGhibU9DK2h1SUJ2QzhLVGpBNmtya0U1cXhxSHhBdG5XR0h5cmxsa2tHMlpZVHd1ZXJZcWRVMEtTdzdpcnR0ZlozMXQyRjB1eTAyMVo3SzBnZ2h1QTZTU1JGREpHZXpBOWdUWGxtb2FMUForSXBGMGJTNFV1dk1EdTBrbTJNeDV5VkNqb2NWNjNyT252ZmFmUEs4OHNjQlhNdHpia0s1VWRBZlQrZGNyWitGdElpdUk5U2gxTzZNOHZFb0w1QlVEamVEMzk2YWFzWmF5aWxkYjMveExzVXB0Y3ZiQ1NTNTFHd2hpdGxrOHEzMmN5YzhrREhiTlpIaWp3VDRYMWF6bnVQS2EzKzBNczV2SkpHTHE0Nkp6bkNtdW5sZ3VKTHFPVlV0N1lGZ2pKTSs0bGY3dzNkTTEzRi9vaWF6RkZkTnFRVlUyUnlCV1V4U0JUMElIZWtwV2R5cU5TckdVdVNUVWxzMDdIaTBFRGFoNFpOblozSGxtTDkxUGNpZm55bDdmTnlRZTJPbGRyYjI4UDJld3RJL09EUXpveGN1WFJndlJHWTl1OWVnV1ZwcCtubWFOOU50M2hXVGRsVUdTcDcxenV0V1VPcHdUclp1VlFFYkltSml3M3QycFgxTVkwNVFndmVVbi9LemxOVThGVFBxMDBpMmNNeXp1enlUUTVTVkN4NmpPZUJYSTNmaCthMjFjazI3M2lHTUNKdm1MbkhHY2o3ckw3MTZkYWFycTlxWWhxVnJjUU5iSVdrZmZ1RXFuanF2ZlBhdFBVZGN2cnN0WjJGa1lKQzZTSkxHMldDSHFYQi9VVWx6WFJoVWpSa20rYVNscHB1L1E4MEdqNi9vOTNGYUpBMXhiUzVsZU55eGI1dWlGajFPZTlkRk5hV2h1Sklwb1pMUzYyajk0ODRFZ3owVlNPLzFwdHI0aWxrYVpkWTFGa01WMXNETkdWVWxSL0I5ZTlkRnE5cDRPdmRSa0VzcXpNOE1lMHMyT0c1VUQ4ZTlWYTcyNkdqcHdjTHBxemt0SlA4QXJVazF2VFhhd2hTSzh1UE1FRWdPeEJ0ZVE4WmZIOFE5YTg2dGIrS0NTMnVtMUp0MGdlS1VTUTdVallERzVUNmRxOW11SnJUVE5NZTJ0MWVhWWJTc1N5N25JWTR4N1pybXRVdFZRcEhjMmtZaks3SHRaQ0dZNytUMDU0OTZJOVYwTjVVYnlUdnNsZTNUNWtVajZoTHBYemFrNlNRektSY1FMdVV4TjFCQjdIMUZjdnJGbnFMUlA5citlT1dWUXF3NVE3eWVKR0k1emp0V3hicDRrdDFXYXl1ckw3SEhLRU5xUG5jcVQzSTZIMnIwUzh1TFBVM2lMVzVkRnVNcXFyc3krTWZOMzQ3VWJGT0VaUlM1bW5iVHpPS3NORDhQNlhJYjd6NURLbTB6WWRnaWdjWllEako3MWsrSkxhQzcxQ3oxcVA3YkFWaE1LTWdYeU9EZ1pIZnJ4WFh5NjlkeHkzRURXU216VjFWekt3Vm1RRGs0NXpXWmNRelhxUjNHbk9Gc1M3UnpReU1wUk9QdmMxSzNLbFpRNUl1Mm15V3YvREhIK0hGOE0yVnRQSW5uNy90Q0lHM0VyS0ZKK2JIMTYxMk9xZjhBQ1BTSUxjenUrNDU4bHlVaklJeWQzNDE0L0pxTWx2NGxqUjlJODFFWGhvazRrVHNJejByM1MvV3lXelc0MkljQUVySkh5TzVVS09lS2IzT2VselNoSk53MDI3bkZhLzRwOE8yVXlhZmVXclJUUndLOFRwQUdVcUIwRFl4MDYxemVsV1doenBhUlgrci9BR2VXUS9hSTdjdHNSVi9oNDdZOUs2alVyVFhMOFd6NlpNcTdZMmFOR1VNdUNlY2J2MEZkL0sybm0zUTNzRm5jVHhxRmN5d2dFTWVEdS84QXJWT3lGeVFuSk5wcFc2N1A3aWpKYWFOZTNCdnJjeE5QQUkxWmhobG5IWTRISSt0WS9pYUdUVkpWdHJqVFNKdHFxOXlxY3hBKy9kYXo3anczNFR0TlZXNnR0UmF6dUpHQ2VUYlNIWXkvUTV3QjNyMlNmVk5DbjBCb3pxRzlkdmwrWXN1RHgxT2ZVVUp2dWRYczRTaktQTW8zK0xiVzN6UEZyTFE3ZlJJYmVDenRSY3h2bmRzakJ5NDZua2R1MWRsbzBGM0RaR3hkemJzRTNLN1JqRHJKMjIrbzcwMXBvR2dDSnEwaFpZM01LQXFDdTBmZTQ5cXV3MjJwWEhoOEczdXpKTVlzeFBLQXpGdjdwSTZBMDcyTW8wNFJxdVNiYmFiM3Z2dWM1TG9HcWZaNFliM1hESDVhNUUwUVVEcWVDdnBXQy93NmlHbFhLM0Y2alhVanMwVXFLVWR2WE8zcm4xcnJiVFF0UTFTYUdUVTBnUVJES0R6c2xISDhKUGNaSEZYdEw4UVNhaE9iV2FlMXRoQ0pOa1FreTVKT01IMEI5cWZkbzFWS2xOWGNXbS9odTlUd3JSZkN5NkJMYy9hYkdDTmJoQ3duWmhNejlpb0J5YzFyZUtQRDl1Nnc2alkzMXpIaUZVU0tISUh5OVNvcjZMaXM3SzJoRnVMUUxMdXp6a2dsdnZGU2UxWm1wMjBjZGg1a0tGZktPRHNCSVhJd1dDaitkUzN0ZEV5dzg3TnVkM2JkM2JYelo0RHEyaXgrSTRGMnZNYmhJNFJKT255RWdjbGlEL0ZYV2FWTi9ZL21MTHBWd2tVUUFNcnpHUldKL2lJN2ZoWEthZENZcjI2RUV4WlhPR2xsWmxDcjM2Z0NwUEUxdmV3NlBOTWlvdnpqZThjcG1VS09nWWRqbjBwMlh5UE9oVmx5dHArL0Z2ejMwL1E5UDAveEJwZmlpNDFDMit4d0NZS1RFN0tEdVZlQ1Jua1Z5MTFxZXMrR0xqVDRvTFdMN0swNlJobXdCaHVwOWNEMXI1NzhJNlByVnZmeVhHbjNoa2trTE94SUsrV1QyR2E5dWJTZGExSFNiaVBWYnExM1oybzhPQ1VIT00raEpweFhSN0hVNmxPVGw3emNsdE5MbCs5SG9Hb1dkdkpxRXQ5QnJFYWVkRmdvNXhDSkQxY1k2Y1Y1dzc2eGJybVNRWEVhcnNLeFpiSlBYY0c2NTdFVmM4TStEdGUwalQ0YmYrMFZ1SUdKRFF5UmNGZXZVNS9LdWcxSFJEY3p0NTRSSHQwVjRSREw1WVE0NkhBd1JqclM1VjNLclVuTnlzdXVqMTFQS3JNM00ycHE0dFRiRk1KNXdIbDRRamxTRHdUN2pwVzFyTmhlYVo0VGU2VzNobmNURndoa0xibFU1eWNkUWE3ZlRacmZVbzVOUHVydTMxSEJLamErR1ZRTzMwUEZjLzRmc05Ca3VielJycTNETEVpeUlUY01XUm42cm1qcVlRb2NxamROcHUxbTdMNTJJN1A0amVINU5FdHJwSTFabWkydGI3c2VSTDBaU3A3WVBVVm9SemVHYm5USjdlMXRMU2ZZeU03TVRHcDI1SFVjNTUvR3M3VmZoL2RwTi94SzdXS0xkTHUyeTRMQmdPeDdnMTR0SjRjMTFKOVE4bEZnbmRpWmJZbmVCS1A0c2pQeW5PUUtTUzBzeldvNXVVN3JsVjdSdnI4cnI4ejZRMGxiK3hzN21XMzBTekV3QTIyN3Z1RWdKNDVPY0gwcTFhNnRaU1hadGRROFB3V1YwMGlueVdqRWhkQU9DMjBZeDZWODhXTnU3eXA5c3VabE1reUtYdGd4NmNOei9DTWpOZHhwWGovVHhmWGNTM0JFamZ1a2FaaTRZamdjK2xOdTN6Q2xXOTJ5am90WFpYWHJvZFBxVW5oZTJhY0RTemF1eitVSGpVSkd5eUgvQUdlY0EvalhTMkdoYTFwMHNyUVhQbjJzaUVDTm13WVdIUk1uT1VJNzE1aFplUElMKzlGaWRBVlhsbmFPRzZWUzZGa09TY2VtZTlla2F4ZnpKYlhWMVBxUzJzcmZMNVVZTW55OU1xdlluM3B1K3pSZHVXOHBkcnEybWh0MmZpMjVoUVJuUm1oV1dRSWg4eENEZ2M4L3c4MTV6THJlbTMxOWNSUHF0eWhENENPdUl6ZzV3VjduSEFOTHJhMnQ1TGF6U2FWS3BJQWpseTNVZ1lMQmUxVVovRGxuYjJseGV3dTdUQkNYQlFnU0JlUDRxemUzUmFuSFVyVjVLVFdxakhUb1gvOEFoSEo0MGFhMjErNFFQSUI1S3FEQ0ZiMS9yWEVhbjQ3dVBEOTJsaGY2UTl4NVVhR04xQmRXamJzY0RyWGE2QjRtczcrT1MxVGFmc3NaYWJnNVU5UTNQb2UxZW5pNXZJOU1lNTB1eVdWMzNNMGNyYmtZNDZBbnA5S3EvYzNvT256TDJpZWtGN3QrVm56MXBueEsxbTUxNFJRMmJ3MkJ6bVpFQTJSazUzRWVnNzE2M2FlSUcxWFVnOXZQWlNXOEJBdUZsaElLdEgvRXJIcUNLei8rRWp1dFRzemF3YVRIYTNJakFjZVJsY0Q3K08yS3J3YWY0cnNaa1dTYlNqYlNKaHBwSTlybGZjQThnZE1WVmxZdjJpNW00M1VGRlgxYnUxNm5wdmlLeHRVZ3RMaUxTb3JoQktMbkViQ01ieDBLcWV2NFZ4SGhxLzBHQzllRk5JaWl1TGtTU2wxRzg1NmpKL242VlgxTHcvck43OWdpc2RaZ3VvNG44d2xUaGxYYmdxbzkrM3BXamJmWmJxM2RWc3B0TXZoQ3NKdXBsQjNiVHpoUWUvZWtudmMwbE9vNjNPckpXV2p0cS9JNlhWejRqYXhodklOSTB5L2FGaVNrWlBtT3A2REpIUTk2eGJNV2Q5UEMxMzRiMCt6dUlrWnBvc2lRNUl6d0J4eldpcGswMmEzdHA3ZVNSWFdSMm1SR1hDcUFlTWNIUGFySnY5SjhpRzVnZGlzSWFTWjR3U2NFNU81RHprZWxQbWRqbzVrMXJaYTNsZmZUc1U3UHdycGpXMm9KWXcrUWtpTVdaeDg4Vy9xd1VuR0I2Vmk2QmI2bmF6WEFtMTU3eUlSaU9lUklSRUZ3ZUJ3Y0hBNzEwRjlxT2hhaGIycnl4K2JhVDd6Y1N3SzZOdFhncVFPYyt0Y25ZMmZoN1Q0REtJRERaU1NCazJGbU1wSklWWEhKSlVjMDAzWW1jb1JkbzJ2MS9ydHFhR2pwYTIxN2YzOXJlVHZFWWlmS1lsMWpBK1hlVlBYUHBXVmM2NWJTeHplVzhONUtyS0ZRcVVVc2Y3MmNqYUsxeHJYZ0I3aThzV3pFMXlpUXliRVpmTCtiamNNZGZmcFZhNTBiVFBEclNmWnRPYTR0N3VUZXJwakljakpBN1lQclUyOG1aVFV1UldhdDF0cnVTM25nclNKV2l2YmV4dkxDNWtDK2JEQmMrVkJQams1N0ErbUswZFk4UDIya3pTYXJCRTdTdkpIeEN4TEJNY21RWitiSDk2b0RwdWpYbHNxelRYdHVza3JBWWt6ODJNakk2REhXdGpUck8ra3ZFWWVJV21TMU1tMks0aFZKRHUrWGNDTWJsUFROVjJPam1jMVpyV3l0WnJvWHJXLzBpOFc1bmttaGVRUUo1ODI3UDNlUUcybkh5bXJON1k2RHFNMXRmVFJQZHB2WlE0ZmJHajR3Zmx4MGIwTlNYSGg2TFRYYU94aGdRU29STkh3NGtZODlHNXlhOEI4VmVNOVY4TlhjV25TYWVxZWNubXFJdVZZZE1PeHhnK29GSkp0bTFxbkx5dUtrK3R2TFU5SzFQdzlxTnpxeVNSNlFIdFZqWmwzS1N5dG5oVk1aRzVjZGpXWGFlRHI2NTFWNUg4UFc5dkZHMjZHUVNGU1NCL2Q5YzlLcjJIeENhQ3owKzVhSm9IdUMwYXhwTVRIdUdBRlZ1Z1k5Y0d2WkwyNDB5K01haVo3YTVsVUpLek9jTVY3TGpHY2YzaFRWMHpDRktoUFc3dW50c3ZrZU1zUEM5bnFibldvRGJ5Um8zbFFJN001OVh3cDJuUFk5YXo3cnhsb28xR0s3MGhMdmQ1Ump4THVLZ3IvRTZuK01kaWE3ZnhWNGJqMWRpeUl0NDl1Nm83TTdKKzZ4OTNjT1MyZTllUzZMclBoZXlab0xkV3RuYVZvNW9XZGxkU3Y4WUxaeUQycVg1R05hTTR1U2phT3Z4SmRQVTlXdkpybTRpaFM5dUxlSVNnelJXNWJsbEdQbFpWNjVyaHRZK0g5bDRoZzh1MTFxNHRDMnlRQlpXdWNSa2Nxb1BJd2VsZDNxRTFyY3g2ZThWODBjc1VxcjVaZ1dSbHlPeEhJYkhPYXlML3c5SnAxOVkzMXJQTis4ZGtlZUlsOXFZenlQNFFUM3B3djNLaE4wNUtTU2xacDMzTkh3L1lSNlJwc2VtM2VsU3l4MjB5L1o1N3VWWkF4a0FQeWtuam50MnJ0OWE4UmVHb3IxVGMyK3lYYVdkQTNLaE9BektlR1VldGZQV28vRTdVZE8zeExiUzZsQVhLdklpK1p0UFJSakhCSnJzcmJ4bHBpdEZEcXQxYlcxMHFJNGlJRWpSSzUrNDdZSUhCNkdxYWR6cFVwdUNkcjgzVnBQYmU1NlBxcDB4dEF2dFJ0eUpZNG8yZFVRN1RJdjkwQTQvT3ZMVHBQaG5WZEtTV3p1TCthT1libzRuWXZzWWpHQVRqR0RYYVQ2VkxkNXV4cU1jdGtzbTZOQ2NpUG5HRlplR1Vqc2FUVEo5VCsxVHpmWVZsc3dybGJpTmdkZ3pqQVVEcHgxN1ZDVDFzemxsSG5tMUtGbTdYa3V2bWVKYWxiMzJtU1diSk9iZTR1Wmxpa1M1bFBrNFFxZk5PZWd4MkZkMWVlSE5ZMXJUTG0waDF1MzhrWEpaZHJNU3lJZmx4ZzlNOWpYYTN1cDNHbHhReW5TMm5oZGR5R09BTUFjNEpKZkl5QjFxb29nMUh4TEZQRmNXc1Z0Zm9peXVpa09YQzQydWg0QitsVWtuMDFNbzA0UjVPVzkwMHJiUC9oam5JUEQrcWFQRXR4ZVhSdTQwQ0s3eFJoSkdCSFErV010eHdjbXNDYnhqNE5XZU9OcnF4bHRra1JyaExoR2R3b08wZVdRTWNkSzl2MU8xOFFhWVV1YlJvbWhTSW9zTU1mbVNTRmVqTnZJNHJ6ZDcyMXViK0EzbW5XOXRjelFNWVlaWWdnZmNlQ3hYT2RwUFNuSDRqb2NLY0c3cVY3K1grUnAyVjNZYXBHNXNOUWhBS0dOWTBRbGlvUEMvUGpiMDlLNFo0dmlOaUlzazBGdXM2TSswcTh1MWlRVlZRZWpEdjJyMFBUL0FBZjRhazFLNHY1bUt6b29ZU0tUdFhZTUhPMEFubjE2MWdhaGFYbHphUlNTNnpGQXU3ekV1SUhKalpsNmdqc2ZVVk9uVFU1K1I4MFgzMnM5UG1qczQ5ZjFhTFJXMUt4c3Byb1pDckVTVWtaVk9IQkJHQVY5TzljRjRvMXI0aXhXOWs5dG9zTW5tSzBqc3NhdGpKK1VNR3gyNjEwdW5hcmVXTHp2cXVwd0dQTFlhTXNxRk1jWURkRDNPS2h0L0cxbGRXSUdrWHVwU2VYdkN1Yk15b1FPcU1jREk5R0hOTldUMlBSVTQyZXJhVzYvcXdsL0xvajZNdGhmcERiWGF4TDU4SG1iZHNzdzNsUWVpc2E4L3dERmtNOXA0Y2hodWo1RWJzb3RuU1ZJcGwrWEdUNVl3d3g5NFZzYXJwMnU2bmMyNlgwbWwzU2ZLOGtubE1HUnVvRFpBM0FqaFQxcGpSWE9rMkNPbW94eTJxU0dNUGJXaGRrM01NNzNrSkFWZS9GTmI3bm5OKzkyU1Zsc3IrcFEwV1BSaEZaV2Qvck1UeUt5cWtOMUV2bEFZejk1ZTU5KzlXYkd3K0hjdDVmTXQ5YTJkM2FsMVpJSldkbUF3ZDhRR000UGF0QzQ4RXozZHJKTEhxME54QUdabzJpQTNHUHJnZzlEbm9lbFpkdm90cFpFejNLQ2Q1RmhBa2tSZk00NDVHT01EMCt0SlM3TWlNcFJYdlFUVnROZEpldmtkTkZwV2thdHAxNEl0V3RiMFRLVGxHZTNLZ2NGd0QxOXdCeFhsdHZwWHduRjBMWXd1TGkxTEh6WXBtWlR4L2ZZY25tdlM5UEhocTkxYTRoaGlKVjFaQXJPKytNWXgrN0hRWjlSUzZwYldzTjVaeFM2MDlzaFpIdHpjMkVjaGovaENpWGdnLzczQXFZdE52YzY2VTR1RTJwVzMwVXRMK2YzbExRL0EvaHpXN1dDemoxVythUzIvZXJiM1RlYXJCeVRrbEFPUG9hOUpzTE43SzNhUFZ0UWQ1WWpJRTNmSUlrRGZlR0NTVXhqcWEwbVcyVFNydUtTN2RaZ3FKRVkxT1ZrY2NOOHVmbE9PM1FWNFBaYU16UFBiM1dtWHd1NDg0dTBrYmN5YnMvTVh6bjV1d3F2aUNwTGxsQnVOMjd1NnZiNW96ZkZ2dzg4SHozbG5meDNsMjZ6c1BNOGk0OHdzU2M3dTV6am9LN2RQQ1VWdE5jeFN4WE4xQ1pBVHRpRXN6Zkx3Q1dPVks0em52WG9zT3BXOFcrekZwT2pwc0VyUnJHcktXR0FYemc0UHJYRkphYWhGcVBsTE5JUExjVHRmTEdFZGd2SGx5S2h3eFhQV21tdG1WVWc2aWpLVW5KUitHTjl1NlJ6TDZmcVJzMjFEU3RTdVp6TEU2UVJUV3VIQVE1WmowNDQ0SkdhdTZQOFFOS2l0LzdQMUtTNHRwMmpacFd1STFpamxaY2N4dHR4akI3aXVwa3Y3cVY3TkxReVNtNk1peXkyNUtBWUJ3UUpEbEhKeDkzZzE1eHFWbjRydDdSUkhDOXhLSm5NbHZleEpjNTNEUHluT2VSd1FLRXRES0hzNHp1bDdyWFI2ZnFkVGRUZUMvRU9tN2pZelNpM20ySTBFNnMrRVVFc3hVNXg3MWwyaitHdEwxZnpIbXVZMzJnU3BPcnN3NE9BN1kvaUhjZGFyeitGN3Uvc21TUHcrbHNTNGtNTU1heG80SStaV0lQNEFqOGFyUzJrZW8yc1ZqYjZmZHBQRXpSZ016R011aTVDc0dKMmc5S1RXcHgxcWtwUzBob3ZoVm1yc2s4UmVLdFB1RFpYV2o2NUhBQXBXWXVwa0hQQVZ0MlNEenhrWVByV2JySHhIMGV3bXNHZTZsdnJwSW1pbmppaWFGcFZQWk9jZGZiT0s0Q1RSNFQ5dnM3clRZcEk0NFZhWnJSZkxlV1FrRW8waElCMit3cnRmREZoNEJuMU5iUmRTMUhkQUY4cUtSa0RSTTMvQUN6U1FETGM5KzFFVTFiVTZvS001UGQyZCtSUGwwMDFiMTZubytoZUpOT3ZZSHVOSzB5Nlc2WUZXZ2tCK1VvTnkrWWtoeUZQVElyR1h4Vm9KdTNlNjA4ckpLUXMxbGhHQTUrK0NlVHV6eVBVVXQxNFhTOGt2N2V4OFN5SXNqbDFGeGNzTGlJZzUyQUU1SUhRRVZ3M2pEd1g0anRsdHIrMHRUZDNLSnNkVnVIYVJ3Um5KWS9lVWR2U2l5dnZ2NW1icHljbW9wSmN6U3ZhM2xkNkk5Q3VmQS9obWJ6cHJhd2VRWGNMaDQ0cGZMQ1NaeUdDYzRPZXBIRmMybmh4OU0xZTJ1SFN5bVpsampXekxLalNaQUJCeUJ1WkIyeHpYZ3NYOXR4RzB2NzJSYlFTQXBzczV5Wm1WT204ZE9PNDZrVno5eDhVYjJYVWJHR2JTNDdoNEpUR3Nsd3BKMm5BR1F2Y1krOVFvVHYzT3luaGNWWGsrU0ttNHh2Snhrbkg3M3ZzZloyb0sraVN1MmwydGs2RzZaSHRXQkRLeEF5d0xqZzVQUUdvdEgxaXp1SnI5Wmt0dnRDUmlJSnN4SktnRzRZVWNNWThrVmxUeWFwYlF6Unl4M1VjY3UxL09ZbGh2SUdTeDVEREhCNmV0WWRuNGJuazFpM25Ga2t0bVZQbWlWdHBoa0M4Q005dzQ2WjRxWHNlTXFxZUk1WXBwMmJhWjI5eGZlSkk5SldOSTJYeTdrZll5cmhQUFhxVU80RS9oaXNMVzlXOFgyK24yT28yNEVJaWliN1dkb01jaEpCUU9TY0FrSEJCcmJ2dkRXbkc1TDIrc2NlVkxzam5ueUlHYm8wZlRwNjlhNW5XWXZGbHRGS2JpQlpiT1V4dDVsc3hrWDFIbUxKbmpJNXFVdFRvVWFzZGZlMGowZDlqejBlQkwvVnJwTDZmVWxzckNkVWxlQ0dmNUFEL0FBcG5rRU1PbklyUG5zOWY4S1JXOE9raWU2RThyUExLbnl2SklUbkROM1BxS2RlK01aMDA4MmNUUW01dVR1amprMnJHUnV3MGFOeUF3SXlCMHJyL0FBVDRqMW93SkhQYnRiUnNTUUhWVHovRDBHMDU5NnQzNWR0RFgybFgyVkp6UzluZjRicFhhdXRrMDJ2TTh2bThjVzJ0YXFwMXJTWW9wSXhnYlpodkpUcGpKMnNNOVZiaXZvVFFOU3NJOUZlSzRzYnhRM25NSXBzTEVZbklPeFdZNEtnbmc5cXhmRmVqMmV0cmFiZE10cmVaTndhZG95cFNWemo1dGd3b2JzM2MxemR0cDNqRFRibTNXVjRMdTNVS3lRdXh3V1pTaTdONCtVODgxSFJXKzR1dFZwYzE2ZnVxMnFiYlh5dmY4VEpuVHcxYWFva01EYXZiVDJIbHJiSXFGWXR6RXZobk9kL3B6MnIxbTMxU3g4bWVXQm5iekZJUzN5REpHUXZPd09UdUFQQjducFhuc09tZUpMcTRoYTVzQmFTUnlzVmFSd1hLQTRPNGpnOEhnRHRYY3dlSGRiL3NLZVcwdExVbHJyemxTUGRNWTFPUVhqTEg3eFBHT1JpdEh1Y3MxV3FWRm8wb2I2MzE2MmFMRnZiYXE3SWw5YTJ0enA2N1pKWXA0MlZsbHh4NWUzbFNlbkh5OWpVUGlYeGZjZUYvRDZYQ1F5WHNVMjhxSGh5b1FlckRJRzA0NE9DYTVHNGUzdDlZdGIxOVNtV1dabGkrd1J4dGlVdDk2Tm1KWG5QcGpGZHZxZXZlR0w3U1UwdWVLK1F6U0lyd2lCM1hJT1hTUkdJT2V4SVBXb1YwL0k2Nk02VU9YbWQ0cm9uWnZYYTVlOEwvQUJFc3ZHVUtIN0FMWHl3RlU3U0dobWZna05qN3VQV3NqeFhKNHkwTmJlMTArNEx3aDFPNzdJdTROMUdXakdDcDlSem5yWEQyWHhQMUxUNUJZNkFwV0ZJNVROaFZ5a01aOUdHTTlzZDY5bDhOK043eVY3YXpYVGJxQlpZMmtXWjJCalk0SUFLSnV3UGJPUlZmSnRIVnowWk4zVXFibHJIbXRkSnZidXpKMDdXZGF2TGpUNDJ2NG8zajNlWTMyZVJkdU9DY1lKQjdOOU0xSDVmOXBYemhMeU8wTUVwODFZcFN3bEo1NDMrdlp1T0swdEpIaS9UOWVLM000dTRwRU8zYmNGVkdCdTJ2NWd6dTkvU3VEdVk3YnhUQ0lESExESkpNL3dDOVdWRk9XSjJrOERJSDU0cDh2WkhteWkvaGMzSnVXelg1SFczWGcveEZmU1dUMmV0d1dzc1VXWGhaRHRrY2Z4TW1XRzRybnAxUE5jL1phZHJtbDNrTGFoZVgxeEt1RjNrc3NXMlRqYXlIZ2pqSUhHSzhWMFB3UjQvdDR2THViMVUwOFhoSDJnU2tFeFoyc0JqSlFFNDdjOXE5dzFId2hEcnIyY056ZGFrWW9ybVZVWkdlYk15LzdUa0VqQTZrVTdXV3R2a2VoVm93aGFDcUxSL0ZGWHVuNnBNd1BFTmo0UHQ3T0NTNHNaRHVZK1d3andGbGJPRElFeVNPNUdjVjVqWmZEM1dkUjFDUFVJbXQwKzBGenNqWWhaMGY3NUcwL0xzNjRJcnY3aC9IR2s2d3RqWjZUTFBaeGlQY0Z0dzBtN080TURoZTNYMHIzYk41TERleHlTMjFvbDlHVmc4dzdHM2pqSlFFOS9UN3A5cUx1L3lNcWJyUmsyNXYzb05XVFQwZTY4anlQVVBERGFodjBtOThSWFU5K0VUN0xMNU95TXFuSndEL0FLeHZYZHlLdTZWNEswL1NiUzVrZFk1a2szSmNSWEtlY1NYeVFTMExibEdCeGdacWEvMTIyc2tpRnhlWDNuUVpPeUdWUkc4a2VBRlBHNVNPdWVwNlZtdWZFdW9YRnBxVjFaTGJJenBtT0s0VnAxVkNjU2hTUG02NUk1NTV4VFQyL1BzUTZybkd5MXM3OHFzcmY4TWJsbG92aGEwRDNsdDRlczRyZG9JZ3BXRm1iSmJES0RPVHlPdlRrVm1TMldrNk5ySU43WlhHbkk4cUcxU0ZERkcvOTg0M09wejZEcURWYnhkNHF1TkprbGdNbXEzYzEwclIyOE1zSVhDZnhTbGlSbHg3Q3FYZy93QVQya0wzSTFQUzU0bGpIN3hKbWVaR3lQbFpvNVFTb0lIQkhXcXMrWG0zMTduWFZqVmxUOXBLVm90clZ0UHJiVlhic2RqZDZKbzJvYVpGcHR0cVZ3aU5OTkpFM2xDWkdJR0NKRWs1eDZBSEk3Vnl1aDNHdmFGZWlNUlhlb1JUTGkyZmNZL0thTTRZTEcyTUhIUWMxcnRyS3lUM1A5azY4YlZKaXJ3dGNRWXd4QnlGZHhrTitHYTZhMThUNjFOcUQyTTFvWlhqVU1iMUUrUmx3RHVERTRaU3ZmZ2cwdDcyUnpLU2Exc3BSZXJTOU91NXIzZmhxeDhUTmFYT29XMDZYQWhHeFZDMnp5QmdNckx0emdqSFExVjBqd3ZySGhpeHZoWnkzRXMrOXpFSGtTWllYYzRLa0lSdUNnZyt1TzFJM2pHVzF0WWJpZXl2N0pMcVJZNFRJUE1oa0tqSUxsTXRHUWNaelZLNmgxTFV0Uk05NVp4V0VtNFN1NlhEUEpNMmRvQ3FCdHlNY2c1SUZMWGwxTzJwVWp5cDN1NzNSeTkxTDQybCt3eHhYMm5RM3Fvd1MyTVFsVExmeE5ML0FBZ25wd1RrMUxxTmxmTnBNOGNVclcxekhia3R2bmpWRWZnbkN4Zk1xZzUrWThBVnE2N3Aya1g3UTNWcGZ3MnorWklGOGd0dWVRL2UzS3AzRXIxNHJNdVlaR1daSTljdUx1S2RFUm9XajNiRVpTcFZpQUQ4M1RKWWNkYWpkZEVjRXAzZHBXMGQxM2FQTTlQMXJ4cFlUeG00TTAxdkxFNHQ3dUNOYnhFa1RrcXpRWk8zUFJ2eHhXVDRsOFErRE5adWJBaUpybVFTTXNra0tPa2pTSEc1V1g1YzhqalBKNzE3bllxbGxJMW5iYURxYnhJQWNBcHVVdDBWUTVBS1k3WjRybE5hbThJcC9hb2tTVFRiaVNTS1F1NUgzMUdDeFRPUmdIa0RyVnBSc3REcTVvT0Y0eGNaUFJPTXJLNjhyRkMxdjR0SGd0NWRROE8ybGpieXkrVzIxSkJMSXFITE1aTnpiVjZZQXJzZEY4WGFOZWFrYlcydUxOMndTdG5JNUxwc3o5MXprTWYxTmVXMmNYZys1MGEzZGZFdDFMWm96RkxjcHdKRisraUE1T01jcjN4eFcvb253aDhNTmZXdXA2WmM2dEJGUEdHV1dZeGxkMmVVQWNBZyt4eDdVbWsrdjREalRUZFZUbkpTU3RCVzBiMnMzdWowdlZKOUtqaHU3cVNkTGVHU05vNTNqUmhFeU9NcTJWQStkVDA0eldOb2V1VzZRMjFrMTdCcUlrakVrTThraFJTQVBrTzhCY2M4YzVJcmR1cjd4QnBjdHpiejZWRkxBN3FYdkptRUJaUWVyTHRZWjdnbmc5NncvdG5ndHI1Yk82bnNmdER5dm55RmtWNDB4amN4VWdaUFRJeVBhaExUVjNPVndmSjltKzd1OUV2UGM5QnZKOVd2MG5oT215eFRSSTNsM0pRU3drTmhRUUR5NDdrNCtocnhHUysxSFM3dDdhOXU3b2FnWlI1U0VHV1dWc0hNY2JLUmhKT2d6bkJ4WFRhUEZZMklFMmlOZlR5STBnbXNyNlo0WkFxY0V3dS9wM0dlbEpiK0pvYmk2RW1xV04zR3BsM3ExeElpcXVXQktveVl5b3huSnFsSFhZNkpOT0xiZDF6V1cydjNISzZmRHFjZDdMSnFsbGNKcHN4ZGpheUFNOFR2d3A0TGh1bUdKR1JSYldWcHBHcFR5MjFxclJQZFozdVRGQ0ZSY0hidHdHeUR5RCtGZGRPbmhEeWRWdDRQRTBrYVNPeFJKTGhRMXVXWTh4aFRuOTVuSi94cnZiUFI5SnVFaVpkY1NiVHlJb3pFN0xORVd4eXVXK1pBMk1nSG9hbHUyd3BVWnQ4c1ZGTFIyUEtaZkVsNVkrVnZzN2RMYUF5R05DaGpNZ1laTHg0NUhYQTYxaCtJdkdJZlNGTm5wOTdZU3lxRnQ3ZUczYTRrdUk4Z2xXbENqYmo3M0djZHpWTFhMUHhYNFhsV2ZUUEQ4dDFheVNLa01sbzMycFJuUEJES1dDdDcvU3V4MEQ0aWVJdFhnbmtYUmJuZmJSSThvWlhBWmp3VVRBeUNjRUZlaHE3UFIydWRFYUU2Y1ZPcEJ5aGUybHRWdDV0R0o0SzhlQllMaUJOVGRyeHBveEV6UmVheHlDU2hHZXZvT3hyZnZOZThUYWROTktmQ3FYOHdiOSswTE9KWTBJeUNYSitaczlmU3VXbDhPNk5xZXVSR1RTZFYwaTRoWlpIdUlSOW1VRmh3d0czR0IrZnJYY0o0SnQ3QnBVaXVidTRSaUdYZE41elI0R0dLZ3FGZGpua1p6NlZQVXdVSVFhY0x5Uyt4UGJYME9ldXRmdTdLQTN1bytITDRQUExod2x1Z1lNVkRMODVKRERIdlJXdkg0T2hmVUpoZlR0Ym9FUVFFU01yeTdRQXpNaGNnWTR3UU9jMFUxWXFPaTFvUmwxdTVOYi9NNWpSL0VkNWZMYngzMmpQRkt3Q2diU2hKWCtJa2ZwWHRzRnZEYTJiUGNJTmlJeGtpSkphTlR6MnJaMXFHUmdEYWhZM2lLc1hiREZoM0FBOWFwcHFKdWJtTm9aR2hNVUpNeElHVzlNNXFIYjhEQ05HRUtzdFlweTBXbjlYUG5zZUcvQTF4TGNhallhcGMyY2dVbHBHeTBVZVRqa0h1YTlPdHJ1dzhQelEzRVRTM3NyV3hVeXFwQ2tEblBIRzQ5cTJydlg3U1cxMUNWN1p2TGhqeVEwYW9IUDA3azF4RnI0OWlMMnRoTlkzRWpUN1NnQy9JTW5wdTloUXJ0TjIyM001YXZuNWs1TDRaV3ZaTDlEamRaOFphdVpybThUUUF3aWozeXlzcEVxcWVRUVQxckUwbnhCclhqRzJ0RXV5VzhpYkNTUm5ZTnBHRGs5ejYxN3ByTWxuNGhzTDdUMVh5OW1JMzNONWYvd0NzVjRsWmVEcHRORVVDVFd3c1laU0dWSGJMSEh6TVRUVGp5dDdNVlJVL3E4bzJsenlrbTViSnJyZnpPbGJ3SkxhbVdPSFdVa2tVNy9MTEZnVjlQWEpydW9yZTVzcmRBd2FRNEhsaEJuYXc2Z2sxekZob1RhajRldW5qTDJrNGJiSGNqbGlvUFFuMHJwdElNelJpM0dvcEhMRTBjZnpmTUE0NmsvV3MwL1BZODZFTE9OUnBKeXVscjBPYThRdHBjTjlZSzl1NlhSRzk1VkJ5b1BVbHNjMURwK3VSd2FsYTI5cllPRGNMbUtNdmdNQWVwelhxT3ZhemU2Y2x0RktFdWwzRlMwVWVTTSt1ZlN2SU5hMENXNjFTQy8wN3owWXdmS05wQTNkTVk2ZzAxcm9YVXB3VlZ0UzFqMHRyZG5kVGFyYVN5M1Voc1VRNzl2bUtBcEJ4Z3FwL3JWbU1nMi9tUTNKVnlZM25pRXdMaFU5L1N1RDA3d3ZyRThGL0pjeVhFSTJLZHFmTVdZZFNBZXhyQ1h3OWUyYVJ5MkVUdGNNcDgrTndXTXFIK0VrZEJTa2wzRXZhTFdmWFpXUFpJTk0wYlh2T1ZJSHRtUnhJenlUWTh4aDA5OERyWE9wNGIxN1NKeDlvMWlPNGdtYmgwVTdrREhrLy9Ycm5QRStsYXRkUVczOW5Rd3BlUnhqOTN2SWRWUFVtcWYyWHhacGx6REl0NmJ5SklRSkkvd0RhN3FSL0toS1dtcU5aeWhHRitWWHZvK3YzSkhxK3JRYW9iZXpoMDdVREtqbmM4a2g1VWQxRlVab2JHWXNOWFNPNWFlSUFxRU9GakhRbjJybTlKdXRGZTVjUjN6Mk1pb0paNEpUdVJXSDkzTmR6Y2ZiOVVzR2xzTGtNV0d3QXJnc28rdlNrckptMFhkT1Nmdk5hSzk5dkl6TlBrdnJlMW5zSXRMalMxV0xmRExDVkFjSG9Odld1SFRmcms5aGJ6bVMybHRwUUVqWkNnNDZZejErdE0xclEyZ2xpbUVrOXZMQ3VHWkhKTW5ZamIwQk5laFBOcDgxakRGYmk1bmxqd1Zkamp5ampvVDNOYXF5Vis1aTI1enRLZHVXTzE5enVVdlpZb1Fra2ZtaFpOa3dLWXdQWDYxaDNtb1I2TnFpeTIyOVZsUm5ZNEpMYlIzN0FDdkVMSHhmNDFqYTZZcEhOQUhDbFhHWk9PcEE5Qml0YTIrS0ZuY1N5UlhHazNlSXhoT2ZrYlBGWjY5VWRheE1ha1c0eWFjVW56YjIrNDlRZlgvRUY1SGJ6L3dCbVR0YTNjVEdLVkNDeXNlbVZPT0t0MnMrcjJUa1MzVVVhTWd5ckFkU2VtVFYreDFMVHIyeGljdEpiSElLcUR1MmtET1BZVjVkcXlXMDJtM0V0dzBkeUlTQXltVGFXSlBiL0FHcXJwc1ZLYXRHU201WFY5ejErK2p2WmJLS0I5Mi8xUUFybnIrVmVJZU1FdWhhUnhTeHBJTnc4MlFRNVpRUDRxN1R3Nm9YVElXdDB1SHRKRk8zenBQbURkTUt4OUtkY2FycWxoREhIZDJoZFpISTNLM200UWMvT2Y3MUNiVDIyWXFuSktITTdwTmZnanp3M1BoNVdoSWpabktLMGpGTnBVSDVRZHA2WnBzT3NXdjhBYVYxYXp0TEhCZ0tzaE9NYmVBdyt1YWUycmFkUHJjY2pOSkJPMGUySXl4L0l5Z1pBYmpuMnE3ZnlhUmROQkxlNkhMY1BDUjVoajRKSzlPQjI1clJ5VnRqeW5DTG5GeDBUNjIzT2p0RXQ5SnVKTEswdVV2WkdqRW4yZnp3UzVYcXBCNysxUUpxMmwyTjhEcUduelFDNEdXSGtIOTJDZUEyTS9uWExXMmkrQjdlNXVibVRTcnFPNHVjRk9TV2pZOXhqcFhvc0xlSGJpR1RURXZKcExneFlSMmZsVkF5T1Q2R28wdWVoeXdVWUtOcmJwUHYyS1hpVFRmQ0dyUkcydWJ5S1pta1VJQXhWMHowNmMxeVUycWFmcEVuOW50cDBDMjNsb3BVdmpPMDREQWRDYTlKMFB3MVpRelNUekRkSUd5a3JZTE9WR0NCL1NwMmg4UFRhNjA4dW1zWHdNckx5QUQwT0QwcW00ZFRvWHRaUWplMEc1YmE3ZVp4TU56YXkzczcyZDQ5eVhPeElVeVU1L2hiMEZOdVBHTnd0OTVONWFDemhpUnZNWXNjRXIwQkg4cTdSN1BSOU8xYmZETkpIRmNrbVNSU01GejBDZ2RNVkpwTTFycU41ZDJWM01Ha1NUZkdqeEFsbEhRazl4VTNpemlWSnIzSXpTazVPNjZNODV1UEZQaGxyUzl0LzlNdG9ycFVQbk9ySGFBZVNOM1hGYjJoU1hDM0V1THlLZjVRSUpVenVWZjRXSTZFbXVpOFVXOXFMUjdxYlRHdW5paExiRVg4TVZ5ZWdMRHFXbWFjTGl4R21Pek52aEVtMEFqa0VqcmsrbEs2c2J1aHl6VW1sZE8wYk94clBwNmFwZStUZnRIZGJXSmdNVGJYRGRHREFjVmhlS1BobElJWUVzV3VMWm8wMnlONWd5NnJ6ako5YTRueGpxZmlmdy9xVUxhYVBNdGpLb1psakdSbmt0a2RqWG9zWGlxNXZOZGxodnJtT0dHWlJIRDgyN0IyNXo5VFZ0dFJUVnJGeTlpcVNjMzcwcFdXMmx2VTgrczRFaWtSYnBMMks2SGxxcmxTUkpzT1FDdzcxMCtxZUxvMGNnYVV0eGRMRUF6TXV4dHZwbnVhczYzZGVJOUEwWkhtSG5vSlBLZ2pIT2NuSWR6NitsV05QL3RlL2x0ZnROcEU4VGIzWnljN09PQm51YWl6UzExK1o1a1ZWcDhxaTNlVnJxUzYrZjNtVXZpQzMwdlRJcjJKR21TNk9XaFZBV1dRREhHT21QV3ZRdFA4QUUwekpiR1N5TzB4Rm1rWmRwOU9jOTYrZGZHZXBUNlRxTWR0Y2FSTEVDLzdxVzNmSVpXUFhBNkgycnQ1dFUxclU3QzF2TkNUNTBHeWVPNVhQQzl1TzlRN2ZObm9SamlJdEszS3RsdFpsNjgwblIvN1JhQzR1dkxqSTNSb2t4WXNYT2NuUFBIcFV6ZUdiUzAwT2VPMDFJRUdSSE8vTDR4MytYdFRZbDhSYWpKWVhIOWwyeVNZMnlsejFLbm5HT1I3VnA2L05McDJuUE9saW9FYmd5Zk1PRS9EOUJRNVNPS041S3BKclJQUitwamFkcktTYUw5bXUvc3JtMmJNRHhOdEpZSGpQY0N1bHM5WThRVzl6Q3FXVVU4TXNmem5BM25kMUFCNmYxcm1mRFIwUzcwKzcxYTRzRmppdVkyamx5bktwbklmSGJQclUycytHSnBYdHJ6UTdvL3ZXVFlaSHlFUURyOWFyVHNheHA0aEsvTnF1bXpTUFlidlZZN1N6Z2lrMDBwaFM2aENQbEhjNUhURmVHYTVxMEd0M29GcXdtODRqaGNoc3I2R3NyK3c5UnM1V09yYTljSXNLa3F5RS93QVE1WFBwN1Yxc1dtZ2FmRzJuNnBEdDV4S3NZK1VkVG5IZXBUMXV5Y1JVcTFQY3RwMXMxZFcwUE81Tk9zNFVlU0MrYU80aG1QblF6TUErY0VINmptcU5sNFN1VGJRc3VwUU5ITVFXaVg1VlhhZWg5VzlUWFMyM2g2MjFTN2oxTFU3R1IyVTdESnQyTS84QXRBQ3VwZTQ4TjZXdHZwNzJqUGNFczBJSUoyN3hnWXgxcTI3NkhMRGR2M2ttdFZKVzFYYmM2elU5RjhDWE9uL2FvWkpvWjRWdzV0emxpZTRZVndtaitJUEJ1aXlXOE41ZmFnSmwzeWhYeURsaGdBN2VNVnNSMkwyM2xTdXF5cklqSTA4Qk1aR09nSTcvQUZyQ2wxYnc5cE42TFNUdzNOY1hGeGtpWEc4WS92RnV0TzdlbDdub0p0elVuQ01iSitXMnQrcDNjbW93L3dCbjJkMHR0SjVUeitZQW96STJUM0hwV1pyR29lRDdXNU4vZGFlNXZFWFlqYlNtRlBPMXNjRWlzL1ZyMjRzdEplNGx0WGFGV1h5L0pmYXlSbnFNK2dycnBidnc5cjJtd3cyRjBPVGwwbEFiY2NkeWVldFp4dnZydUtFcFNqSnFYb210L1ExWS9FOGF3V2hhQm1qY0FlYm5QbDhaNTlmYXVqbnZKWjlQWkpKMHQ3WmxWak9nSWNBSFBUMXFyWm8xckJBaHRJTGlObzhzMGVOcXVvNEdEMjk2NWk0MXlLK2h2N0s3dTRJUmpaNUk0SUE5RFJiVzUyUm5PTVZ6eTFhMjJQRHRiMU94MVBWNDRvTmJsaWpqVStVTGhOc1Q3VDA0N25zYTlRRUdoV2x2RUwyVkpVdTFaZHlOOHVRUG1Za1k2VlcxWDRkZUY5V2pRejN0eUZ0b2xJVkdBUTkrM2VuNk40STBTM2haSTd3eklWbUNCMjNxbThZT0FlOWEzank3bk5QRHcrSlI1cHZlOXJKSEo2eU5GZXpsanRic1dheCtYc2tqa0xia0I1M1k2a2pwWHBGanBlbldNLzJxS2RUYnZBcWtTTWYzaDZnblBldUl1dEIwelNORE80RzVpV1Q1RHdvVXB5ZU9wcnE5TDhWNkpyTnFyUVdNb0ljS0hNZVJ3T0d3YWZRNW9Vb3B0eTVWWnEybmYwSDNzOTNaU1cyWHVGRjB3TWtTcnVDQURPNEgwckNiV0dPb1NCcjVDNVBsaUl4a3R2N0E0OWE2aldMbldHaGxrc04wcnFoRVpHQWNuc00xejJ1M3ZpU0xTN0UyMXREYTNHTjF6Y2xRKzNqN3h4M3BQbHN1NXJVM3NwTkphM0t0cG8ydHdYRnkwT2hRV1prWlZiVUZVYjFIVTdVNysxZVZhMzRiMGFMVlhtMDhYUXUzTzJTWXZoV1p6a25ubzMwcjN2VERydXJKYlhNbXFtVlBza2tjcVJrQU0zOFB2dXJ6cUdEK3lwR2prMU1OQWttVEhQSHVrRDlUdFA4QUttMjBncnpsQ2t1U2JTYXMyK3E3VzdHOVpXdHhGSmFwL2JodWJqeXNZa2JtRURxK2UrSzgraGh2MjF1V1BSOWNzcnFWNW1Mb2ZsSTR3Um4rSUdzMjQwN1R0ZmU1Z3Q3dVN5TGdyNTNPY08zSTU3R3Vyc3ZCR2dhRHBxL1pJNWI1azNGMzNCSERJTWs1NjFHL1hYdFl5Z291aktiazNQbVM1ZWx1cklyV1BXb0x4enF1bVNScTJjbUZUSXJnWjR3dlRQcldWbzl0bytuWGtrVi9iUVJXbHpkSTZwS296NkxnOVJqdlducHZ4aHNGczdxMnVHVHpBQXNPMXlkd1BHMXM5S25zTHJ3M3EwTnhKYytRNHQxSmFKVUpkZVBYb2FMNk5XTm5UVkszdVRqeldiVFRTdDh6MWl6K3l4M3pQWnVxbzVWRkZ1Rm1FWjU2RHRWSzVpMVhVek5EZTZOc0FEQjMzYkJ0QjRQMU5aK2gyV2dYMm1xK2g3STJCVlo1QXBYNVJ5U1BmM3JxbzllaGF3SGtPdDNLaktqZWVUdDRQVWU5TlBSV0xVWWV6Y1hLeTMvelJBVU05bGNTcmRTVzhuM0YyaklWZ01BZlN2Q2JyWE5Sc3A0RGVYcngzQVVJOEJKQ25KNmM5U1IzRmVzMy9pclFHdm9rRjc1RTRQNzJMYWZMWnVtUG9PMVp0N3FmaG0vczN0UVlwdk1tMmtZM2lNazhzcFBPUlVKNjJPWEVLazR0dXBaUjEwZTVuYWZxL2htOWwxU3l0clJiTzRuamJ6WENoWkpZMUdmbDlUbXMzUXJMN1BvUmVEeElnYU5aR0lrYmNtRlBVci9lcnA5TjBlRlo3WkxoTGE1YUNSbSswTm1LVlZ4OG8rdE4welJMSmJ5NjFCZkl4SUdTVzJrQWJqZHpqNm1ta3JHa1Zma2JXcTgrMy9Ebk0rRTlYbi90KzFsYlZXWVhFZUpFZkFBWTV6dFU5alh1UGlQdysrb2FQYjIwOHNlOHlsNDM4dmNGeHpqSTlxOGk4UStHUENWM1pzcHVQS3l6U0R5aWQwYmROb0s5aDZWeGkzMnM2ZFl3UVJ2TGQyMXlXMmJpd01KQStVc2ZldExMZEd0UGxwMHBRbStmbXUzcm9rZXoyTnJQYnJLSUx4RW50a1hFcktxaVhjZW9BN3JYei80dWJ4WGQzNnY5bW11cG9wQ1VNUVpVSWIwSXIwT3lzOUR3WTdtNmFDNHZzZ2hITGlJa2VwNlpwbXUrRWI2eit6TEZxbDRjamFpdzVLRWdjYnlPaE5acEs3dWpsWFBhTFZuR0x1MWU2K2RqRXpyK29YOGRrdHpMYVc2d0laSVJJVElwNkVaSHZ6WFVSdytKTkdXT1diVTdWMmpmYjVJUTc1bDljL3hOaXZMNDlOVFJKckc1dTVKL1BaM1pvaEt5TSs0WU80OXhtdldoZjJseG95TDUwZ1NSd3JOT1FmS1pEa3NoOWNkS3Q3YXBEZzBvdGN6dWs3ZExHVmYrT0xkZFVLVHRLenhRSEVTZklBSkRuRGUrUFdwL0RONVplSnROdTRaTlJNVVVjNEtyeXJxQnlvQkFGZEovWW1qWGpHK3RWaHVHMjdaQ3k3WGtVSEcvSjZrVjN3OE8yY01Veldzb3RqT1ZESmhkb1pSMXgycWZkNkpuWlNoT2MrYjRsdjhBRm9jTGNhZGNsWkw2d3Y0cEgyaUZsRVpZc3E4NFBxYzk2NUczMVh4Q0lUYlNGN2lGcFFyV3Z5UnNpN2VPdnZYcnNzTnZERTB0dEhITk9xSGVrY25scTNxU0J4azE1S3VxYUJxbW9reWFkTFl5MnhXUHpUODRMK2hJNjBLVitoRXFjb3U2a2svNWJ1eHZhaEpxTm5ZU3BIYW5MQm04cVJSSUFGSElYYlhoOTlyUHc5OFEyTGZiYjY1MDI1amp5SkVZcXJLZXFvT2hHYTlObDFDS1hVNTdlUVBJUWczTjlvOHZxY2JZKzJQYXN5MDhNV3R0cVJNRFFQQ0d5TGU0aURiVUhEZHYxcWw1N2pwMUxWZWJWdTZ0WjJ0MzdtaHBXbTZuTFlJK2krSXBuV1NLSVFUWFVhczJVUEEzZWxlajZEUEhGQmNXbmlDNkYzZXE3TWozS0Q1bTZreGp1b3JUa1R3N3BGdWx2L2FDUngzU3Nxd3FBTmhia2RPTUExNTVyM2grRzdoamptdXBwWWx4dWRjYnhnL3duT1Q3MVdyT2w4MUxsZTZjbTVMUm8zSi8rRVprdm10cmlXMnRWWXBKRUNGV0lTZEN3eDBKOVRYWDZYTko5b2svdEZiY0xieHBDbDJySXduTE1TTUE5R0E2MTVmYitCdkRrcUN5dXJWNTg0OHFUZXpIYU9Sd0s2ci9BSVFqd21iZjdHOXF6eFJTS3pmdkd5ampwdFlrWTlNVkwwTnFkMjFMVFYyK1I2ZnJHclcxbklZL3RVZHROSWhkV1FaVnR2WnZZMTU5cW1pNlpmMnhXNWlzVXV5aXZIS3dPSEJQb09Sak5hZHMra1NSSUkyU0ZrYllyS2R6YmxIR1ZhdVA4VitIcHRRMEM2TU9weHh0Rjh5WFFjeHVyazhvd1grRTl2U21yWDh5MjNOYTh0bS91UnlEMkhqVFI3dWFTME5yTmJzaE1za0M3aHdNWnczUEE0cURTenJYaUxVQkJZUExwenlXekZwRjNLb0EvaDJuQU9mV3MvUXRPbjArQ09TNnVUSGxTalhGdlA1cU9vT0M3S2ZUdWE3elY1TDhRMi8yYlZVdVlvb0czSUI1VWpaNERBclRhU2RqeUhwZDYyaS9oVDN0Mk9ucy9DNHNMUy9kdFJrZ0Z2RG1YYVEyNHJ3Sk52UWc5Njh5MUx4ZjRiajhQK2JlNmZCZUNaQWplVkZsbjU1YkpIQkhwWHVOdGVMSnBWcVpJVlpwRThwSFVCMU9SbkQ5Y0RpdU0xSHczUE8xMG1uUlEyMDVDdEl6cnVnbDJqcXFqb2ZwVDV1NTEyZ28wL1p4NmFyditaNGxvbnhLMUNlNmgwM1JkT2doc0VtR0kyaUk0UFhqcFgxSmNEU3JhQ2FOemQyVWJ2dGE0amx3QVg0QVVIUEI3Q3ZGZEt0dkhGMWN0YjNHbjJzRnJ3cG1LbEdZRHVnR09sZlJlbU5ickU2dnNuQ25hemw4N3l2cUc0d0t6ZktySFpUbnp5VjQyMFZrM2M0eTRLNlF0bEV2aUs1bkpEb1FWUUtWd1Bsa0I3ODFnZUlkTnVZdFBOeGFhaUlKcEowRUt5UmhVR0JnOEwzSFVHc3JYOUdXZXl1a2lTMVVzUE1sblNRdGdrbkoyODlPbWE1WHd6NEwxTy8xUnJtZlhETkVzTFJCQ1Q1YnIvZEdlalpIVVVYVmprbFZVcWpqR0t1MWVLMTNSMitrZjJuZldpMldxYWRjR0sxK1Jicnp0bjJnTU1oaGc1UHZWcS84TEFXOHkyVTF6T2JGb3pIdGtCdUVRL2VXUGVQbUhjQ3FHcTZMcThaaU50ZVlpVzJ5SWVKZm1IUUFIQjlzNXJFMHJ4amR3WGNkdGMyOGhkMnlaRlhCU1BwKzhQUU1DT3RDYnM3RVNxUWpOUXFSYTB0cjVJMVlielY3S3l2cnl4Z2E5anR0cGxTNExMTGtkeU9wNjVJcTlxZXR5eVdsck1rUXRvaVNKWTRvUWZtSTU2OGpub2FzeWFpMm9hMWFXOXBjbG9uZ0lWb25EZVlGNnNYUHArdGViYTNwUGpXSFU3MjFFc3NWdXlPOEYxR1VJZmJ3QTRIUDRWRm1ZdFQ1WktFbnlwdE9YWm1yclZoOFNMZTNrdmZKdHJ5M2l1R3VRc2tnd0UyNCtaQ001eDB4WE54ZkZEUzdYdzdBc3VrWE1FOHJFZVdzTWlvTjNSa1BBQ2p2VzFwR3RUV2QybG5QcjB3bEtLWmZOWlkwYkFHQms1TzZ0enhIcVhqTzF0cnEvWFdvNVlreUliYllyY25vUVQwQS9XdEcwOUdhMHFsQngxaEs2M2xmZjVzN0ZQRU9ud1JhYUlyOXpMZElKSklWUXlLeWdaTWE1SDN2YXZOTC9XckI5TXVMeTJhSzJFNWFOTFdkVEQ1eUhxcEhPMGcrdGN4YmFock4xQjlzMVM3dHhNSlUySkZLZDVEREc5V1VmTDlLN3Q5QnVyNnpjUjZQRnFNWTJpZTN1NXN5cnQ1RHhQOEF4RDM2MUNXck1JUzl2TndmUjZOTytuZFc2bXJvdHo0ZWkwT05XRnZCTEdBcW9qbDVGVmowNDVZVXR4QmJYenovQU5uNnIrL0NoSkxkd0kvTFJzNTJ0ak9UMk5lTVRmWjdMVzVuczRyaTVpandaclJZMW04dENOcFZYemtWdjZGZTJWL2NTTTFwZWFlaGZFTEdSWTJEZFBja0gzbzJzMHpKT2ZMRk5Sc3JKdTl0UWc4Q2FqSkxiM2o2MUhacEZJZG9FWVIwQy83ZVFHSEhXdlR0QjFYeEhHTHUwdW9iUzloYWI5M2NOc3c4VERERnM5L2J2VTB0aDR4aXRZN2VEVVRmbVRoQzZJSVl2VmRoR1NjZHdhODdodWZFT2l6M0ZoRG9WbGNPVkkrMG00VlE1SEpCVmprRStsUFd6YXN6MC9nbkZwV3NyWGRsL2xjK2paOUh0SmZMRm5ISmF5MjZncGIyN2dRdDJCSVA4cThsOFJlSjlLMHFDQWFwYjNKYVp6RUxxSHVWd1dVc1B1Z210TmRRdnJMVHJhZG9Za1pkck9Hbk1rY0s0L3ZENzNOVjdyeEJwZXFNOWpGcmRwQzd4RXNDQktwa3prRUU0UFQ4UlNUYXNhT3JDU2J0cXQ0clJQN3lsZFpsdHJHOGprTFFTRGN2bHhtVGNqZXJFazhkYTZpd2Z4Q1kxbHQ3S014cyt5VHo1REVDRzVCVGpPVDBHSzVIVGI3U3RLdVRiV0dwd1N5Ui9QNVNCbVl1M0c3dUZ6ME5VZFY4VzMxdGQyY0dvaG1hUm5SYlpNaUtSVC90WSs4dFZaTm5OR1VJeWxMM2xaYXBlbHl4SlphMXBVNE9uWE52TEFqdUZ6TTVlTnM1SzVDc0FlYXRmMnA0azA2UzlNZGdMbVFzcmVVVnlmbXhnSXh3TWR6VEYwalNybVdPYlR0UWExalU0YTNpblZlVHlQbGJrayt0T3R0QUJXNk0xeE5mVzgwalJyR3R3RzhzcjF5UWVub0tkOXJrS01yd2NZdEs5MVo2V1oxZW42dnJrOEVyeGFlSWtaT1FpSTRCSFVQdU9DZlFpckdrK0wwdHlwTnJMRkc2SGZrcXdXVFBRaGNrQnV4TlpFWGcyQzEwcGpwK28zQW5EaGs4OWpJa2ZQT3hVSXh4MEZaR3NhbHJ0bHBGd1pGU0taNGNxeUo1cnVFSUdjWTZrVkt0YzJicTBtcGN6MDI2a21xL1liNi84bHZzRXF4bGd3WjNZZVl3NFU0NkVIOGErZnZFVjU0OTBhN0svd0JqNmRld1FLVWJ5MVh6NGhqZDhyWURBWTVCRmRUYWF4WTZ4NVEvc2lXWGFTWlJIRjVTUzdjRlc2Z2J3YTZtL3N0S1M2VzVtc3ByT1JwQ3N0dzRlWkhKNkw1WUpISTQ0NmRxMDFUN25JcTdqVmszUmpLVDA1WnAyZDF0bzFZOHkwSHhKNFI4VVhLVzJvMkM2ZExza0tibk82VmlPcVA5NVQ2WnlLOTI4UFNlR3RGKzFTVytzemFpNlJJaXlTUDV4Z3ljWnl1QUFPOWViTmJUYXVJOVBmVDQvSldmZEJORkNvWkFUa2ZmMmtjZTliTmhONGEwSlRCY3gzVWl5TWQwVFc0UFA5MGJNZkxucnppaDNPaFZxRW5hbkJRVjlFNWN5VE85dTcyQzd0NXBqQmIvQUxzWkZ4SkdwUW5vQ0FoeWVPNUZlV2FwYjI1LzBlUFV0Rkp3dVk1SVRBd2NISzU0UFVjRWREVzFyUHhJOEw2VDlodHpaVDJrRTl2TDVNalI3UXU0WUlLNHhrOUs0RHczcjNoN1d0Vmp0SDB3WFVMUkt5U3pSbEd3dlQ1dWNNT25wVTJsYnFLclJxeDVKOHNwVTJ0WjhyU1ZuYmZxZCtmRmQ1b2NWbGJYTnRiYm5VU0t5ZzdHT05wRVJPY0RIU3VJMDc0bjJUejNVRDJzNlFCOE1NWUs0NEhYakZlb1dlb2VHYis2ZUk2ZGN6YWhhU09pUnlncVFQUWZ3OERvZTljTmU2aDhNcng3NlNYVVpra1l4eFRJVkVMSXlIREVEMEhmSU9hemF2MFpFS0tuZDJuSzFyYTI1Yjc5Q2FiU1BEdC9ZcnFNaGMzRVlhWHpBd1IyaFB5N1dKK1g1UjA0cjEzd25kNmxkYU5GQmR4eGl5alFLa3l1RWRWSDNXSTU1QSs5WG50cmZhQnBsamR4V212dGNReUdRbzdCVEZLb0h5b1R4aGg2anJXNzRjMUdKN0I3V1RUQmFONWtpZ3hZYmZ0WGNWS3J5RGpveDVxN054dFlpRXBKMDR5bXRJdE5YM3QwMU5odEJ0NExHZnlFc3R6VE9iV1M0VVBuak9Rd0I0WWRzVnFXSmdXUzVNVnBGTEtxSjVnVDVHM2JlUnRPUnRQdlh6NUY0am11ZDZvMFZwSEc0Mm1UZHRCUnVpWUl3eTlhNmEzMTVYMVlTV1ZzZk91Vk1jMHBsekczYk9NWUhyanZVTlNhT09WWGs1UDNmS2s5dC91TkhYdnRhUmFoSmE2TmVKSWJtTnB2S0RLcytPTmluQkdQcFhCM2Q5Zm5TNDcyT3puaCt5emZ2SXB0enMwV2RyZ0VZeHNQdGtaelhXNnAvd0FKanA5Z2JxMnVEZXl4R1NSbnRzZVdJMVBCWlRqRERQSUZKZWVJZkU5aExhM2QxcXpPTGxzeTI3UWIwRVlBSk9NbWlNZmRORW90YzA0YzN2T3ozdXY2Mk54NTU5VThNUzNNbXkzM2JRSkNXd1VKK1Z3VlA0R3J2aHVXNHN0TGd0MGlXQzRnRGJXVzQzTkpsdCtBRDJidG10UFg3Mnl2UEJxWE1jN0NOWmxZcnZhS0FvdzNZeC9kUDhTMTRqY1h1Z3lmWjBPaXd5UjNMcUdlSmo1cU9Ea2JXYzlEN0hrVmJkbzIxM0tqT1VhbE5jMHJOSHR2aUx3L0RyRmdsM3F0cGZMSEhJSndZc0p0R003ajNPQ09PT0s1ZE5Hc0xYVnJlYlM5VXVCS0VKaGlrdVBORXl1dTQ4dGpCSi9NVjZYY1hxVDIreWJWR2pqaVdQRWNnMmphT09KQm44YTh3MTMrd0lkY2hGdkZMQ1JJRzh1MmJMUnlINVE0WmdBVmM4a2V0QzAwN0cxU2Q0cFJuZFhWN3UrcjAwTTdVTld1SVlvaGEydHRITEdRcFJZeEZNQklPVlpUeTROWHRHOE1lSTdtNmptUGxXNmJNUmlRK1VTVzZnZ0FrSDBOZWlhcnJQaDJPMWcvdFNHMmtSRlYzTWkvdjBJK1VOa0hxRDF4WEIrSU5PZS9YejlNMXZ6SW5VSHl4RWRyRHR1SjQzRG9TVFU4eHpMRHhqYWJrbmZwZTJ2NG1tMmcrS3RMV1ZOUHNiZlVKNUxnaDVMdVlTTzdZNUM5dG9IR1RWbU94OFd4YU83U3ZielhNYk96Mit6NU5tQ1ZFYktBR0lIR0R4WEVXV21lTnJXZEpyQ3pXNloxU09XR1c2REFNMmN1RVhCR0FNRW5yWFFRNjNxZ1M1anZvTlZ0TG1KeXF0R2drZ0RucDVaUUU0SG9SMHJSN0k5QnFMbzN0YStydEpkZlF4WDhTQlYrelNURzJCOHRvbk9SRW1XQkNObGNBRVp4MTVyMmROYzhMR1NLMGJVWmhOTnRBM2c0ZkhYZ0Rya2NkSzhwdHJqVklOQ3ZJWnJxSllwbUxSckRBSkhSM09OckJTYzd1Mk1ZcnkvWC9DbW9hVHAwRTM5clhheGljU3pwUER0ZU5INmhtVWt0OUtscnNaMGs3cHByVkpPOTNmVG9lNGVJOUJrVzZ2cm1YVTc5SXAwOHNSUlJibFJjNXlPcFdRZFJ4akZjL3ArbDZWSEtDOTljYW5MYnpiNFZ2WmxBeS9WY3JqRE4yTGNWUTBmeFRkYXhidFo2WkhJWWlyUExQZEFMRVZpQnlVWml6Zk5WdXgvZlhWMzlsbnRZWW5VTTNscGlWbVhCMnVHQk9Ebm9PQ09sRHZvWlZwemhVNUZHMzh5MHZmc2E2MituelgrclNTV082N2hVUEpEQ3dFZUNmbmt3UVNHVWR4bk5RYUFrbDU0a2tzWXhaU2FkQzIrQzNrVlcrWmhrU3g1d2R2WnNkNnc3WStFZE9zSHRMaStZUnlYUlV1MGhieW1mdXJyakFCNmc5cTI3YlJiUzMxSkxuUmIyQy9NS0lOMzJoQU53KytBeERjWTV3UlF0dHlvS2NaUm1vM1hNMDNvcm0vNGpHbS9hTGhSbzV1eXg1RGJYQUdQOWRibHQzeThZSTRyRDAzeGJBVnRsdU5FRnRNVklNazV5REdxNUd3cnVHUGJvYXU2c1BGdG9ZN2hkUCt6dkRJWFdPMGNNTGhYYm5iOHVFeG5Qb2ZTdXh1clRTTlJzb3pQQmUyMHFMdGlqU1R5bUsvZllHUEJDa0hvUjFvZTJ0enJVR25VK0ZkbGI1bk82bnFNRUxQYlI2TXJ1MXVyaEZkVGxBTWpjdTBnL1E4MVEwWHhGcU1rNnl3M1JndG5Rc0lFVWVmR1U0T1ZLNDJBbjhSeml0eTh1dkU5c2lTYWZGWjNrUmpVUkFSa3V5cjJsSmJKYm5nanYxcmhKTmJXeUN2ck4wb3Q3dVJXYVdDRUhaemtKSUh5eTg4YzFQVTVwWGpLS1Y3dVN0Wlc4K2hwcHFXcDI5MWR3UytJMWVHNlJ2cys5V3R5eEp4a09QbGJCNnRpdUg4S2FQNDFzclhWL0t0azFDWTRlQ1NLNkhtS3lNR0NNVHdRZStDSzdtOThSYUZlcGFTYVRESkpCNWMwWkN4dUdSRjVMQlhHMERzVFhiZUcvRUhoeVkrVHVqczNSQkxFWUVCMnJqSDd3b1NwOS93QXFyNWJuVEZQMnpoTlJzM0cvVFZkankxcm53N3FZUzgxYlFkU3ROU1dWL01paGplTGJMbmtlWURnQnUyUjE3MTJQaHJYcm1XUzhoZEJMR2tCeUNOdHg1VEE3UTZuK0lkK29ycURyS1hWemZmYkxPM09uUnhEekpzbVVtVDFDeGdrZTZ0WG5WdjR0OEtYYTNFZGhxRzZTMFFCRWFCZDUzTmhVZkEzWXljWW90Ym9heVVydWNiY3NXNzI2Sy9YeU9BdWZCMS80YTFkOVNzTGkxbXNKOGViYjNwa1l4TTRPM0VxL2RJN0h0M3JxZEUwbUJnbGpxY01yTE1seEh1WUpNRkRIN3FUZ0VFZmxqc2ExN0R4N3E4Q1hNMTFwY1FJamtLeGlObGZ6SVNBZVBseXBYc1J6VFY4WnBmMmd1N1d4Y2Z2R2t1ZGtFbkJmQVpBcHp0eU9SdDlLdFhhMVd2Y21kYjJrMUxYbWpLemZMcnBwcTF1Vk5HOEcyTnBPNzZQZVhFTnNpS3NpWGtSWUVrNEcxdmxPUWVuY1YwVXRqWkM5amd2TlU4dTdtakRlV2toSWNyMEVmSStaZlZobXMrMkd0NjVieFBIYnBKREtTRmtsU1dGbUs4WUtsaVF5Ky9COWFrOFFhanJVTjNaRmtsZUdJQTJ4TnN3eGNJcHlzaHdXVW50ZzQ3MHJOdlZuTlVtM0tvcHdrMjNxNzcrcDBNa043WTJzazZlSVdTT01yOXFTYUxaUEdTTVlrSTNJeURxT2hyaC9FK2w2YmRXMm02amVXY2tvdG5UeXRXdG9qY0JRT1BuQU9BdWZZNHE1TnBlcjYzcGM4R3N4WFhreVJ2TTArSVg4cGxBT2N4bFdZZ2RpS3h2RDNpL1dyVytpWFQ3aUtmU2RpeHZCWnd5U1NSbFc0WUtWVEJidlZMWTZxVm5hWE5PT2pUdHBkUDc5elJ1dkUxcHBNRVU4R2tXMGdQNzFaMWw1dUVZK1dSSXN1MHNXN2tBNFBlc3pUdGMxSFhZRnN6NFhlenMwZDBqVXhFTFB1SjJzbU9BeWRXd2VuU3ZaZGMxcUJJYlc0dExCSm1hNEN2Sk5HMGFxc280RzdCT2M4Y2ZqWGljR3VlS0x5K3ZQN09ld1MwVWJmc3poMGtpZGVzbTBxQVFQWDg2TFBYUW1kTjhzb0pxN1NhZXEyZjNYT0lUd0g4UDlaTmxidmVyWWFoREs0YTJpaTQ4djd3TCtZVkxFOXVlbGUyUStFZkJEank3elhTNEpHV0pTSXl0Rnl1VlRBM3I2K25CcnJiKzF1N2lPTVhkdHB0OURMR3IrZU5zVGtnWUtNVlBUdUNPaHJNZzhJYTFPYlJkUmhpdkZqaVpZM0NDWnZMZHQzemh3TjVJNFk0SDUxVGxjN25WcTFJeGpMbWx5Ykp0dHErcitSTG91bjJWcHA3dzZYY3d6U3loTmhlNEtobWt5Q0pOcDRBSGZIdFN6V25pNjJoaSt5ZUk3VnpFNktWVGNqU3NTZHhlVmdBT3Z5cjBxdHFFOW5vTXNZbHNyYXlXVXNBMGdYQ0VFZnhzQ0FNZERVbW0rTGRMMUtlNHM3eldiVzlQbE1VdGxpS3c3UjFaWGtBTGtZejB3VDByUHB0Y3hqRjhqOTJ6VjFkZEw2anA3L1dZRHFPbjNHdU0xNmJkWkVpWVlmSjVMNUorWlIzMm5COXFiYk5idFkyMDJwWEVrczI4RkpvM0t4Yng4cThEcVBUUE5iMXJKNGQxRzJnV09ZVHh4NTIzY2tid2tIMEQ4YkNEMHJ6enhIcTBOdGFQYm16djdpeWdrUVJLa2JreGtOdWFRQWc3a0I2blBTa2xyWWljVzJ0bjJXN3VldDJkbEhjeE9GV0hFWlV4eW9RekZYR1dRN3ljQUhwME5GY1BvVXRrYm1aWS90RE9VRDdiV2VTT1B5MjVSbCtWamhoMjZBOUtLcXh0VG5Ea1YxYjB1WmtNT3M2N3A5dEs3eVJ3TEwwaUJEdGtjWUo3Vm1IVTlEZzFWWVdsdVZtaWx4SXNoSFFEQSs3MXhXcy9pbUxTWTdRQzhhVlpTV2FNampIUVl4MHhYUDZ4cldtcEhEZVgxaXlHVEtLNnhubzNjazl4VXAzVnJIZ3JrbENOcDgwcnJ6THVyYXhxcTZmY0pKb1RYbHVjQ0tSRlB6OXdlTzljM291b3czOWo1VjllR05wWDhxTlFOc2tiRGtMbnNCWHAramE3WnhHMVdTL204aEZLcENZenVaaU9EbjJybXJ5ZndxdXF4MnMxcTZyT3pPV0F3V0o3NVBRaXMxYmF6S3FSaktFV3FpbFoyMWY0YUdQY2FucDlvMGNXb1c2QjNrRVFtUjhsdjk3SDYxNmhkYUZwRStrQm9FM3JFTXNFSStaanhrK29GZlBuaUx3YjRZZ2plN2d2cFdPL0tJNXcyZXk4OXpXWmNhejR1c1BNRWErUVNxRmxBQlhZT25UK0tyNUpPS2tyMkdseXhTNWVaTldiZGtrL0x1ZXhwcEZ0QnAyNDZqTkcwWUplM0h5Z3FwNzFnM01lbGF0UDVVRXEyeVM0ZWQ4NTJPQmhUVW1oZUpyYlhWdDQ1SDJKR0NzNnNuRHRqako3Vnp0ekRZNlJyRWx4SmVyY1JzQnZ0d3UzSTdjOTZTM09TcENQc3JXNWJTVjFyZTU2RGR3YTdwMXJHc1RSM2NNY1JIbjdpTnpIdWE2UHc3NGl2UWltK2RJQzZFcnVVbFY5OTN2WGsybmVQcFRLOXVMU0tLRU9DaTdzam4wRkw0bXZKTlJ0blEyOTFDZ1g5MkkxeVBYT2FsYS81alZYMmMxeXVWMWIzZDBrejMrVFhkRzArM1dRM3F0TEljaGh5cmV3SHBYUFh1dGFYY3pHNFhXdnNjY2hVYkI4cHllNXpYeVZObzkzcHR2RmRhakxMZlJTeEJFZ2lIenEzVUVrZERYcVdoWEdqNnBDMWpxZmgrYUtCQXJvWEo4eGlQVTljVW1yV3N6MHBTcVNhOTZQSmRhNjIvR3paNm5iK0diS2ZVWHZrMVl5TXcyc1ZiSmtWdXVQU3NPMHM5UHRkZHU3ZWJ6RnVBZ2FHSjJKVWhlNEk0SjlhNDN4QWtzTjNhSm9saExFenNFVkZ5dU8yVG50WFhmWWRXdFFrdHd6Q1NKV0IyamVXM2RTRFZybTZzNFdvcFA4QWQzYWU2ZDcvQUhsNjk4SzZYcUxOck1lTjBLbFhoSXlHSUhQSHJVK21RM1ZqcHR2ZjJ0NHBnWVNEeVhISUlIQVVldWVLakdnYWxieVc5M1phayt4a0phT1ZjcXg5TVZjMDY2MWZVWW8yRm1zVXlUUEhoZ2R2MXgycWZMYzNoQjgwSlNnMUpyVHF0ZjYyTkRTTG5WZGR0TGw3N1RudDNtRzFVWDc0OVd6MnJ6QzB0WmRGMVEyTHRORmJ1M21sNW5HNTJIWEZmU1dvenBaVzhUeXl1TGxjSis3SHlFZXByaVBFT202TE5MYjNON2NMTklVQ1pVNUEzZE9CV3VpMDZIVlhwTlIwdHpidHQyTSsvdEpiTjBtMFlXd2E1UldkcER1WTg4aHZhb29QRWh1YnFld3ViRzFlS1JBaXZFdUR5ZWVPd3FPeThMMlZsSFBLSmJoVjJnSzd0Z25QR0IvaFhTYVhheDJ0K0pvclZndUZFMDdMa3Qvc2lzMUpXT2VOT3R6cEswVTN0dXJIQWEzb0lqaXNiYXdqdTRrbk1oa2tFaEFSQnhuNjE1MnMrbTNlbzIyanRhTlBEWmdFUzRPWkpCMExmU3Zwblg3NjFkeGJvWldrbFVtT1ZGeXE4ODVyeURWVjhXZk9JNUxXQ0J5Tmx5Vkc3MDV4VmN6MHY5NU5TbkNFNUtMdHIwNmZjYUlpMHpUcmxZYnJVNVlDeEFTSmVVNSt2UW12WUxpNHQwUldXNEhsZ0JHR0J6eDFyeFZkTHVkUXM1UkpyMXRjUzIxdXpoakdEbGgzOWFYd2ZlNjNJczhseEhDK1k4THVCN2QvYk5KcTZ2YzJvMUZHOGRMUDRkYnZROUZqdUxHK1pvWVZVU2lUYWo3ZU1xT2xaZW9uUjlNdGpieUV4eVNPV1o1RG41Ky8vd0JZVjBtbVhqS2tjZjdxSGF4LzVaNFBIT2Ntc1h4Rm9kdlBaWE9vM0Z6SGN1b2JZeEdSR01jSEE3aW8wN20wazNSYmlrNUsrL1lxWGZsSnBQMnFHNmpra0lYS0VmTTJPM0hhdkgzZGRUOCs0dU5LK3pNbkhtbksvZDZCTWRhMjlFMFdQVm9MZFlyK1pab3BQTk1tTUZoL2R3T01WNlhxbC9iWE9rdTRhUGZDUUpJMk9HT3p1UGM5cWFkblpzNHBMMnRPNjkxY3ZyZG56NzRrYnhycFZ2TkxIZHExc1ZUeVFqWmVPVHN4QTZWemxqYy9FclVEQmJSc2tiekV0Y1RaenUyOUJYc1duYVJZM0RyZVNTendlY2ZuRE5nazl2cUswMTBxdzIzVnRCcWJFNUFIT0NtZWVEM0pxK1pMZmNWS3BLUEtsU2haYnQ2dmF4NXhxZDVkVzBWdFpYR3BZa2hiTW0wYmNzRG5PNytsZWwyM2lJWEdzSWkzVnVoV0tNUmxXQmQ4Y25OWWtYaGVLK21VTnB5VFJJNVh6R2s1SkhWbXozTmVTK0tkQzF2UjlUbG10dERhZUIyV1FOSHkwZTNqSEZLeWs3THFaMDRWbk84WlBXMWsyb3JUWlhkajdGVFc3VzVhNWl0MlpwV0toMC9pR093QjcxeGZpcncxUGQyZ2tteW9VTTBDQWZPV3hqTE1PMWZPdWllUElybU80ZVJXZ244OVFRVU80Z2V1SzdHODhhWDdhaEROcGs2dWtzYklGbEorVEhWOEdoUWtwV09xcE9UVTRWb1NqSmZKTHFMcXVsZVAvS3Mvc1Z4RzZDSUJvbklQL3dDdXFVSGcyZVM5dFB0TjRWdTR0MDdSTU1BazlRUHBYTTZkRGQzOTFhWGMzaXhGTzRzeW9kbzYvZDlzMTdQY1NxbHd0NUhOQmNMSXhCVXQ4KzBqQjVvZlk0cGNzWVFTbGZsMGJTMXM5NzNTRnVOSjFPNWlpbmwxenpXaVlDRlFtVkQrNDZHdUJUeEZxV2lhK2xucUt5ZVhPd0t4amtidXVRZXc5cTdSN0MzdGRQbnVkQmxhVHk4TzF2dUxrNEhiTlNhZkVmRmVqUXozVVI4NkZqdlZsK2NZN0RGRjlMUFlwSnVWMUdUYVRzMDFabUxmeTJlbzZydWtEb1ZqQlJlaDloazlxaTBXMDFpRHpKNHdsdmwyRE9yYmx3RGpEZ2NjK3RTYTNydmgrMjFLeml1Tk5sWlVCaG40eHNCL2lQdUs2TFVmRTJoNkxwOHNlbVFHNXQ1bTNLcUF0dlp1cTBkTm1FS1Y1dWQ3dHZScmRsS3gvdGFPeWxubW5YYjVqZjZzOWljYnVLckRVOVZ2SmY3THViT0x5blA3eTRQM2ovZHpXWlplT05JdDlKajFFVysyVVpUN0tUZ0Fqa0FnOXEwN2JVMDhhNlUwOHNjbGhjeGo5MFl1UU1ldnNlMUs2dnFyQktuSlU1V2JYdmNyVDY5MGIxOXBtbzJ0aExGQnNCRWVIRWJaUmw2RGcrdGVXU1hGMDhUV2sxdFBieW95N1o0M0piY3B4dEFIR0RYWlcxOURaa1dPb3ptZTRuUmhFUVJ1eW96bml1MDArYTB1N1g1MVk0S0ZTRGgxY2V0UG02TkZ5cHVmTEtMY1U0Nlg4amJrMWJUWXJlM3NyNks0M2tLWFo0aXdZWXdjdFhHbC9EK214ank0cFlvV25QQy9NcFBYSlBiNlYzK3BNNldNWXVicDFaNU1KdUk2anRYTklkRTh1RlRkRVMrYVhJS2pramc0OWFodnlPaW9rNUpYam9rcnZjcFhWN1phcUREWjNUeHlXOGdjK1prYncvUVZNMTlhTHFleTd0MVNlSUJ3ZHdKeDB3RFZxZlZmRGNkek5CYmp6SjVGQllZQWJjdlExODA2MXBPcldWOUpld3lQUE83L0FIWEp4azhuRkpSdWpuazR4ZWtvM2Z6V20xKzNxZlU0dU5IaVM1YmQ4Z2NzNWM3ZG5mdlhtVnVtaWE3ZXlQYjY2OEx4cVhDS01NU0I3OXErZFc4WTZ0TUdhL3NBSWcyeVJUa2hqNlY5VmFQNGZzTHpRSUpyY3hXckZRUTRYOTR2ZmI2NHA3SjY2blJVcDFIcFVwUTBlbHBKcC9ORWRocVlzbFMydkdTYTJtUWdrakxFbnVCNlZTMC9TdkRzVjVld1dkeEVMdVZBMGJQenN4em5GWm12NkdValc0ZExtNGw1RWFxUG00R1B3RmNoNGY4QUJtdVhWd2wzSis0Y2dGOHJsdVBUM3BhMjBmcWN0T05XN2lvLzRWMTlQUTlIMURUZGV0b2JhN3NkZWl6Q3dTWkh3RXlUa25IdlhhWFdqeCtVMTBKN0VQT0drbFpodjNGdXkxalJhTUxhNW11L3NmbnpzQW1HKzZ3NloyK3RZUitITitMcDVyalVBVW1rejVDdHRWQi9DR0hZMWFkMXVkejU0d2RxYmJTMDhtZDhrVFcwVzIzMDZXTGVONk1HL2Ruc2Q0N1Y0Zko0NTFtRFVaTGRZSVcyc3hmRVJ3UUQxRFl4bXZkckxRWjdBWEV6WGt1SFZVaFVQdlRqMnJSdU5QdnBOUE1UT2hERXR0Q0tBNFBZOXhUVGoxUm9xZFNVVTlZTkovZWVkNmpyL2hpUVEyTXl1Ym1ZQmtSa0pDcy9HY2l1bTB5eXRyZTJFYnh4aTNYQ2phU3NqUGprNHJ3MDNuaVMydllXbXNJYldhT2NySklSbFFoNmZwWHFhNmphNmd2K2hnU1hTN28vTUhBWWpuSVdxZDBrcnM0T2VQUGR4VjFaZXA1UjRpMXJ4REpkRzEwdTBrMjI3OXZsSngzSlBlc3JTUEUrdXhGNGJtMlozSTJ5eEZzRWQ4blBVVjdiZmFvWjRGc3J5emVPZFl3eGtRN1BtWGo3M2V1ZXNkVHR3UHMrUTF3a28zeU1vWTdQVFBwUm8xc1JXNUhhS1ViOUphM3YyT2F0L0ZPa1c5a1k0WUpiYWRadk1qU05HK2NqM3JxdFExSHdYcXR4RXozaE1sc29hVjlqSGE1NkJzY1lGZHRiVGFVYlFoNUlmTjNLM3k4NEdhOFd2YkhUZEZ2dFJ1N080U1ZMMlFvME9RYyt1UlNVays2WnI3a0tYdk55Zkt0T3pQV1pmRDl0ZTZlc01pUi92SkZrU2VMSWJKOVI2Vnh1bFErSnRPZVg3TnFGcEpHWlpGZ1NSTVp3ZWZtN210alJydlVGS201bWEyUUFlVVNuQVVqako5SzZrNmZvMTdzbFc3RE9pc2k3U0FxRnY0bEZRbnVPQ2pLS3Q3c3V6c21jcnFQaExUYmk4aDFHKzBpMmhZN1daNHlBU3lkeVBTcU9qS2wwYjJDYTUwNmVPUWxDc1NoRzIraEk5S1pxWTFvYWFkT3VJR3VZZGh4TVJramFlTUZmV3ZKTHZ3THJKU0hWTk5LUlJwRU0vTVZac2NrbFQzRlZkOHU0b3lWU1NXcXN2dEp2WC9JNzYyazAzdzFkUXdRUTNNY1pkektWQmFNeHNlbGRkcFhpblJtUzRlRkRIQ3NwWGZPd1ZWNzRIdFhrR2w2aHFXb2xaWU5Ta010c0FIRExsY2R3ZXg5cTlFMWJ3M3BHclc5c3Q5YnNzVGhwQXFOc084am1uSGwzdnVjMEtudk56Y28rOTcybDNydnZZcS8yL3dDQi93RGhJelp6WE1NenlMKzZlSUYvbUp6eWE1MjlzdkQwTjRKTFcyYWE1V1ZnOGlzUUFRYzlCVy9iNlJvL2hMVDdTVkxQN1Fxa256UEx5d3owWFBYTlhqb0dqUmFrdC9GS3NMeXFISzRJL3dCWU9NanBWdExkTjJMeENwdFNqU3ZGV3MzMWxmOEFUN3oxblF0VnY3MjF0SmpiUmtMdkxJVitkMXh4eWU5VXJheThQUVF6YTB0bUdkaXdrQWNrS1Y0STI1eHhYQ1J4YXRIYmFqYlFha0NraTd0L1JralBYYWVNR3ZQOU1zOVQwMkM1a3RyU1poSkxnN25MSTNxVDlmV2xGRFdJNUlLTGk1UzduVjYzNCs4TGFmcEZ3MWdJQXhPL1pnN2llK085ZVVXSHhXdDlhbSt6eWFoTGJod3BBVkFNTkdlNVBZMTMwMnEzYithSi9Dc0R5SkdDWFdQSUtuM0hldVVYd2o0ZnU3cVc4ZlRianlpRmFOSTR0cXJucUMzdFVwWGZVM2pVd2s0elZTTlZUbGZsbENTc3JkMVk5bDBmdzNhMzgwOTZVa3VsbGtWNGlBWWxBL0QxcnJkVXRWdDBuV0RWSHRHWWdORTN6REo2RVZ6aXdYT2l5Q2UwMWVWWVBzK3hiZVhsWTI5VDZqSFN1M1M1ZThndGJrVzBidXo3VmtBNHg2MDNlNWRPbFFqQnhVZmV0djFPWXV0Rm0xVzBzR3V5MXkwWkl5RUNFSG9kdnNSWExYbmhxT3hzTGkwczdWNWtTWW1NU1pMTXg0eGsvd0E2K2pwZExLUVRocndSN1Nzb0lBVUFZNUE5cTVQVWRLalFXcy85bzdmTElaU1crVVo3ajNwSTZaNFZxTHV1MTllMmg1dzFycE9sUytaZlRlUktpUkxIR3I4b1QxNHJlanY5U1dDZHZzejN5TElTcktGSG1JUjA1OUs2ZSs4UFI2cVM4N1FzN0tNc0ZCM0Vjak9hOHNlWFdyVy9nZ2pFVWFTc1kyZU01VmU1T0RSYzU1UmRKUlN1azlGM2ZxWGJidzlvYzlnNnhTelF6RnN5UnEzektYNXdNZWxkRHBHbTJZbGlzN1ZFYU9OZzhpeThPekRxZnBYbG02YlM5ZXN0bDFLWXB3NW1aVlZrTzNwd085V05WMG01dWRYc05TaGlhYU1nZ0NPVWJYM0hzUDcxTnE3M000T21sRjhpNXIrOVpYdWVwWCtsYWJCdEUra3htVTVJbGpYbmFyWndmNTFhbFhSNTRwQUxmN1RKS3B3QVN1U09jRWp0N1V2OXFlSUZsc3JCclJrekg5NVZETUNlQURucGp2VTJremFyZjZWS1FpV2NxYm85MkJoNU9nZkZDdXRUMHZkY2x5eDI3eDZtVzk1NFhRdGJhbWxwWnorU3JxdjNteXY4VzV1MWMzb3ZpVFJta2tNVFJPdm5FeGdwaER1NmtrLy9BS3F5MjFlTFNMdUt6OFM2VXNpeU1WaW5NZm1LNGJralBibm11dm5zUEQwaVhyVzlpU2x4aU1KdTJJT001VWV0UFR6Smw3OFl2Uk9OOTFZYU5ZdmJSYmlhTFVyUklJUmtBeDczVWV4Qnozcno2eDhWM09xeU9VaTFBYm0yc2pJcGkzWnlHejZHdG5RUENzdWp5K2RQYndRd0ZkM21NQzVBNmJmcWF2MnI2N1k2dEtZcldDNHRacEZQbktjWVh1Q3A0eU8xQ3RkbkpLVStSY3phdmYxWHlPeWswK2VhNXQ3aDcyenRKWklTZ0JYR1hZWUhYZ2tWbFduaERXNElwdnRzZHBlSXpCakFwS29Iejk0NDY1NzEwaDFDeHZma2EzSkhtZ1F5eGdNVXh6a0NxTW1yeTM5bGVRMnVyeXd5MnpicEJOYi9BRE11T1FPbjZWTVdqdWhDam83dDliMzNQRjlPMFNEV05idUgwMlkyc1VUYmJuekV4QnN4Z3JHRGdISkhXdXZ1ZGQwNjF0eloyZjJTV1VNb0xMZ0E0UEkrdGNRZkRHb1g4VnZkWG12NzdWaHVlR1g5d0J6MEdEbjg2N2V4OE0yK2xTeWVaQUxxR1hhUmNySUNJMVhuTEE5K2UzV2lXdTcyT0tUYmJzOTk1ZjBpanB1aWFESlpmMmlseE5hdjlxSXVZMG44cEh5T2dIR1JuMHJ2N0JiSnRVczMweFF5STVqdVhrbktqT09XQVAzaUt5ZFk4TmFacjFva1VNc3EydTVDWFVqSllIcVQvZHJtcnJ3bjRkVFNvTE5OVWtpbHRuYVFlVTJKRElUamxUeVJTYjgva2F3ZzBvU2RycGZFMytSMW5qYTZ0ejRadXJPYlVYU1JFa1l6SWNIbjdvTzNKVWRPZTlmRlhoT3g4VmxvSlgxRVhObVhWSm1obDNHTXQwYmIzOTYreDlJMUh3NWJXOFl2QjVFOXhHVWtOd3UxSi9MNFBMY1lBOUs3YTE4T2VIWmJlQ2JSMnNsaU1qdVNFQXlwL3VrZWg5YUU5N3E1MEtWV3JScUpSZzFOTGRhcjA2bmtUYURZeDZVZFFqZDVvbFIvUGlEa2lRRVkzQlY1d0s5TWlzdkJVMm1tMmd2UHNrczlvb1ZWbHc2aGhuSUIvaTk2aXY4QVRydlNwbnViVzRoZUV4Rm1jeGdIS2M3ZU8xY1ViU3oxMlk2bGkyOHBVM1lSQVpCSjNWZ2UxSzdPS0VWU2xhTk5jMWtyUDgwenp1dzAzVlpyaVBTN2JYZk90MG1PWm9sSWxWbFAzU3pkUml1aThUK0U1ektMZUsvbVdDZFVGd1dPNVRJRHdXeHlBUjFyZDhUNnJiNmFBSUxZUitWR3NrbTJJNW1qYmpnam9mYXZNVjhQUWFxOEdwYVpxOHNFK1RLMm1UTVVlUlY3alA4QUtrbks2MDBNdVM3a2xwSk50U3RvbXVpOVQzWFJyQzAwZlRmS3RCYVJTb2ZMUnkyUXc5Y24yNlY1eGErSUw2SFhBYnE3S1FKSzdTV2VETVpFSTZ4NDZIdlROQzhTZUVydWFRTnBjMzJvZktyU05oQVIvRUZQQWIycnZtdTlNMW1PWkxLN2pqdW8yMnR1UUhCVVlCQnhrQTBQZDM3RnB6NVlxNlVvdS9MZTkvWHpPVTFiUnZEYXZBMEZyTEo1Zzg1bVVmNnZKNEp6eHllMWRRMnEzT3A2ZmRSdFpTdERhcVZjeUFCanM3aGV1M0hlbWFKSDRzaXNMZU52Sm1FUmZ6bEREZG5QRmVkYW40cTF5RFZHalc3dXJaUWpTU2JZQXloYzR3eHFscjJiOVRKUmFqSjJrcjdwUk9rYnhScGVrK0hwYnNhTmN4d3V3L2ZMRUdWQVQxL3dxanAzanpUVHFjZGpMZTNGdUpRcndPWWRody91ZWg5NjdqUk5ZbXZMTFpZdlpyRlA4OEpranl4QzhrU0owNTYxekhpZlNkTHQ3K050VXQ0QTdoUTBoZHZMWkQvZFUvZFlHbFpHOFZGVTR2WDNiclRSWFpXdk5Pc2pmM04vYVcxNHF5ekNObldVQlpDUDRwQU9nYjJyemZYL0FBWXMwVnhkR1dlMG5VSFpHSTJJWTR6c0RlbnBYdDlsSDRmZ1VXMXRQc0RPaStUNXhaR3gzWHVNaXVTMW00MUdPMnRiaTV0WENwTVJMdFlrQUE4SDNCRk5zNTd1UDd4U1hNdTJ4NGJwbm5qWkhlK0lab0ZqVU1HV1F4RlVIYjYxdjZ4OE9mQ212enBOWmFwUGJTVEhkRWZOM21WajBPMXYxTmVzM21rdmM2cEZkMitrUVNUUjJteUtSUmt1TVp6c09Ca1Z5Vng0bzhRNmRhWFNYZGtSTmF3cVlvakRrTms4RU1vNEk5UldsK1cxdERXamlLOUtxcHdxVFVuYlZKSlhmUzNZNWJ3MTRiMWp3cmUyME9xM0YrMEV6Qk44SkRxaFBUekkyQitYMU5lbGFwcHNXb2F0QmEzdCt1d1NrTDltc1JDMjFEMUxqa0RIZm9hem8vRjg4ME1jMXhEZHRkMnlLSkFyNVYxSUdUazlWNTZIbXRmVmZFTFBvOGR6YlhNS0dTM2tSSXVja2RDcEo1VWV3cVZlK3dUciswcVRsZldVcnlhc2svdTBLK25lRXREdDlRdWJhTzV2YktTNVZCRkk4amRRZXFFOVJucU8xZDAzaHVDNWxNZDhXbnViUlN5eHE3SHA4cGtCN2tqa2l2SHJQVmZpRkpiMmNVMWltYlpDMFRvZ2tLQThGZzJlU1IxelczSGRYOG1teng2bGN5d1hFaktQTzVEdXVlbVIwT08xRm5kYW1WV3BGVGFsSG1mVjMzVnZ4T3RqMGZUTkpGMmpzdHk2WUtwa0hZaEdjWmNaem11ZjhSUzNXazJ0bGVhZDRXaG5qbkRmYVpJZ0drUWs0SU1ha1pJSGVyZHRZYTlhM0NYSDlvMnQ5YmNnQzRqS1NJZTJDZXArdGFOamJyRUlyMkM2dGc2N2pzaFp3eEpPRHVVZnpvdWt0VFNGVnhxUmk0ODBYRzZpdHZ2T1UxcWJUTGFMUzlaMGpVYnUwa2tjQ2UwbERmT0ZHUGxEL2Q1cTdhZUl2TnZvcHhxaXE1STNSM0N1WWo3RXFNRVo2VSsydExUV2I4M04zZUpiM01ETDVjM21HUmkvSTJ1SkFCOUtyZUtKTHUzc29oUHJrMHlQbU1TMjhTNVVrLzdORHRvYzFXWHRIRjZxeldpOHU1MHR6cVY3S3hFbG1rYXlZeEw5cGpGdjF3V1h2a2YzYStlOVExTHhQTHFJbHNkYWlWSXBtVkVoa1o5d1UvTGtkQm4xRmRKNGNoOExYRTAybnFiM1VadGhrSzNERUtHUFYxQzg0OVJYdE1PbjZiT3YyUWFZc0JWY0FSSHpZdDYveEZjY01QclMxMnNkZks0eWxLeTVyYWMwYnAzVzltZVo2dEQ0bzFXenQzV0dlRzRVa3k0K2RzOUNVMjRMWi9TdFNkdGJoYTJzMnNZbW1OdTVRTyt4eUdPQ0NEa05ra0d0K3dTKzBVdGR3STh4VVBHck51SmhKL2oya2tNQjJ4VVd2YWpjeldjVnhjdGJYYyt3U0tKQUxkK09QbHgrZWF0YkxRNGFjS2ZzMXphU2QvZGZaK2JPYkdqZUpyeVRUbm5TMEEwNURtTm5VbzJmWGZua2RLNkRSOVM4TTM4YXlSbzlnYlZaVWJabG1CSEpRRVpCRmNNbmpIVmRQdDdPV3lzb1pyS09NdGNSbVR6U2hiOE1uSjlhNFd6OGMrSnJtNmpOell0OWt1WmkwcW9xd29BM0dEeGtacE81M1VxQ2RKelVVN2RHNHExcnUzcWU0YTdyY2x4UGF5NmZhYWl6Q01TTVpJakc1MjhNdU9qREhPTTF4Y09oYUhyVWNlcmYyRGIzRWtWd3duWUJvR2tVOVE4Y3ZIYkdQeXIwUFY3ZlZmS1crdGJlNmk4NUZCTVU0ZFdBK1Vid2Z1bnNUWG0xenBlb3k2dmMyZDdxNndwZHFpRkpRR2lmWWNqQkhSajYrdFd0bGJjbHpuR1RjWEtEbHUwMnRIMHQ1bnBuaDNTTkRBdWJTeXNEWjIwd0dJNTh5cWdmazdBeElLK25jVjU2L2dyeGhiWEZyOWxsdHIveVdPOVJLVmVGbFB5N1FTQ01yMEp6aXZiN0M1MDZ3dDdXeXZKN0swaktyRkdPakZ1aFB6NHlENjF3R29SSHdwcUN5TnFFTndzZ2J5eEdtU0Z4eVNSdXljZnBVV2V1dDJ6V1RrNDg4bHpOdThtOTdzNWRiZlVuV1dlVFNyZDdWaGhwR01jYzYzQkdHUm1mSTNkK1J5S2hqOE42bmVTUjNONWVXaDJEbExVN1pJd2NLckhieHgrVlhyZnhqcDF6S3RtTk1rWkJLWlZrUWM3aU1aS25xY2RLOU4wN1Q0RndkTXZZL21iYzlyTW1KQzdIY2RwT05ySDA2VVg2SExKOHlVWFphZWovQUJLRmo0WjFBM04ySk5kdTQ5MytyWkFKUUVIOTVsNE9hbGdpV1RXSGlsMGVXNUhtdXFsbzJpVjQxQUJNd2IxL2hJNjFuYWQ0MThLU3hTMkZqR2JlNnQ1NURjV2NqT3J5RUhMQWV2MHJMdkJCNGp1NUx6VGZGSmdTR05ZMWprRHB0UFVjazgrM2FwVFd2UTZuU2pIM09WeGE1VzdydVkrdWZEelU3cUdPeXNiMlJkUGtsRDNFUUlkdHlrNENCejhweHd4emcxdjZQOE85RGpzVWlpZWVRZVlXUXZLcjVZai9BRlpWZU9EWGxWOTRtMTNUNWJxSFZMLzdTMGVVVVFLUWs2cWM1WWRNMUhvL2lpeDFLU2FPN25XMmt0L250bEFLQ1FxUCtXcEhRanRWTjJTMUlsS3U0U2lvT1ZPTjNkUFJ2YS9jK25OQzhHeGYyWGNXOTIxMmdqT1E4c2lxVUw4bE9PQ1BTdEhVZE5taWpkVEcwOEF0L3Y3bEcxbFBCd1EzUGNpdVFqOGJXV2g2WEJKREJGZDJzakdPVjR3ek9oSzVPNHRrWXo2MCt5OFFYRWZoQzd1TGVHVzRsbExlVEZBU3BVTTJRVC9zajFyTzZOSUtoWkpLemNYZVM4dFRnOVp1RTBxNXQ0cnF4aXZidDRTREZEYnB1QWJsV1BUR1I3MU5vZGxlM052Wlg0K3drTk9VVlhkaklySG5hNFhnSHZ6WGRXWGlLK211N09XOEwyeWlaV0tTQU9qNEdTb09PY0grRW5wVGRZZ3RMVFV2N1FaUUo3cVhkSktnV0xZQXVPamNiY2ZqVnF6c2MwbzRlVVZKTnUzWHNtVi83WXQ1TlZ1N1dHemp0N3RKVmFaNDBMUEtJamdrSEkzTU00cWJVZFI4U1hrb3NVczBtaGR2TWVWbmt0OGd0aGxCeGdQajE2VmgzbmhDOGt1TlF2TFBWUzB0NUttRitVcENDdkpCUThGc2NHbWFmYmVKTE5MZU84dmlrYkZ3ZHpzZUY3UG5CK1lad2FwSmFPOXphVXBVNU50dVNkdXU2OHpOMC9SMzBDUFdkdWx2YUpFd1o3NVpGbU1neVNvRE5uZHo2YzFRbjhiK0o3NndOdjhBWW9MbU40eHU4Mk1sWFpUbk85Umdldk5XcDlVc2JPNGp2TFZMaVN5ZUFxVktob1RKRytBQ0NlRCtIVG10MDNzTjA3SzFoSll3TkVwZWFKc0tqOW1CR1FDYzhqdlNhdnFjOVRFUG52elM3TlhiKzh6SjlVMXNlSFZuTmhweXlsU1RiMjZreW5qNWd3NDQ2SGpvYXlmRHZpTzBnaXM1cis3VzhlUmd4WnBWTHhTRG9nSkdPdlk5NjZxMnVaOU11WW9oZGg1UHZRVFNESWZKMjVrQ2o1UjZudFZPUHdiSnFmaUc1dWRVME8wOHJadGtuVzZDN202cWRpNEJQb2FqUWloS1ZSeTBhYWx1a250NjlEYTFXOWt1SkxlZXphRzR0MzNMY1dNa1VhU3V3NXkrQ0E0NTRQVVZCYitIL0Q4c0VUSHcrdGxjTXZuTXVTSW1Dbjd4MkhESDI0T0s4cTE3d1Q0TkVxYjU1OUxudXQza3lPVEpBSk05TXFUc1lZelhvR2dlSG9ZZEpraHROVGd2Skk1RklrbG44N2JnNTVUZzRQUFE4VTNhMjUzVkVrcnFwek9XNmNiTFR0cXk5cVd1M0drYVJhWEdtWHdTM0Y3NVE4bUx6VHQ2TkdmTk9BVnp4bm1ycGxzSU5UVi83VTFpVXlzR21SbzFsaUlrNURQdHdNWjZZcmhKYmV3djdpQ3hqc1hSQmNpUzRnVEJZeVFqaHMvb081cXY0aDB2VE5jczdtNzAxTGhaYmNCVExNRGJ4dXF0eXVSZ0hHZTRIdlRiVmlZMUZVZ2twSzBXazFiWitSNi9lMkZqZVF0Ylg5MnR6Q2preHRhZ1JYRU83N3VBTUFnVjU3Y0xvVmxxNVdkdFlsRjBoU2E0WEVxUzg1Mk1qTGpJNjhjMDNUb2JKZEUreVhPdGFaYXI4aDg2TkFXQzV5UktHeXYweFczbytrUjI4ODA5dnFWclBiUWx5SmpJM2xzQnlGa1Z3UUQ3clVKZDJaOHpseXRKV3ZyMS9NN1R3dDRpOEx4SVYwYlY0aEZiNUxxVkVnVUU0d1VISzd1eEhmZzFrNng0NHRiYS9OdnBGckZxTTB6dG1HSWZaOE8vQkUyNWNBRDNOWVhnclI0WWJ2N2ZwNkxacE9HQkZ0R3BBVS94aGpuSVB2VzdGcGs5emRlWkpyYVhjd2taeDV3QWRSMkdGeUc2Y0U4VlZ6MFZWV25LdmR1clgwOVR6KzU4VGFjYlRmcUdwMnF4N3ZMa3Q0SVhsTWcvaS9lQVpMRHBtc2ZSZGU4QXhOUGVhVnBqWEJ5SXJpYVpDSm1CT1J0VWNrZS9YMXIzUTZ1cTNpUlhFb1dKVXl5QXF2dGxNSEJHTzJLSjQvREdJYnVPMWp1UE1keUNrbXlNakh6QmgwQkhYNjFYTXZNd3RDTUpXbDcxOVh6ZEw5ckhCeTJpWEZ4TGV5ZUdyN0VMcThNVUxxeFpXNVdUeTJYdDN6ViswazFXNjFoUFAwSjQ0RmxqWVR5VE1nNlpBWHloaG5CNHdlbGRERnI1MHkxVVJ4VEdGV0tlWVA4QVNXTzhiZ2VUblljOEd2TU5SK0pxV2wxTmE2aHBMQ0l1cUFubDNVL05sUU1FQWVuVVVycTlrVENOT1ZvcldXOXJIb3V0YWJBekNaaXl4TktVZVh6WEFVNTNBdUkvbUI3Y1Z2V0dpWGR0ZG1DVFU1WHRHVENRaVJuRWdZWnd4bEdNZlRGZUt6V043UHFBdnRHanNHaGtHY3V6d3lCcE9SdkNQODMrOWl1bjB0UEdGM0FMZlVOTFY1QS96U0l6QmdGNk83c2VVb0tYSmU5dXFORFZMVFVZTGtSdm9lbnpXVXpBd1NNNFpoZ2NoR0dNTU1kTTF3K3U2UjR6MWUwUUxmV2x3L21vSVkxSGt5ZVN2OFFkR0FZRDM1NHIwbHpxZW1hZVhzSWRQdVFyRXpva3FncnU1TEt1Y1pIcFhtK3RXMmx3Mzl2ZHp3dkM3cWp4WE5sR3hpY0U4aHdqRUEvVDhhdFBYdUVkSkpwYnJiZmJVOUgwZlR2aUpEZDJ4ZldrdWJmWUNFYUVTUmgwSEFCNGNrNDY5cVM1MXEwMU5idS91b2ZJbkVwQ3R0Yi9BRWQ0eDFZUHdQY0UxQm9aZzFCcFVpdFpyenk0eXdhZG5oTVRuN3Z5S0FEei9FRDBxN3Ayc2kvV2RwcERhUWdORThFa0Jkam5nbkwvQUhzSFBOVHFrK2hwenk1WWF1MHU5dExmY1ZQREdwNm5OYVh3dTlVczd4SFpYUzJGcUlYY09PZktLazdqNzV4VnJUcmJVelBBaWVIcnZhTU1yM1Z6dWxCSEJBREhJWDF4V1ZhMm5nbUxWRmxzOVl0YnJ5Z0VrUnBXU1JFeGpHd0VLUm4ycXhxeStLTGx0T2wwQy90VWtoYy9hNEZsS0s2ajV0OFJrQncvWTlxbFBYUTA1WmN5VXFpVCtTdXR6c2IzVTlTMUtMN05KWlRNNktmTWVTRStTdlVBWVA4QXJFYm9RdlRyV1hEYjI4OEVOakxvbW1pOXRZbVMzTUJKV04rbUYzQUVEdWV0UVNhdnJWdGJwTE5xYWs3Q1dsdkdWWmxBNkZHUlNNRHB5djQxd3ZtTFBaM0YvSGVsNDdoeWtreXVzd0d6NVNVV1BZWTJIWFA2VlZ4VHFxV3FiODIxMEk1NElkSjA1WlRwOSt0eExKaVdPMno1T000eE1ybGh0UFVISDByWDFXNDFhWFNGZU8xTHRrelF5aDQ0MlJFR0Q4cmhjRWYzYzF6NmEzcXVseC9hYkpKdFZnYklCUnBEc0sveEVrRFlleFhuUFd1bVg0azNwMDhGckNieVdoS1NvWTMzSzNxWk5vNDdjaXE2WHNjNm5TVVkzNWt0cjczOWJIT3grTFRwVnJiUzNFcjdwVkkyeVErUXdPZWNNdnlNUHB6UlhUWG12WDlyWVd0ekk2dkZObFZobVpKT1Y1RDUyOEVnNHhSVWE5Z2o3UGxWbFBWWDN0K2h6WGlUVHJYVHRHZ3VMVlBMa1NNYlNPY2ZuWG0xajRzMWlXM1MybmtTZU1PUDlZdVQ4dy9DaWlpSFE4aGFKMjAxWDVIcFdnR1JkQmxjeXV6SmRmS1dQUUR0OUs3Mkt5czcyNE04OEN2SXVkckh0OUtLS3lmeHM3bHJDS2UxM29mbjU4WjcyNlR4YTZwS3lLZ1FLaW5DL2R6bkhyWHFId3gwNUwrM2htdUxpZDJicUMrUWNkc0h0UlJYc3R2NnN0VDc3TWtsd3hoYkxkcFAwdWU0YVhBa1dwM05taHhGTk5sOEFaUHRuSFN1UitJVm5IS1pvbUxiWVljTGpBUHJ5YUtLOHMvT2FUYTVOZHB4L004WXQ5U2wwOFJReFF3c3BqQnk2YmpuNjE5bnJESFBvdW5xVjJodG1kcEk0eG5IMG9vcVpIVFRTOXJWZHRXdFg4enRIdDRMR09NMjhTSU1nNDJnako3ODFrYTljYkVNb2pUZUR0emp0bnBSUlVvMnhDU2cwdHJvNWIrMnJ1YXhlY3JHSkRJVkRLQ05vNmNjMXhkbjRoMVArMC9zck9IaWtaUVEyU2NFWjRORkZIUitodzFwU1ZTR3IyT3NpOFVhblorSVBzMFhsaUpJMktxVnpnNHpucjFwOXY0bDFWYlh6L01YZk5sM09NWlBQcFJSVlBaR2RPcFVidHp5MG5LMnZtalIwL1hyMi9zWmpjTEhJTnBPQ3ZHYzQ5YXZlR05Kc2JlNlYxanlXZmNReDNEUDQwVVZQUm5kVy9qVXZVN3U0dEkyU1dkaXpObjdwT1Y0OXE4dDhiYXRxdjJLelpMeVdJQmhoWXlGWGp2aWlpczRmRXZVN2NRMnFWU3oreVlYaFR6OVQwN1ZHdUxtVW1PVWJDR0F4K2xlZzZWYVFTa1dzb01rUlRjUTNQZWlpdFpmcWViaDlZUXYxV3BXMURSTk4wenhMWUMxZ0VZbXlIQTZHdTVsQzJqM2FSS0FHR1NjYzlNMFVWQzZlaHZCSmUxc2tyVGR2dU9GaVJkUnQ1aGNaT1lYNUIybjA3VjBOeWtGdDRVRnZGQWlvbTJNY0VrcWV1YzlUUlJTZTQ2R3RHbytyaTlUd0t6U1N5OFlCTGVlV09NeGc3QTN5amNCbmlzRHgvY3pXay8ybUZ5cnVpcTNjRURuT0Qzb29yV1A4VDVIRDl1QzZjMGRENkEwNjB0cjNTTEtlZU1NNGdRK2d5UjF4V1Y0cHQ0MDA0engvdTNWa3dVNDc0b29xWi9HalN0R0t3MDJraytWYS9JNEI0WlpOTnZwUHRkd3AreXMrRmZBM0Faeml2SVBCUGl2eEF5d05MZlNUR1FzcmVZZDJRcHdCUlJXOWxZem9OLzJiVmw5cFNwMmZWWFRPdml1aTl6NWdpaVFtUnQyMUFOMlBYUE5kcHJDUUQ3VXZrUi9MRW9VN2NFQTljVVVWbkJ1NlBLdzJ0T3FlSDJGalozRmhlU3RBaXRHcnNOb3dNajFydGZoM2Z5eTJmbVNwSEl4Y0lOeTUycVQyOUtLS3FleStaNk5QM29UY3RXcXNiTjYyM1BYdEx1MnNMVFUzdG9vNHlzeWdZWG9HNmlwUERldDNrWGlDNWdVUmhDTngrWG5PU0tLS3greVhoWk85UFY3UDh6czlUMCt6dTN2SVpJVjJ2RnVZZ2ZNU2Nuclhrbmg2d2ppdEF3a2Nza255a2tmTHQ3RGlpaXFiZksva2RtSlM1bzZkU3JZK0hOSmsxcTdsa2gzNWsrWkdPVUpQY2l1cnZiOTlGczJGcERFb2trWU1DdkdCOUNLS0tUM1J5VU5ZM2VyVDBmeU1QVmRDMHUrdXJDK2tnMjNFYXVWZEdLbnAwK2xlT2VIZFF1WVM0RGJzeXZrdHllT241VVVWckhWSTVNVktUbzFkWDd2S2w1YnZROVo4UDZoY2F1ME1sNlJLMGNqaFNmYXVlMXkzVzJuZ2VObnlaV2ZKT2NFNDZlMUZGUTkvbVl5YjVHKysvNEhwLzhBd2oybVBhTGRGRzg5SXBIRW1mbUpBNzEwY0ZqYURRWXBEQ3JPc2U3TGNuSjdtaWlpWHdvNzZNWThpMFg4TTREU05OMDdWTFNlSzV0WXlva0xEYU1janZXZHIrYk9LMit6czBSMzQzS3hCd0QwTkZGVERXYU1rbDlXZzdhMk9vMGpVYnFiUm9wWkgzT1hJSlBvRFhaYXpNOXRmU3lSbkJTMTNLTzI0ZC9yUlJVUGRuclVXL1pKMzEwT0p0OVN1bzNna0xiMkpYNzJUMUdlMks3elY0UE1zWGtFc2lOTWZuS3RqT1JSUlQ2b3hUYmpXdTc2TTVuUXJpZUhVSTlQRWpQQkZoa0RrazUrdGU0Q3pna2pWMkJMZk1PdEZGVjFaMFlMV2k3Nm5sR3U2cGNJL2w3WXlyVzV6bGMxOHVheHFsenBVa1UxbUZoa1ZoaGxIUE5GRlg5bCtoNWxadDRtRjlkVGUwUFdienhQZFhVV3A3WlVoakRJQUN1RCtCcnRZYmo3SFp6eVF4UmhoTUZCSzU0SDFvb3BRK0JFdjQvdi9JTlowK0RVTDZLU1hjcCt6aHNJZGd6K0ZXL0MyazZiY3dUR1MxUXZGdVVQL0VSbnZSUlM2L2NZUzF4Q1hTelBYaG9XbmF0WjdycEdZMjVLSnRZcndCMzlhK1ExdHZzZmkxOU90NXBZb0VqWnh0YjVzaHNjazBVVWZaWjZNa25QVlh2Q1Yva3REM0hWdFkxTFNOS2hlMXVHQjNLcDNnTmtOMXptdGUvMTI4ZzBwSmxTSXVkcW5LNUdHSFBGRkZPUHcvTXpwTit6bHE5UDhrY3I0WXZaRmoxRkZqalVTWjNFSUFlS2oxUFRCZWVIN2llUzd1QTltU1lkcmdBZHVlT2FLS1QrTmVwbmgwbkNsZlhSL21jam9lcGFqTkJtYTdrbENvemhId1Z5dlE0eFd4NFExbS8xbGJrM2JnbEh3Tm94d0QwK2xGRlgzT2FYOFdYK0pma08xWFY3cTBnRWFMR3lrNHc2NTRQYXZaZE52WnJteHRrY0tCSVFHMmpHUmlpaWxJOUtodS9RMVlMbVdDQ1NLUENxSml1Y0FuQTU3MTVqcUhpM1diSy9sdG9aRUVRZFBsSzV6dTY1b29yTmZFUlVsSktObTEwMFBhVVdHNGhobW1namRpdURsZURuMUZjaFlXa2RuYjZySEN6cW9qWmxHNGtJZjluUFNpaXRWMU95WDhXRDhuK1JVMU9KWmRFdDQzTE1MbUZESVN4eVQwcmo1dkNOakRwa2thM2w3dDgrSWdHYk9QcGtjVVVWVU92eU9PdEtYdHFhdTdXMkwvaHp3cmFQcU9xdkplMzBodFhKaDNUbkM5dWc0clp2YlcxanNyV013cStaQ043WkxjZzl4aWlpcHFmR3ZSSFZpRXZaUDBPQThMZUc5T0d0RkNaV1F3eU5zWjhnRTVIQXJ1N2ExU3gxUFQxZ1poSEI1aFNJNEtCa3lRMk1kYUtLMmY2R1ZOdTBIMTV0eS80ZHZyclZOVHVibTZrTHlibVRnNEcwOXEwdE9oaVRjeUxzTVprQzRKL2hQR2M1b29yQ2U1MlVXM1NUYjF2TFUxYmZVWmIySW00ampsOHVRYmR5NXg3L0FGcW5jYWxMSm9FODdRdzcwZDNYNUFNTW1jRWZsUlJXUzNmeU5ydmxmK0dSNHA0TjFyVk5VMCtTUzd1WGw4dVptUkNmbEJCNDRyc3ZHMHoyV2sya3NXTnp5a0hQVDVoeWFLSzMrMGp5S3Y4QURyZVgrWnY2UGNtMnM3V09HS09NTzRWaW93Y2ZXdG5WSUxaSjRZeENwRTdFdG5PUWV2QnpSUlVQN1hxZDFMK0JIMFI4TS9HWFRZN1BYTFFRenpLa3lobVRmbGMrd05laStHRE8rdGFWL3BNeXBMcHNqU1JCdmtaazRCSU9hS0sxU1hzMGVsaVVsZ2NGWkxXTmM5d3VMNjR0YnEwZ1FneHZidVdWdW1jWnp4aXNuUjFoMVRTZjdVbWhSYnFLWEFkQVZ5QjJQV2lpc1h1ZUZRMXRmWGZmMFBUTEpvUEVtaW1MVTdXR2VPS1JrUlN2QURkVDE0SjlxeVp0RzAzdy9IYVJhYkFMZU1CeVZCSkIyK3VUUlJUazN0Yzc1eWx5WHUraGd4eVNhakxPa3JsVWxVczZKd0R4MDV6eFhEYVhEQmJhdTlyREVxUW9kMndER1RqcVQxTkZGRXZnUjUxVGFQOEFqUjN0eGUzRnBwRXlLNWNyaE43a3N4VXQwejdWd00xNS93QUpMZnkyVjlCRnN0UWpSUEVESElNWTQzQTV4UlJVTGNKU2twTFY5Qzc0azhQNlRiUnBQSGJqelVYZXJFa2tOak9lYStlYlB4bHJVWGlKL0tlT0l5UmZPeUpndHoxTkZGWFA0R0pwS25PeTJoSnJ5UHQzdzZCSnBjOTJ3L2Z0QXBMampKd2VvNlZtTmR2cVAyQVRvaFNZRlpZd1BsY2NENXMwVVZpdDJkYWJlSHBhNzJ2OTVSOFRXdHZiV0huVzhTUVN4TXlKSkdvRGJGeDh1ZlNzUFI3OTlRa0ZoZFF4VFFTd0VrT3U0ajJVbk9CUlJXaHJVMHFSdDFrYjkzNEs4T3lLRUZxWXdrbTFTanNDQmducm11RWorMVI2c3NSdmJpUlZYYUJJKzdJeGpuSTVvb3A5RHlhK2xWcGFMbldoNTFybDFlU2FMUE1ibVZaZnRZUlhWaXBRRG41Y1Y3YnEyblJYR2dRM0RTeXJQNUNqelZmRGV1ZWM5YUtLMXN1WkNvNjAwbnF1YVcveUtmdyt1UFAwMlZab29wU0pqR1dkQVN3SDk3MU5kWDRndHJMVDdKNDdhMGhqVGZ2Q2hNZ0Z1dU01b29yR2JmTWVsRkpZZFdTUE1wdGN1OVEwaWFDVklsU1dZUVBzWGFTZ0dmd1B2WHpBMzJuVGRPZG9idWRoRmN5Tkdzajd3aGorNlJuNjBVVnRTNm5aUWJjR203cm1qb2ZTdmhEWGI3VU5KRFhBalltWVJ0OGcrWUZkMlc5ODk2NER4QnFsM284RWR6WXNJWlJKSUN5anJubmtkS0tLejdubVRTOXBIVDdTTVB3aDhRL0VHcDY3YndYaTJzeU5rbmRDQTJRT3VSZzVyM1h4WGN2YVc4YndLaUdYYnZ3bzV5Y2ZnZnBSUlVMNGljY2xHZFN5UzBqc1c5SzBEU0V2TFc4UzFWYmlPTU1zZ0ozWnpqazFnK0tMalVMVFViMjR0dFF1SUhGdkxOaEdBWGVvOU1VVVYwclY2OWpHRGZKRFYvRWtmTDkxNC84QUZjbzBtV1RVR2N5b1haU0FGeUd4MEdPSzlLMUR4dHJFb2hnWllESG5hQjVmUVB6Z2M4WVBJb29wMldoNm1NakdNcVZrbGRUdmJyWm5ZK0hKN21PMHZsODR0aUJDck1xbGw1UFE0L25YVytJTHU2LzRST1pubU1nbWpXUjFZQWpLc0FNY1VVVkszZnFqamlsN0NYcXp6dlEvRitzUk5hMmNiUnBBNUc2TUx3YzhuODYrbE5RZ3RKN0llYmF3dUNVSEs5aVIwSTVGRkZaVDBZcVRiamJva3JFVS9oL1NMM1M3eU9XMlVpTThOMUo3ODdzMTU3clZuWmFEYlFteXRvd3JNWDh0d1hVTmpHUUQ3VVVWcXRtR0kwUzlFY2RxSGh1d3ZZa3U5OHNCQUJFY0RCSS9sQjR4Z25INDE1ZkNaN1R3N2RUSmN5bVJKbzJWbWJKR1R5UHBSUlZML0kzakdMVUUwbjcwZnpaTjRQU0tXN3Z0U2VKV3VtVWt1Ui9Gbjd3OStLOTMwaTRHcTJpVzk3QkRNalNNVGxBRGtkK01VVVZoTDRuNkhuMTV5ZUsxazMwMzdiSG5maE1OcTE1cU5sZHVYUlZtMlNBQlpFQUdRQVFBTUFqaml2RmRWMWU3dEcxVklWaVJvaDVmbWVXcFp4bkdXeU1Fa2Q2S0t2cXowNlZLbDliVWVTUEw3U0t0YlMxMGJXZ1NUV3NHazI4Y3JlVmVLVE9od1EyUWY4SytpZEV1N2lmV05aMCtXUXRCYnBHa2Y4SkFZZXE0ejE0b29xWmJmTTRzU2w5YXF1MnJUYjgvZWFNVFdMQVdIaWFIVFk3cTVlMW1paGNwSktXMnNUaktuZ2ppdlZqb09rWHVuMk50YzJpU3JLN1FsbnlXQ0ZzRUtUMCt0RkZIOHBqQnRWWjYvWVQvQUNQTk5ROEJhRm9jTno5aGE1amUxY0dLVHppVzVQUTU0SSt0ZGRkYU5IZGFabzhsN2RYRjRaWlZVaVp3UXU3dXUwTGdqdFJSV2s5bVZXcVZKUnFPVW0zZGF0MzZuamFHZXkxS2N3M0VnaWhhVlZnYkRSWTV6bFNPcHgxcjZDYXd0ZEYreS9ZMEtKZnhGWm8yWm1YTzNkdlhKeUc5L1NpaW9sc3ZRcUd5ZlhraCtKOGkrS1BGdmlDM2FLTkx4aXNMdnN5Qm43MkRrams1SFd2ckFuL2kyYTMyQjU4c2FsbS8yZ2VHK29vb3FxcVh1Nkhhb3grcnhsWlhjS2wzMTBzZUwybWkybXBlR2JxK3VHa014QVp5cmJWa0k1QlpSeGtZNmptdWYwTzNFR21YVjVHN0JrTWNnajRNZTduUEJvb3FWc3p5SnR1TWxkMjdmOXZHeDhPN0NQeEw0cjFDSy9sbVA3OHlCNDVDakFnWkF5T3dyMFBXTEtIVFRxRWNaYVhrQm1sWXVYejh4M0RvZWZhaWlybHNkZUtTVUhaYld0LzRDaWEyMGZUbW1sVVFJbjJraDMyb293eUFiZG94Z1l6WE1lSnRYdWJEVVlMZFVpbGpsaVF1c3FBZzdjNDRHQjI5S0tLNTRiczVJdHVrdGVqL0FDT1NqMWUvTjlaUWlUWkhjS1M2TDhvQWNjcXVPZ3J1Ymk1dWZDbXIyOXRwOHptSmdyRVRIelB2U2JTTzNHRFJSVnZjVkJ2a2krdk5EOVRydGFodHBMalIyTnZFRnVMdDRwWXdvMkVFNHlBZWgrbGN0NDk4dlRuSzJjU1FJYmFSU2lEQy91MndHOWM4ODBVVTBlbk9NYjF0RjluOGp3THd4NHB2N21XWFQ3cUMzdWJkN1l5YlpGTzRFTmdZWlNDTWRxK3RmQk9oNlpxZXBYa056RHZXT1BjdVdKT1FCamtrOUtLS2lXalJyWGhCWStqSGxYTGZhMmhWdExHS0s0MTVXWXkvWlNUR1hDN3R2M1FoWlFDVkE2ZDY4dzFCdFZndVVhTFd0UVZjc2dpRTN5QlN1N0FHS0tLcU83TXEybFN5MDl5ZjRGSFhkWHUvRFdyYVpiMlJEUVhkaEM4MFV1WFZtY2tFOVFjbXZRckRXYjZHTFZVREFyRGFCNHd3M2JTN1lJQlBPT2FLSzBTVFNGUDNhY09YVFI3YWREYmd2Ym1TUzNScEdKZ21VSSs0aHVVSjV3Y0g4cXc5SjhWNmhmZUhyeWVlRzNaNDBKSkNFQjhISHpBSCtXS0tLaVd5OVRTTGJuVHU5N0hLeVBiUjZ0Rko5aHQzTXFTeFNiMExoMVpCSjgyVHlWSjRQWVYxbW9lSDlOc2JXM3ZiTkh0NUdkVkt4dWRoRGNFRlRrR2lpdDE5a3hxdCt3azc2M0xQaHkwUnRRU0F1NWhTK2FKWXkyUXE3QStGemtqbnNPS1M3SzJYakFKYnhwRXNrRE02b05xc1ZQQlpSd2Z4RkZGWnkzK1JwU2JkUC90NUhlNkZxVTdlS3Rac2lxZVFZcmM3Y0VZWmszRWdnOWE1UzZtdm0xRFViZU8rdUlZbW5rVjBqZjVYQVhPQ0dCR1BZWUZGRkxxdlEzcjZVby80bWFPbTJzU1JSeEhjNjRkdm1QT2VQVEZGRkZTVFRpdVZhSS8vMlE9PVwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/css/images/bb8.jpeg\n");

/***/ }),

/***/ "./src/app/css/index.css":
/*!*******************************!*\
  !*** ./src/app/css/index.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./index.css */ \"./node_modules/css-loader/index.js!./src/app/css/index.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9pbmRleC5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Nzcy9pbmRleC5jc3M/NTIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/css/index.css\n");

/***/ }),

/***/ "./src/app/home.js":
/*!*************************!*\
  !*** ./src/app/home.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\nvar Home = function (_React$Component) {\n    _inherits(Home, _React$Component);\n\n    function Home() {\n        _classCallCheck(this, Home);\n\n        return _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).apply(this, arguments));\n    }\n\n    _createClass(Home, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                { className: 'homepage-body' },\n                React.createElement(\n                    'h1',\n                    { className: 'homepage-header' },\n                    'Hi, I\\'m Misha. Mechanical engineer, builder & maker of '\n                ),\n                React.createElement(\n                    'h1',\n                    { className: 'homepage-subheader' },\n                    'robotic arms, legs, and other extremities.'\n                )\n            );\n        }\n    }]);\n\n    return Home;\n}(React.Component);\n\nmodule.exports = Home;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2hvbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC9ob21lLmpzPzc5MGUiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmxldCBjc3MgPSByZXF1aXJlKCcuL2Nzcy9pbmRleC5jc3MnKTtcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuXG5cblxuXG5jbGFzcyBIb21lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybihcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdob21lcGFnZS1ib2R5Jz5cbiAgICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPSdob21lcGFnZS1oZWFkZXInPkhpLCBJJ20gTWlzaGEuIE1lY2hhbmljYWwgZW5naW5lZXIsIGJ1aWxkZXIgJiBtYWtlciBvZiA8L2gxPlxuICAgICAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9J2hvbWVwYWdlLXN1YmhlYWRlcic+cm9ib3RpYyBhcm1zLCBsZWdzLCBhbmQgb3RoZXIgZXh0cmVtaXRpZXMuPC9oMT5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBIb21lXG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTtBQUNBOzs7Ozs7O0FBSEE7QUFDQTtBQUNBO0FBTUE7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBTUE7Ozs7QUFUQTtBQUNBO0FBYUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/home.js\n");

/***/ }),

/***/ "./src/app/index.js":
/*!**************************!*\
  !*** ./src/app/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\n\n// modules\n\nvar Home = __webpack_require__(/*! ./home */ \"./src/app/home.js\");\nvar About = __webpack_require__(/*! ./about */ \"./src/app/about.js\");\nvar ProjectPage = __webpack_require__(/*! ./project */ \"./src/app/project.js\");\nvar NavBar = __webpack_require__(/*! ./nav */ \"./src/app/nav.js\");\nvar Admin = __webpack_require__(/*! ./admin */ \"./src/app/admin.js\");\n\nvar App = function (_React$Component) {\n    _inherits(App, _React$Component);\n\n    function App() {\n        _classCallCheck(this, App);\n\n        return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));\n    }\n\n    _createClass(App, [{\n        key: 'render',\n        value: function render() {\n            var routes = [React.createElement(_reactRouterDom.Route, { exact: true, path: '/', component: Home }), React.createElement(_reactRouterDom.Route, { exact: true, path: '/about', component: About }), React.createElement(_reactRouterDom.Route, { exact: true, path: '/projects', component: ProjectPage })];\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(NavBar, null),\n                React.createElement(\n                    _reactRouterDom.BrowserRouter,\n                    null,\n                    React.createElement(\n                        _reactRouterDom.Switch,\n                        null,\n                        routes\n                    )\n                )\n            );\n        }\n    }]);\n\n    return App;\n}(React.Component);\n\nReactDOM.render(React.createElement(App, null), document.getElementById('app'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvaW5kZXguanM/NmZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xubGV0IFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvaW5kZXguY3NzJyk7XG5pbXBvcnQgeyBCcm93c2VyUm91dGVyLCBSb3V0ZXIsIFJvdXRlLCBTd2l0Y2gsIExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuLy8gbW9kdWxlc1xuXG5sZXQgSG9tZSA9IHJlcXVpcmUoJy4vaG9tZScpO1xubGV0IEFib3V0ID0gcmVxdWlyZSgnLi9hYm91dCcpO1xubGV0IFByb2plY3RQYWdlID0gcmVxdWlyZSgnLi9wcm9qZWN0Jyk7XG5sZXQgTmF2QmFyID0gcmVxdWlyZSgnLi9uYXYnKTtcbmxldCBBZG1pbiA9IHJlcXVpcmUoJy4vYWRtaW4nKTtcblxuXG5cbmNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByb3V0ZXMgPSBbXG4gICAgICAgICAgICA8Um91dGUgZXhhY3QgcGF0aD0nLycgY29tcG9uZW50PXtIb21lfT48L1JvdXRlPixcbiAgICAgICAgICAgIDxSb3V0ZSBleGFjdCBwYXRoPScvYWJvdXQnIGNvbXBvbmVudD17QWJvdXR9PjwvUm91dGU+LFxuICAgICAgICAgICAgPFJvdXRlIGV4YWN0IHBhdGg9Jy9wcm9qZWN0cycgY29tcG9uZW50PXtQcm9qZWN0UGFnZX0+PC9Sb3V0ZT5cbiAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4oXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxOYXZCYXIvPlxuICAgICAgICAgICAgICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICAgICAgICAgICAgICA8U3dpdGNoPiBcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyb3V0ZXN9XG4gICAgICAgICAgICAgICAgICAgIDwvU3dpdGNoPlxuICAgICAgICAgICAgICAgIDwvQnJvd3NlclJvdXRlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuUmVhY3RET00ucmVuZGVyKDxBcHAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKTsiXSwibWFwcGluZ3MiOiI7Ozs7QUFHQTtBQUNBOzs7Ozs7O0FBSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFGQTtBQVNBOzs7O0FBakJBO0FBQ0E7QUFtQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/index.js\n");

/***/ }),

/***/ "./src/app/nav.js":
/*!************************!*\
  !*** ./src/app/nav.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\nvar NavBar = function (_React$Component) {\n    _inherits(NavBar, _React$Component);\n\n    function NavBar(props) {\n        _classCallCheck(this, NavBar);\n\n        return _possibleConstructorReturn(this, (NavBar.__proto__ || Object.getPrototypeOf(NavBar)).call(this, props));\n    }\n\n    _createClass(NavBar, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'nav',\n                    null,\n                    React.createElement(\n                        'ul',\n                        { 'class': 'nav' },\n                        React.createElement(\n                            'li',\n                            { 'class': 'internal' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element home', href: '/' },\n                                'Home'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'internal' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element about', href: '/about' },\n                                'About'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'internal' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element projects', href: 'projects' },\n                                'Projects'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'external' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element linkedin', href: 'http://linkedin.com' },\n                                'Linkedin'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'external' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element github', href: 'http://github.com' },\n                                'Github'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'external' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element facebook', href: 'http://facebook.com' },\n                                'Facebook'\n                            )\n                        )\n                    )\n                )\n            );\n        }\n    }]);\n\n    return NavBar;\n}(React.Component);\n\nmodule.exports = NavBar;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL25hdi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwL25hdi5qcz9hOGYwIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvaW5kZXguY3NzJyk7XG5cblxuY2xhc3MgTmF2QmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4oXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxuYXY+XG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz0nbmF2Jz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0naW50ZXJuYWwnPjxhIGNsYXNzPSduYXYtZWxlbWVudCBob21lJyBocmVmPScvJz5Ib21lPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9J2ludGVybmFsJz48YSBjbGFzcz0nbmF2LWVsZW1lbnQgYWJvdXQnIGhyZWY9Jy9hYm91dCc+QWJvdXQ8L2E+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0naW50ZXJuYWwnPjxhIGNsYXNzPSduYXYtZWxlbWVudCBwcm9qZWN0cycgaHJlZj0ncHJvamVjdHMnPlByb2plY3RzPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICB7LyogPGxpIGNsYXNzPSdpbnRlcm5hbCBsb2dvJz48c3BhbiBjbGFzcz0nbmF2LWVsZW1lbnQnPk1TPC9zcGFuPjwvbGk+ICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPSdleHRlcm5hbCc+PGEgY2xhc3M9J25hdi1lbGVtZW50IGxpbmtlZGluJyBocmVmPSdodHRwOi8vbGlua2VkaW4uY29tJz5MaW5rZWRpbjwvYT48L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPSdleHRlcm5hbCc+PGEgY2xhc3M9J25hdi1lbGVtZW50IGdpdGh1YicgaHJlZj0naHR0cDovL2dpdGh1Yi5jb20nPkdpdGh1YjwvYT48L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPSdleHRlcm5hbCc+PGEgY2xhc3M9J25hdi1lbGVtZW50IGZhY2Vib29rJyBocmVmPSdodHRwOi8vZmFjZWJvb2suY29tJz5GYWNlYm9vazwvYT48L2xpPlxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgIDwvbmF2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2QmFyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFQQTtBQURBO0FBREE7QUFjQTs7OztBQXJCQTtBQUNBO0FBdUJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/nav.js\n");

/***/ }),

/***/ "./src/app/project.js":
/*!****************************!*\
  !*** ./src/app/project.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\n\n// in componentDidMount, use fs.readFileSync() to get projects from a .json file in api/projects.json\n// in the api, make routes for listing projects, creating projects, and updating projects\n// add a property to each project called \"archived: true/false\" which prevents it from being displayed\n// until he's ready for it to be shown (or acts as a soft-delete)\n// protect these routes with authentication\n\nvar projects = [{\n    name: \"name\",\n    desc: \"Sunt anim cillum ullamco est tempor magna. Ea dolore nisi anim ea et proident ullamco esse sunt qui adipisicing velit. Incididunt dolore Lorem velit id duis reprehenderit consectetur consectetur eiusmod magna sit id nulla. Irure eu minim duis incididunt pariatur. Aliquip velit aliqua mollit minim pariatur laboris sunt Lorem minim fugiat laboris eu elit incididunt. Est voluptate pariatur enim tempor velit pariatur. Eu incididunt consectetur dolore dolore aliqua id aliquip esse velit ex ad et reprehenderit.\",\n    link: \"http://google.com\",\n    pic: \"picture\"\n}, {\n    name: \"name2\",\n    desc: \"Velit non ipsum ea mollit eu Lorem occaecat non. Velit mollit minim amet labore magna cillum eu ea. Ipsum mollit cupidatat eiusmod officia non fugiat veniam. Reprehenderit culpa cillum exercitation minim labore proident velit id dolore. Cillum ad nostrud ut ea anim esse ut consectetur ullamco.\",\n    link: \"http://google.com\",\n    pic: \"picture\"\n}, {\n    name: \"name3\",\n    desc: \"Minim id veniam sit aute nisi anim occaecat. Laborum ad voluptate id laborum aliqua enim in nulla voluptate cupidatat culpa in nisi. Labore proident adipisicing occaecat est anim sit. Eiusmod duis commodo velit eu. Consequat commodo do minim sunt fugiat aliquip nisi proident consequat. Excepteur cupidatat do ea sunt ullamco eiusmod et laborum. Sint incididunt laborum nisi eu ad.\",\n    link: \"http://google.com\",\n    pic: \"https://images.pexels.com/photos/248797/pexels-photo-248797.jpeg?auto=compress&cs=tinysrgb&h=350\"\n}];\n\nvar ProjectPage = function (_React$Component) {\n    _inherits(ProjectPage, _React$Component);\n\n    function ProjectPage(props) {\n        _classCallCheck(this, ProjectPage);\n\n        return _possibleConstructorReturn(this, (ProjectPage.__proto__ || Object.getPrototypeOf(ProjectPage)).call(this, props));\n    }\n\n    _createClass(ProjectPage, [{\n        key: 'render',\n        value: function render() {\n            var projectDiv = projects.map(function (project) {\n                return React.createElement(Project, { name: project.name, desc: project.desc, pic: project.pic });\n            });\n\n            return React.createElement(\n                'div',\n                { className: 'container' },\n                React.createElement(\n                    'h1',\n                    null,\n                    'These are my projects'\n                ),\n                React.createElement(\n                    'div',\n                    null,\n                    projectDiv\n                )\n            );\n        }\n    }]);\n\n    return ProjectPage;\n}(React.Component);\n\nvar Project = function (_React$Component2) {\n    _inherits(Project, _React$Component2);\n\n    function Project() {\n        _classCallCheck(this, Project);\n\n        return _possibleConstructorReturn(this, (Project.__proto__ || Object.getPrototypeOf(Project)).apply(this, arguments));\n    }\n\n    _createClass(Project, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'h2',\n                    null,\n                    this.props.name\n                ),\n                React.createElement(\n                    'p',\n                    null,\n                    this.props.desc\n                ),\n                React.createElement(\n                    'a',\n                    { href: this.props.link },\n                    'Link to it'\n                ),\n                React.createElement('img', { src: this.props.pic })\n            );\n        }\n    }]);\n\n    return Project;\n}(React.Component);\n\nmodule.exports = ProjectPage;\n\n//pro, name, desc, link, pic//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL3Byb2plY3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC9wcm9qZWN0LmpzPzY2YjIiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmxldCBjc3MgPSByZXF1aXJlKCcuL2Nzcy9pbmRleC5jc3MnKTtcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuXG4vLyBpbiBjb21wb25lbnREaWRNb3VudCwgdXNlIGZzLnJlYWRGaWxlU3luYygpIHRvIGdldCBwcm9qZWN0cyBmcm9tIGEgLmpzb24gZmlsZSBpbiBhcGkvcHJvamVjdHMuanNvblxuLy8gaW4gdGhlIGFwaSwgbWFrZSByb3V0ZXMgZm9yIGxpc3RpbmcgcHJvamVjdHMsIGNyZWF0aW5nIHByb2plY3RzLCBhbmQgdXBkYXRpbmcgcHJvamVjdHNcbi8vIGFkZCBhIHByb3BlcnR5IHRvIGVhY2ggcHJvamVjdCBjYWxsZWQgXCJhcmNoaXZlZDogdHJ1ZS9mYWxzZVwiIHdoaWNoIHByZXZlbnRzIGl0IGZyb20gYmVpbmcgZGlzcGxheWVkXG4gICAgLy8gdW50aWwgaGUncyByZWFkeSBmb3IgaXQgdG8gYmUgc2hvd24gKG9yIGFjdHMgYXMgYSBzb2Z0LWRlbGV0ZSlcbi8vIHByb3RlY3QgdGhlc2Ugcm91dGVzIHdpdGggYXV0aGVudGljYXRpb25cblxubGV0IHByb2plY3RzID0gW3tcbiAgICBuYW1lOiBcIm5hbWVcIixcbiAgICBkZXNjOiBcIlN1bnQgYW5pbSBjaWxsdW0gdWxsYW1jbyBlc3QgdGVtcG9yIG1hZ25hLiBFYSBkb2xvcmUgbmlzaSBhbmltIGVhIGV0IHByb2lkZW50IHVsbGFtY28gZXNzZSBzdW50IHF1aSBhZGlwaXNpY2luZyB2ZWxpdC4gSW5jaWRpZHVudCBkb2xvcmUgTG9yZW0gdmVsaXQgaWQgZHVpcyByZXByZWhlbmRlcml0IGNvbnNlY3RldHVyIGNvbnNlY3RldHVyIGVpdXNtb2QgbWFnbmEgc2l0IGlkIG51bGxhLiBJcnVyZSBldSBtaW5pbSBkdWlzIGluY2lkaWR1bnQgcGFyaWF0dXIuIEFsaXF1aXAgdmVsaXQgYWxpcXVhIG1vbGxpdCBtaW5pbSBwYXJpYXR1ciBsYWJvcmlzIHN1bnQgTG9yZW0gbWluaW0gZnVnaWF0IGxhYm9yaXMgZXUgZWxpdCBpbmNpZGlkdW50LiBFc3Qgdm9sdXB0YXRlIHBhcmlhdHVyIGVuaW0gdGVtcG9yIHZlbGl0IHBhcmlhdHVyLiBFdSBpbmNpZGlkdW50IGNvbnNlY3RldHVyIGRvbG9yZSBkb2xvcmUgYWxpcXVhIGlkIGFsaXF1aXAgZXNzZSB2ZWxpdCBleCBhZCBldCByZXByZWhlbmRlcml0LlwiLFxuICAgIGxpbms6IFwiaHR0cDovL2dvb2dsZS5jb21cIixcbiAgICBwaWM6IFwicGljdHVyZVwiLFxufSxcbntcbiAgICBuYW1lOlwibmFtZTJcIixcbiAgICBkZXNjOiBcIlZlbGl0IG5vbiBpcHN1bSBlYSBtb2xsaXQgZXUgTG9yZW0gb2NjYWVjYXQgbm9uLiBWZWxpdCBtb2xsaXQgbWluaW0gYW1ldCBsYWJvcmUgbWFnbmEgY2lsbHVtIGV1IGVhLiBJcHN1bSBtb2xsaXQgY3VwaWRhdGF0IGVpdXNtb2Qgb2ZmaWNpYSBub24gZnVnaWF0IHZlbmlhbS4gUmVwcmVoZW5kZXJpdCBjdWxwYSBjaWxsdW0gZXhlcmNpdGF0aW9uIG1pbmltIGxhYm9yZSBwcm9pZGVudCB2ZWxpdCBpZCBkb2xvcmUuIENpbGx1bSBhZCBub3N0cnVkIHV0IGVhIGFuaW0gZXNzZSB1dCBjb25zZWN0ZXR1ciB1bGxhbWNvLlwiLFxuICAgIGxpbms6IFwiaHR0cDovL2dvb2dsZS5jb21cIixcbiAgICBwaWM6IFwicGljdHVyZVwiXG59LFxue1xuICAgIG5hbWU6XCJuYW1lM1wiLFxuICAgIGRlc2M6IFwiTWluaW0gaWQgdmVuaWFtIHNpdCBhdXRlIG5pc2kgYW5pbSBvY2NhZWNhdC4gTGFib3J1bSBhZCB2b2x1cHRhdGUgaWQgbGFib3J1bSBhbGlxdWEgZW5pbSBpbiBudWxsYSB2b2x1cHRhdGUgY3VwaWRhdGF0IGN1bHBhIGluIG5pc2kuIExhYm9yZSBwcm9pZGVudCBhZGlwaXNpY2luZyBvY2NhZWNhdCBlc3QgYW5pbSBzaXQuIEVpdXNtb2QgZHVpcyBjb21tb2RvIHZlbGl0IGV1LiBDb25zZXF1YXQgY29tbW9kbyBkbyBtaW5pbSBzdW50IGZ1Z2lhdCBhbGlxdWlwIG5pc2kgcHJvaWRlbnQgY29uc2VxdWF0LiBFeGNlcHRldXIgY3VwaWRhdGF0IGRvIGVhIHN1bnQgdWxsYW1jbyBlaXVzbW9kIGV0IGxhYm9ydW0uIFNpbnQgaW5jaWRpZHVudCBsYWJvcnVtIG5pc2kgZXUgYWQuXCIsXG4gICAgbGluazogXCJodHRwOi8vZ29vZ2xlLmNvbVwiLFxuICAgIHBpYzogXCJodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8yNDg3OTcvcGV4ZWxzLXBob3RvLTI0ODc5Ny5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2ImaD0zNTBcIlxufV1cblxuY2xhc3MgUHJvamVjdFBhZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdERpdiA9IHByb2plY3RzLm1hcChwcm9qZWN0ID0+IDxQcm9qZWN0IG5hbWU9e3Byb2plY3QubmFtZX0gZGVzYz17cHJvamVjdC5kZXNjfSBwaWM9e3Byb2plY3QucGljfSAvPilcblxuICAgICAgICByZXR1cm4oXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY29udGFpbmVyJz5cbiAgICAgICAgICAgICAgICA8aDE+VGhlc2UgYXJlIG15IHByb2plY3RzPC9oMT5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICB7cHJvamVjdERpdn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuY2xhc3MgUHJvamVjdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGgyPnt0aGlzLnByb3BzLm5hbWV9PC9oMj5cbiAgICAgICAgICAgICAgICA8cD57dGhpcy5wcm9wcy5kZXNjfTwvcD5cbiAgICAgICAgICAgICAgICA8YSBocmVmPXt0aGlzLnByb3BzLmxpbmt9PkxpbmsgdG8gaXQ8L2E+XG4gICAgICAgICAgICAgICAgPGltZyBzcmM9e3RoaXMucHJvcHMucGljfS8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0UGFnZVxuXG4vL3BybywgbmFtZSwgZGVzYywgbGluaywgcGljXG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTtBQUNBOzs7Ozs7O0FBSEE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRkE7QUFPQTs7OztBQWhCQTtBQUNBO0FBa0JBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQU9BOzs7O0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/project.js\n");

/***/ })

/******/ });