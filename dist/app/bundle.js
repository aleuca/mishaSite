/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/app/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/app/css/about.css":
/*!*********************************************************!*\
  !*** ./node_modules/css-loader!./src/app/css/about.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".img {\\n    height: 50px;\\n    width: 50px;\\n}\\n\\n.about-me {\\n    display: inline-block;\\n    text-align: center;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9hcHAvY3NzL2Fib3V0LmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvY3NzL2Fib3V0LmNzcz84NzMyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmltZyB7XFxuICAgIGhlaWdodDogNTBweDtcXG4gICAgd2lkdGg6IDUwcHg7XFxufVxcblxcbi5hYm91dC1tZSB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/app/css/about.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/app/css/home.css":
/*!********************************************************!*\
  !*** ./node_modules/css-loader!./src/app/css/home.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(/*! ../../../node_modules/css-loader/lib/url/escape.js */ \"./node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"body {\\n    background-image: url(\" + escape(__webpack_require__(/*! ./images/ac.jpeg */ \"./src/app/css/images/ac.jpeg\")) + \");\\n    background-size: cover;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9hcHAvY3NzL2hvbWUuY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jc3MvaG9tZS5jc3M/YmQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXNjYXBlID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5IHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL2ltYWdlcy9hYy5qcGVnXCIpKSArIFwiKTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/app/css/home.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/app/css/index.css":
/*!*********************************************************!*\
  !*** ./node_modules/css-loader!./src/app/css/index.css ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"html, body {\\n    margin: 0;\\n    height: 100%;\\n    padding-top: 30px; \\n    background-color: #f7f7f7;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9hcHAvY3NzL2luZGV4LmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvY3NzL2luZGV4LmNzcz85NmU4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCwgYm9keSB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBwYWRkaW5nLXRvcDogMzBweDsgXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjc7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/app/css/index.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/app/css/nav.css":
/*!*******************************************************!*\
  !*** ./node_modules/css-loader!./src/app/css/nav.css ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".nav {\\n    top: 0;\\n    left: 0;\\n    margin: 0;\\n    width: 100%;\\n    position: fixed;\\n    padding: 0;\\n    height: 50px;\\n    background-color: #1e1f26;\\n    justify-content: center;\\n}\\n\\na.nav-element {\\n    text-align: center;\\n    vertical-align: center;\\n}\\n\\nli {\\n    display: table;\\n    text-decoration: none;\\n    align-content: center;\\n    height: 100%;\\n    padding-left: 15px;\\n    padding-right: 15px;\\n    margin: auto;\\n    text-align: center;\\n}\\n\\n\\nli:hover {\\n    background-color: #4d648d;\\n    height: 100%;\\n    font-weight:bold;\\n    box-shadow: 8px 5px 5px #283655;\\n}\\n\\n.external {\\n    float: right;\\n}\\n\\n.internal {\\n    float: left;\\n}\\n\\n/* .logo {\\n    color: white;\\n    text-align: center;\\n} */\\n\\na {\\n    font-family: 'PT Sans', sans-serif;\\n    text-decoration: none;\\n    color: white;\\n    vertical-align: middle;\\n    display: table-cell;\\n}\\n\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9hcHAvY3NzL25hdi5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Nzcy9uYXYuY3NzPzNlNjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubmF2IHtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGhlaWdodDogNTBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzFlMWYyNjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbmEubmF2LWVsZW1lbnQge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBjZW50ZXI7XFxufVxcblxcbmxpIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHBhZGRpbmctbGVmdDogMTVweDtcXG4gICAgcGFkZGluZy1yaWdodDogMTVweDtcXG4gICAgbWFyZ2luOiBhdXRvO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcblxcbmxpOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRkNjQ4ZDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBmb250LXdlaWdodDpib2xkO1xcbiAgICBib3gtc2hhZG93OiA4cHggNXB4IDVweCAjMjgzNjU1O1xcbn1cXG5cXG4uZXh0ZXJuYWwge1xcbiAgICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbi5pbnRlcm5hbCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4vKiAubG9nbyB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn0gKi9cXG5cXG5hIHtcXG4gICAgZm9udC1mYW1pbHk6ICdQVCBTYW5zJywgc2Fucy1zZXJpZjtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxufVxcblxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/app/css/nav.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/app/css/project.css":
/*!***********************************************************!*\
  !*** ./node_modules/css-loader!./src/app/css/project.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".header {\\n    position: relative;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NyYy9hcHAvY3NzL3Byb2plY3QuY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jc3MvcHJvamVjdC5jc3M/YTVmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5oZWFkZXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./src/app/css/project.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzP2IwNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICB9XG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG4gICAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICsgJ1wiJ1xuICAgIH1cblxuICAgIHJldHVybiB1cmxcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/url/escape.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanM/YzRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/ExecutionEnvironment.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelize.js":
/*!*******************************************!*\
  !*** ./node_modules/fbjs/lib/camelize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanM/MzYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelize.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelizeStyleName.js":
/*!****************************************************!*\
  !*** ./node_modules/fbjs/lib/camelizeStyleName.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar camelize = __webpack_require__(/*! ./camelize */ \"./node_modules/fbjs/lib/camelize.js\");\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanM/OTU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelizeStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/containsNode.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/containsNode.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = __webpack_require__(/*! ./isTextNode */ \"./node_modules/fbjs/lib/isTextNode.js\");\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcz80ZDZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/containsNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzP2EyMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyFunction.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (true) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanM/Yjc3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyObject.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/getActiveElement.js":
/*!***************************************************!*\
  !*** ./node_modules/fbjs/lib/getActiveElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzPzhlNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/getActiveElement.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenate.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcz9mOWExIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenate.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenateStyleName.js":
/*!*****************************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenateStyleName.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar hyphenate = __webpack_require__(/*! ./hyphenate */ \"./node_modules/fbjs/lib/hyphenate.js\");\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcz9mYmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenateStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcz9kOGRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/invariant.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isNode.js":
/*!*****************************************!*\
  !*** ./node_modules/fbjs/lib/isNode.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcz9mNzg2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isTextNode.js":
/*!*********************************************!*\
  !*** ./node_modules/fbjs/lib/isTextNode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = __webpack_require__(/*! ./isNode */ \"./node_modules/fbjs/lib/isNode.js\");\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzPzQ5MGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isTextNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/shallowEqual.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcz9hZjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/shallowEqual.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzP2RhNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/warning.js\n");

/***/ }),

/***/ "./node_modules/history/DOMUtils.js":
/*!******************************************!*\
  !*** ./node_modules/history/DOMUtils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nvar canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nvar addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nvar removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nvar getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = exports.supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nvar isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzP2I4NDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgZ2V0Q29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbnZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZXhwb3J0cy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xudmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xudmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBleHBvcnRzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/DOMUtils.js\n");

/***/ }),

/***/ "./node_modules/history/LocationUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/history/LocationUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.locationsAreEqual = exports.createLocation = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _resolvePathname = __webpack_require__(/*! resolve-pathname */ \"./node_modules/resolve-pathname/index.js\");\n\nvar _resolvePathname2 = _interopRequireDefault(_resolvePathname);\n\nvar _valueEqual = __webpack_require__(/*! value-equal */ \"./node_modules/value-equal/index.js\");\n\nvar _valueEqual2 = _interopRequireDefault(_valueEqual);\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = (0, _PathUtils.parsePath)(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nvar locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qcz9jYjNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZSA9IHJlcXVpcmUoJ3Jlc29sdmUtcGF0aG5hbWUnKTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVzb2x2ZVBhdGhuYW1lKTtcblxudmFyIF92YWx1ZUVxdWFsID0gcmVxdWlyZSgndmFsdWUtZXF1YWwnKTtcblxudmFyIF92YWx1ZUVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbHVlRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAoMCwgX3Jlc29sdmVQYXRobmFtZTIuZGVmYXVsdCkobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgKDAsIF92YWx1ZUVxdWFsMi5kZWZhdWx0KShhLnN0YXRlLCBiLnN0YXRlKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/LocationUtils.js\n");

/***/ }),

/***/ "./node_modules/history/PathUtils.js":
/*!*******************************************!*\
  !*** ./node_modules/history/PathUtils.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nvar addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nvar stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nvar hasBasename = exports.hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nvar stripBasename = exports.stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nvar stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nvar parsePath = exports.parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar createPath = exports.createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanM/OTM5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5hZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxudmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG52YXIgaGFzQmFzZW5hbWUgPSBleHBvcnRzLmhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZXhwb3J0cy5zdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG52YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZXhwb3J0cy5zdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxudmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/PathUtils.js\n");

/***/ }),

/***/ "./node_modules/history/createBrowserHistory.js":
/*!******************************************************!*\
  !*** ./node_modules/history/createBrowserHistory.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _LocationUtils = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/LocationUtils.js\");\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nvar _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/createTransitionManager.js\");\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nvar _DOMUtils = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/DOMUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = (0, _DOMUtils.supportsHistory)();\n  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);\n\n    return (0, _LocationUtils.createLocation)(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + (0, _PathUtils.createPath)(location);\n  };\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createBrowserHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzPzZlOTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhKDAsIF9ET01VdGlscy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKSgpO1xuXG4gIHZhciBfcHJvcHMkZm9yY2VSZWZyZXNoID0gcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyAoMCwgX1BhdGhVdGlscy5zdHJpcFRyYWlsaW5nU2xhc2gpKCgwLCBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCkocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG5cblxuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKCgwLCBfRE9NVXRpbHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCkoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcblxuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/createBrowserHistory.js\n");

/***/ }),

/***/ "./node_modules/history/createHashHistory.js":
/*!***************************************************!*\
  !*** ./node_modules/history/createHashHistory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _invariant = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _LocationUtils = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/LocationUtils.js\");\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nvar _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/createTransitionManager.js\");\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nvar _DOMUtils = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/DOMUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: _PathUtils.stripLeadingSlash,\n    decodePath: _PathUtils.addLeadingSlash\n  },\n  slash: {\n    encodePath: _PathUtils.addLeadingSlash,\n    decodePath: _PathUtils.addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);\n\n    return (0, _LocationUtils.createLocation)(path);\n  };\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));\n  };\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = (0, _PathUtils.createPath)(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = (0, _PathUtils.createPath)(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createHashHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzP2U3ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyAoMCwgX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCkocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/createHashHistory.js\n");

/***/ }),

/***/ "./node_modules/history/createMemoryHistory.js":
/*!*****************************************************!*\
  !*** ./node_modules/history/createMemoryHistory.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _PathUtils = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/PathUtils.js\");\n\nvar _LocationUtils = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/LocationUtils.js\");\n\nvar _createTransitionManager = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/createTransitionManager.js\");\n\nvar _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar clamp = function clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n};\n\n/**\n * Creates a history object that stores locations in memory.\n */\nvar createMemoryHistory = function createMemoryHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var getUserConfirmation = props.getUserConfirmation,\n      _props$initialEntries = props.initialEntries,\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n\n  var transitionManager = (0, _createTransitionManager2.default)();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());\n  });\n\n  // Public interface\n\n  var createHref = _PathUtils.createPath;\n\n  var push = function push(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n\n      var nextEntries = history.entries.slice(0);\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  };\n\n  var replace = function replace(path, state) {\n    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      history.entries[history.index] = location;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var canGo = function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  };\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return transitionManager.setPrompt(prompt);\n  };\n\n  var listen = function listen(listener) {\n    return transitionManager.appendListener(listener);\n  };\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexports.default = createMemoryHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcz84NWZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IF9QYXRoVXRpbHMuY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/createMemoryHistory.js\n");

/***/ }),

/***/ "./node_modules/history/createTransitionManager.js":
/*!*********************************************************!*\
  !*** ./node_modules/history/createTransitionManager.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _warning = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexports.default = createTransitionManager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzPzA0NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/history/createTransitionManager.js\n");

/***/ }),

/***/ "./node_modules/history/es/DOMUtils.js":
/*!*********************************************!*\
  !*** ./node_modules/history/es/DOMUtils.js ***!
  \*********************************************/
/*! exports provided: canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, supportsGoWithoutReloadUsingHash, isExtraneousPopstateEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canUseDOM\", function() { return canUseDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addEventListener\", function() { return addEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeEventListener\", function() { return removeEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getConfirmation\", function() { return getConfirmation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsHistory\", function() { return supportsHistory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsPopStateOnHashChange\", function() { return supportsPopStateOnHashChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"supportsGoWithoutReloadUsingHash\", function() { return supportsGoWithoutReloadUsingHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isExtraneousPopstateEvent\", function() { return isExtraneousPopstateEvent; });\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nvar addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nvar removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nvar getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nvar supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nvar supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nvar supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nvar isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzPzViZTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnQgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciBnZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuZXhwb3J0IHZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/es/DOMUtils.js\n");

/***/ }),

/***/ "./node_modules/history/es/LocationUtils.js":
/*!**************************************************!*\
  !*** ./node_modules/history/es/LocationUtils.js ***!
  \**************************************************/
/*! exports provided: createLocation, locationsAreEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLocation\", function() { return createLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"locationsAreEqual\", function() { return locationsAreEqual; });\n/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resolve-pathname */ \"./node_modules/resolve-pathname/index.js\");\n/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! value-equal */ \"./node_modules/value-equal/index.js\");\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\nvar createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_2__[\"parsePath\"])(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = Object(resolve_pathname__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nvar locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(a.state, b.state);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9Mb2NhdGlvblV0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcz9kMjgwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCByZXNvbHZlUGF0aG5hbWUgZnJvbSAncmVzb2x2ZS1wYXRobmFtZSc7XG5pbXBvcnQgdmFsdWVFcXVhbCBmcm9tICd2YWx1ZS1lcXVhbCc7XG5pbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IHJlc29sdmVQYXRobmFtZShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxuZXhwb3J0IHZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiB2YWx1ZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/es/LocationUtils.js\n");

/***/ }),

/***/ "./node_modules/history/es/PathUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/history/es/PathUtils.js ***!
  \**********************************************/
/*! exports provided: addLeadingSlash, stripLeadingSlash, hasBasename, stripBasename, stripTrailingSlash, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLeadingSlash\", function() { return addLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripLeadingSlash\", function() { return stripLeadingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasBasename\", function() { return hasBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripBasename\", function() { return stripBasename; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripTrailingSlash\", function() { return stripTrailingSlash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parsePath\", function() { return parsePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPath\", function() { return createPath; });\nvar addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nvar stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nvar hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nvar stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nvar stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nvar parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanM/NWEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxuZXhwb3J0IHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/es/PathUtils.js\n");

/***/ }),

/***/ "./node_modules/history/es/createBrowserHistory.js":
/*!*********************************************************!*\
  !*** ./node_modules/history/es/createBrowserHistory.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/es/createTransitionManager.js\");\n/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/es/DOMUtils.js\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\n\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"canUseDOM\"], 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"supportsHistory\"])();\n  var needsHashChangeListener = !Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"supportsPopStateOnHashChange\"])();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"getConfirmation\"] : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripTrailingSlash\"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"])(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"hasBasename\"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripBasename\"])(path, basename);\n\n    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"isExtraneousPopstateEvent\"])(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location);\n  };\n\n  var push = function push(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"addEventListener\"])(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"addEventListener\"])(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"removeEventListener\"])(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"removeEventListener\"])(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createBrowserHistory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzP2NjNzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0hpc3RvcnksIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UsIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQnJvd3Nlckhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/es/createBrowserHistory.js\n");

/***/ }),

/***/ "./node_modules/history/es/createHashHistory.js":
/*!******************************************************!*\
  !*** ./node_modules/history/es/createHashHistory.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/es/createTransitionManager.js\");\n/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ \"./node_modules/history/es/DOMUtils.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\n\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripLeadingSlash\"])(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripLeadingSlash\"],\n    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"]\n  },\n  slash: {\n    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"],\n    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"]\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"canUseDOM\"], 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"supportsGoWithoutReloadUsingHash\"])();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"getConfirmation\"] : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripTrailingSlash\"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"addLeadingSlash\"])(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"hasBasename\"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"stripBasename\"])(path, basename);\n\n    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path);\n  };\n\n  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"locationsAreEqual\"])(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location));\n  };\n\n  var push = function push(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__[\"createPath\"])(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"addEventListener\"])(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__[\"removeEventListener\"])(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createHashHistory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVIYXNoSGlzdG9yeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzPzAyNjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgc3RyaXBMZWFkaW5nU2xhc2gocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IHN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxudmFyIGdldEhhc2hQYXRoID0gZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59O1xuXG52YXIgcHVzaEhhc2hQYXRoID0gZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn07XG5cbnZhciByZXBsYWNlSGFzaFBhdGggPSBmdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaEluZGV4ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGhhc2hJbmRleCA+PSAwID8gaGFzaEluZGV4IDogMCkgKyAnIycgKyBwYXRoKTtcbn07XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGludmFyaWFudChjYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IHByb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiBsb2NhdGlvbnNBcmVFcXVhbChwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aCh0b0xvY2F0aW9uKSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbY3JlYXRlUGF0aChpbml0aWFsTG9jYXRpb24pXTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcblxuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHdhcm5pbmcoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJyk7XG5cbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVIYXNoSGlzdG9yeTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/history/es/createHashHistory.js\n");

/***/ }),

/***/ "./node_modules/history/es/createMemoryHistory.js":
/*!********************************************************!*\
  !*** ./node_modules/history/es/createMemoryHistory.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createTransitionManager */ \"./node_modules/history/es/createTransitionManager.js\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\n\n\n\n\nvar clamp = function clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n};\n\n/**\n * Creates a history object that stores locations in memory.\n */\nvar createMemoryHistory = function createMemoryHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var getUserConfirmation = props.getUserConfirmation,\n      _props$initialEntries = props.initialEntries,\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n\n  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(entry, undefined, createKey()) : Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(entry, undefined, entry.key || createKey());\n  });\n\n  // Public interface\n\n  var createHref = _PathUtils__WEBPACK_IMPORTED_MODULE_1__[\"createPath\"];\n\n  var push = function push(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n\n      var nextEntries = history.entries.slice(0);\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__[\"createLocation\"])(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      history.entries[history.index] = location;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var canGo = function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  };\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return transitionManager.setPrompt(prompt);\n  };\n\n  var listen = function listen(listener) {\n    return transitionManager.appendListener(listener);\n  };\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createMemoryHistory);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcz83ZmUzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgeyBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcblxuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/history/es/createMemoryHistory.js\n");

/***/ }),

/***/ "./node_modules/history/es/createTransitionManager.js":
/*!************************************************************!*\
  !*** ./node_modules/history/es/createTransitionManager.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createTransitionManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzPzdkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5cbnZhciBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICB2YXIgc2V0UHJvbXB0ID0gZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKTtcblxuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgdmFyIGFwcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/history/es/createTransitionManager.js\n");

/***/ }),

/***/ "./node_modules/history/es/index.js":
/*!******************************************!*\
  !*** ./node_modules/history/es/index.js ***!
  \******************************************/
/*! exports provided: createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserHistory */ \"./node_modules/history/es/createBrowserHistory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createBrowserHistory\", function() { return _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _createHashHistory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createHashHistory */ \"./node_modules/history/es/createHashHistory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createHashHistory\", function() { return _createHashHistory__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createMemoryHistory */ \"./node_modules/history/es/createMemoryHistory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createMemoryHistory\", function() { return _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LocationUtils */ \"./node_modules/history/es/LocationUtils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createLocation\", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__[\"createLocation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"locationsAreEqual\", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__[\"locationsAreEqual\"]; });\n\n/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathUtils */ \"./node_modules/history/es/PathUtils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"parsePath\", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"parsePath\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPath\", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"createPath\"]; });\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2luZGV4LmpzPzYwNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/history/es/index.js\n");

/***/ }),

/***/ "./node_modules/hoist-non-react-statics/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n(function (global, factory) {\n     true ? module.exports = factory() :\n    undefined;\n}(this, (function () {\n    'use strict';\n    \n    var REACT_STATICS = {\n        childContextTypes: true,\n        contextTypes: true,\n        defaultProps: true,\n        displayName: true,\n        getDefaultProps: true,\n        getDerivedStateFromProps: true,\n        mixins: true,\n        propTypes: true,\n        type: true\n    };\n    \n    var KNOWN_STATICS = {\n        name: true,\n        length: true,\n        prototype: true,\n        caller: true,\n        callee: true,\n        arguments: true,\n        arity: true\n    };\n    \n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var getPrototypeOf = Object.getPrototypeOf;\n    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n    \n    return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n        if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n            \n            if (objectPrototype) {\n                var inheritedComponent = getPrototypeOf(sourceComponent);\n                if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                    hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n                }\n            }\n            \n            var keys = getOwnPropertyNames(sourceComponent);\n            \n            if (getOwnPropertySymbols) {\n                keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n            }\n            \n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                    var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                    try { // Avoid failures from read-only properties\n                        defineProperty(targetComponent, key, descriptor);\n                    } catch (e) {}\n                }\n            }\n            \n            return targetComponent;\n        }\n        \n        return targetComponent;\n    };\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanM/ZmNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuaG9pc3ROb25SZWFjdFN0YXRpY3MgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBcbiAgICB2YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICAgICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgICAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICAgICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gICAgICAgIG1peGluczogdHJ1ZSxcbiAgICAgICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgICAgICB0eXBlOiB0cnVlXG4gICAgfTtcbiAgICBcbiAgICB2YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgbGVuZ3RoOiB0cnVlLFxuICAgICAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgICAgIGNhbGxlcjogdHJ1ZSxcbiAgICAgICAgY2FsbGVlOiB0cnVlLFxuICAgICAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgICAgIGFyaXR5OiB0cnVlXG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICB2YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgdmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG4gICAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH07XG59KSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hoist-non-react-statics/index.js\n");

/***/ }),

/***/ "./node_modules/invariant/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (true) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanM/NDBiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/invariant/browser.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzPzMyMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  var invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\n  var warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzP2ExNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (\"development\" !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : undefined;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2IwNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(isValidElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2Q3YmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FJQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.3.2\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar ExecutionEnvironment = __webpack_require__(/*! fbjs/lib/ExecutionEnvironment */ \"./node_modules/fbjs/lib/ExecutionEnvironment.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\nvar getActiveElement = __webpack_require__(/*! fbjs/lib/getActiveElement */ \"./node_modules/fbjs/lib/getActiveElement.js\");\nvar shallowEqual = __webpack_require__(/*! fbjs/lib/shallowEqual */ \"./node_modules/fbjs/lib/shallowEqual.js\");\nvar containsNode = __webpack_require__(/*! fbjs/lib/containsNode */ \"./node_modules/fbjs/lib/containsNode.js\");\nvar emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\nvar hyphenateStyleName = __webpack_require__(/*! fbjs/lib/hyphenateStyleName */ \"./node_modules/fbjs/lib/hyphenateStyleName.js\");\nvar camelizeStyleName = __webpack_require__(/*! fbjs/lib/camelizeStyleName */ \"./node_modules/fbjs/lib/camelizeStyleName.js\");\n\n// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  this._hasCaughtError = false;\n  this._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this._caughtError = error;\n    this._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;\n      var evt = document.createEvent('Event');\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        this._hasCaughtError = true;\n        this._caughtError = error;\n      } else {\n        this._hasCaughtError = false;\n        this._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallback$1 = invokeGuardedCallback;\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar EventPluginRegistry = Object.freeze({\n\tplugins: plugins,\n\teventNameDispatchConfigs: eventNameDispatchConfigs,\n\tregistrationNameModules: registrationNameModules,\n\tregistrationNameDependencies: registrationNameDependencies,\n\tpossibleRegistrationNames: possibleRegistrationNames,\n\tinjectEventPluginOrder: injectEventPluginOrder,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      !(getNodeFromInstance && getInstanceFromNode) ? warning(false, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n    }\n  }\n};\n\n\n\n\n\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warning(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventsInBatch(events, false);\n}\n\nvar EventPluginHub = Object.freeze({\n\tinjection: injection,\n\tgetListener: getListener,\n\trunEventsInBatch: runEventsInBatch,\n\trunExtractedEventsInBatch: runExtractedEventsInBatch\n});\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\nvar Mode = 11;\nvar ContextConsumer = 12;\nvar ContextProvider = 13;\nvar ForwardRef = 14;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode$1(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps$1(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = Object.freeze({\n\tprecacheFiberNode: precacheFiberNode$1,\n\tgetClosestInstanceFromNode: getClosestInstanceFromNode,\n\tgetInstanceFromNode: getInstanceFromNode$1,\n\tgetNodeFromInstance: getNodeFromInstance$1,\n\tgetFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n\tupdateFiberProps: updateFiberProps$1\n});\n\nfunction getParent(inst) {\n  do {\n    inst = inst['return'];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warning(false, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EventPropagators = Object.freeze({\n\taccumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n\taccumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n\taccumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n\taccumulateDirectDispatches: accumulateDirectDispatches\n});\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nfunction initialize(nativeEventTarget) {\n  compositionState._root = nativeEventTarget;\n  compositionState._startText = getText();\n  return true;\n}\n\nfunction reset() {\n  compositionState._root = null;\n  compositionState._startText = null;\n  compositionState._fallbackText = null;\n}\n\nfunction getData() {\n  if (compositionState._fallbackText) {\n    return compositionState._fallbackText;\n  }\n\n  var start = void 0;\n  var startValue = compositionState._startText;\n  var startLength = startValue.length;\n  var end = void 0;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  compositionState._fallbackText = endValue.slice(start, sliceTail);\n  return compositionState._fallbackText;\n}\n\nfunction getText() {\n  if ('value' in compositionState._root) {\n    return compositionState._root.value;\n  }\n  return compositionState._root[getTextContentAccessor()];\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  var isProxySupported = typeof Proxy === 'function' &&\n  // https://github.com/facebook/react/issues/12011\n  !Object.isSealed(new Proxy({}, {}));\n\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              !(didWarnForAddedNewProperty || target.isPersistent()) ? warning(false, \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warning(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar SyntheticCompositionEvent = SyntheticEvent$1.extend({\n  data: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar SyntheticInputEvent = SyntheticEvent$1.extend({\n  data: null\n});\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case 'topCompositionStart':\n      return eventTypes.compositionStart;\n    case 'topCompositionEnd':\n      return eventTypes.compositionEnd;\n    case 'topCompositionUpdate':\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topKeyUp':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'topKeyDown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'topKeyPress':\n    case 'topMouseDown':\n    case 'topBlur':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType = void 0;\n  var fallbackData = void 0;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topCompositionEnd':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'topKeyPress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'topTextInput':\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case 'topPaste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'topKeyPress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'topCompositionEnd':\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars = void 0;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n}\n\nvar injection$2 = ReactControlledComponentInjection;\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\nvar ReactControlledComponent = Object.freeze({\n\tinjection: injection$2,\n\tenqueueStateRestore: enqueueStateRestore,\n\tneedsStateRestore: needsStateRestore,\n\trestoreStateIfNeeded: restoreStateIfNeeded\n});\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdates = function (fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdates = function () {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdates();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction interactiveUpdates(fn, a, b) {\n  return _interactiveUpdates(fn, a, b);\n}\n\n\n\nvar injection$3 = {\n  injectRenderer: function (renderer) {\n    _batchedUpdates = renderer.batchedUpdates;\n    _interactiveUpdates = renderer.interactiveUpdates;\n    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;\n  }\n};\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n\n  Object.defineProperty(node, valueField, {\n    configurable: true,\n    get: function () {\n      return descriptor.get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      descriptor.set.call(this, value);\n    }\n  });\n  // We could've passed this the first time\n  // but it triggers a bug in IE11 and Edge 14/15.\n  // Calling defineProperty() again should be equivalent.\n  // https://github.com/facebook/react/issues/11768\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol['for']('react.strict_mode') : 0xeacc;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol['for']('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol['for']('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol['for']('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol['for']('react.forward_ref') : 0xead0;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'ReactFragment';\n    case REACT_PORTAL_TYPE:\n      return 'ReactPortal';\n    case REACT_CALL_TYPE:\n      return 'ReactCall';\n    case REACT_RETURN_TYPE:\n      return 'ReactReturn';\n  }\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || '';\n        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    }\n  }\n  return null;\n}\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum$1() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum$1;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName$1,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum$1\n};\n\n// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED = 0;\n\n// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nvar STRING = 1;\n\n// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING = 2;\n\n// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN = 3;\n\n// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN = 4;\n\n// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC = 5;\n\n// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC = 6;\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\n\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\nfunction shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null) {\n    return propertyInfo.type === RESERVED;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return true;\n  }\n  return false;\n}\n\nfunction shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n    return false;\n  }\n  switch (typeof value) {\n    case 'function':\n    // $FlowIssue symbol is perfectly valid here\n    case 'symbol':\n      // eslint-disable-line\n      return true;\n    case 'boolean':\n      {\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (propertyInfo !== null) {\n          return !propertyInfo.acceptsBooleans;\n        } else {\n          var prefix = name.toLowerCase().slice(0, 5);\n          return prefix !== 'data-' && prefix !== 'aria-';\n        }\n      }\n    default:\n      return false;\n  }\n}\n\nfunction shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n  if (value === null || typeof value === 'undefined') {\n    return true;\n  }\n  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n    return true;\n  }\n  if (propertyInfo !== null) {\n    switch (propertyInfo.type) {\n      case BOOLEAN:\n        return !value;\n      case OVERLOADED_BOOLEAN:\n        return value === false;\n      case NUMERIC:\n        return isNaN(value);\n      case POSITIVE_NUMERIC:\n        return isNaN(value) || value < 1;\n    }\n  }\n  return false;\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {\n  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n  this.attributeName = attributeName;\n  this.attributeNamespace = attributeNamespace;\n  this.mustUseProperty = mustUseProperty;\n  this.propertyName = name;\n  this.type = type;\n}\n\n// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties = {};\n\n// These props are reserved by React. They shouldn't be written to the DOM.\n['children', 'dangerouslySetInnerHTML',\n// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\n  name, // attributeName\n  null);\n});\n\n// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {\n  var name = _ref[0],\n      attributeName = _ref[1];\n\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, // attributeName\n  null);\n});\n\n// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse', 'externalResourcesRequired', 'preserveAlpha'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name, // attributeName\n  null);\n});\n\n// These are HTML boolean attributes.\n['allowFullScreen', 'async',\n// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',\n// Microdata\n'itemScope'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',\n// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple', 'muted', 'selected'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture', 'download'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are HTML attributes that must be positive numbers.\n['cols', 'rows', 'size', 'span'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\n// These are HTML attributes that must be numbers.\n['rowSpan', 'start'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n});\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\n// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, null);\n});\n\n// String SVG attributes with the xlink namespace.\n['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/1999/xlink');\n});\n\n// String SVG attributes with the xml namespace.\n['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/XML/1998/namespace');\n});\n\n// Special case: this attribute exists both in HTML and SVG.\n// Its \"tabindex\" attribute name is case-sensitive in SVG so we can't just use\n// its React `tabIndex` name, like we do for attributes that exist only in HTML.\nproperties.tabIndex = new PropertyInfoRecord('tabIndex', STRING, false, // mustUseProperty\n'tabindex', // attributeName\nnull);\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value, isCustomComponentTag) {\n  var propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      var _attributeName = name;\n      if (value === null) {\n        node.removeAttribute(_attributeName);\n      } else {\n        node.setAttribute(_attributeName, '' + value);\n      }\n    }\n    return;\n  }\n  var mustUseProperty = propertyInfo.mustUseProperty;\n\n  if (mustUseProperty) {\n    var propertyName = propertyInfo.propertyName;\n\n    if (value === null) {\n      var type = propertyInfo.type;\n\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  var attributeName = propertyInfo.attributeName,\n      attributeNamespace = propertyInfo.attributeNamespace;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    var _type = propertyInfo.type;\n\n    var attributeValue = void 0;\n    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = '' + value;\n    }\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var checked = props.checked;\n\n  var hostProps = _assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var node = element;\n  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getSafeValue(props.value != null ? props.value : defaultValue),\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var _controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {\n      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum());\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {\n      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum());\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = getSafeValue(props.value);\n\n  if (value != null) {\n    if (props.type === 'number') {\n      if (value === 0 && node.value === '' ||\n      // eslint-disable-next-line\n      node.value != value) {\n        node.value = '' + value;\n      }\n    } else if (node.value !== '' + value) {\n      node.value = '' + value;\n    }\n  }\n\n  if (props.hasOwnProperty('value')) {\n    setDefaultValue(node, props.type, value);\n  } else if (props.hasOwnProperty('defaultValue')) {\n    setDefaultValue(node, props.type, getSafeValue(props.defaultValue));\n  }\n\n  if (props.checked == null && props.defaultChecked != null) {\n    node.defaultChecked = !!props.defaultChecked;\n  }\n}\n\nfunction postMountWrapper(element, props) {\n  var node = element;\n\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n    if (node.value === '') {\n      node.value = '' + node._wrapperState.initialValue;\n    }\n\n    // value must be assigned before defaultValue. This fixes an issue where the\n    // visually displayed value of date inputs disappears on mobile Safari and Chrome:\n    // https://github.com/facebook/react/issues/7233\n    node.defaultValue = '' + node._wrapperState.initialValue;\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n  node.defaultChecked = !node.defaultChecked;\n  node.defaultChecked = !node.defaultChecked;\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node, type, value) {\n  if (\n  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n  type !== 'number' || node.ownerDocument.activeElement !== node) {\n    if (value == null) {\n      node.defaultValue = '' + node._wrapperState.initialValue;\n    } else if (node.defaultValue !== '' + value) {\n      node.defaultValue = '' + value;\n    }\n  }\n}\n\nfunction getSafeValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'object':\n    case 'string':\n    case 'undefined':\n      return value;\n    default:\n      // function, symbol are assigned as empty strings\n      return '';\n  }\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event, false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  setDefaultValue(node, 'number', node.value);\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc = void 0,\n        handleEventFunc = void 0;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\nvar SyntheticUIEvent = SyntheticEvent$1.extend({\n  view: null,\n  detail: null\n});\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticMouseEvent = SyntheticUIEvent.extend({\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n});\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (topLevelType === 'topMouseOut') {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */0;\nvar PerformedWork = /*         */1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */2;\nvar Update = /*                */4;\nvar PlacementAndUpdate = /*    */6;\nvar Deletion = /*              */8;\nvar ContentReset = /*          */16;\nvar Callback = /*              */32;\nvar DidCapture = /*            */64;\nvar Ref = /*                   */128;\nvar ErrLog = /*                */256;\nvar Snapshot = /*              */2048;\n\n// Union of all host effects\nvar HostEffectMask = /*        */2559;\n\nvar Incomplete = /*            */512;\nvar ShouldCapture = /*         */1024;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender ? warning(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component') : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction addEventBubbleListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, false);\n}\n\nfunction addEventCaptureListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, true);\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar SyntheticAnimationEvent = SyntheticEvent$1.extend({\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar SyntheticClipboardEvent = SyntheticEvent$1.extend({\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n});\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticFocusEvent = SyntheticUIEvent.extend({\n  relatedTarget: null\n});\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode = void 0;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n  // report Enter as charCode 10 when ctrl is pressed.\n  if (charCode === 10) {\n    charCode = 13;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticKeyboardEvent = SyntheticUIEvent.extend({\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n});\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticDragEvent = SyntheticMouseEvent.extend({\n  dataTransfer: null\n});\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar SyntheticTouchEvent = SyntheticUIEvent.extend({\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar SyntheticTransitionEvent = SyntheticEvent$1.extend({\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticWheelEvent = SyntheticMouseEvent.extend({\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n});\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: ['topAbort'],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = {\n *   'topAbort': { sameConfig }\n * };\n */\nvar interactiveEventTypeNames = ['blur', 'cancel', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'dragEnd', 'dragStart', 'drop', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'mouseDown', 'mouseUp', 'paste', 'pause', 'play', 'rateChange', 'reset', 'seeked', 'submit', 'touchCancel', 'touchEnd', 'touchStart', 'volumeChange'];\nvar nonInteractiveEventTypeNames = ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'canPlay', 'canPlayThrough', 'drag', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseMove', 'mouseOut', 'mouseOver', 'playing', 'progress', 'scroll', 'seeking', 'stalled', 'suspend', 'timeUpdate', 'toggle', 'touchMove', 'transitionEnd', 'waiting', 'wheel'];\n\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n\nfunction addEventTypeNameToConfig(event, isInteractive) {\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n  var topEvent = 'top' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent],\n    isInteractive: isInteractive\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n}\n\ninteractiveEventTypeNames.forEach(function (eventTypeName) {\n  addEventTypeNameToConfig(eventTypeName, true);\n});\nnonInteractiveEventTypeNames.forEach(function (eventTypeName) {\n  addEventTypeNameToConfig(eventTypeName, false);\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  isInteractiveTopLevelEventType: function (topLevelType) {\n    var config = topLevelEventsToDispatchConfig[topLevelType];\n    return config !== undefined && config.isInteractive === true;\n  },\n\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor = void 0;\n    switch (topLevelType) {\n      case 'topKeyPress':\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case 'topKeyDown':\n      case 'topKeyUp':\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case 'topBlur':\n      case 'topFocus':\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case 'topClick':\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case 'topDoubleClick':\n      case 'topMouseDown':\n      case 'topMouseMove':\n      case 'topMouseUp':\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case 'topMouseOut':\n      case 'topMouseOver':\n      case 'topContextMenu':\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case 'topDrag':\n      case 'topDragEnd':\n      case 'topDragEnter':\n      case 'topDragExit':\n      case 'topDragLeave':\n      case 'topDragOver':\n      case 'topDragStart':\n      case 'topDrop':\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case 'topTouchCancel':\n      case 'topTouchEnd':\n      case 'topTouchMove':\n      case 'topTouchStart':\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case 'topAnimationEnd':\n      case 'topAnimationIteration':\n      case 'topAnimationStart':\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case 'topTransitionEnd':\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case 'topCopy':\n      case 'topCut':\n      case 'topPaste':\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent$1;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nvar isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;\n\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst['return']) {\n    inst = inst['return'];\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventBubbleListener(element, handlerBaseName,\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventCaptureListener(element, handlerBaseName,\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\nfunction dispatchInteractiveEvent(topLevelType, nativeEvent) {\n  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nvar ReactDOMEventListener = Object.freeze({\n\tget _enabled () { return _enabled; },\n\tsetEnabled: setEnabled,\n\tisEnabled: isEnabled,\n\ttrapBubbledEvent: trapBubbledEvent,\n\ttrapCapturedEvent: trapCapturedEvent,\n\tdispatchEvent: dispatchEvent\n});\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return eventName;\n}\n\n/**\n * Types of raw signals from the browser caught at the top level.\n *\n * For events like 'submit' or audio/video events which don't consistently\n * bubble (which we trap at a lower node than `document`), binding\n * at `document` would cause duplicate events so we don't include them here.\n */\nvar topLevelTypes = {\n  topAnimationEnd: getVendorPrefixedEventName('animationend'),\n  topAnimationIteration: getVendorPrefixedEventName('animationiteration'),\n  topAnimationStart: getVendorPrefixedEventName('animationstart'),\n  topBlur: 'blur',\n  topCancel: 'cancel',\n  topChange: 'change',\n  topClick: 'click',\n  topClose: 'close',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoad: 'load',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topScroll: 'scroll',\n  topSelectionChange: 'selectionchange',\n  topTextInput: 'textInput',\n  topToggle: 'toggle',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topTransitionEnd: getVendorPrefixedEventName('transitionend'),\n  topWheel: 'wheel'\n};\n\n// There are so many media events, it makes sense to just\n// maintain a list of them. Note these aren't technically\n// \"top-level\" since they don't bubble. We should come up\n// with a better naming convention if we come to refactoring\n// the event system.\nvar mediaEventTypes = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} contentDocumentHandle Document which owns the container\n */\nfunction listenTo(registrationName, contentDocumentHandle) {\n  var mountAt = contentDocumentHandle;\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      if (dependency === 'topScroll') {\n        trapCapturedEvent('topScroll', 'scroll', mountAt);\n      } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n        trapCapturedEvent('topFocus', 'focus', mountAt);\n        trapCapturedEvent('topBlur', 'blur', mountAt);\n\n        // to make sure blur and focus event listeners are only attached once\n        isListening.topBlur = true;\n        isListening.topFocus = true;\n      } else if (dependency === 'topCancel') {\n        if (isEventSupported('cancel', true)) {\n          trapCapturedEvent('topCancel', 'cancel', mountAt);\n        }\n        isListening.topCancel = true;\n      } else if (dependency === 'topClose') {\n        if (isEventSupported('close', true)) {\n          trapCapturedEvent('topClose', 'close', mountAt);\n        }\n        isListening.topClose = true;\n      } else if (topLevelTypes.hasOwnProperty(dependency)) {\n        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n      }\n\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElement();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElement();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    priorFocusedElem.focus();\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case 'topFocus':\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case 'topBlur':\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case 'topMouseDown':\n        mouseDown = true;\n        break;\n      case 'topContextMenu':\n      case 'topMouseUp':\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case 'topSelectionChange':\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case 'topKeyDown':\n      case 'topKeyUp':\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(DOMEventPluginOrder);\ninjection$1.injectComponentTree(ReactDOMComponentTree);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\n\n// TODO: Use an opaque type once ESLint et al support the syntax\n\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = MAX_SIGNED_31_BIT_INT;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === 'function') {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_CALL_TYPE:\n        fiberTag = CallComponent;\n        break;\n      case REACT_RETURN_TYPE:\n        fiberTag = ReturnComponent;\n        break;\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break;\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break;\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n                break;\n              default:\n                if (typeof type.tag === 'number') {\n                  // Currently assumed to be a continuation and therefore is a\n                  // fiber already.\n                  // TODO: The yield system is currently broken for updates in\n                  // some cases. The reified yield stores a fiber, but we don't\n                  // know which fiber that is; the current or a workInProgress?\n                  // When the continuation gets rendered here we don't know if we\n                  // can reuse that fiber or if we need to clone it. There is\n                  // probably a clever way to restructure this.\n                  fiber = type;\n                  fiber.pendingProps = pendingProps;\n                  fiber.expirationTime = expirationTime;\n                  return fiber;\n                } else {\n                  throwOnInvalidElementType(type, owner);\n                }\n                break;\n            }\n          } else {\n            throwOnInvalidElementType(type, owner);\n          }\n        }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction throwOnInvalidElementType(type, owner) {\n  var info = '';\n  {\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n    }\n    var ownerName = owner ? getComponentName(owner) : null;\n    if (ownerName) {\n      info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n    }\n  }\n  invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target['return'] = source['return'];\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.alternate = source.alternate;\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n// TODO: This should be lifted into the renderer.\n\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    pendingCommitExpirationTime: NoWork,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    remainingExpirationTime: NoWork,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function () {},\n  flushPendingDeprecationWarnings: function () {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordDeprecationWarnings: function (fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: 'componentDidMount',\n    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',\n    UNSAFE_componentWillUpdate: 'componentDidUpdate'\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function (fiber) {\n            componentNames.add(getComponentName(fiber) || 'Component');\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace('UNSAFE_', '');\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(strictRoot);\n\n        warning(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\\n\\n%s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMesages.join('\\n\\n'));\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var getStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n\n    while (fiber !== null) {\n      if (fiber.mode & StrictMode) {\n        maybeStrictRoot = fiber;\n      }\n\n      fiber = fiber['return'];\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        _uniqueNames.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        _uniqueNames2.add(getComponentName(fiber) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    var strictRoot = getStrictRoot(fiber);\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    // Note that it is sufficient to check for the presence of a\n    // single lifecycle, componentWillMount, with the polyfill flag.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning === true) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (typeof instance.componentWillMount === 'function' || typeof instance.UNSAFE_componentWillMount === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillMount');\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');\n    }\n    if (typeof instance.componentWillUpdate === 'function' || typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillUpdate');\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function (lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n}\n\n// Exports ReactDOM.createRoot\nvar enableUserTimingAPI = true;\n\n// Mutating mode (React DOM, React ART, React Native):\nvar enableMutatingReconciler = true;\n// Experimental noop mode (currently unused):\nvar enableNoopReconciler = false;\n// Experimental persistent mode (Fabric):\nvar enablePersistentReconciler = false;\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\nvar enableGetDerivedStateFromCatch = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\nvar debugRenderPhaseSideEffectsForStrictMode = true;\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\nvar warnAboutDeprecatedLifecycles = false;\n\nvar alwaysUseRequestIdleCallbackPolyfill = false;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case CallComponent:\n    case ReturnComponent:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber['return'];\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber['return'] !== null) {\n    resumeTimersRecursively(fiber['return']);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\nvar didWarnUpdateInsideUpdate = void 0;\n\n{\n  didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false,\n    capturedValues: null\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nvar q1 = void 0;\nvar q2 = void 0;\nfunction ensureUpdateQueues(fiber) {\n  q1 = q2 = null;\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Use module variables instead of returning a tuple\n  q1 = queue1;\n  q2 = queue2;\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  ensureUpdateQueues(fiber);\n  var queue1 = q1;\n  var queue2 = q2;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n    case ClassComponent:\n      var updateQueue = fiber.updateQueue;\n      if (updateQueue === null) {\n        return NoWork;\n      }\n      return updateQueue.expirationTime;\n    default:\n      return NoWork;\n  }\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    return partialState.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      capturedValues: currentQueue.capturedValues,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    // Ignore the return value in this case.\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      getStateFromUpdate(update, instance, state, props);\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    if (update.capturedValue !== null) {\n      var _capturedValues = queue.capturedValues;\n      if (_capturedValues === null) {\n        queue.capturedValues = [update.capturedValue];\n      } else {\n        _capturedValues.push(update.capturedValue);\n      }\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate && queue.capturedValues === null) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar warnOnInvalidCallback$1 = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback$1 = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    var key = callerName + '_' + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warning(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\nfunction callGetDerivedStateFromCatch(ctor, capturedValues) {\n  var resultState = {};\n  for (var i = 0; i < capturedValues.length; i++) {\n    var capturedValue = capturedValues[i];\n    var error = capturedValue.value;\n    var partialState = ctor.getDerivedStateFromCatch.call(null, error);\n    if (partialState !== null && partialState !== undefined) {\n      _assign(resultState, partialState);\n    }\n  }\n  return resultState;\n}\n\nvar ReactFiberClassComponent = function (legacyContext, scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  var cacheContext = legacyContext.cacheContext,\n      getMaskedContext = legacyContext.getMaskedContext,\n      getUnmaskedContext = legacyContext.getUnmaskedContext,\n      isContextConsumer = legacyContext.isContextConsumer,\n      hasContextChanged = legacyContext.hasContextChanged;\n\n  // Class component state updater\n\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback$1(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback$1(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback$1(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        capturedValue: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var ctor = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      stopPhaseTimer();\n\n      {\n        !(shouldUpdate !== undefined) ? warning(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Component') : void 0;\n      }\n\n      return shouldUpdate;\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress) || 'Component';\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      !noGetInitialStateOnES6 ? warning(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      !noGetDefaultPropsOnES6 ? warning(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;\n      var noInstancePropTypes = !instance.propTypes;\n      !noInstancePropTypes ? warning(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;\n      var noInstanceContextTypes = !instance.contextTypes;\n      !noInstanceContextTypes ? warning(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      !noComponentShouldUpdate ? warning(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      !noComponentDidUnmount ? warning(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;\n      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n      !noComponentDidReceiveProps ? warning(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      !noComponentWillRecieveProps ? warning(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;\n      var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n      !noUnsafeComponentWillRecieveProps ? warning(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      !(instance.props === undefined || !hasMutatedProps) ? warning(false, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name) : void 0;\n      var noInstanceDefaultProps = !instance.defaultProps;\n      !noInstanceDefaultProps ? warning(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;\n\n      if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type)) {\n        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type);\n        warning(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(workInProgress));\n      }\n\n      var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';\n      !noInstanceGetDerivedStateFromProps ? warning(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n      var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== 'function';\n      !noInstanceGetDerivedStateFromCatch ? warning(false, '%s: getDerivedStateFromCatch() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n      var noStaticGetSnapshotBeforeUpdate = typeof type.getSnapshotBeforeUpdate !== 'function';\n      !noStaticGetSnapshotBeforeUpdate ? warning(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;\n      var _state = instance.state;\n      if (_state && (typeof _state !== 'object' || isArray(_state))) {\n        warning(false, '%s.state: must be set to an object or null', name);\n      }\n      if (typeof instance.getChildContext === 'function') {\n        !(typeof type.childContextTypes === 'object') ? warning(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;\n      }\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n\n    // Instantiate twice to help detect side-effects.\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n\n    var instance = new ctor(props, context);\n    var state = instance.state !== null && instance.state !== undefined ? instance.state : null;\n    adoptClassInstance(workInProgress, instance);\n\n    {\n      if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutUninitializedState.has(componentName)) {\n          didWarnAboutUninitializedState.add(componentName);\n          warning(false, '%s: Did not properly initialize state during construction. ' + 'Expected state to be an object, but it was %s.', componentName, instance.state === null ? 'null' : 'undefined');\n        }\n      }\n\n      // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n      // Warn about these lifecycles if they are present.\n      // Don't warn about react-lifecycles-compat polyfilled methods though.\n      if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n        var foundWillMountName = null;\n        var foundWillReceivePropsName = null;\n        var foundWillUpdateName = null;\n        if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n          foundWillMountName = 'componentWillMount';\n        } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n          foundWillMountName = 'UNSAFE_componentWillMount';\n        }\n        if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n          foundWillReceivePropsName = 'componentWillReceiveProps';\n        } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n          foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n        }\n        if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n          foundWillUpdateName = 'componentWillUpdate';\n        } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n          foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n        }\n        if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n          var _componentName = getComponentName(workInProgress) || 'Component';\n          var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n          if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n            warning(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '');\n          }\n        }\n      }\n    }\n\n    workInProgress.memoizedState = state;\n\n    var partialState = callGetDerivedStateFromProps(workInProgress, instance, props, state);\n\n    if (partialState !== null && partialState !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      workInProgress.memoizedState = _assign({}, workInProgress.memoizedState, partialState);\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, 'componentWillMount');\n    var oldState = instance.state;\n\n    if (typeof instance.componentWillMount === 'function') {\n      instance.componentWillMount();\n    }\n    if (typeof instance.UNSAFE_componentWillMount === 'function') {\n      instance.UNSAFE_componentWillMount();\n    }\n\n    stopPhaseTimer();\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress) || 'Component');\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    var oldState = instance.state;\n    startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n    if (typeof instance.componentWillReceiveProps === 'function') {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n    if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      instance.UNSAFE_componentWillReceiveProps(newProps, newContext);\n    }\n    stopPhaseTimer();\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n          didWarnAboutStateAssignmentForComponent.add(componentName);\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callGetDerivedStateFromProps(workInProgress, instance, nextProps, prevState) {\n    var type = workInProgress.type;\n\n\n    if (typeof type.getDerivedStateFromProps === 'function') {\n      if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        // Invoke method an extra time to help detect side-effects.\n        type.getDerivedStateFromProps.call(null, nextProps, prevState);\n      }\n\n      var partialState = type.getDerivedStateFromProps.call(null, nextProps, prevState);\n\n      {\n        if (partialState === undefined) {\n          var componentName = getComponentName(workInProgress) || 'Component';\n          if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n            didWarnAboutUndefinedDerivedState.add(componentName);\n            warning(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n          }\n        }\n      }\n\n      return partialState;\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    {\n      if (workInProgress.mode & StrictMode) {\n        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n      }\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);\n      }\n    }\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  function resumeMountClassInstance(workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    var hasNewLifecycles = typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(null, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null && updateQueue.capturedValues !== null && enableGetDerivedStateFromCatch && typeof ctor.getDerivedStateFromCatch === 'function') {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(ctor, capturedValues);\n      }\n    } else {\n      newState = oldState;\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      // The prevState parameter should be the partially updated state.\n      // Otherwise, spreading state in return values could override updates.\n      derivedStateFromProps = callGetDerivedStateFromProps(workInProgress, instance, newProps, newState);\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromProps : _assign({}, newState, derivedStateFromProps);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue = workInProgress.updateQueue;\n      if (_updateQueue !== null) {\n        _updateQueue.baseState = _assign({}, _updateQueue.baseState, derivedStateFromProps);\n      }\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromCatch : _assign({}, newState, derivedStateFromCatch);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue2 = workInProgress.updateQueue;\n      if (_updateQueue2 !== null) {\n        _updateQueue2.baseState = _assign({}, _updateQueue2.baseState, derivedStateFromCatch);\n      }\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for components using the new APIs.\n      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n        startPhaseTimer(workInProgress, 'componentWillMount');\n        if (typeof instance.componentWillMount === 'function') {\n          instance.componentWillMount();\n        }\n        if (typeof instance.UNSAFE_componentWillMount === 'function') {\n          instance.UNSAFE_componentWillMount();\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidMount === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidMount === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    var hasNewLifecycles = typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n      if (oldProps !== newProps || oldContext !== newContext) {\n        callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    var derivedStateFromCatch = void 0;\n\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null && updateQueue.capturedValues !== null && enableGetDerivedStateFromCatch && typeof ctor.getDerivedStateFromCatch === 'function') {\n        var capturedValues = updateQueue.capturedValues;\n        // Don't remove these from the update queue yet. We need them in\n        // finishClassComponent. Do the reset there.\n        // TODO: This is awkward. Refactor class components.\n        // updateQueue.capturedValues = null;\n        derivedStateFromCatch = callGetDerivedStateFromCatch(ctor, capturedValues);\n      }\n    } else {\n      newState = oldState;\n    }\n\n    var derivedStateFromProps = void 0;\n    if (oldProps !== newProps) {\n      // The prevState parameter should be the partially updated state.\n      // Otherwise, spreading state in return values could override updates.\n      derivedStateFromProps = callGetDerivedStateFromProps(workInProgress, instance, newProps, newState);\n    }\n\n    if (derivedStateFromProps !== null && derivedStateFromProps !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromProps : _assign({}, newState, derivedStateFromProps);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue3 = workInProgress.updateQueue;\n      if (_updateQueue3 !== null) {\n        _updateQueue3.baseState = _assign({}, _updateQueue3.baseState, derivedStateFromProps);\n      }\n    }\n    if (derivedStateFromCatch !== null && derivedStateFromCatch !== undefined) {\n      // Render-phase updates (like this) should not be added to the update queue,\n      // So that multiple render passes do not enqueue multiple updates.\n      // Instead, just synchronously merge the returned state into the instance.\n      newState = newState === null || newState === undefined ? derivedStateFromCatch : _assign({}, newState, derivedStateFromCatch);\n\n      // Update the base state of the update queue.\n      // FIXME: This is getting ridiculous. Refactor plz!\n      var _updateQueue4 = workInProgress.updateQueue;\n      if (_updateQueue4 !== null) {\n        _updateQueue4.baseState = _assign({}, _updateQueue4.baseState, derivedStateFromCatch);\n      }\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Snapshot;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      // In order to support react-lifecycles-compat polyfilled components,\n      // Unsafe lifecycles should not be invoked for components using the new APIs.\n      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        if (typeof instance.componentWillUpdate === 'function') {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n        if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n          instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n        }\n        stopPhaseTimer();\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n        workInProgress.effectTag |= Snapshot;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Snapshot;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    callGetDerivedStateFromProps: callGetDerivedStateFromProps,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    resumeMountClassInstance: resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\nvar getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function (child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$2() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$2());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber) || 'Component';\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warning(false, 'A string ref, \"%s\",has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\\n%s' + '\\n\\nLearn more about using refs safely here:' + '\\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackAddendumByWorkInProgressFiber(returnFiber));\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a functional component\\n2. You may be adding a ref to a component that was not created inside a component\\'s render method\\n3. You have multiple copies of React loaded\\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$2() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$2() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$2() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created['return'] = returnFiber;\n            return _created;\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            _created2['return'] = returnFiber;\n            return _created2;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        _created3['return'] = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$2());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$2()) : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4['return'] = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, legacyContext, newContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var pushProvider = newContext.pushProvider;\n  var getMaskedContext = legacyContext.getMaskedContext,\n      getUnmaskedContext = legacyContext.getUnmaskedContext,\n      hasLegacyContextChanged = legacyContext.hasContextChanged,\n      pushLegacyContextProvider = legacyContext.pushContextProvider,\n      pushTopLevelContextObject = legacyContext.pushTopLevelContextObject,\n      invalidateContextProvider = legacyContext.invalidateContextProvider;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(legacyContext, scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      callGetDerivedStateFromProps = _ReactFiberClassCompo.callGetDerivedStateFromProps,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      resumeMountClassInstance = _ReactFiberClassCompo.resumeMountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateForwardRef(current, workInProgress) {\n    var render = workInProgress.type.render;\n    var nextChildren = render(workInProgress.pendingProps, workInProgress.ref);\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function updateMode(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps.children;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (current === null && ref !== null || current !== null && current.ref !== ref) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else {\n      if (workInProgress.memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren = void 0;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushLegacyContextProvider(workInProgress);\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (workInProgress.stateNode === null) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n\n        shouldUpdate = true;\n      } else {\n        // In a resume, we'll already have an instance we can reuse.\n        shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n\n    // We processed the update queue inside updateClassInstance. It may have\n    // included some errors that were dispatched during the commit phase.\n    // TODO: Refactor class components so this is less awkward.\n    var didCaptureError = false;\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null && updateQueue.capturedValues !== null) {\n      shouldUpdate = true;\n      didCaptureError = true;\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, didCaptureError, renderExpirationTime);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext, didCaptureError, renderExpirationTime) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate && !didCaptureError) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var ctor = workInProgress.type;\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof ctor.getDerivedStateFromCatch !== 'function')) {\n      // If we captured an error, but getDerivedStateFrom catch is not defined,\n      // unmount all the children. componentDidCatch will schedule an update to\n      // re-render a fallback. This is temporary until we migrate everyone to\n      // the new API.\n      // TODO: Warn in a future release.\n      nextChildren = null;\n    } else {\n      {\n        ReactDebugCurrentFiber.setCurrentPhase('render');\n        nextChildren = instance.render();\n        if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n          instance.render();\n        }\n        ReactDebugCurrentFiber.setCurrentPhase(null);\n      }\n    }\n\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    if (didCaptureError) {\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildrenAtExpirationTime(current, workInProgress, null, renderExpirationTime);\n      workInProgress.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    }\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      memoizeState(workInProgress, state);\n      updateQueue = workInProgress.updateQueue;\n\n      var element = void 0;\n      if (updateQueue !== null && updateQueue.capturedValues !== null) {\n        // There's an uncaught error. Unmount the whole root.\n        element = null;\n      } else if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      } else {\n        element = state.element;\n      }\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (memoizedProps === nextProps) {\n      var isHidden = workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps);\n      if (isHidden) {\n        // Before bailing out, make sure we've deprioritized a hidden component.\n        workInProgress.expirationTime = Never;\n      }\n      if (!isHidden || renderExpirationTime !== Never) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // If we're rendering a hidden node at hidden priority, don't bailout. The\n      // parent is complete, but the children may not be.\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      workInProgress.memoizedProps = nextProps;\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value = void 0;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress) || 'Unknown';\n\n        if (!didWarnAboutBadClass[componentName]) {\n          warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n          didWarnAboutBadClass[componentName] = true;\n        }\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      var Component = workInProgress.type;\n\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n\n      if (typeof Component.getDerivedStateFromProps === 'function') {\n        var partialState = callGetDerivedStateFromProps(workInProgress, value, props, workInProgress.memoizedState);\n\n        if (partialState !== null && partialState !== undefined) {\n          workInProgress.memoizedState = _assign({}, workInProgress.memoizedState, partialState);\n        }\n      }\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushLegacyContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext, false, renderExpirationTime);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var _Component = workInProgress.type;\n\n        if (_Component) {\n          !!_Component.childContextTypes ? warning(false, '%s(...): childContextTypes cannot be defined on a functional component.', _Component.displayName || _Component.name || 'Component') : void 0;\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!didWarnAboutStatelessRefs[warningKey]) {\n            didWarnAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n\n        if (typeof fn.getDerivedStateFromProps === 'function') {\n          var _componentName = getComponentName(workInProgress) || 'Unknown';\n\n          if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n            warning(false, '%s: Stateless functional components do not support getDerivedStateFromProps.', _componentName);\n            didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextProps = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextProps) {\n      nextProps = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, current.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextProps);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {\n    var fiber = workInProgress.child;\n    if (fiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      fiber['return'] = workInProgress;\n    }\n    while (fiber !== null) {\n      var nextFiber = void 0;\n      // Visit this fiber.\n      switch (fiber.tag) {\n        case ContextConsumer:\n          // Check if the context matches.\n          var observedBits = fiber.stateNode | 0;\n          if (fiber.type === context && (observedBits & changedBits) !== 0) {\n            // Update the expiration time of all the ancestors, including\n            // the alternates.\n            var node = fiber;\n            while (node !== null) {\n              var alternate = node.alternate;\n              if (node.expirationTime === NoWork || node.expirationTime > renderExpirationTime) {\n                node.expirationTime = renderExpirationTime;\n                if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n                  alternate.expirationTime = renderExpirationTime;\n                }\n              } else if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n                alternate.expirationTime = renderExpirationTime;\n              } else {\n                // Neither alternate was updated, which means the rest of the\n                // ancestor path already has sufficient priority.\n                break;\n              }\n              node = node['return'];\n            }\n            // Don't scan deeper than a matching consumer. When we render the\n            // consumer, we'll continue scanning from that point. This way the\n            // scanning work is time-sliced.\n            nextFiber = null;\n          } else {\n            // Traverse down.\n            nextFiber = fiber.child;\n          }\n          break;\n        case ContextProvider:\n          // Don't scan deeper if this is a matching provider\n          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n          break;\n        default:\n          // Traverse down.\n          nextFiber = fiber.child;\n          break;\n      }\n      if (nextFiber !== null) {\n        // Set the return pointer of the child to the work-in-progress fiber.\n        nextFiber['return'] = fiber;\n      } else {\n        // No child. Traverse to next sibling.\n        nextFiber = fiber;\n        while (nextFiber !== null) {\n          if (nextFiber === workInProgress) {\n            // We're back to the root of this subtree. Exit.\n            nextFiber = null;\n            break;\n          }\n          var sibling = nextFiber.sibling;\n          if (sibling !== null) {\n            nextFiber = sibling;\n            break;\n          }\n          // No more siblings. Traverse up.\n          nextFiber = nextFiber['return'];\n        }\n      }\n      fiber = nextFiber;\n    }\n  }\n\n  function updateContextProvider(current, workInProgress, renderExpirationTime) {\n    var providerType = workInProgress.type;\n    var context = providerType._context;\n\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (oldProps === newProps) {\n      workInProgress.stateNode = 0;\n      pushProvider(workInProgress);\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var newValue = newProps.value;\n    workInProgress.memoizedProps = newProps;\n\n    var changedBits = void 0;\n    if (oldProps === null) {\n      // Initial render\n      changedBits = MAX_SIGNED_31_BIT_INT;\n    } else {\n      if (oldProps.value === newProps.value) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children) {\n          workInProgress.stateNode = 0;\n          pushProvider(workInProgress);\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        changedBits = 0;\n      } else {\n        var oldValue = oldProps.value;\n        // Use Object.is to compare the new context value to the old value.\n        // Inlined Object.is polyfill.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n        if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue // eslint-disable-line no-self-compare\n        ) {\n            // No change. Bailout early if children are the same.\n            if (oldProps.children === newProps.children) {\n              workInProgress.stateNode = 0;\n              pushProvider(workInProgress);\n              return bailoutOnAlreadyFinishedWork(current, workInProgress);\n            }\n            changedBits = 0;\n          } else {\n          changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\n          {\n            !((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits) ? warning(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;\n          }\n          changedBits |= 0;\n\n          if (changedBits === 0) {\n            // No change. Bailout early if children are the same.\n            if (oldProps.children === newProps.children) {\n              workInProgress.stateNode = 0;\n              pushProvider(workInProgress);\n              return bailoutOnAlreadyFinishedWork(current, workInProgress);\n            }\n          } else {\n            propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n          }\n        }\n      }\n    }\n\n    workInProgress.stateNode = changedBits;\n    pushProvider(workInProgress);\n\n    var newChildren = newProps.children;\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  function updateContextConsumer(current, workInProgress, renderExpirationTime) {\n    var context = workInProgress.type;\n    var newProps = workInProgress.pendingProps;\n    var oldProps = workInProgress.memoizedProps;\n\n    var newValue = context._currentValue;\n    var changedBits = context._changedBits;\n\n    if (hasLegacyContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (changedBits === 0 && oldProps === newProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    workInProgress.memoizedProps = newProps;\n\n    var observedBits = newProps.unstable_observedBits;\n    if (observedBits === undefined || observedBits === null) {\n      // Subscribe to all changes by default\n      observedBits = MAX_SIGNED_31_BIT_INT;\n    }\n    // Store the observedBits on the fiber's stateNode for quick access.\n    workInProgress.stateNode = observedBits;\n\n    if ((changedBits & observedBits) !== 0) {\n      // Context change propagation stops at matching consumers, for time-\n      // slicing. Continue the propagation here.\n      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n    } else if (oldProps === newProps) {\n      // Skip over a memoized parent with a bitmask bailout even\n      // if we began working on it because of a deeper matching child.\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    // There is no bailout on `children` equality because we expect people\n    // to often pass a bound method as a child, but it may reference\n    // `this.state` or `this.props` (and thus needs to re-render on `setState`).\n\n    var render = newProps.children;\n\n    {\n      !(typeof render === 'function') ? warning(false, 'A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;\n    }\n\n    var newChildren = render(newValue);\n    reconcileChildren(current, workInProgress, newChildren);\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushLegacyContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n      case ContextProvider:\n        pushProvider(workInProgress);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case ForwardRef:\n        return updateForwardRef(current, workInProgress);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      case Mode:\n        return updateMode(current, workInProgress);\n      case ContextProvider:\n        return updateContextProvider(current, workInProgress, renderExpirationTime);\n      case ContextConsumer:\n        return updateContextConsumer(current, workInProgress, renderExpirationTime);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    beginWork: beginWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, legacyContext, newContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var popLegacyContextProvider = legacyContext.popContextProvider,\n      popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject;\n  var popProvider = newContext.popProvider;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // a PlacementAndUpdate.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.pendingProps.value);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var props = workInProgress.memoizedProps;\n    !props ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = props.handler;\n    var childProps = props.props;\n    var nextChildren = fn(childProps, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          portalOrRoot.pendingChildren = newChildSet;\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n          finalizeContainerChildren(container, newChildSet);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    var newProps = workInProgress.pendingProps;\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popLegacyContextProvider(workInProgress);\n\n          // If this component caught an error, schedule an error log effect.\n          var instance = workInProgress.stateNode;\n          var updateQueue = workInProgress.updateQueue;\n          if (updateQueue !== null && updateQueue.capturedValues !== null) {\n            workInProgress.effectTag &= ~DidCapture;\n            if (typeof instance.componentDidCatch === 'function') {\n              workInProgress.effectTag |= ErrLog;\n            } else {\n              // Normally we clear this in the commit phase, but since we did not\n              // schedule an effect, we need to reset it here.\n              updateQueue.capturedValues = null;\n            }\n          }\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelLegacyContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n\n          var _updateQueue = workInProgress.updateQueue;\n          if (_updateQueue !== null && _updateQueue.capturedValues !== null) {\n            workInProgress.effectTag |= ErrLog;\n          }\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var _instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            // TODO: Experiencing an error where oldProps is null. Suggests a host\n            // component is hitting the resume path. Figure out why. Possibly\n            // related to `hidden`.\n            var updatePayload = prepareUpdate(_instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance2 = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance2, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance2, type, newProps, rootContainerInstance, _currentHostContext)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance2;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case ForwardRef:\n        return null;\n      case Fragment:\n        return null;\n      case Mode:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        // Pop provider fiber\n        popProvider(workInProgress);\n        return null;\n      case ContextConsumer:\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackAddendumByWorkInProgressFiber(source)\n  };\n}\n\nvar ReactFiberUnwindWork = function (hostContext, legacyContext, newContext, scheduleWork, isAlreadyFailedLegacyErrorBoundary) {\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext;\n  var popLegacyContextProvider = legacyContext.popContextProvider,\n      popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject;\n  var popProvider = newContext.popProvider;\n\n\n  function throwException(returnFiber, sourceFiber, rawValue) {\n    // The source fiber did not complete.\n    sourceFiber.effectTag |= Incomplete;\n    // Its effect list is no longer valid.\n    sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n    var value = createCapturedValue(rawValue, sourceFiber);\n\n    var workInProgress = returnFiber;\n    do {\n      switch (workInProgress.tag) {\n        case HostRoot:\n          {\n            // Uncaught error\n            var errorInfo = value;\n            ensureUpdateQueues(workInProgress);\n            var updateQueue = workInProgress.updateQueue;\n            updateQueue.capturedValues = [errorInfo];\n            workInProgress.effectTag |= ShouldCapture;\n            return;\n          }\n        case ClassComponent:\n          // Capture and retry\n          var ctor = workInProgress.type;\n          var _instance = workInProgress.stateNode;\n          if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === 'function' && enableGetDerivedStateFromCatch || _instance !== null && typeof _instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(_instance))) {\n            ensureUpdateQueues(workInProgress);\n            var _updateQueue = workInProgress.updateQueue;\n            var capturedValues = _updateQueue.capturedValues;\n            if (capturedValues === null) {\n              _updateQueue.capturedValues = [value];\n            } else {\n              capturedValues.push(value);\n            }\n            workInProgress.effectTag |= ShouldCapture;\n            return;\n          }\n          break;\n        default:\n          break;\n      }\n      workInProgress = workInProgress['return'];\n    } while (workInProgress !== null);\n  }\n\n  function unwindWork(workInProgress) {\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        {\n          popLegacyContextProvider(workInProgress);\n          var effectTag = workInProgress.effectTag;\n          if (effectTag & ShouldCapture) {\n            workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;\n            return workInProgress;\n          }\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelLegacyContextObject(workInProgress);\n          var _effectTag = workInProgress.effectTag;\n          if (_effectTag & ShouldCapture) {\n            workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;\n            return workInProgress;\n          }\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          return null;\n        }\n      case HostPortal:\n        popHostContainer(workInProgress);\n        return null;\n      case ContextProvider:\n        popProvider(workInProgress);\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  function unwindInterruptedWork(interruptedWork) {\n    switch (interruptedWork.tag) {\n      case ClassComponent:\n        {\n          popLegacyContextProvider(interruptedWork);\n          break;\n        }\n      case HostRoot:\n        {\n          popHostContainer(interruptedWork);\n          popTopLevelLegacyContextObject(interruptedWork);\n          break;\n        }\n      case HostComponent:\n        {\n          popHostContext(interruptedWork);\n          break;\n        }\n      case HostPortal:\n        popHostContainer(interruptedWork);\n        break;\n      case ContextProvider:\n        popProvider(interruptedWork);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return {\n    throwException: throwException,\n    unwindWork: unwindWork,\n    unwindInterruptedWork: unwindInterruptedWork\n  };\n};\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(capturedError) {\n  return true;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$3 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null) {\n    stack = getStackAddendumByWorkInProgressFiber(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // Prevent cycle if logCapturedError() throws.\n    // A cycle may still occur if logCapturedError renders a component that throws.\n    var suppressLogging = e && e.suppressReactErrorLogging;\n    if (!suppressLogging) {\n      console.error(e);\n    }\n  }\n}\n\nvar ReactFiberCommitWork = function (config, captureError, scheduleWork, computeExpirationForFiber, markLegacyErrorBoundaryAsFailed, recalculateCurrentTime) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  var callComponentWillUnmountWithTimer = function (current, instance) {\n    startPhaseTimer(current, 'componentWillUnmount');\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$3(null, callComponentWillUnmountWithTimer, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      if (typeof ref === 'function') {\n        {\n          invokeGuardedCallback$3(null, ref, null, null);\n          if (hasCaughtError$1()) {\n            var refError = clearCaughtError$1();\n            captureError(current, refError);\n          }\n        }\n      } else {\n        ref.current = null;\n      }\n    }\n  }\n\n  function commitBeforeMutationLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          if (finishedWork.effectTag & Snapshot) {\n            if (current !== null) {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n              var _instance = finishedWork.stateNode;\n              _instance.props = finishedWork.memoizedProps;\n              _instance.state = finishedWork.memoizedState;\n              var snapshot = _instance.getSnapshotBeforeUpdate(prevProps, prevState);\n              {\n                var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                  didWarnSet.add(finishedWork.type);\n                  warning(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork));\n                }\n              }\n              _instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n              stopPhaseTimer();\n            }\n          }\n          return;\n        }\n      case HostRoot:\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n        // Nothing to do for these component types\n        return;\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitLifeCycles(finishedRoot, current, finishedWork, currentTime, committedExpirationTime) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n              _instance2.props = finishedWork.memoizedProps;\n              _instance2.state = finishedWork.memoizedState;\n              _instance2.componentDidMount();\n              stopPhaseTimer();\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n              _instance2.props = finishedWork.memoizedProps;\n              _instance2.state = finishedWork.memoizedState;\n              _instance2.componentDidUpdate(prevProps, prevState, _instance2.__reactInternalSnapshotBeforeUpdate);\n              stopPhaseTimer();\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, _instance2);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance3 = null;\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  _instance3 = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n                case ClassComponent:\n                  _instance3 = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n            commitCallbacks(_updateQueue, _instance3);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance4 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance4, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitErrorLogging(finishedWork, onUncaughtError) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var ctor = finishedWork.type;\n          var _instance5 = finishedWork.stateNode;\n          var updateQueue = finishedWork.updateQueue;\n          !(updateQueue !== null && updateQueue.capturedValues !== null) ? invariant(false, 'An error logging effect should not have been scheduled if no errors were captured. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var capturedErrors = updateQueue.capturedValues;\n          updateQueue.capturedValues = null;\n\n          if (typeof ctor.getDerivedStateFromCatch !== 'function') {\n            // To preserve the preexisting retry behavior of error boundaries,\n            // we keep track of which ones already failed during this batch.\n            // This gets reset before we yield back to the browser.\n            // TODO: Warn in strict mode if getDerivedStateFromCatch is\n            // not defined.\n            markLegacyErrorBoundaryAsFailed(_instance5);\n          }\n\n          _instance5.props = finishedWork.memoizedProps;\n          _instance5.state = finishedWork.memoizedState;\n          for (var i = 0; i < capturedErrors.length; i++) {\n            var errorInfo = capturedErrors[i];\n            var _error = errorInfo.value;\n            var stack = errorInfo.stack;\n            logError(finishedWork, errorInfo);\n            _instance5.componentDidCatch(_error, {\n              componentStack: stack !== null ? stack : ''\n            });\n          }\n        }\n        break;\n      case HostRoot:\n        {\n          var _updateQueue2 = finishedWork.updateQueue;\n          !(_updateQueue2 !== null && _updateQueue2.capturedValues !== null) ? invariant(false, 'An error logging effect should not have been scheduled if no errors were captured. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var _capturedErrors = _updateQueue2.capturedValues;\n          _updateQueue2.capturedValues = null;\n          for (var _i = 0; _i < _capturedErrors.length; _i++) {\n            var _errorInfo = _capturedErrors[_i];\n            logError(finishedWork, _errorInfo);\n            onUncaughtError(_errorInfo.value);\n          }\n          break;\n        }\n      default:\n        invariant(false, 'This unit of work tag cannot capture errors.  This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var _instance6 = finishedWork.stateNode;\n      var instanceToUse = void 0;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          instanceToUse = getPublicInstance(_instance6);\n          break;\n        default:\n          instanceToUse = _instance6;\n      }\n      if (typeof ref === 'function') {\n        ref(instanceToUse);\n      } else {\n        {\n          if (!ref.hasOwnProperty('current')) {\n            warning(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork), getStackAddendumByWorkInProgressFiber(finishedWork));\n          }\n        }\n\n        ref.current = instanceToUse;\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      if (typeof currentRef === 'function') {\n        currentRef(null);\n      } else {\n        currentRef.current = null;\n      }\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var _instance7 = current.stateNode;\n          if (typeof _instance7.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, _instance7);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  var emptyPortalContainer = void 0;\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitBeforeMutationLifeCycles: commitBeforeMutationLifeCycles,\n        commitErrorLogging: commitErrorLogging,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance8 = finishedWork.stateNode;\n          if (_instance8 != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(_instance8, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitBeforeMutationLifeCycles: commitBeforeMutationLifeCycles,\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitErrorLogging: commitErrorLogging,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config, stack) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n  var createCursor = stack.createCursor,\n      push = stack.push,\n      pop = stack.pop;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n\n    // Finally, we need to push the host context to the stack.\n    // However, we can't just call getRootHostContext() and push it because\n    // we'd have a different number of entries on the stack depending on\n    // whether getRootHostContext() throws somewhere in renderer code or not.\n    // So we push an empty value first. This lets us safely unwind on errors.\n    push(contextStackCursor, NO_CONTEXT, fiber);\n    var nextRootContext = getRootHostContext(nextRootInstance);\n    // Now that we know this function doesn't throw, replace it.\n    pop(contextStackCursor, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext\n  };\n};\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          var instance = canHydrateInstance(nextInstance, type, props);\n          if (instance !== null) {\n            fiber.stateNode = instance;\n            return true;\n          }\n          return false;\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          var textInstance = canHydrateTextInstance(nextInstance, text);\n          if (textInstance !== null) {\n            fiber.stateNode = textInstance;\n            return true;\n          }\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar ReactFiberLegacyContext = function (stack) {\n  var createCursor = stack.createCursor,\n      push = stack.push,\n      pop = stack.pop;\n\n  // A cursor to the current merged context object on the stack.\n\n  var contextStackCursor = createCursor(emptyObject);\n  // A cursor to a boolean indicating whether the context has changed.\n  var didPerformWorkStackCursor = createCursor(false);\n  // Keep track of the previous context object that was on the stack.\n  // We use this to get access to the parent context after we have already\n  // pushed the next context provider, and now need to merge their contexts.\n  var previousContext = emptyObject;\n\n  function getUnmaskedContext(workInProgress) {\n    var hasOwnContext = isContextProvider(workInProgress);\n    if (hasOwnContext) {\n      // If the fiber is a context provider itself, when we read its context\n      // we have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n    return contextStackCursor.current;\n  }\n\n  function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n    var instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n\n  function getMaskedContext(workInProgress, unmaskedContext) {\n    var type = workInProgress.type;\n    var contextTypes = type.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n\n    // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n    var instance = workInProgress.stateNode;\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    var context = {};\n    for (var key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    {\n      var name = getComponentName(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n    }\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n\n  function hasContextChanged() {\n    return didPerformWorkStackCursor.current;\n  }\n\n  function isContextConsumer(fiber) {\n    return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n  }\n\n  function isContextProvider(fiber) {\n    return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n  }\n\n  function popContextProvider(fiber) {\n    if (!isContextProvider(fiber)) {\n      return;\n    }\n\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n\n  function popTopLevelContextObject(fiber) {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n\n  function pushTopLevelContextObject(fiber, context, didChange) {\n    !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n\n  function processChildContext(fiber, parentContext) {\n    var instance = fiber.stateNode;\n    var childContextTypes = fiber.type.childContextTypes;\n\n    // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n    if (typeof instance.getChildContext !== 'function') {\n      {\n        var componentName = getComponentName(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n          warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n      return parentContext;\n    }\n\n    var childContext = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n    }\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    {\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    for (var contextKey in childContext) {\n      !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n    }\n    {\n      var name = getComponentName(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n    }\n\n    return _assign({}, parentContext, childContext);\n  }\n\n  function pushContextProvider(workInProgress) {\n    if (!isContextProvider(workInProgress)) {\n      return false;\n    }\n\n    var instance = workInProgress.stateNode;\n    // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n    // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n    return true;\n  }\n\n  function invalidateContextProvider(workInProgress, didChange) {\n    var instance = workInProgress.stateNode;\n    !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      var mergedContext = processChildContext(workInProgress, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n      // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress);\n      // Now push the new context and mark that it has changed.\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n\n  function findCurrentUnmaskedContext(fiber) {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var node = fiber;\n    while (node.tag !== HostRoot) {\n      if (isContextProvider(node)) {\n        return node.stateNode.__reactInternalMemoizedMergedChildContext;\n      }\n      var parent = node['return'];\n      !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      node = parent;\n    }\n    return node.stateNode.context;\n  }\n\n  return {\n    getUnmaskedContext: getUnmaskedContext,\n    cacheContext: cacheContext,\n    getMaskedContext: getMaskedContext,\n    hasContextChanged: hasContextChanged,\n    isContextConsumer: isContextConsumer,\n    isContextProvider: isContextProvider,\n    popContextProvider: popContextProvider,\n    popTopLevelContextObject: popTopLevelContextObject,\n    pushTopLevelContextObject: pushTopLevelContextObject,\n    processChildContext: processChildContext,\n    pushContextProvider: pushContextProvider,\n    invalidateContextProvider: invalidateContextProvider,\n    findCurrentUnmaskedContext: findCurrentUnmaskedContext\n  };\n};\n\nvar ReactFiberNewContext = function (stack) {\n  var createCursor = stack.createCursor,\n      push = stack.push,\n      pop = stack.pop;\n\n\n  var providerCursor = createCursor(null);\n  var valueCursor = createCursor(null);\n  var changedBitsCursor = createCursor(0);\n\n  var rendererSigil = void 0;\n  {\n    // Use this to detect multiple renderers using the same context\n    rendererSigil = {};\n  }\n\n  function pushProvider(providerFiber) {\n    var context = providerFiber.type._context;\n\n    push(changedBitsCursor, context._changedBits, providerFiber);\n    push(valueCursor, context._currentValue, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue = providerFiber.pendingProps.value;\n    context._changedBits = providerFiber.stateNode;\n\n    {\n      !(context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warning(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  }\n\n  function popProvider(providerFiber) {\n    var changedBits = changedBitsCursor.current;\n    var currentValue = valueCursor.current;\n\n    pop(providerCursor, providerFiber);\n    pop(valueCursor, providerFiber);\n    pop(changedBitsCursor, providerFiber);\n\n    var context = providerFiber.type._context;\n    context._currentValue = currentValue;\n    context._changedBits = changedBits;\n  }\n\n  return {\n    pushProvider: pushProvider,\n    popProvider: popProvider\n  };\n};\n\nvar ReactFiberStack = function () {\n  var valueStack = [];\n\n  var fiberStack = void 0;\n\n  {\n    fiberStack = [];\n  }\n\n  var index = -1;\n\n  function createCursor(defaultValue) {\n    return {\n      current: defaultValue\n    };\n  }\n\n  function isEmpty() {\n    return index === -1;\n  }\n\n  function pop(cursor, fiber) {\n    if (index < 0) {\n      {\n        warning(false, 'Unexpected pop.');\n      }\n      return;\n    }\n\n    {\n      if (fiber !== fiberStack[index]) {\n        warning(false, 'Unexpected Fiber popped.');\n      }\n    }\n\n    cursor.current = valueStack[index];\n\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n\n  function push(cursor, value, fiber) {\n    index++;\n\n    valueStack[index] = cursor.current;\n\n    {\n      fiberStack[index] = fiber;\n    }\n\n    cursor.current = value;\n  }\n\n  function checkThatStackIsEmpty() {\n    {\n      if (index !== -1) {\n        warning(false, 'Expected an empty stack. Something was not reset properly.');\n      }\n    }\n  }\n\n  function resetStackAfterFatalErrorInDev() {\n    {\n      index = -1;\n      valueStack.length = 0;\n      fiberStack.length = 0;\n    }\n  }\n\n  return {\n    createCursor: createCursor,\n    isEmpty: isEmpty,\n    pop: pop,\n    push: push,\n    checkThatStackIsEmpty: checkThatStackIsEmpty,\n    resetStackAfterFatalErrorInDev: resetStackAfterFatalErrorInDev\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function (fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, \"Can't call setState (or forceUpdate) on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in the ' + 'componentWillUnmount method.%s', getStackAddendumByWorkInProgressFiber(fiber));\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var stack = ReactFiberStack();\n  var hostContext = ReactFiberHostContext(config, stack);\n  var legacyContext = ReactFiberLegacyContext(stack);\n  var newContext = ReactFiberNewContext(stack);\n  var popHostContext = hostContext.popHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var popTopLevelLegacyContextObject = legacyContext.popTopLevelContextObject,\n      popLegacyContextProvider = legacyContext.popContextProvider;\n  var popProvider = newContext.popProvider;\n\n  var hydrationContext = ReactFiberHydrationContext(config);\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, legacyContext, newContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, legacyContext, newContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberUnwindWork = ReactFiberUnwindWork(hostContext, legacyContext, newContext, scheduleWork, isAlreadyFailedLegacyErrorBoundary),\n      throwException = _ReactFiberUnwindWork.throwException,\n      unwindWork = _ReactFiberUnwindWork.unwindWork,\n      unwindInterruptedWork = _ReactFiberUnwindWork.unwindInterruptedWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, onCommitPhaseError, scheduleWork, computeExpirationForFiber, markLegacyErrorBoundaryAsFailed, recalculateCurrentTime),\n      commitBeforeMutationLifeCycles = _ReactFiberCommitWork.commitBeforeMutationLifeCycles,\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitErrorLogging = _ReactFiberCommitWork.commitErrorLogging,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      cancelDeferredCallback = config.cancelDeferredCallback,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var originalStartTimeMs = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n  var mostRecentCurrentTimeMs = originalStartTimeMs;\n\n  // Used to ensure computeUniqueAsyncExpiration is monotonically increases.\n  var lastUniqueAsyncExpiration = 0;\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  var isCommitting = false;\n\n  var isRootReadyForCommit = false;\n\n  var legacyErrorBoundariesThatAlreadyFailed = null;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  var stashedWorkInProgressProperties = void 0;\n  var replayUnitOfWork = void 0;\n  var isReplayingFailedUnitOfWork = void 0;\n  var originalReplayError = void 0;\n  var rethrowOriginalError = void 0;\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = null;\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    replayUnitOfWork = function (failedUnitOfWork, error, isAsync) {\n      // Restore the original state of the work-in-progress\n      assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);\n      switch (failedUnitOfWork.tag) {\n        case HostRoot:\n          popHostContainer(failedUnitOfWork);\n          popTopLevelLegacyContextObject(failedUnitOfWork);\n          break;\n        case HostComponent:\n          popHostContext(failedUnitOfWork);\n          break;\n        case ClassComponent:\n          popLegacyContextProvider(failedUnitOfWork);\n          break;\n        case HostPortal:\n          popHostContainer(failedUnitOfWork);\n          break;\n        case ContextProvider:\n          popProvider(failedUnitOfWork);\n          break;\n      }\n      // Replay the begin phase.\n      isReplayingFailedUnitOfWork = true;\n      originalReplayError = error;\n      invokeGuardedCallback$2(null, workLoop, null, isAsync);\n      isReplayingFailedUnitOfWork = false;\n      originalReplayError = null;\n      if (hasCaughtError()) {\n        clearCaughtError();\n      } else {\n        // If the begin phase did not fail the second time, set this pointer\n        // back to the original value.\n        nextUnitOfWork = failedUnitOfWork;\n      }\n    };\n    rethrowOriginalError = function () {\n      throw originalReplayError;\n    };\n  }\n\n  function resetStack() {\n    if (nextUnitOfWork !== null) {\n      var interruptedWork = nextUnitOfWork['return'];\n      while (interruptedWork !== null) {\n        unwindInterruptedWork(interruptedWork);\n        interruptedWork = interruptedWork['return'];\n      }\n    }\n\n    {\n      ReactStrictModeWarnings.discardPendingWarnings();\n      stack.checkThatStackIsEmpty();\n    }\n\n    nextRoot = null;\n    nextRenderExpirationTime = NoWork;\n    nextUnitOfWork = null;\n\n    isRootReadyForCommit = false;\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            commitDeletion(nextEffect);\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitBeforeMutationLifecycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & Snapshot) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitBeforeMutationLifeCycles(current, nextEffect);\n      }\n\n      // Don't cleanup effects yet;\n      // This will be done by commitAllLifeCycles()\n      nextEffect = nextEffect.nextEffect;\n    }\n  }\n\n  function commitAllLifeCycles(finishedRoot, currentTime, committedExpirationTime) {\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n      if (warnAboutDeprecatedLifecycles) {\n        ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n      }\n    }\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(finishedRoot, current, nextEffect, currentTime, committedExpirationTime);\n      }\n\n      if (effectTag & ErrLog) {\n        commitErrorLogging(nextEffect, onUncaughtError);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function isAlreadyFailedLegacyErrorBoundary(instance) {\n    return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n  }\n\n  function markLegacyErrorBoundaryAsFailed(instance) {\n    if (legacyErrorBoundariesThatAlreadyFailed === null) {\n      legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n    } else {\n      legacyErrorBoundariesThatAlreadyFailed.add(instance);\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var committedExpirationTime = root.pendingCommitExpirationTime;\n    !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.pendingCommitExpirationTime = NoWork;\n\n    var currentTime = recalculateCurrentTime();\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit(root.containerInfo);\n\n    // Invoke instances of getSnapshotBeforeUpdate before mutation.\n    nextEffect = firstEffect;\n    startCommitSnapshotEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitBeforeMutationLifecycles, null);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        onCommitPhaseError(nextEffect, error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitSnapshotEffectsTimer();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$2(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        onCommitPhaseError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError2 = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$2(null, commitAllLifeCycles, null, root, currentTime, committedExpirationTime);\n        if (hasCaughtError()) {\n          _didError2 = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError2) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        onCommitPhaseError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    var remainingTime = root.current.expirationTime;\n    if (remainingTime === NoWork) {\n      // If there's no remaining work, we can clear the set of already failed\n      // error boundaries.\n      legacyErrorBoundariesThatAlreadyFailed = null;\n    }\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    // Attempt to complete the current unit of work, then move to the\n    // next sibling. If there are no more siblings, return to the\n    // parent fiber.\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n        // This fiber completed.\n        var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n        stopWorkTimer(workInProgress);\n        resetExpirationTime(workInProgress, nextRenderExpirationTime);\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          return next;\n        }\n\n        if (returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect) {\n          // Append all the effects of the subtree and this fiber onto the effect\n          // list of the parent. The completion order of the children affects the\n          // side-effect order.\n          if (returnFiber.firstEffect === null) {\n            returnFiber.firstEffect = workInProgress.firstEffect;\n          }\n          if (workInProgress.lastEffect !== null) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n            }\n            returnFiber.lastEffect = workInProgress.lastEffect;\n          }\n\n          // If this fiber had side-effects, we append it AFTER the children's\n          // side-effects. We can perform certain side-effects earlier if\n          // needed, by doing multiple passes over the effect list. We don't want\n          // to schedule our own side-effect on our own list because if end up\n          // reusing children we'll schedule this effect onto itself since we're\n          // at the end.\n          var effectTag = workInProgress.effectTag;\n          // Skip both NoWork and PerformedWork tags when creating the effect list.\n          // PerformedWork effect is read by React DevTools but shouldn't be committed.\n          if (effectTag > PerformedWork) {\n            if (returnFiber.lastEffect !== null) {\n              returnFiber.lastEffect.nextEffect = workInProgress;\n            } else {\n              returnFiber.firstEffect = workInProgress;\n            }\n            returnFiber.lastEffect = workInProgress;\n          }\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          // We've reached the root.\n          isRootReadyForCommit = true;\n          return null;\n        }\n      } else {\n        // This fiber did not complete because something threw. Pop values off\n        // the stack without entering the complete phase. If this is a boundary,\n        // capture values if possible.\n        var _next = unwindWork(workInProgress);\n        // Because this fiber did not complete, don't reset its expiration time.\n        if (workInProgress.effectTag & DidCapture) {\n          // Restarting an error boundary\n          stopFailedWorkTimer(workInProgress);\n        } else {\n          stopWorkTimer(workInProgress);\n        }\n\n        {\n          ReactDebugCurrentFiber.resetCurrentFiber();\n        }\n\n        if (_next !== null) {\n          stopWorkTimer(workInProgress);\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n          // If completing this work spawned new work, do that next. We'll come\n          // back here again.\n          // Since we're restarting, remove anything that is not a host effect\n          // from the effect tag.\n          _next.effectTag &= HostEffectMask;\n          return _next;\n        }\n\n        if (returnFiber !== null) {\n          // Mark the parent fiber as incomplete and clear its effect list.\n          returnFiber.firstEffect = returnFiber.lastEffect = null;\n          returnFiber.effectTag |= Incomplete;\n        }\n\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (siblingFiber !== null) {\n          // If there is more work to do in this returnFiber, do that next.\n          return siblingFiber;\n        } else if (returnFiber !== null) {\n          // If there's no more work in this returnFiber. Complete the returnFiber.\n          workInProgress = returnFiber;\n          continue;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n      stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);\n    }\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n      if (isReplayingFailedUnitOfWork) {\n        // Currently replaying a failed unit of work. This should be unreachable,\n        // because the render phase is meant to be idempotent, and it should\n        // have thrown again. Since it didn't, rethrow the original error, so\n        // React's internal stack is not misaligned.\n        rethrowOriginalError();\n      }\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(isAsync) {\n    if (!isAsync) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function renderRoot(root, expirationTime, isAsync) {\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {\n      // Reset the stack and start working from the root.\n      resetStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);\n      root.pendingCommitExpirationTime = NoWork;\n    }\n\n    var didFatal = false;\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    do {\n      try {\n        workLoop(isAsync);\n      } catch (thrownValue) {\n        if (nextUnitOfWork === null) {\n          // This is a fatal error.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          var failedUnitOfWork = nextUnitOfWork;\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);\n        }\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber['return'];\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n        throwException(returnFiber, sourceFiber, thrownValue);\n        nextUnitOfWork = completeUnitOfWork(sourceFiber);\n      }\n      break;\n    } while (true);\n\n    // We're done performing work. Time to clean up.\n    var didCompleteRoot = false;\n    isWorking = false;\n\n    // Yield back to main thread.\n    if (didFatal) {\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // There was a fatal error.\n      {\n        stack.resetStackAfterFatalErrorInDev();\n      }\n      return null;\n    } else if (nextUnitOfWork === null) {\n      // We reached the root.\n      if (isRootReadyForCommit) {\n        didCompleteRoot = true;\n        stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n        interruptedBy = null;\n        // The root successfully completed. It's ready for commit.\n        root.pendingCommitExpirationTime = expirationTime;\n        var finishedWork = root.current.alternate;\n        return finishedWork;\n      } else {\n        // The root did not complete.\n        stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n        interruptedBy = null;\n        invariant(false, 'Expired work should have completed. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } else {\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      interruptedBy = null;\n      // There's more work to do, but we ran out of time. Yield back to\n      // the renderer.\n      return null;\n    }\n  }\n\n  function scheduleCapture(sourceFiber, boundaryFiber, value, expirationTime) {\n    // TODO: We only support dispatching errors.\n    var capturedValue = createCapturedValue(value, sourceFiber);\n    var update = {\n      expirationTime: expirationTime,\n      partialState: null,\n      callback: null,\n      isReplace: false,\n      isForced: false,\n      capturedValue: capturedValue,\n      next: null\n    };\n    insertUpdateIntoFiber(boundaryFiber, update);\n    scheduleWork(boundaryFiber, expirationTime);\n  }\n\n  function dispatch(sourceFiber, value, expirationTime) {\n    !(!isWorking || isCommitting) ? invariant(false, 'dispatch: Cannot dispatch during the render phase.') : void 0;\n\n    // TODO: Handle arrays\n\n    var fiber = sourceFiber['return'];\n    while (fiber !== null) {\n      switch (fiber.tag) {\n        case ClassComponent:\n          var ctor = fiber.type;\n          var instance = fiber.stateNode;\n          if (typeof ctor.getDerivedStateFromCatch === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n            scheduleCapture(sourceFiber, fiber, value, expirationTime);\n            return;\n          }\n          break;\n        // TODO: Handle async boundaries\n        case HostRoot:\n          scheduleCapture(sourceFiber, fiber, value, expirationTime);\n          return;\n      }\n      fiber = fiber['return'];\n    }\n\n    if (sourceFiber.tag === HostRoot) {\n      // Error was thrown at the root. There is no parent, so the root\n      // itself should capture it.\n      scheduleCapture(sourceFiber, sourceFiber, value, expirationTime);\n    }\n  }\n\n  function onCommitPhaseError(fiber, error) {\n    return dispatch(fiber, error, Sync);\n  }\n\n  function computeAsyncExpiration(currentTime) {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var expirationMs = 5000;\n    var bucketSizeMs = 250;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeInteractiveExpiration(currentTime) {\n    var expirationMs = void 0;\n    // We intentionally set a higher expiration time for interactive updates in\n    // dev than in production.\n    // If the main thread is being blocked so long that you hit the expiration,\n    // it's a problem that could be solved with better scheduling.\n    // People will be more likely to notice this and fix it with the long\n    // expiration time in development.\n    // In production we opt for better UX at the risk of masking scheduling\n    // problems, by expiring fast.\n    {\n      // Should complete within ~500ms. 600ms max.\n      expirationMs = 500;\n    }\n    var bucketSizeMs = 100;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  // Creates a unique async expiration time.\n  function computeUniqueAsyncExpiration() {\n    var currentTime = recalculateCurrentTime();\n    var result = computeAsyncExpiration(currentTime);\n    if (result <= lastUniqueAsyncExpiration) {\n      // Since we assume the current time monotonically increases, we only hit\n      // this branch when computeUniqueAsyncExpiration is fired multiple times\n      // within a 200ms window (or whatever the async bucket size is).\n      result = lastUniqueAsyncExpiration + 1;\n    }\n    lastUniqueAsyncExpiration = result;\n    return lastUniqueAsyncExpiration;\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (fiber.mode & AsyncMode) {\n        if (isBatchingInteractiveUpdates) {\n          // This is an interactive update\n          var currentTime = recalculateCurrentTime();\n          expirationTime = computeInteractiveExpiration(currentTime);\n        } else {\n          // This is an async update\n          var _currentTime = recalculateCurrentTime();\n          expirationTime = computeAsyncExpiration(_currentTime);\n        }\n      } else {\n        // This is a sync update\n        expirationTime = Sync;\n      }\n    }\n    if (isBatchingInteractiveUpdates) {\n      // This is an interactive update. Keep track of the lowest pending\n      // interactive expiration time. This allows us to synchronously flush\n      // all interactive updates when needed.\n      if (lowestPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPendingInteractiveExpirationTime) {\n        lowestPendingInteractiveExpirationTime = expirationTime;\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n          if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {\n            // This is an interruption. (Used for performance tracking.)\n            interruptedBy = fiber;\n            resetStack();\n          }\n          if (\n          // If we're in the render phase, we don't need to schedule this root\n          // for an update, because we'll do it before we exit...\n          !isWorking || isCommitting ||\n          // ...unless this is a different root than the one we're rendering.\n          nextRoot !== root) {\n            // Add this root to the root schedule.\n            requestWork(root, expirationTime);\n          }\n          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n            invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n          }\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    mostRecentCurrentTimeMs = now() - originalStartTimeMs;\n    mostRecentCurrentTime = msToExpirationTime(mostRecentCurrentTimeMs);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    var currentTime = recalculateCurrentTime();\n    expirationContext = computeAsyncExpiration(currentTime);\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n  function syncUpdates(fn, a, b, c, d) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn(a, b, c, d);\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var lowestPendingInteractiveExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n  var isBatchingInteractiveUpdates = false;\n\n  var completedBatches = null;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - originalStartTimeMs;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    addRootToSchedule(root, expirationTime);\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(root, Sync, false);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performSyncWork();\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function addRootToSchedule(root, expirationTime) {\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot && highestPriorityWork === Sync) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, true, dl);\n  }\n\n  function performSyncWork() {\n    performWork(Sync, false, null);\n  }\n\n  function performWork(minExpirationTime, isAsync, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    if (isAsync) {\n      while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || recalculateCurrentTime() >= nextFlushedExpirationTime)) {\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, !deadlineDidExpire);\n        findHighestPriorityRoot();\n      }\n    } else {\n      while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n        findHighestPriorityRoot();\n      }\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n\n    finishRendering();\n  }\n\n  function flushRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;\n    // Perform work on root as if the given expiration time is the current time.\n    // This has the effect of synchronously flushing all work up to and\n    // including the given time.\n    nextFlushedRoot = root;\n    nextFlushedExpirationTime = expirationTime;\n    performWorkOnRoot(root, expirationTime, false);\n    // Flush any sync work that was scheduled by lifecycles\n    performSyncWork();\n    finishRendering();\n  }\n\n  function finishRendering() {\n    nestedUpdateCount = 0;\n\n    if (completedBatches !== null) {\n      var batches = completedBatches;\n      completedBatches = null;\n      for (var i = 0; i < batches.length; i++) {\n        var batch = batches[i];\n        try {\n          batch._onComplete();\n        } catch (error) {\n          if (!hasUnhandledError) {\n            hasUnhandledError = true;\n            unhandledError = error;\n          }\n        }\n      }\n    }\n\n    if (hasUnhandledError) {\n      var error = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw error;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime, isAsync) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    if (!isAsync) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime, false);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          completeRoot(root, finishedWork, expirationTime);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, _finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime, true);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            completeRoot(root, _finishedWork, expirationTime);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  function completeRoot(root, finishedWork, expirationTime) {\n    // Check if there's a batch that matches this expiration time.\n    var firstBatch = root.firstBatch;\n    if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n      if (completedBatches === null) {\n        completedBatches = [firstBatch];\n      } else {\n        completedBatches.push(firstBatch);\n      }\n      if (firstBatch._defer) {\n        // This root is blocked from committing by a batch. Unschedule it until\n        // we receive another update.\n        root.finishedWork = finishedWork;\n        root.remainingExpirationTime = NoWork;\n        return;\n      }\n    }\n\n    // Commit the root.\n    root.finishedWork = null;\n    root.remainingExpirationTime = commitRoot(finishedWork);\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn, a) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn(a);\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn(a);\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn, a) {\n    !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn, a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      performSyncWork();\n    }\n  }\n\n  function interactiveUpdates(fn, a, b) {\n    if (isBatchingInteractiveUpdates) {\n      return fn(a, b);\n    }\n    // If there are any pending interactive updates, synchronously flush them.\n    // This needs to happen before we read any handlers, because the effect of\n    // the previous event may influence which handlers are called during\n    // this event.\n    if (!isBatchingUpdates && !isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n    var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingInteractiveUpdates = true;\n    isBatchingUpdates = true;\n    try {\n      return fn(a, b);\n    } finally {\n      isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performSyncWork();\n      }\n    }\n  }\n\n  function flushInteractiveUpdates() {\n    if (!isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n      // Synchronously flush pending interactive updates.\n      performWork(lowestPendingInteractiveExpirationTime, false, null);\n      lowestPendingInteractiveExpirationTime = NoWork;\n    }\n  }\n\n  function flushControlled(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, false, null);\n      }\n    }\n  }\n\n  return {\n    recalculateCurrentTime: recalculateCurrentTime,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    requestWork: requestWork,\n    flushRoot: flushRoot,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    flushControlled: flushControlled,\n    deferredUpdates: deferredUpdates,\n    syncUpdates: syncUpdates,\n    interactiveUpdates: interactiveUpdates,\n    flushInteractiveUpdates: flushInteractiveUpdates,\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n    legacyContext: legacyContext\n  };\n};\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nvar ReactFiberReconciler$1 = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeUniqueAsyncExpiration = _ReactFiberScheduler.computeUniqueAsyncExpiration,\n      recalculateCurrentTime = _ReactFiberScheduler.recalculateCurrentTime,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      requestWork = _ReactFiberScheduler.requestWork,\n      flushRoot = _ReactFiberScheduler.flushRoot,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      flushControlled = _ReactFiberScheduler.flushControlled,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates,\n      syncUpdates = _ReactFiberScheduler.syncUpdates,\n      interactiveUpdates = _ReactFiberScheduler.interactiveUpdates,\n      flushInteractiveUpdates = _ReactFiberScheduler.flushInteractiveUpdates,\n      legacyContext = _ReactFiberScheduler.legacyContext;\n\n  var findCurrentUnmaskedContext = legacyContext.findCurrentUnmaskedContext,\n      isContextProvider = legacyContext.isContextProvider,\n      processChildContext = legacyContext.processChildContext;\n\n\n  function getContextForSubtree(parentComponent) {\n    if (!parentComponent) {\n      return emptyObject;\n    }\n\n    var fiber = get(parentComponent);\n    var parentContext = findCurrentUnmaskedContext(fiber);\n    return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n  }\n\n  function scheduleRootUpdate(current, element, currentTime, expirationTime, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      !(callback === null || typeof callback === 'function') ? warning(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      capturedValue: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n  }\n\n  function updateContainerAtExpirationTime(element, container, parentComponent, currentTime, expirationTime, callback) {\n    // TODO: If this is a nested container, this won't be the root.\n    var current = container.current;\n\n    {\n      if (ReactFiberInstrumentation_1.debugTool) {\n        if (current.alternate === null) {\n          ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n        } else if (element === null) {\n          ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n        } else {\n          ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n        }\n      }\n    }\n\n    var context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n      container.context = context;\n    } else {\n      container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(current, element, currentTime, expirationTime, callback);\n  }\n\n  function findHostInstance(component) {\n    var fiber = get(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n      }\n    }\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function (containerInfo, isAsync, hydrate) {\n      return createFiberRoot(containerInfo, isAsync, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      var current = container.current;\n      var currentTime = recalculateCurrentTime();\n      var expirationTime = computeExpirationForFiber(current);\n      return updateContainerAtExpirationTime(element, container, parentComponent, currentTime, expirationTime, callback);\n    },\n    updateContainerAtExpirationTime: function (element, container, parentComponent, expirationTime, callback) {\n      var currentTime = recalculateCurrentTime();\n      return updateContainerAtExpirationTime(element, container, parentComponent, currentTime, expirationTime, callback);\n    },\n\n\n    flushRoot: flushRoot,\n\n    requestWork: requestWork,\n\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    syncUpdates: syncUpdates,\n\n    interactiveUpdates: interactiveUpdates,\n\n    flushInteractiveUpdates: flushInteractiveUpdates,\n\n    flushControlled: flushControlled,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function (devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(_assign({}, devToolsConfig, {\n        findHostInstanceByFiber: function (fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        },\n        findFiberByHostInstance: function (instance) {\n          if (!findFiberByHostInstance) {\n            // Might not be implemented by the renderer.\n            return null;\n          }\n          return findFiberByHostInstance(instance);\n        }\n      }));\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n\tdefault: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.3.2';\n\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n{\n  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n}\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar now = void 0;\nif (hasNativePerformanceNow) {\n  now = function () {\n    return performance.now();\n  };\n} else {\n  now = function () {\n    return Date.now();\n  };\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nvar rIC = void 0;\nvar cIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    return setTimeout(function () {\n      frameCallback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n  };\n  cIC = function (timeoutID) {\n    clearTimeout(timeoutID);\n  };\n} else if (alwaysUseRequestIdleCallbackPolyfill || typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback and cancelIdleCallback\n\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = void 0;\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = frameDeadline - performance.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // Fallback to Date.now()\n        var remaining = frameDeadline - Date.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  }\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = now();\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        frameDeadlineObject.didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrame(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    } else {\n      // There's still time left in this idle period.\n      frameDeadlineObject.didTimeout = false;\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  rIC = function (callback, options) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = now() + options.timeout;\n    }\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n\n  cIC = function () {\n    scheduledRICCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n} else {\n  rIC = window.requestIdleCallback;\n  cIC = window.cancelIdleCallback;\n}\n\nvar didWarnSelectedSetOnOption = false;\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  // TODO (yungsters): Remove support for `selected` in <option>.\n  {\n    if (props.selected != null && !didWarnSelectedSetOnOption) {\n      warning(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n      didWarnSelectedSetOnOption = true;\n    }\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', props.value);\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\nvar didWarnValueDefaultValue$1 = void 0;\n\n{\n  didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$3();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  var value = props.value;\n  node._wrapperState = {\n    initialValue: value != null ? value : props.defaultValue,\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  // After the initial mount, we control selected-ness manually so don't pass\n  // this value down\n  node._wrapperState.initialValue = undefined;\n\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: '' + node._wrapperState.initialValue\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: '' + initialValue\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = props.value;\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = '' + value;\n\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = props.defaultValue;\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar warnValidStyle = emptyFunction;\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n  };\n\n  var warnBadVendoredStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, getStack) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n  };\n\n  var warnStyleValueIsNaN = function (name, value, getStack) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, getStack) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  warnValidStyle = function (name, value, getStack) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, getStack);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, getStack);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, getStack);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, getStack);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, getStack);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles, getStack) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName], getStack);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\nvar HTML$1 = '__html';\n\nfunction assertValidProps(tag, props, getStack) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack()) : void 0;\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  'class': 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  'default': 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  'for': 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nomodule: 'noModule',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  'in': 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  'typeof': 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getStackAddendum() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  } else if (invalidProps.length > 1) {\n    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n    } else {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n    }\n  }\n}\n\nfunction getStackAddendum$2() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nvar validateProperty$1 = function () {};\n\n{\n  var warnedProperties$1 = {};\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var propertyInfo = getPropertyInfo(name);\n    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      if (value) {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n      } else {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  } else if (unknownProps.length > 1) {\n    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar getStack = emptyFunction.thatReturns('');\n\nvar warnedUnknownTags = void 0;\nvar suppressHydrationWarning = void 0;\n\nvar validatePropertiesInDevelopment = void 0;\nvar warnForTextDifference = void 0;\nvar warnForPropDifference = void 0;\nvar warnForExtraAttributes = void 0;\nvar warnForInvalidEventListener = void 0;\n\nvar normalizeMarkupForTextOrAttribute = void 0;\nvar normalizeHTML = void 0;\n\n{\n  getStack = getCurrentFiberStackAddendum$3;\n\n  warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true\n  };\n\n  validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning(false, 'Extra attributes from the server: %s', names);\n  };\n\n  warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$3());\n    } else {\n      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$3());\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We blacklist it here rather than in the property list because we emit it in SSR.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (nextProp != null) {\n      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {\n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n    }\n  }\n}\n\nfunction createElement$1(type, props, rootContainerElement, parentNamespace) {\n  var isCustomComponentTag = void 0;\n\n  // We create tags in the namespace of their parent container, except HTML\n  // tags get no namespace.\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement = void 0;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      !(isCustomComponentTag || type === type.toLowerCase()) ? warning(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode$1(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$2() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props = void 0;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEventTypes) {\n        if (mediaEventTypes.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEventTypes[event], domElement);\n        }\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props, getStack);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps = void 0;\n  var nextProps = void 0;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps, getStack);\n\n  var propKey = void 0;\n  var styleName = void 0;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction getPossibleStandardName(propName) {\n  {\n    var lowerCasedName = propName.toLowerCase();\n    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      return null;\n    }\n    return possibleStandardNames[lowerCasedName] || null;\n  }\n  return null;\n}\n\nfunction diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  var isCustomComponentTag = void 0;\n  var extraAttributeNames = void 0;\n\n  {\n    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$2() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEventTypes) {\n        if (mediaEventTypes.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEventTypes[event], domElement);\n        }\n      }\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps, getStack);\n\n  {\n    extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var i = 0; i < attributes.length; i++) {\n      var name = attributes[i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (true &&\n    // Convince Flow we've calculated it (it's DEV-only in this method.)\n    typeof isCustomComponentTag === 'boolean') {\n      // Validate that the properties correspond to their expected values.\n      var serverValue = void 0;\n      var propertyInfo = getPropertyInfo(propKey);\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n        var serverHTML = domElement.innerHTML;\n        var expectedHTML = normalizeHTML(domElement, rawHtml);\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey);\n        var expectedStyle = createDangerousStringForStyles(nextProp);\n        serverValue = domElement.getAttribute('style');\n        if (expectedStyle !== serverValue) {\n          warnForPropDifference(propKey, serverValue, expectedStyle);\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n        var isMismatchDueToBadCasing = false;\n        if (propertyInfo !== null) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey.toLowerCase());\n          } else {\n            var standardName = getPossibleStandardName(propKey);\n            if (standardName !== null && standardName !== propKey) {\n              // If an SVG prop is supplied with bad casing, it will\n              // be successfully parsed from HTML, but will produce a mismatch\n              // (and would be incorrectly rendered on the client).\n              // However, we already warn about bad casing elsewhere.\n              // So we'll skip the misleading extra mismatch warning in this case.\n              isMismatchDueToBadCasing = true;\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](standardName);\n            }\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText$1(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText$1(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement$1(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText$1(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState$1(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\nvar ReactDOMFiberComponent = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateTextNode: createTextNode$1,\n\tsetInitialProperties: setInitialProperties$1,\n\tdiffProperties: diffProperties$1,\n\tupdateProperties: updateProperties$1,\n\tdiffHydratedProperties: diffHydratedProperties$1,\n\tdiffHydratedText: diffHydratedText$1,\n\twarnForUnmatchedText: warnForUnmatchedText$1,\n\twarnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n\twarnForDeletedHydratableText: warnForDeletedHydratableText$1,\n\twarnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n\twarnForInsertedHydratedText: warnForInsertedHydratedText$1,\n\trestoreControlledState: restoreControlledState$1\n});\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar validateDOMNesting = emptyFunction;\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      !(childTag == null) ? warning(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackAddendum$6();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  // TODO: turn this into a named export\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;\n}\n\nvar validateDOMNesting$1 = validateDOMNesting;\n\n// TODO: This type is shared between the reconciler and ReactDOM, but will\n// eventually be lifted out to the renderer.\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar createElement = createElement$1;\nvar createTextNode = createTextNode$1;\nvar setInitialProperties = setInitialProperties$1;\nvar diffProperties = diffProperties$1;\nvar updateProperties = updateProperties$1;\nvar diffHydratedProperties = diffHydratedProperties$1;\nvar diffHydratedText = diffHydratedText$1;\nvar warnForUnmatchedText = warnForUnmatchedText$1;\nvar warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\nvar warnForDeletedHydratableText = warnForDeletedHydratableText$1;\nvar warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\nvar warnForInsertedHydratedText = warnForInsertedHydratedText$1;\nvar updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\nvar precacheFiberNode = precacheFiberNode$1;\nvar updateFiberProps = updateFiberProps$1;\n\n\nvar SUPPRESS_HYDRATION_WARNING = void 0;\nvar topLevelUpdateWarnings = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutUnstableCreatePortal = false;\n\n{\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n\n  topLevelUpdateWarnings = function (container) {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n      if (hostInstance) {\n        !(hostInstance.parentNode === container) ? warning(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warning(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\n\n    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warning(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\n  };\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    !(callback === null || typeof callback === 'function') ? warning(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;\n  };\n}\n\ninjection$2.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\nfunction ReactBatch(root) {\n  var expirationTime = DOMRenderer.computeUniqueAsyncExpiration();\n  this._expirationTime = expirationTime;\n  this._root = root;\n  this._next = null;\n  this._callbacks = null;\n  this._didComplete = false;\n  this._hasChildren = false;\n  this._children = null;\n  this._defer = true;\n}\nReactBatch.prototype.render = function (children) {\n  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;\n  this._hasChildren = true;\n  this._children = children;\n  var internalRoot = this._root._internalRoot;\n  var expirationTime = this._expirationTime;\n  var work = new ReactWork();\n  DOMRenderer.updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);\n  return work;\n};\nReactBatch.prototype.then = function (onComplete) {\n  if (this._didComplete) {\n    onComplete();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onComplete);\n};\nReactBatch.prototype.commit = function () {\n  var internalRoot = this._root._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n\n  if (!this._hasChildren) {\n    // This batch is empty. Return.\n    this._next = null;\n    this._defer = false;\n    return;\n  }\n\n  var expirationTime = this._expirationTime;\n\n  // Ensure this is the first batch in the list.\n  if (firstBatch !== this) {\n    // This batch is not the earliest batch. We need to move it to the front.\n    // Update its expiration time to be the expiration time of the earliest\n    // batch, so that we can flush it without flushing the other batches.\n    if (this._hasChildren) {\n      expirationTime = this._expirationTime = firstBatch._expirationTime;\n      // Rendering this batch again ensures its children will be the final state\n      // when we flush (updates are processed in insertion order: last\n      // update wins).\n      // TODO: This forces a restart. Should we print a warning?\n      this.render(this._children);\n    }\n\n    // Remove the batch from the list.\n    var previous = null;\n    var batch = firstBatch;\n    while (batch !== this) {\n      previous = batch;\n      batch = batch._next;\n    }\n    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n    previous._next = batch._next;\n\n    // Add it to the front.\n    this._next = firstBatch;\n    firstBatch = internalRoot.firstBatch = this;\n  }\n\n  // Synchronously flush all the work up to this batch's expiration time.\n  this._defer = false;\n  DOMRenderer.flushRoot(internalRoot, expirationTime);\n\n  // Pop the batch from the list.\n  var next = this._next;\n  this._next = null;\n  firstBatch = internalRoot.firstBatch = next;\n\n  // Append the next earliest batch's children to the update queue.\n  if (firstBatch !== null && firstBatch._hasChildren) {\n    firstBatch.render(firstBatch._children);\n  }\n};\nReactBatch.prototype._onComplete = function () {\n  if (this._didComplete) {\n    return;\n  }\n  this._didComplete = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback = callbacks[i];\n    _callback();\n  }\n};\n\nfunction ReactWork() {\n  this._callbacks = null;\n  this._didCommit = false;\n  // TODO: Avoid need to bind by replacing callbacks in the update queue with\n  // list of Work objects.\n  this._onCommit = this._onCommit.bind(this);\n}\nReactWork.prototype.then = function (onCommit) {\n  if (this._didCommit) {\n    onCommit();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onCommit);\n};\nReactWork.prototype._onCommit = function () {\n  if (this._didCommit) {\n    return;\n  }\n  this._didCommit = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback2 = callbacks[i];\n    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;\n    _callback2();\n  }\n};\n\nfunction ReactRoot(container, isAsync, hydrate) {\n  var root = DOMRenderer.createContainer(container, isAsync, hydrate);\n  this._internalRoot = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  DOMRenderer.updateContainer(children, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  DOMRenderer.updateContainer(null, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  DOMRenderer.updateContainer(children, root, parentComponent, work._onCommit);\n  return work;\n};\nReactRoot.prototype.createBatch = function () {\n  var batch = new ReactBatch(this);\n  var expirationTime = batch._expirationTime;\n\n  var internalRoot = this._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  if (firstBatch === null) {\n    internalRoot.firstBatch = batch;\n    batch._next = null;\n  } else {\n    // Insert sorted by expiration time then insertion order\n    var insertAfter = null;\n    var insertBefore = firstBatch;\n    while (insertBefore !== null && insertBefore._expirationTime <= expirationTime) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore._next;\n    }\n    batch._next = insertBefore;\n    if (insertAfter !== null) {\n      insertAfter._next = batch;\n    }\n  }\n\n  return batch;\n};\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nvar DOMRenderer = reactReconciler({\n  getRootHostContext: function (rootContainerInstance) {\n    var type = void 0;\n    var namespace = void 0;\n    var nodeType = rootContainerInstance.nodeType;\n    switch (nodeType) {\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        {\n          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n          var root = rootContainerInstance.documentElement;\n          namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n          break;\n        }\n      default:\n        {\n          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n          var ownNamespace = container.namespaceURI || null;\n          type = container.tagName;\n          namespace = getChildNamespace(ownNamespace, type);\n          break;\n        }\n    }\n    {\n      var validatedTag = type.toLowerCase();\n      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n      return { namespace: namespace, ancestorInfo: _ancestorInfo };\n    }\n    return namespace;\n  },\n  getChildHostContext: function (parentHostContext, type) {\n    {\n      var parentHostContextDev = parentHostContext;\n      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n    }\n    var parentNamespace = parentHostContext;\n    return getChildNamespace(parentNamespace, type);\n  },\n  getPublicInstance: function (instance) {\n    return instance;\n  },\n  prepareForCommit: function () {\n    eventsEnabled = isEnabled();\n    selectionInformation = getSelectionInformation();\n    setEnabled(false);\n  },\n  resetAfterCommit: function () {\n    restoreSelection(selectionInformation);\n    selectionInformation = null;\n    setEnabled(eventsEnabled);\n    eventsEnabled = null;\n  },\n  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    var parentNamespace = void 0;\n    {\n      // TODO: take namespace into account when validating.\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        var string = '' + props.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n      parentNamespace = hostContextDev.namespace;\n    }\n    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n    precacheFiberNode(internalInstanceHandle, domElement);\n    updateFiberProps(domElement, props);\n    return domElement;\n  },\n  appendInitialChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n    setInitialProperties(domElement, type, props, rootContainerInstance);\n    return shouldAutoFocusHostComponent(type, props);\n  },\n  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    {\n      var hostContextDev = hostContext;\n      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n        var string = '' + newProps.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n    }\n    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n  },\n  shouldSetTextContent: function (type, props) {\n    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n  },\n  shouldDeprioritizeSubtree: function (type, props) {\n    return !!props.hidden;\n  },\n  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n    {\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n    }\n    var textNode = createTextNode(text, rootContainerInstance);\n    precacheFiberNode(internalInstanceHandle, textNode);\n    return textNode;\n  },\n\n\n  now: now,\n\n  mutation: {\n    commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n      // Despite the naming that might imply otherwise, this method only\n      // fires if there is an `Update` effect scheduled during mounting.\n      // This happens if `finalizeInitialChildren` returns `true` (which it\n      // does to implement the `autoFocus` attribute on the client). But\n      // there are also other cases when this might happen (such as patching\n      // up text content during hydration mismatch). So we'll check this again.\n      if (shouldAutoFocusHostComponent(type, newProps)) {\n        domElement.focus();\n      }\n    },\n    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n      // Update the props handle so that we know which props are the ones with\n      // with current event handlers.\n      updateFiberProps(domElement, newProps);\n      // Apply the diff to the DOM node.\n      updateProperties(domElement, updatePayload, type, oldProps, newProps);\n    },\n    resetTextContent: function (domElement) {\n      setTextContent(domElement, '');\n    },\n    commitTextUpdate: function (textInstance, oldText, newText) {\n      textInstance.nodeValue = newText;\n    },\n    appendChild: function (parentInstance, child) {\n      parentInstance.appendChild(child);\n    },\n    appendChildToContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, container);\n      } else {\n        container.appendChild(child);\n      }\n    },\n    insertBefore: function (parentInstance, child, beforeChild) {\n      parentInstance.insertBefore(child, beforeChild);\n    },\n    insertInContainerBefore: function (container, child, beforeChild) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, beforeChild);\n      } else {\n        container.insertBefore(child, beforeChild);\n      }\n    },\n    removeChild: function (parentInstance, child) {\n      parentInstance.removeChild(child);\n    },\n    removeChildFromContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.removeChild(child);\n      } else {\n        container.removeChild(child);\n      }\n    }\n  },\n\n  hydration: {\n    canHydrateInstance: function (instance, type, props) {\n      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n        return null;\n      }\n      // This has now been refined to an element node.\n      return instance;\n    },\n    canHydrateTextInstance: function (instance, text) {\n      if (text === '' || instance.nodeType !== TEXT_NODE) {\n        // Empty strings are not parsed by HTML so there won't be a correct match here.\n        return null;\n      }\n      // This has now been refined to a text node.\n      return instance;\n    },\n    getNextHydratableSibling: function (instance) {\n      var node = instance.nextSibling;\n      // Skip non-hydratable nodes.\n      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    },\n    getFirstHydratableChild: function (parentInstance) {\n      var next = parentInstance.firstChild;\n      // Skip non-hydratable nodes.\n      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n        next = next.nextSibling;\n      }\n      return next;\n    },\n    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, instance);\n      // TODO: Possibly defer this until the commit phase where all the events\n      // get attached.\n      updateFiberProps(instance, props);\n      var parentNamespace = void 0;\n      {\n        var hostContextDev = hostContext;\n        parentNamespace = hostContextDev.namespace;\n      }\n      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n    },\n    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, textInstance);\n      return diffHydratedText(textInstance, text);\n    },\n    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {\n      {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotHydrateContainerInstance: function (parentContainer, instance) {\n      {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentContainer, instance);\n        } else {\n          warnForDeletedHydratableText(parentContainer, instance);\n        }\n      }\n    },\n    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentInstance, instance);\n        } else {\n          warnForDeletedHydratableText(parentInstance, instance);\n        }\n      }\n    },\n    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {\n      {\n        warnForInsertedHydratedElement(parentContainer, type, props);\n      }\n    },\n    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {\n      {\n        warnForInsertedHydratedText(parentContainer, text);\n      }\n    },\n    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedElement(parentInstance, type, props);\n      }\n    },\n    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedText(parentInstance, text);\n      }\n    }\n  },\n\n  scheduleDeferredCallback: rIC,\n  cancelDeferredCallback: cIC\n});\n\ninjection$3.injectRenderer(DOMRenderer);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    var warned = false;\n    var rootSibling = void 0;\n    while (rootSibling = container.lastChild) {\n      {\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n  // Legacy roots are not async by default.\n  var isAsync = false;\n  return new ReactRoot(container, isAsync, shouldHydrate);\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // TODO: Ensure all entry points contain this check\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    topLevelUpdateWarnings(container);\n  }\n\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  var root = container._reactRootContainer;\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = DOMRenderer.getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = DOMRenderer.getPublicRootInstance(root._internalRoot);\n        _originalCallback.call(instance);\n      };\n    }\n    // Update\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return DOMRenderer.getPublicRootInstance(root._internalRoot);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null && owner.stateNode !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        !warnedAboutRefsInRender ? warning(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component') : void 0;\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    return DOMRenderer.findHostInstance(componentOrElement);\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        !!renderedByDifferentReact ? warning(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.') : void 0;\n      }\n\n      // Unmount should not be batched.\n      DOMRenderer.unbatchedUpdates(function () {\n        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        !!hasNonRootReactChild ? warning(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: function () {\n    if (!didWarnAboutUnstableCreatePortal) {\n      didWarnAboutUnstableCreatePortal = true;\n      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the \"unstable_\" prefix.');\n    }\n    return createPortal.apply(undefined, arguments);\n  },\n\n\n  unstable_batchedUpdates: DOMRenderer.batchedUpdates,\n\n  unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n\n  flushSync: DOMRenderer.flushSync,\n\n  unstable_flushControlled: DOMRenderer.flushControlled,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry,\n    EventPropagators: EventPropagators,\n    ReactControlledComponent: ReactControlledComponent,\n    ReactDOMComponentTree: ReactDOMComponentTree,\n    ReactDOMEventListener: ReactDOMEventListener\n  }\n};\n\nReactDOM.unstable_createRoot = function createRoot(container, options) {\n  var hydrate = options != null && options.hydrate === true;\n  return new ReactRoot(container, true, hydrate);\n};\n\nvar foundDevTools = DOMRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/NjFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjMuMlxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcblxuLy8gUmVseWluZyBvbiB0aGUgYGludmFyaWFudCgpYCBpbXBsZW1lbnRhdGlvbiBsZXRzIHVzXG4vLyBoYXZlIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHRoaXMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIHRoaXMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIHRoaXMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICAhKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy4nKSA6IHZvaWQgMDtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuICAgICAgICAvLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbiAgICAgICAgLy8gbmVzdGVkIGNhbGwgd291bGQgdHJpZ2dlciB0aGUgZmFrZSBldmVudCBoYW5kbGVycyBvZiBhbnkgY2FsbCBoaWdoZXJcbiAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuICAgICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWNyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSBPYmplY3QuZnJlZXplKHtcblx0cGx1Z2luczogcGx1Z2lucyxcblx0ZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cdHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblx0cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcblx0cG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcblx0aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblx0aW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn0pO1xuXG52YXIgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IEluamVjdGVkLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7XG4gICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICAhKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSkgPyB3YXJuaW5nKGZhbHNlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cblxuXG5cblxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSB2b2lkIDA7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgIShpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4pID8gd2FybmluZyhmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudHNJbkJhdGNoKGV2ZW50cywgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudHMgIT09IG51bGwpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxuXG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnRzLCBmYWxzZSk7XG59XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbixcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRydW5FdmVudHNJbkJhdGNoOiBydW5FdmVudHNJbkJhdGNoLFxuXHRydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoOiBydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xudmFyIE1vZGUgPSAxMTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSAxMjtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSAxMztcbnZhciBGb3J3YXJkUmVmID0gMTQ7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlJDEoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIsIHRoaXMgd2lsbCBhbHdheXMgYmUgdGhlIGRlZXBlc3Qgcm9vdC5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUkMShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlJDEoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMkMShub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcblx0Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuXHRnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEsXG5cdGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSxcblx0Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuXHR1cGRhdGVGaWJlclByb3BzOiB1cGRhdGVGaWJlclByb3BzJDFcbn0pO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgIWluc3QgPyB3YXJuaW5nKGZhbHNlLCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSBPYmplY3QuZnJlZXplKHtcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuXHRhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzXG59KTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICovXG5TeW50aGV0aWNFdmVudC5leHRlbmQgPSBmdW5jdGlvbiAoSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIGZ1bmN0aW9uIENsYXNzKCkge1xuICAgIHJldHVybiBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG5cbiAgcmV0dXJuIENsYXNzO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIHZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nICYmXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTIwMTFcbiAgIU9iamVjdC5pc1NlYWxlZChuZXcgUHJveHkoe30sIHt9KSk7XG5cbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAhKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSkgPyB3YXJuaW5nKGZhbHNlLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvbiA/IHdhcm5pbmcoZmFsc2UsIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb29sZWRFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucG9wKCk7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgIShldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IpID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gZXZlbnQgaW5zdGFuY2UgIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG52YXIgU3ludGhldGljRXZlbnQkMSA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblN0YXJ0JywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblN0YXJ0JzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbnZhciBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZSA9IHZvaWQgMDtcbiAgdmFyIGZhbGxiYWNrRGF0YSA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZykge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBnZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RvcExldmVsVHlwZXN9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnMgPSB2b2lkIDA7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGNvbXBvc2l0aW9uID0gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgdmFyIGJlZm9yZUlucHV0ID0gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgaWYgKGNvbXBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmVmb3JlSW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZUlucHV0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjb21wb3NpdGlvbiwgYmVmb3JlSW5wdXRdO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDIgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQyLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRuZWVkc1N0YXRlUmVzdG9yZTogbmVlZHNTdGF0ZVJlc3RvcmUsXG5cdHJlc3RvcmVTdGF0ZUlmTmVlZGVkOiByZXN0b3JlU3RhdGVJZk5lZWRlZFxufSk7XG5cbi8vIFVzZWQgYXMgYSB3YXkgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcyB3aGVuIHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG9cbi8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuXG4vLyBEZWZhdWx0c1xudmFyIF9iYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG52YXIgX2ludGVyYWN0aXZlVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYSwgYikge1xuICByZXR1cm4gZm4oYSwgYik7XG59O1xudmFyIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaXNCYXRjaGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKSB7XG4gIGlmIChpc0JhdGNoaW5nKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuICBpc0JhdGNoaW5nID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gX2JhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzQmF0Y2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuICAgIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgICAgLy8gSWYgYSBjb250cm9sbGVkIGV2ZW50IHdhcyBmaXJlZCwgd2UgbWF5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RhdGUgb2ZcbiAgICAgIC8vIHRoZSBET00gbm9kZSBiYWNrIHRvIHRoZSBjb250cm9sbGVkIHZhbHVlLiBUaGlzIGlzIG5lY2Vzc2FyeSB3aGVuIFJlYWN0XG4gICAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgICBfZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMoKTtcbiAgICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYikge1xuICByZXR1cm4gX2ludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYik7XG59XG5cblxuXG52YXIgaW5qZWN0aW9uJDMgPSB7XG4gIGluamVjdFJlbmRlcmVyOiBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICBfYmF0Y2hlZFVwZGF0ZXMgPSByZW5kZXJlci5iYXRjaGVkVXBkYXRlcztcbiAgICBfaW50ZXJhY3RpdmVVcGRhdGVzID0gcmVuZGVyZXIuaW50ZXJhY3RpdmVVcGRhdGVzO1xuICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlcyA9IHJlbmRlcmVyLmZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzO1xuICB9XG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tlcihub2RlKSB7XG4gIHJldHVybiBub2RlLl92YWx1ZVRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGRldGFjaFRyYWNrZXIobm9kZSkge1xuICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlID0gJyc7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICB2YXIgY3VycmVudFZhbHVlID0gJycgKyBub2RlW3ZhbHVlRmllbGRdO1xuXG4gIC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcbiAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCkgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdENhbGwnO1xuICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UmV0dXJuJztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEsXG4gIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW06IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMVxufTtcblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwO1xuXG4vLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbnZhciBTVFJJTkcgPSAxO1xuXG4vLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7XG5cbi8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxudmFyIEJPT0xFQU4gPSAzO1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgTlVNRVJJQyA9IDU7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4vLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59KTtcblxuLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSk7XG5cbi8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJyxcbi8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJyxcbi8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59KTtcblxuLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5bJ2NoZWNrZWQnLFxuLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblsnY2FwdHVyZScsICdkb3dubG9hZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0pO1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIHdoaXRlbGlzdC5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3htbG5zOnhsaW5rJywgJ3gtaGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCBudWxsKTtcbn0pO1xuXG4vLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbn0pO1xuXG4vLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyk7XG59KTtcblxuLy8gU3BlY2lhbCBjYXNlOiB0aGlzIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBJdHMgXCJ0YWJpbmRleFwiIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gaXRzIFJlYWN0IGB0YWJJbmRleGAgbmFtZSwgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cbnByb3BlcnRpZXMudGFiSW5kZXggPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd0YWJJbmRleCcsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3RhYmluZGV4JywgLy8gYXR0cmlidXRlTmFtZVxubnVsbCk7XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcblxuICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG4gICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gbnVsbCA/IGV4cGVjdGVkIDogc3RyaW5nVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHZhbHVlID0gbnVsbDtcbiAgfVxuICAvLyBJZiB0aGUgcHJvcCBpc24ndCBpbiB0aGUgc3BlY2lhbCBsaXN0LCB0cmVhdCBpdCBhcyBhIHNpbXBsZSBhdHRyaWJ1dGUuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbXVzdFVzZVByb3BlcnR5ID0gcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eTtcblxuICBpZiAobXVzdFVzZVByb3BlcnR5KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHR5cGUgPT09IEJPT0xFQU4gPyBmYWxzZSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxuICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lLFxuICAgICAgYXR0cmlidXRlTmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3R5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IHZvaWQgMDtcbiAgICBpZiAoX3R5cGUgPT09IEJPT0xFQU4gfHwgX3R5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTiAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJpYnV0ZU5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IG51bGxcbn07XG5cbntcbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9LFxuICAgIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAgICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAgICovXG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBnZXRTdGFjaykge1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgdGFnTmFtZSwgZ2V0U3RhY2spO1xuICB9O1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFNhZmVWYWx1ZShwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICB2YXIgX2NvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBfY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhX2NvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gZ2V0U2FmZVZhbHVlKHByb3BzLnZhbHVlKTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wcy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCBnZXRTYWZlVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gIH1cblxuICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG4gICAgaWYgKG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIH1cblxuICAgIC8vIHZhbHVlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGRlZmF1bHRWYWx1ZS4gVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSB0aGVcbiAgICAvLyB2aXN1YWxseSBkaXNwbGF5ZWQgdmFsdWUgb2YgZGF0ZSBpbnB1dHMgZGlzYXBwZWFycyBvbiBtb2JpbGUgU2FmYXJpIGFuZCBDaHJvbWU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH1cblxuICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKFxuICAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgdmFsdWUpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2FmZVZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbCBhcmUgYXNzaWduZWQgYXMgZW1wdHkgc3RyaW5nc1xuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbnZhciBldmVudFR5cGVzJDEgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25DaGFuZ2UnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNoYW5nZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDaGFuZ2UnLCAndG9wQ2xpY2snLCAndG9wRm9jdXMnLCAndG9wSW5wdXQnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDEuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBydW5FdmVudHNJbkJhdGNoKGV2ZW50LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gdm9pZCAwLFxuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSB2b2lkIDA7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5leHRlbmQoe1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn0pO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn0pO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luID0gdm9pZCAwO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSB2b2lkIDA7XG4gICAgdmFyIHRvID0gdm9pZCAwO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8wO1xudmFyIFBlcmZvcm1lZFdvcmsgPSAvKiAgICAgICAgICovMTtcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gLyogICAgICAgICAgICAgKi8yO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSAvKiAgICAqLzY7XG52YXIgRGVsZXRpb24gPSAvKiAgICAgICAgICAgICAgKi84O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovMTY7XG52YXIgQ2FsbGJhY2sgPSAvKiAgICAgICAgICAgICAgKi8zMjtcbnZhciBEaWRDYXB0dXJlID0gLyogICAgICAgICAgICAqLzY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovMTI4O1xudmFyIEVyckxvZyA9IC8qICAgICAgICAgICAgICAgICovMjU2O1xudmFyIFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovMjA0ODtcblxuLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xudmFyIEhvc3RFZmZlY3RNYXNrID0gLyogICAgICAgICovMjU1OTtcblxudmFyIEluY29tcGxldGUgPSAvKiAgICAgICAgICAgICovNTEyO1xudmFyIFNob3VsZENhcHR1cmUgPSAvKiAgICAgICAgICovMTAyNDtcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcihlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKGVsZW1lbnQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZXh0ZW5kKHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZXh0ZW5kKHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZSA9IHZvaWQgMDtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IFN5bnRoZXRpY1VJRXZlbnQuZXh0ZW5kKHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5leHRlbmQoe1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZXh0ZW5kKHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcblxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn0pO1xuXG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICogaW50b1xuICogZXZlbnRUeXBlcyA9IHtcbiAqICAgJ2Fib3J0Jzoge1xuICogICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gKiAgICAgICBidWJibGVkOiAnb25BYm9ydCcsXG4gKiAgICAgICBjYXB0dXJlZDogJ29uQWJvcnRDYXB0dXJlJyxcbiAqICAgICB9LFxuICogICAgIGRlcGVuZGVuY2llczogWyd0b3BBYm9ydCddLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gKiAgICd0b3BBYm9ydCc6IHsgc2FtZUNvbmZpZyB9XG4gKiB9O1xuICovXG52YXIgaW50ZXJhY3RpdmVFdmVudFR5cGVOYW1lcyA9IFsnYmx1cicsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbW91c2VEb3duJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3NlZWtlZCcsICdzdWJtaXQnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVDaGFuZ2UnXTtcbnZhciBub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnZHJhZycsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3Njcm9sbCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaE1vdmUnLCAndHJhbnNpdGlvbkVuZCcsICd3YWl0aW5nJywgJ3doZWVsJ107XG5cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKGV2ZW50LCBpc0ludGVyYWN0aXZlKSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdLFxuICAgIGlzSW50ZXJhY3RpdmU6IGlzSW50ZXJhY3RpdmVcbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufVxuXG5pbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZU5hbWUpIHtcbiAgYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKGV2ZW50VHlwZU5hbWUsIHRydWUpO1xufSk7XG5ub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZU5hbWUpIHtcbiAgYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKGV2ZW50VHlwZU5hbWUsIGZhbHNlKTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZTogZnVuY3Rpb24gKHRvcExldmVsVHlwZSkge1xuICAgIHZhciBjb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICByZXR1cm4gY29uZmlnICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmlzSW50ZXJhY3RpdmUgPT09IHRydWU7XG4gIH0sXG5cblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrbm93bkhUTUxUb3BMZXZlbFR5cGVzLmluZGV4T2YodG9wTGV2ZWxUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuIFRoaXMgd2FybmluZyAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIHRvcExldmVsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufTtcblxudmFyIGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZSA9IFNpbXBsZUV2ZW50UGx1Z2luLmlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZTtcblxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcudGFyZ2V0SW5zdDtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGlmICghYW5jZXN0b3IpIHtcbiAgICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGZpbmRSb290Q29udGFpbmVyTm9kZShhbmNlc3Rvcik7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocm9vdCk7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuLyoqXG4gKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZGlzcGF0Y2ggPSBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUodG9wTGV2ZWxUeXBlKSA/IGRpc3BhdGNoSW50ZXJhY3RpdmVFdmVudCA6IGRpc3BhdGNoRXZlbnQ7XG5cbiAgYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaW50ZXJhY3RpdmVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKlxuICogRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIG9yIGF1ZGlvL3ZpZGVvIGV2ZW50cyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHlcbiAqIGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZ1xuICogYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IHtcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJyksXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JyksXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJyksXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCBvZiB0aGVtLiBOb3RlIHRoZXNlIGFyZW4ndCB0ZWNobmljYWxseVxuLy8gXCJ0b3AtbGV2ZWxcIiBzaW5jZSB0aGV5IGRvbid0IGJ1YmJsZS4gV2Ugc2hvdWxkIGNvbWUgdXBcbi8vIHdpdGggYSBiZXR0ZXIgbmFtaW5nIGNvbnZlbnRpb24gaWYgd2UgY29tZSB0byByZWZhY3RvcmluZ1xuLy8gdGhlIGV2ZW50IHN5c3RlbS5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQmx1ciA9IHRydWU7XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENhbmNlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENhbmNlbCcsICdjYW5jZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2xvc2UnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENsb3NlJywgJ2Nsb3NlJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGVzLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wTGV2ZWxUeXBlc1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJpb3JGb2N1c2VkRWxlbS5mb2N1cygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQxLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG4vLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG52YXIgTUFYX1NJR05FRF8zMV9CSVRfSU5UID0gMTA3Mzc0MTgyMztcblxuLy8gVE9ETzogVXNlIGFuIG9wYXF1ZSB0eXBlIG9uY2UgRVNMaW50IGV0IGFsIHN1cHBvcnQgdGhlIHN5bnRheFxuXG5cbnZhciBOb1dvcmsgPSAwO1xudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNNb2RlID0gMTtcbnZhciBTdHJpY3RNb2RlID0gMjtcblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gdm9pZCAwO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIHZhciB0ZXN0TWFwID0gbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgdmFyIHRlc3RTZXQgPSBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIFJvbGx1cCB0byBub3QgY29uc2lkZXIgdGhlc2UgdW51c2VkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNzcxXG4gICAgLy8gVE9ETzogd2UgY2FuIHJlbW92ZSB0aGVzZSBpZiBSb2xsdXAgZml4ZXMgdGhlIGJ1Zy5cbiAgICB0ZXN0TWFwLnNldCgwLCAwKTtcbiAgICB0ZXN0U2V0LmFkZCgwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG52YXIgZGVidWdDb3VudGVyID0gdm9pZCAwO1xuXG57XG4gIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIoaXNBc3luYykge1xuICB2YXIgbW9kZSA9IGlzQXN5bmMgPyBBc3luY01vZGUgfCBTdHJpY3RNb2RlIDogTm9Db250ZXh0O1xuICByZXR1cm4gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIG51bGwsIG1vZGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcblxuICB2YXIgZmliZXJUYWcgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyVGFnID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gQ2xhc3NDb21wb25lbnQgOiBJbmRldGVybWluYXRlQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IEFzeW5jTW9kZSB8IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gUmV0dXJuQ29tcG9uZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb25zdW1lclxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHkgYXNzdW1lZCB0byBiZSBhIGNvbnRpbnVhdGlvbiBhbmQgdGhlcmVmb3JlIGlzIGFcbiAgICAgICAgICAgICAgICAgIC8vIGZpYmVyIGFscmVhZHkuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGUgeWllbGQgc3lzdGVtIGlzIGN1cnJlbnRseSBicm9rZW4gZm9yIHVwZGF0ZXMgaW5cbiAgICAgICAgICAgICAgICAgIC8vIHNvbWUgY2FzZXMuIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgIC8vIGtub3cgd2hpY2ggZmliZXIgdGhhdCBpczsgdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz9cbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmUgd2UgZG9uJ3Qga25vdyBpZiB3ZVxuICAgICAgICAgICAgICAgICAgLy8gY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC4gVGhlcmUgaXNcbiAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGEgY2xldmVyIHdheSB0byByZXN0cnVjdHVyZSB0aGlzLlxuICAgICAgICAgICAgICAgICAgZmliZXIgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3dPbkludmFsaWRFbGVtZW50VHlwZSh0eXBlLCBvd25lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd09uSW52YWxpZEVsZW1lbnRUeXBlKHR5cGUsIG93bmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLnR5cGUgPSB0eXBlO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRFbGVtZW50VHlwZSh0eXBlLCBvd25lcikge1xuICB2YXIgaW5mbyA9ICcnO1xuICB7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICB9XG4gICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgZmliZXIudHlwZSA9ICdERUxFVEVEJztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbi8vIFVzZWQgZm9yIHN0YXNoaW5nIFdJUCBwcm9wZXJ0aWVzIHRvIHJlcGxheSBmYWlsZWQgd29yayBpbiBERVYuXG5mdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBGaWJlcidzIGluaXRpYWwgcHJvcGVydGllcyB3aWxsIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5cbiAgICAvLyBXZSBvbmx5IHVzZSBhIEZpYmVyIHRvIGVuc3VyZSB0aGUgc2FtZSBoaWRkZW4gY2xhc3Mgc28gREVWIGlzbid0IHNsb3cuXG4gICAgdGFyZ2V0ID0gY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIGFzIGEgbGlzdCBvZiBhbGwgcHJvcGVydGllcy5cbiAgLy8gV2UgdHJpZWQgdG8gdXNlIE9iamVjdC5hc3NpZ24oKSBpbnN0ZWFkIGJ1dCB0aGlzIGlzIGNhbGxlZCBpblxuICAvLyB0aGUgaG90dGVzdCBwYXRoLCBhbmQgT2JqZWN0LmFzc2lnbigpIHdhcyB0b28gc2xvdzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwMlxuICAvLyBUaGlzIGNvZGUgaXMgREVWLW9ubHkgc28gc2l6ZSBpcyBub3QgYSBjb25jZXJuLlxuXG4gIHRhcmdldC50YWcgPSBzb3VyY2UudGFnO1xuICB0YXJnZXQua2V5ID0gc291cmNlLmtleTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldFsncmV0dXJuJ10gPSBzb3VyY2VbJ3JldHVybiddO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5tb2RlID0gc291cmNlLm1vZGU7XG4gIHRhcmdldC5lZmZlY3RUYWcgPSBzb3VyY2UuZWZmZWN0VGFnO1xuICB0YXJnZXQubmV4dEVmZmVjdCA9IHNvdXJjZS5uZXh0RWZmZWN0O1xuICB0YXJnZXQuZmlyc3RFZmZlY3QgPSBzb3VyY2UuZmlyc3RFZmZlY3Q7XG4gIHRhcmdldC5sYXN0RWZmZWN0ID0gc291cmNlLmxhc3RFZmZlY3Q7XG4gIHRhcmdldC5leHBpcmF0aW9uVGltZSA9IHNvdXJjZS5leHBpcmF0aW9uVGltZTtcbiAgdGFyZ2V0LmFsdGVybmF0ZSA9IHNvdXJjZS5hbHRlcm5hdGU7XG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gc291cmNlLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBsaWZ0ZWQgaW50byB0aGUgcmVuZGVyZXIuXG5cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKGlzQXN5bmMpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0QmF0Y2g6IG51bGwsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fVxufTtcblxue1xuICB2YXIgTElGRUNZQ0xFX1NVR0dFU1RJT05TID0ge1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJyxcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogJ2NvbXBvbmVudERpZFVwZGF0ZSdcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cbiAgdmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlV2FybmluZ3NNYXAsIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB2YXIgbGlmZWN5Y2xlV2FybmluZ3MgPSBsaWZlY3ljbGVXYXJuaW5nc01hcFtsaWZlY3ljbGVdO1xuICAgICAgICBpZiAobGlmZWN5Y2xlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBsaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IGxpZmVjeWNsZS5yZXBsYWNlKCdVTlNBRkVfJywgJycpO1xuICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gTElGRUNZQ0xFX1NVR0dFU1RJT05TW2xpZmVjeWNsZV07XG4gICAgICAgICAgdmFyIHNvcnRlZENvbXBvbmVudE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50TmFtZXMpO1xuXG4gICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLnB1c2goZm9ybWF0dGVkICsgJzogUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgdG8gdXNlICcgKyAoc3VnZ2VzdGlvbiArICcgaW5zdGVhZDogJyArIHNvcnRlZENvbXBvbmVudE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoc3RyaWN0Um9vdCk7XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vuc2FmZSBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGZvdW5kIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWU6JXMnICsgJ1xcblxcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmpvaW4oJ1xcblxcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZ2V0U3RyaWN0Um9vdCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBtYXliZVN0cmljdFJvb3QgPSBudWxsO1xuXG4gICAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgbWF5YmVTdHJpY3RSb290ID0gZmliZXI7XG4gICAgICB9XG5cbiAgICAgIGZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZVN0cmljdFJvb3Q7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxNb3VudCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2UgY29tcG9uZW50RGlkTW91bnQgaW5zdGVhZC4gQXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCwgJyArICd5b3UgY2FuIHJlbmFtZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50LicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgc29ydGVkTmFtZXMpO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhfdW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgaW5zdGVhZC4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9zb3J0ZWROYW1lcyk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzMiA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzMi5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhfdW5pcXVlTmFtZXMyKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdjb21wb25lbnRXaWxsVXBkYXRlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiAnICsgJ1VzZSBjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4gQXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCwgJyArICd5b3UgY2FuIHJlbmFtZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZS4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9zb3J0ZWROYW1lczIpO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZERlcHJlY2F0aW9uV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGdldFN0cmljdFJvb3QoZmliZXIpO1xuXG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIC8vIFRoaXMgaXMgZGlmZmljdWx0IHRvIHRyYWNrIGFueSBvdGhlciB3YXkgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gICAgLy8gYXJlIG9mdGVuIHZhZ3VlIGFuZCBhcmUgbGlrZWx5IHRvIGNvbGxpZGUgYmV0d2VlbiAzcmQgcGFydHkgbGlicmFyaWVzLlxuICAgIC8vIEFuIGV4cGFuZCBwcm9wZXJ0eSBpcyBwcm9iYWJseSBva2F5IHRvIHVzZSBoZXJlIHNpbmNlIGl0J3MgREVWLW9ubHksXG4gICAgLy8gYW5kIHdpbGwgb25seSBiZSBzZXQgaW4gdGhlIGV2ZW50IG9mIHNlcmlvdXMgd2FybmluZ3MuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgLy8gTm90ZSB0aGF0IGl0IGlzIHN1ZmZpY2llbnQgdG8gY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhXG4gICAgLy8gc2luZ2xlIGxpZmVjeWNsZSwgY29tcG9uZW50V2lsbE1vdW50LCB3aXRoIHRoZSBwb2x5ZmlsbCBmbGFnLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHZvaWQgMDtcbiAgICBpZiAoIXBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5oYXMoc3RyaWN0Um9vdCkpIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBbXSxcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6IFtdXG4gICAgICB9O1xuXG4gICAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Muc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5nZXQoc3RyaWN0Um9vdCk7XG4gICAgfVxuXG4gICAgdmFyIHVuc2FmZUxpZmVjeWNsZXMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaCgnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgIH1cblxuICAgIGlmICh1bnNhZmVMaWZlY3ljbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdFtsaWZlY3ljbGVdLnB1c2goZmliZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChGYWJyaWMpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgZXJyb3ItYm91bmRhcnkgQVBJIHRoYXQgY2FuIHJlY292ZXIgZnJvbSBlcnJvcnMgd2l0aGluIGEgc2luZ2xlXG4vLyByZW5kZXIgcGhhc2VcbnZhciBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSBmYWxzZTtcbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBJbiBzb21lIGNhc2VzLCBTdHJpY3RNb2RlIHNob3VsZCBhbHNvIGRvdWJsZS1yZW5kZXIgbGlmZWN5Y2xlcy5cbi8vIFRoaXMgY2FuIGJlIGNvbmZ1c2luZyBmb3IgdGVzdHMgdGhvdWdoLFxuLy8gQW5kIGl0IGNhbiBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGlzIGZlYXR1cmUgZmxhZyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBiZWhhdmlvcjpcbnZhciBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlID0gdHJ1ZTtcblxuLy8gVG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgZGVidWdnZXIsIHdlXG4vLyByZXBsYXkgdGhlIGJlZ2luIHBoYXNlIG9mIGEgZmFpbGVkIGNvbXBvbmVudCBpbnNpZGUgaW52b2tlR3VhcmRlZENhbGxiYWNrLlxudmFyIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrID0gdHJ1ZTtcblxuLy8gV2FybiBhYm91dCBkZXByZWNhdGVkLCBhc3luYy11bnNhZmUgbGlmZWN5Y2xlczsgcmVsYXRlcyB0byBSRkMgIzY6XG52YXIgd2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMgPSBmYWxzZTtcblxudmFyIGFsd2F5c1VzZVJlcXVlc3RJZGxlQ2FsbGJhY2tQb2x5ZmlsbCA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4gd2lsbCBmb3JjZSBmbHVzaCBpbiAnICsgZXhwaXJhdGlvblRpbWUgKyAnIG1zKScsICcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgd2FybmluZyQkMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyQkMSA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyQkMSk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgdmFyIGxhYmVsID0gZGlkQ29tcGxldGVSb290ID8gJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBDb21wbGV0ZWQgUm9vdCknIDogJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBZaWVsZGVkKSc7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyayhsYWJlbCwgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG59XG5cbi8vIENhbGxiYWNrcyBhcmUgbm90IHZhbGlkYXRlZCB1bnRpbCBpbnZvY2F0aW9uXG5cblxuLy8gU2luZ2x5IGxpbmtlZC1saXN0IG9mIHVwZGF0ZXMuIFdoZW4gYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCwgaXQgaXMgYWRkZWQgdG9cbi8vIHRoZSBxdWV1ZSBvZiB0aGUgY3VycmVudCBmaWJlciBhbmQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoZSB0d28gcXVldWVzXG4vLyBhcmUgc2VwYXJhdGUgYnV0IHRoZXkgc2hhcmUgYSBwZXJzaXN0ZW50IHN0cnVjdHVyZS5cbi8vXG4vLyBEdXJpbmcgcmVjb25jaWxpYXRpb24sIHVwZGF0ZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlcixcbi8vIGJ1dCB0aGV5IHJlbWFpbiBvbiB0aGUgY3VycmVudCBmaWJlci4gVGhhdCBlbnN1cmVzIHRoYXQgaWYgYSB3b3JrLWluLXByb2dyZXNzXG4vLyBpcyBhYm9ydGVkLCB0aGUgYWJvcnRlZCB1cGRhdGVzIGFyZSByZWNvdmVyZWQgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYWx3YXlzIGEgc3Vic2V0IG9mIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIFdoZW4gdGhlIHRyZWUgaXMgY29tbWl0dGVkLCB0aGUgd29yay1pbi1wcm9ncmVzcyBiZWNvbWVzIHRoZSBjdXJyZW50LlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlKGJhc2VTdGF0ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgY2FwdHVyZWRWYWx1ZXM6IG51bGxcbiAgfTtcbiAge1xuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgaWYgKHF1ZXVlLmxhc3QgPT09IG51bGwpIHtcbiAgICAvLyBRdWV1ZSBpcyBlbXB0eVxuICAgIHF1ZXVlLmZpcnN0ID0gcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZS5sYXN0Lm5leHQgPSB1cGRhdGU7XG4gICAgcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfVxuICBpZiAocXVldWUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBxdWV1ZS5leHBpcmF0aW9uVGltZSA+IHVwZGF0ZS5leHBpcmF0aW9uVGltZSkge1xuICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICB9XG59XG5cbnZhciBxMSA9IHZvaWQgMDtcbnZhciBxMiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVuc3VyZVVwZGF0ZVF1ZXVlcyhmaWJlcikge1xuICBxMSA9IHEyID0gbnVsbDtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFVzZSBtb2R1bGUgdmFyaWFibGVzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgdHVwbGVcbiAgcTEgPSBxdWV1ZTE7XG4gIHEyID0gcXVldWUyO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICBlbnN1cmVVcGRhdGVRdWV1ZXMoZmliZXIpO1xuICB2YXIgcXVldWUxID0gcTE7XG4gIHZhciBxdWV1ZTIgPSBxMjtcblxuICAvLyBXYXJuIGlmIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlciBmdW5jdGlvbi5cbiAge1xuICAgIGlmICgocXVldWUxLmlzUHJvY2Vzc2luZyB8fCBxdWV1ZTIgIT09IG51bGwgJiYgcXVldWUyLmlzUHJvY2Vzc2luZykgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHF1ZXVlLCBhZGQgdGhlIHVwZGF0ZSB0byB0aGF0IHF1ZXVlIGFuZCBleGl0LlxuICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBlaXRoZXIgcXVldWUgaXMgZW1wdHksIHdlIG5lZWQgdG8gYWRkIHRvIGJvdGggcXVldWVzLlxuICBpZiAocXVldWUxLmxhc3QgPT09IG51bGwgfHwgcXVldWUyLmxhc3QgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTIsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgYm90aCBsaXN0cyBhcmUgbm90IGVtcHR5LCB0aGUgbGFzdCB1cGRhdGUgaXMgdGhlIHNhbWUgZm9yIGJvdGggbGlzdHNcbiAgLy8gYmVjYXVzZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuIFNvLCB3ZSBzaG91bGQgb25seSBhcHBlbmQgdG8gb25lIG9mXG4gIC8vIHRoZSBsaXN0cy5cbiAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgLy8gQnV0IHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBgbGFzdGAgcG9pbnRlciBvZiBxdWV1ZTIuXG4gIHF1ZXVlMi5sYXN0ID0gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZShmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBOb1dvcms7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlUXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOb1dvcms7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhcnRpYWxTdGF0ZS5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICBjYXB0dXJlZFZhbHVlczogY3VycmVudFF1ZXVlLmNhcHR1cmVkVmFsdWVzLFxuICAgICAgLy8gVGhlc2UgZmllbGRzIGFyZSBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB0aGV5IHdlcmUgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgICAvLyBSZXNldCB0aGVtLlxuICAgICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICAvLyBTZXQgdGhpcyBmbGFnIHNvIHdlIGNhbiB3YXJuIGlmIHNldFN0YXRlIGlzIGNhbGxlZCBpbnNpZGUgdGhlIHVwZGF0ZVxuICAgIC8vIGZ1bmN0aW9uIG9mIGFub3RoZXIgc2V0U3RhdGUuXG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLiBJZiB3ZSBza2lwIG92ZXIgYW55IHVwZGF0ZXMsIHdlJ2xsXG4gIC8vIGluY3JlYXNlIHRoaXMgYWNjb3JkaW5nbHkuXG4gIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRPRE86IFdlIGRvbid0IGtub3cgd2hhdCB0aGUgYmFzZSBzdGF0ZSB3aWxsIGJlIHVudGlsIHdlIGJlZ2luIHdvcmsuXG4gIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgLy8gaGFwcHkgd2l0aCB0aGlzIGFwcHJvYWNoLlxuICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gIGlmIChxdWV1ZS5pc0luaXRpYWxpemVkKSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHF1ZXVlLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIHZhciBkb250TXV0YXRlUHJldlN0YXRlID0gdHJ1ZTtcbiAgdmFyIHVwZGF0ZSA9IHF1ZXVlLmZpcnN0O1xuICB2YXIgZGlkU2tpcCA9IGZhbHNlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBxdWV1ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICAgIGRpZFNraXAgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiBubyBwcmV2aW91cyB1cGRhdGVzIHdlcmUgc2tpcHBlZCwgZHJvcCB0aGlzIHVwZGF0ZSBmcm9tIHRoZSBxdWV1ZSBieVxuICAgIC8vIGFkdmFuY2luZyB0aGUgaGVhZCBvZiB0aGUgbGlzdC5cbiAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgIHF1ZXVlLmZpcnN0ID0gdXBkYXRlLm5leHQ7XG4gICAgICBpZiAocXVldWUuZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgcXVldWUubGFzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIC8vIElnbm9yZSB0aGUgcmV0dXJuIHZhbHVlIGluIHRoaXMgY2FzZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYXB0dXJlZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NhcHR1cmVkVmFsdWVzID0gcXVldWUuY2FwdHVyZWRWYWx1ZXM7XG4gICAgICBpZiAoX2NhcHR1cmVkVmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmNhcHR1cmVkVmFsdWVzID0gW3VwZGF0ZS5jYXB0dXJlZFZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9jYXB0dXJlZFZhbHVlcy5wdXNoKHVwZGF0ZS5jYXB0dXJlZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSAmJiBxdWV1ZS5jYXB0dXJlZFZhbHVlcyA9PT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuXG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2FsbEdldERlcml2ZWRTdGF0ZUZyb21DYXRjaChjdG9yLCBjYXB0dXJlZFZhbHVlcykge1xuICB2YXIgcmVzdWx0U3RhdGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXB0dXJlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjYXB0dXJlZFZhbHVlID0gY2FwdHVyZWRWYWx1ZXNbaV07XG4gICAgdmFyIGVycm9yID0gY2FwdHVyZWRWYWx1ZS52YWx1ZTtcbiAgICB2YXIgcGFydGlhbFN0YXRlID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2guY2FsbChudWxsLCBlcnJvcik7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCAmJiBwYXJ0aWFsU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgX2Fzc2lnbihyZXN1bHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFN0YXRlO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKGxlZ2FjeUNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgdmFyIGNhY2hlQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuY2FjaGVDb250ZXh0LFxuICAgICAgZ2V0TWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0TWFza2VkQ29udGV4dCxcbiAgICAgIGdldFVubWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0VW5tYXNrZWRDb250ZXh0LFxuICAgICAgaXNDb250ZXh0Q29uc3VtZXIgPSBsZWdhY3lDb250ZXh0LmlzQ29udGV4dENvbnN1bWVyLFxuICAgICAgaGFzQ29udGV4dENoYW5nZWQgPSBsZWdhY3lDb250ZXh0Lmhhc0NvbnRleHRDaGFuZ2VkO1xuXG4gIC8vIENsYXNzIGNvbXBvbmVudCBzdGF0ZSB1cGRhdGVyXG5cbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmVkVmFsdWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmVkVmFsdWU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICB7XG4gICAgICAgICEoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQpID8gd2FybmluZyhmYWxzZSwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA9ICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3RhbmNlLnN0YXRlO1xuICAgICAgIW5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPyB3YXJuaW5nKGZhbHNlLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAgICFub0dldERlZmF1bHRQcm9wc09uRVM2ID8gd2FybmluZyhmYWxzZSwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICAgIW5vSW5zdGFuY2VQcm9wVHlwZXMgPyB3YXJuaW5nKGZhbHNlLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZXM7XG4gICAgICAhbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA/IHdhcm5pbmcoZmFsc2UsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgICAhbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbic7XG4gICAgICAhbm9Db21wb25lbnREaWRVbm1vdW50ID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA/IHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vVW5zYWZlQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgICFub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAhKGluc3RhbmNlLnByb3BzID09PSB1bmRlZmluZWQgfHwgIWhhc011dGF0ZWRQcm9wcykgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgIW5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyh0eXBlKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgICFub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID8gd2FybmluZyhmYWxzZSwgJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgdmFyIG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCgpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHR5cGVvZiB0eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgIW5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICAgIHZhciBfc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIGlmIChfc3RhdGUgJiYgKHR5cGVvZiBfc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoX3N0YXRlKSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgISh0eXBlb2YgdHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gd2FybmluZyhmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHwgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclczogRGlkIG5vdCBwcm9wZXJseSBpbml0aWFsaXplIHN0YXRlIGR1cmluZyBjb25zdHJ1Y3Rpb24uICcgKyAnRXhwZWN0ZWQgc3RhdGUgdG8gYmUgYW4gb2JqZWN0LCBidXQgaXQgd2FzICVzLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuXG4gICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBwcm9wcywgc3RhdGUpO1xuXG4gICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCAmJiBwYXJ0aWFsU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVuZGVyLXBoYXNlIHVwZGF0ZXMgKGxpa2UgdGhpcykgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgdXBkYXRlIHF1ZXVlLFxuICAgICAgLy8gU28gdGhhdCBtdWx0aXBsZSByZW5kZXIgcGFzc2VzIGRvIG5vdCBlbnF1ZXVlIG11bHRpcGxlIHVwZGF0ZXMuXG4gICAgICAvLyBJbnN0ZWFkLCBqdXN0IHN5bmNocm9ub3VzbHkgbWVyZ2UgdGhlIHJldHVybmVkIHN0YXRlIGludG8gdGhlIGluc3RhbmNlLlxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9hc3NpZ24oe30sIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIH1cblxuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIC8vIEludm9rZSBtZXRob2QgYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgIHR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLmNhbGwobnVsbCwgbmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydGlhbFN0YXRlID0gdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuY2FsbChudWxsLCBuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnRpYWxTdGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZERlcHJlY2F0aW9uV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gICAgdmFyIG5ld1VubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAgIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gICAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpIHtcbiAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgdmFyIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IHZvaWQgMDtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKG51bGwsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsICYmIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCAmJiB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVkVmFsdWVzID0gdXBkYXRlUXVldWUuY2FwdHVyZWRWYWx1ZXM7XG4gICAgICAgIC8vIERvbid0IHJlbW92ZSB0aGVzZSBmcm9tIHRoZSB1cGRhdGUgcXVldWUgeWV0LiBXZSBuZWVkIHRoZW0gaW5cbiAgICAgICAgLy8gZmluaXNoQ2xhc3NDb21wb25lbnQuIERvIHRoZSByZXNldCB0aGVyZS5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhd2t3YXJkLiBSZWZhY3RvciBjbGFzcyBjb21wb25lbnRzLlxuICAgICAgICAvLyB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IG51bGw7XG4gICAgICAgIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2goY3RvciwgY2FwdHVyZWRWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIHZhciBkZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB2b2lkIDA7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgLy8gVGhlIHByZXZTdGF0ZSBwYXJhbWV0ZXIgc2hvdWxkIGJlIHRoZSBwYXJ0aWFsbHkgdXBkYXRlZCBzdGF0ZS5cbiAgICAgIC8vIE90aGVyd2lzZSwgc3ByZWFkaW5nIHN0YXRlIGluIHJldHVybiB2YWx1ZXMgY291bGQgb3ZlcnJpZGUgdXBkYXRlcy5cbiAgICAgIGRlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChkZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09IG51bGwgJiYgZGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFJlbmRlci1waGFzZSB1cGRhdGVzIChsaWtlIHRoaXMpIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIHVwZGF0ZSBxdWV1ZSxcbiAgICAgIC8vIFNvIHRoYXQgbXVsdGlwbGUgcmVuZGVyIHBhc3NlcyBkbyBub3QgZW5xdWV1ZSBtdWx0aXBsZSB1cGRhdGVzLlxuICAgICAgLy8gSW5zdGVhZCwganVzdCBzeW5jaHJvbm91c2x5IG1lcmdlIHRoZSByZXR1cm5lZCBzdGF0ZSBpbnRvIHRoZSBpbnN0YW5jZS5cbiAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUgPT09IG51bGwgfHwgbmV3U3RhdGUgPT09IHVuZGVmaW5lZCA/IGRlcml2ZWRTdGF0ZUZyb21Qcm9wcyA6IF9hc3NpZ24oe30sIG5ld1N0YXRlLCBkZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGJhc2Ugc3RhdGUgb2YgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICAgIC8vIEZJWE1FOiBUaGlzIGlzIGdldHRpbmcgcmlkaWN1bG91cy4gUmVmYWN0b3IgcGx6IVxuICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBfdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gX2Fzc2lnbih7fSwgX3VwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbVByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlcml2ZWRTdGF0ZUZyb21DYXRjaCAhPT0gbnVsbCAmJiBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVuZGVyLXBoYXNlIHVwZGF0ZXMgKGxpa2UgdGhpcykgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgdXBkYXRlIHF1ZXVlLFxuICAgICAgLy8gU28gdGhhdCBtdWx0aXBsZSByZW5kZXIgcGFzc2VzIGRvIG5vdCBlbnF1ZXVlIG11bHRpcGxlIHVwZGF0ZXMuXG4gICAgICAvLyBJbnN0ZWFkLCBqdXN0IHN5bmNocm9ub3VzbHkgbWVyZ2UgdGhlIHJldHVybmVkIHN0YXRlIGludG8gdGhlIGluc3RhbmNlLlxuICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZSA9PT0gbnVsbCB8fCBuZXdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gZGVyaXZlZFN0YXRlRnJvbUNhdGNoIDogX2Fzc2lnbih7fSwgbmV3U3RhdGUsIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgYmFzZSBzdGF0ZSBvZiB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgICAgLy8gRklYTUU6IFRoaXMgaXMgZ2V0dGluZyByaWRpY3Vsb3VzLiBSZWZhY3RvciBwbHohXG4gICAgICB2YXIgX3VwZGF0ZVF1ZXVlMiA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKF91cGRhdGVRdWV1ZTIgIT09IG51bGwpIHtcbiAgICAgICAgX3VwZGF0ZVF1ZXVlMi5iYXNlU3RhdGUgPSBfYXNzaWduKHt9LCBfdXBkYXRlUXVldWUyLmJhc2VTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbUNhdGNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcyk7XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gICAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkge1xuICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXh0IHN0YXRlIHVzaW5nIHRoZSBtZW1vaXplZCBzdGF0ZSBhbmQgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIC8vIFRPRE86IFByZXZpb3VzIHN0YXRlIGNhbiBiZSBudWxsLlxuICAgIHZhciBuZXdTdGF0ZSA9IHZvaWQgMDtcbiAgICB2YXIgZGVyaXZlZFN0YXRlRnJvbUNhdGNoID0gdm9pZCAwO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyAhPT0gbnVsbCAmJiBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggJiYgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYXB0dXJlZFZhbHVlcyA9IHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzO1xuICAgICAgICAvLyBEb24ndCByZW1vdmUgdGhlc2UgZnJvbSB0aGUgdXBkYXRlIHF1ZXVlIHlldC4gV2UgbmVlZCB0aGVtIGluXG4gICAgICAgIC8vIGZpbmlzaENsYXNzQ29tcG9uZW50LiBEbyB0aGUgcmVzZXQgdGhlcmUuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYXdrd2FyZC4gUmVmYWN0b3IgY2xhc3MgY29tcG9uZW50cy5cbiAgICAgICAgLy8gdXBkYXRlUXVldWUuY2FwdHVyZWRWYWx1ZXMgPSBudWxsO1xuICAgICAgICBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSBjYWxsR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoKGN0b3IsIGNhcHR1cmVkVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdm9pZCAwO1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIFRoZSBwcmV2U3RhdGUgcGFyYW1ldGVyIHNob3VsZCBiZSB0aGUgcGFydGlhbGx5IHVwZGF0ZWQgc3RhdGUuXG4gICAgICAvLyBPdGhlcndpc2UsIHNwcmVhZGluZyBzdGF0ZSBpbiByZXR1cm4gdmFsdWVzIGNvdWxkIG92ZXJyaWRlIHVwZGF0ZXMuXG4gICAgICBkZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjYWxsR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoZGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSBudWxsICYmIGRlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW5kZXItcGhhc2UgdXBkYXRlcyAobGlrZSB0aGlzKSBzaG91bGQgbm90IGJlIGFkZGVkIHRvIHRoZSB1cGRhdGUgcXVldWUsXG4gICAgICAvLyBTbyB0aGF0IG11bHRpcGxlIHJlbmRlciBwYXNzZXMgZG8gbm90IGVucXVldWUgbXVsdGlwbGUgdXBkYXRlcy5cbiAgICAgIC8vIEluc3RlYWQsIGp1c3Qgc3luY2hyb25vdXNseSBtZXJnZSB0aGUgcmV0dXJuZWQgc3RhdGUgaW50byB0aGUgaW5zdGFuY2UuXG4gICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlID09PSBudWxsIHx8IG5ld1N0YXRlID09PSB1bmRlZmluZWQgPyBkZXJpdmVkU3RhdGVGcm9tUHJvcHMgOiBfYXNzaWduKHt9LCBuZXdTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbVByb3BzKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBiYXNlIHN0YXRlIG9mIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgICAvLyBGSVhNRTogVGhpcyBpcyBnZXR0aW5nIHJpZGljdWxvdXMuIFJlZmFjdG9yIHBseiFcbiAgICAgIHZhciBfdXBkYXRlUXVldWUzID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAoX3VwZGF0ZVF1ZXVlMyAhPT0gbnVsbCkge1xuICAgICAgICBfdXBkYXRlUXVldWUzLmJhc2VTdGF0ZSA9IF9hc3NpZ24oe30sIF91cGRhdGVRdWV1ZTMuYmFzZVN0YXRlLCBkZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSBudWxsICYmIGRlcml2ZWRTdGF0ZUZyb21DYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBSZW5kZXItcGhhc2UgdXBkYXRlcyAobGlrZSB0aGlzKSBzaG91bGQgbm90IGJlIGFkZGVkIHRvIHRoZSB1cGRhdGUgcXVldWUsXG4gICAgICAvLyBTbyB0aGF0IG11bHRpcGxlIHJlbmRlciBwYXNzZXMgZG8gbm90IGVucXVldWUgbXVsdGlwbGUgdXBkYXRlcy5cbiAgICAgIC8vIEluc3RlYWQsIGp1c3Qgc3luY2hyb25vdXNseSBtZXJnZSB0aGUgcmV0dXJuZWQgc3RhdGUgaW50byB0aGUgaW5zdGFuY2UuXG4gICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlID09PSBudWxsIHx8IG5ld1N0YXRlID09PSB1bmRlZmluZWQgPyBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggOiBfYXNzaWduKHt9LCBuZXdTdGF0ZSwgZGVyaXZlZFN0YXRlRnJvbUNhdGNoKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBiYXNlIHN0YXRlIG9mIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgICAvLyBGSVhNRTogVGhpcyBpcyBnZXR0aW5nIHJpZGljdWxvdXMuIFJlZmFjdG9yIHBseiFcbiAgICAgIHZhciBfdXBkYXRlUXVldWU0ID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAoX3VwZGF0ZVF1ZXVlNCAhPT0gbnVsbCkge1xuICAgICAgICBfdXBkYXRlUXVldWU0LmJhc2VTdGF0ZSA9IF9hc3NpZ24oe30sIF91cGRhdGVRdWV1ZTQuYmFzZVN0YXRlLCBkZXJpdmVkU3RhdGVGcm9tQ2F0Y2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcyk7XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gICAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlOiBhZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgY2FsbEdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogY2FsbEdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZTogcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHZvaWQgMDtcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0ge307XG5cbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBzdHJpbmcgcmVmLCBcIiVzXCIswqBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArICdcXG4lcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYsIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIocmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZy4nKSA6IHZvaWQgMDtcbiAgICAgICFlbGVtZW50Ll9vd25lciA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKCVzKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbjIuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgIHtcbiAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpIHx8ICcnKTtcbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBuZXdDaGlsZCwgYWRkZW5kdW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZSgpIHtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSB8fCAnJyk7XG5cbiAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIHdhcm5pbmcoZmFsc2UsICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpIHx8ICcnKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkMlsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQzWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiVzJywga2V5LCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aHMgZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cblxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cblxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKCFfbmV3RmliZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjIpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHtcbiAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBvc3NpYmxlTWFwID0gbmV3Q2hpbGRyZW5JdGVyYWJsZTtcbiAgICAgICAgaWYgKHBvc3NpYmxlTWFwLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICAhZGlkV2FybkFib3V0TWFwcyA/IHdhcm5pbmcoZmFsc2UsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG4gICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7XG59XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcih0cnVlKTtcbnZhciBtb3VudENoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKGZhbHNlKTtcblxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAhKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gICAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyA9IHt9O1xufVxuXG52YXIgUmVhY3RGaWJlckJlZ2luV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSA9IGNvbmZpZy5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlO1xuICB2YXIgcHVzaEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250ZXh0LFxuICAgICAgcHVzaEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRhaW5lcjtcbiAgdmFyIHB1c2hQcm92aWRlciA9IG5ld0NvbnRleHQucHVzaFByb3ZpZGVyO1xuICB2YXIgZ2V0TWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0TWFza2VkQ29udGV4dCxcbiAgICAgIGdldFVubWFza2VkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQuZ2V0VW5tYXNrZWRDb250ZXh0LFxuICAgICAgaGFzTGVnYWN5Q29udGV4dENoYW5nZWQgPSBsZWdhY3lDb250ZXh0Lmhhc0NvbnRleHRDaGFuZ2VkLFxuICAgICAgcHVzaExlZ2FjeUNvbnRleHRQcm92aWRlciA9IGxlZ2FjeUNvbnRleHQucHVzaENvbnRleHRQcm92aWRlcixcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QgPSBsZWdhY3lDb250ZXh0LnB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QsXG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyID0gbGVnYWN5Q29udGV4dC5pbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyO1xuICB2YXIgZW50ZXJIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQuZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ2xhc3NDb21wbyA9IFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudChsZWdhY3lDb250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSxcbiAgICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5hZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgICBjYWxsR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgICBtb3VudENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8ubW91bnRDbGFzc0luc3RhbmNlLFxuICAgICAgcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgdXNlIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBkaXJlY3RseS5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVuZGVyID0gd29ya0luUHJvZ3Jlc3MudHlwZS5yZW5kZXI7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHJlbmRlcih3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHdvcmtJblByb2dyZXNzLnJlZik7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gV2UgcHJvY2Vzc2VkIHRoZSB1cGRhdGUgcXVldWUgaW5zaWRlIHVwZGF0ZUNsYXNzSW5zdGFuY2UuIEl0IG1heSBoYXZlXG4gICAgLy8gaW5jbHVkZWQgc29tZSBlcnJvcnMgdGhhdCB3ZXJlIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuXG4gICAgLy8gVE9ETzogUmVmYWN0b3IgY2xhc3MgY29tcG9uZW50cyBzbyB0aGlzIGlzIGxlc3MgYXdrd2FyZC5cbiAgICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgZGlkQ2FwdHVyZUVycm9yID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIGRpZENhcHR1cmVFcnJvciwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgZGlkQ2FwdHVyZUVycm9yLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAvLyBSZXJlbmRlclxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICAgIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgKCFlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tIGNhdGNoIGlzIG5vdCBkZWZpbmVkLFxuICAgICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gICAgaWYgKGRpZENhcHR1cmVFcnJvcikge1xuICAgICAgLy8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgdHdpY2U6IGZpcnN0IHRvIGRlbGV0ZVxuICAgICAgLy8gYWxsIHRoZSBleGlzdGluZyBjaGlsZHJlbi5cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgLy8gTm93IHdlIGNhbiBjb250aW51ZSByZWNvbmNpbGluZyBsaWtlIG5vcm1hbC4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gICAgICAvLyBpZGVudGl0eSBtYXRjaGVzLlxuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBzdGF0ZSk7XG4gICAgICB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSdzIGFuIHVuY2F1Z2h0IGVycm9yLiBVbm1vdW50IHRoZSB3aG9sZSByb290LlxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgdGhlIHNhbWUgYXMgYmVmb3JlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2Ugd2UgaGFkXG4gICAgICAgIC8vIG5vIHdvcmsgdGhhdCBleHBpcmVzIGF0IHRoaXMgdGltZS5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzTGVnYWN5Q29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgaXNIaWRkZW4gPSB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQXN5bmNNb2RlICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKTtcbiAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAvLyBCZWZvcmUgYmFpbGluZyBvdXQsIG1ha2Ugc3VyZSB3ZSd2ZSBkZXByaW9yaXRpemVkIGEgaGlkZGVuIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNIaWRkZW4gfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3JlIHJlbmRlcmluZyBhIGhpZGRlbiBub2RlIGF0IGhpZGRlbiBwcmlvcml0eSwgZG9uJ3QgYmFpbG91dC4gVGhlXG4gICAgICAvLyBwYXJlbnQgaXMgY29tcGxldGUsIGJ1dCB0aGUgY2hpbGRyZW4gbWF5IG5vdCBiZS5cbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIEFzeW5jTW9kZSAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAgIC8vIERvd24tcHJpb3JpdGl6ZSB0aGUgY2hpbGRyZW4uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgICAgLy8gQmFpbG91dCBhbmQgY29tZSBiYWNrIHRvIHRoaXMgZmliZXIgbGF0ZXIuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGNhbGxHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIHZhbHVlLCBwcm9wcywgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSk7XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAhPT0gbnVsbCAmJiBwYXJ0aWFsU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfYXNzaWduKHt9LCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hMZWdhY3lDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCwgZmFsc2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChfQ29tcG9uZW50KSB7XG4gICAgICAgICAgISFfQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgX0NvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBfQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICAgIHZhciBvd25lck5hbWUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG4gICAgICAgICAgaWYgKGRlYnVnU291cmNlKSB7XG4gICAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZuLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBTdGF0ZWxlc3MgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnRbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0xlZ2FjeUNvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNMZWdhY3lDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgZmliZXJbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5leHRGaWJlciA9IHZvaWQgMDtcbiAgICAgIC8vIFZpc2l0IHRoaXMgZmliZXIuXG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBmaWJlci5zdGF0ZU5vZGUgfCAwO1xuICAgICAgICAgIGlmIChmaWJlci50eXBlID09PSBjb250ZXh0ICYmIChvYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDApIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXhwaXJhdGlvbiB0aW1lIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmdcbiAgICAgICAgICAgIC8vIHRoZSBhbHRlcm5hdGVzLlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIChhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIGFsdGVybmF0ZSB3YXMgdXBkYXRlZCwgd2hpY2ggbWVhbnMgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIHRoYW4gYSBtYXRjaGluZyBjb25zdW1lci4gV2hlbiB3ZSByZW5kZXIgdGhlXG4gICAgICAgICAgICAvLyBjb25zdW1lciwgd2UnbGwgY29udGludWUgc2Nhbm5pbmcgZnJvbSB0aGF0IHBvaW50LiBUaGlzIHdheSB0aGVcbiAgICAgICAgICAgIC8vIHNjYW5uaW5nIHdvcmsgaXMgdGltZS1zbGljZWQuXG4gICAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICBuZXh0RmliZXJbJ3JldHVybiddID0gZmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXJbJ3JldHVybiddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIHByb3ZpZGVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChoYXNMZWdhY3lDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcblxuICAgIHZhciBjaGFuZ2VkQml0cyA9IHZvaWQgMDtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgIC8vIEluaXRpYWwgcmVuZGVyXG4gICAgICBjaGFuZ2VkQml0cyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9sZFByb3BzLnZhbHVlID09PSBuZXdQcm9wcy52YWx1ZSkge1xuICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gMDtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICAgICAgLy8gVXNlIE9iamVjdC5pcyB0byBjb21wYXJlIHRoZSBuZXcgY29udGV4dCB2YWx1ZSB0byB0aGUgb2xkIHZhbHVlLlxuICAgICAgICAvLyBJbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUgJiYgKG9sZFZhbHVlICE9PSAwIHx8IDEgLyBvbGRWYWx1ZSA9PT0gMSAvIG5ld1ZhbHVlKSB8fCBvbGRWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgIT09IG5ld1ZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gMDtcbiAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlZEJpdHMgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgICEoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMpID8gd2FybmluZyhmYWxzZSwgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYW5nZWRCaXRzIHw9IDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZEJpdHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjaGFuZ2VkQml0cztcbiAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNvbnRleHQuX2NoYW5nZWRCaXRzO1xuXG4gICAgaWYgKGhhc0xlZ2FjeUNvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKGNoYW5nZWRCaXRzID09PSAwICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gbmV3UHJvcHMudW5zdGFibGVfb2JzZXJ2ZWRCaXRzO1xuICAgIGlmIChvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwpIHtcbiAgICAgIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBieSBkZWZhdWx0XG4gICAgICBvYnNlcnZlZEJpdHMgPSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgfVxuICAgIC8vIFN0b3JlIHRoZSBvYnNlcnZlZEJpdHMgb24gdGhlIGZpYmVyJ3Mgc3RhdGVOb2RlIGZvciBxdWljayBhY2Nlc3MuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gb2JzZXJ2ZWRCaXRzO1xuXG4gICAgaWYgKChjaGFuZ2VkQml0cyAmIG9ic2VydmVkQml0cykgIT09IDApIHtcbiAgICAgIC8vIENvbnRleHQgY2hhbmdlIHByb3BhZ2F0aW9uIHN0b3BzIGF0IG1hdGNoaW5nIGNvbnN1bWVycywgZm9yIHRpbWUtXG4gICAgICAvLyBzbGljaW5nLiBDb250aW51ZSB0aGUgcHJvcGFnYXRpb24gaGVyZS5cbiAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIGNoYW5nZWRCaXRzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIFNraXAgb3ZlciBhIG1lbW9pemVkIHBhcmVudCB3aXRoIGEgYml0bWFzayBiYWlsb3V0IGV2ZW5cbiAgICAgIC8vIGlmIHdlIGJlZ2FuIHdvcmtpbmcgb24gaXQgYmVjYXVzZSBvZiBhIGRlZXBlciBtYXRjaGluZyBjaGlsZC5cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgLy8gVGhlcmUgaXMgbm8gYmFpbG91dCBvbiBgY2hpbGRyZW5gIGVxdWFsaXR5IGJlY2F1c2Ugd2UgZXhwZWN0IHBlb3BsZVxuICAgIC8vIHRvIG9mdGVuIHBhc3MgYSBib3VuZCBtZXRob2QgYXMgYSBjaGlsZCwgYnV0IGl0IG1heSByZWZlcmVuY2VcbiAgICAvLyBgdGhpcy5zdGF0ZWAgb3IgYHRoaXMucHJvcHNgIChhbmQgdGh1cyBuZWVkcyB0byByZS1yZW5kZXIgb24gYHNldFN0YXRlYCkuXG5cbiAgICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAgICB7XG4gICAgICAhKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIC8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuICBmdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBpZGVhbGx5IGJlIGFibGUgdG8gYmFpbCBvdXQgZWFybHkgaWYgdGhlIGNoaWxkcmVuIGhhdmUgbm9cbiAgICAvLyBtb3JlIHdvcmsgdG8gZG8uIEhvd2V2ZXIsIHNpbmNlIHdlIGRvbid0IGhhdmUgYSBzZXBhcmF0aW9uIG9mIHRoaXNcbiAgICAvLyBGaWJlcidzIHByaW9yaXR5IGFuZCBpdHMgY2hpbGRyZW4geWV0IC0gd2UgZG9uJ3Qga25vdyB3aXRob3V0IGRvaW5nIGxvdHNcbiAgICAvLyBvZiB0aGUgc2FtZSB3b3JrIHdlIGRvIGFueXdheS4gT25jZSB3ZSBoYXZlIHRoYXQgc2VwYXJhdGlvbiB3ZSBjYW4ganVzdFxuICAgIC8vIGJhaWwgb3V0IGhlcmUgaWYgdGhlIGNoaWxkcmVuIGhhcyBubyBtb3JlIHdvcmsgYXQgdGhpcyBwcmlvcml0eSBsZXZlbC5cbiAgICAvLyBpZiAod29ya0luUHJvZ3Jlc3MucHJpb3JpdHlPZkNoaWxkcmVuIDw9IHByaW9yaXR5TGV2ZWwpIHtcbiAgICAvLyAgIC8vIElmIHRoZXJlIGFyZSBzaWRlLWVmZmVjdHMgaW4gdGhlc2UgY2hpbGRyZW4gdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgIC8vICAgLy8gY29tbWl0dGVkIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhleSBnZXQgcHJvcGVybHkgdHJhbnNmZXJyZWQgdXAuXG4gICAgLy8gICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmNoaWxkICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgIC8vICAgICByZXVzZUNoaWxkcmVuRWZmZWN0cyh3b3JrSW5Qcm9ncmVzcywgY2hpbGQpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgLy8gfVxuXG4gICAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIEhvc3RDb21wb25lbnQgdGFncyBoZXJlIGFzIHdlbGwgYW5kIGNhbGwgcHVzaEhvc3RDb250ZXh0KCk/XG4gICAgLy8gU2VlIFBSIDg1OTAgZGlzY3Vzc2lvbiBmb3IgY29udGV4dFxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBUT0RPOiBXaGF0IGlmIHRoaXMgaXMgY3VycmVudGx5IGluIHByb2dyZXNzP1xuICAgIC8vIEhvdyBjYW4gdGhhdCBoYXBwZW4/IEhvdyBpcyB0aGlzIG5vdCBiZWluZyBjbG9uZWQ/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbiAgZnVuY3Rpb24gbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuICAgIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgICAvLyBpcyBoYW5kbGVkIGJ5IHByb2Nlc3NVcGRhdGVRdWV1ZS5cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFRoaXMgaXMgYSByZXN0YXJ0LiBSZXNldCB0aGUgdGFnIHRvIHRoZSBpbml0aWFsIHBoYXNlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggc2luY2UgdGhpcyBpcyBub3cgdGhlIHNhbWUuXG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gQSByZXR1cm4gY29tcG9uZW50IGlzIGp1c3QgYSBwbGFjZWhvbGRlciwgd2UgY2FuIGp1c3QgcnVuIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIG5leHQgb25lIGltbWVkaWF0ZWx5LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBNb2RlOlxuICAgICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gdW5pdCBvZiB3b3JrIHRhZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwb3BMZWdhY3lDb250ZXh0UHJvdmlkZXIgPSBsZWdhY3lDb250ZXh0LnBvcENvbnRleHRQcm92aWRlcixcbiAgICAgIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCA9IGxlZ2FjeUNvbnRleHQucG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0O1xuICB2YXIgcG9wUHJvdmlkZXIgPSBuZXdDb250ZXh0LnBvcFByb3ZpZGVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUucGVuZGluZ1Byb3BzLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVDYWxsVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhcHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gcHJvcHMuaGFuZGxlcjtcbiAgICB2YXIgY2hpbGRQcm9wcyA9IHByb3BzLnByb3BzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBmbihjaGlsZFByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIHRoZW4gbm9uZSBvZiBvdXIgY2hpbGRyZW4gaGFkIGFueSB1cGRhdGVzLlxuICAgICAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVjeWNsYWJsZUluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoY3VycmVudEluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHdvcmtJblByb2dyZXNzLCBjaGlsZHJlblVuY2hhbmdlZCwgcmVjeWNsYWJsZUluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGNhdWdodCBhbiBlcnJvciwgc2NoZWR1bGUgYW4gZXJyb3IgbG9nIGVmZmVjdC5cbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gfkRpZENhcHR1cmU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBFcnJMb2c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3JtYWxseSB3ZSBjbGVhciB0aGlzIGluIHRoZSBjb21taXQgcGhhc2UsIGJ1dCBzaW5jZSB3ZSBkaWQgbm90XG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlIGFuIGVmZmVjdCwgd2UgbmVlZCB0byByZXNldCBpdCBoZXJlLlxuICAgICAgICAgICAgICB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwgJiYgX3VwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyTG9nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3RcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4gICAgICAgICAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKF9pbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oX2luc3RhbmNlMiwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UyLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dDIsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdmVDYWxsVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRhZyB0byBub3cgYmUgYSBmaXJzdCBwaGFzZSBjYWxsLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBEb2VzIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBNb2RlOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzb3VyY2UpXG4gIH07XG59XG5cbnZhciBSZWFjdEZpYmVyVW53aW5kV29yayA9IGZ1bmN0aW9uIChob3N0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgbmV3Q29udGV4dCwgc2NoZWR1bGVXb3JrLCBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KSB7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQ7XG4gIHZhciBwb3BMZWdhY3lDb250ZXh0UHJvdmlkZXIgPSBsZWdhY3lDb250ZXh0LnBvcENvbnRleHRQcm92aWRlcixcbiAgICAgIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCA9IGxlZ2FjeUNvbnRleHQucG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0O1xuICB2YXIgcG9wUHJvdmlkZXIgPSBuZXdDb250ZXh0LnBvcFByb3ZpZGVyO1xuXG5cbiAgZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByYXdWYWx1ZSkge1xuICAgIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgICBzb3VyY2VGaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgICAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICB2YXIgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHJhd1ZhbHVlLCBzb3VyY2VGaWJlcik7XG5cbiAgICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFVuY2F1Z2h0IGVycm9yXG4gICAgICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgICBlbnN1cmVVcGRhdGVRdWV1ZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IFtlcnJvckluZm9dO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgX2luc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoX2luc3RhbmNlKSkpIHtcbiAgICAgICAgICAgIGVuc3VyZVVwZGF0ZVF1ZXVlcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZWRWYWx1ZXMgPSBfdXBkYXRlUXVldWUuY2FwdHVyZWRWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZWRWYWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3VwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgfSB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAgIGlmIChlZmZlY3RUYWcgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgX2VmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgICBpZiAoX2VmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IF9lZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gICAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxMZWdhY3lDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGhyb3dFeGNlcHRpb246IHRocm93RXhjZXB0aW9uLFxuICAgIHVud2luZFdvcms6IHVud2luZFdvcmssXG4gICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrOiB1bndpbmRJbnRlcnJ1cHRlZFdvcmtcbiAgfTtcbn07XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcikge1xuICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGVycm9yICYmIGVycm9yLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gIGlmIChzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQzID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gIGlmIChzdGFjayA9PT0gbnVsbCkge1xuICAgIHN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UpIDogbnVsbCxcbiAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnLFxuICAgIGVycm9yOiBlcnJvckluZm8udmFsdWUsXG4gICAgZXJyb3JCb3VuZGFyeTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5TmFtZTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGZhbHNlLFxuICAgIHdpbGxSZXRyeTogZmFsc2VcbiAgfTtcblxuICBpZiAoYm91bmRhcnkgIT09IG51bGwgJiYgYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeSA9IGJvdW5kYXJ5LnN0YXRlTm9kZTtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeSk7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgIGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGUgJiYgZS5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSkge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQzKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgICBjYXB0dXJlRXJyb3IoY3VycmVudCwgcmVmRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY3VycmVudFRpbWUsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgICAgICAgX2luc3RhbmNlMi5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfaW5zdGFuY2UyLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIF9pbnN0YW5jZTIuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgICAgICAgX2luc3RhbmNlMi5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBfaW5zdGFuY2UyLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIF9pbnN0YW5jZTIuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBfaW5zdGFuY2UyLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZTMgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UzID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlNCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2U0LCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9yTG9nZ2luZyhmaW5pc2hlZFdvcmssIG9uVW5jYXVnaHRFcnJvcikge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjdG9yID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAhKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGVycm9yIGxvZ2dpbmcgZWZmZWN0IHNob3VsZCBub3QgaGF2ZSBiZWVuIHNjaGVkdWxlZCBpZiBubyBlcnJvcnMgd2VyZSBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgY2FwdHVyZWRFcnJvcnMgPSB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcztcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5jYXB0dXJlZFZhbHVlcyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIGlzXG4gICAgICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoX2luc3RhbmNlNSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2luc3RhbmNlNS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZTUuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhcHR1cmVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JJbmZvID0gY2FwdHVyZWRFcnJvcnNbaV07XG4gICAgICAgICAgICB2YXIgX2Vycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgICAgICAgbG9nRXJyb3IoZmluaXNoZWRXb3JrLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgX2luc3RhbmNlNS5jb21wb25lbnREaWRDYXRjaChfZXJyb3IsIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdXBkYXRlUXVldWUyID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICEoX3VwZGF0ZVF1ZXVlMiAhPT0gbnVsbCAmJiBfdXBkYXRlUXVldWUyLmNhcHR1cmVkVmFsdWVzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGVycm9yIGxvZ2dpbmcgZWZmZWN0IHNob3VsZCBub3QgaGF2ZSBiZWVuIHNjaGVkdWxlZCBpZiBubyBlcnJvcnMgd2VyZSBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgX2NhcHR1cmVkRXJyb3JzID0gX3VwZGF0ZVF1ZXVlMi5jYXB0dXJlZFZhbHVlcztcbiAgICAgICAgICBfdXBkYXRlUXVldWUyLmNhcHR1cmVkVmFsdWVzID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2NhcHR1cmVkRXJyb3JzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9lcnJvckluZm8gPSBfY2FwdHVyZWRFcnJvcnNbX2ldO1xuICAgICAgICAgICAgbG9nRXJyb3IoZmluaXNoZWRXb3JrLCBfZXJyb3JJbmZvKTtcbiAgICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcihfZXJyb3JJbmZvLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBjYW5ub3QgY2FwdHVyZSBlcnJvcnMuICBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2luc3RhbmNlNiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICB2YXIgaW5zdGFuY2VUb1VzZSA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKF9pbnN0YW5jZTYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBfaW5zdGFuY2U2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLiVzJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmspLCBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbiAgLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbiAgLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbiAgZnVuY3Rpb24gY29tbWl0VW5tb3VudChjdXJyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHZhciBfaW5zdGFuY2U3ID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfaW5zdGFuY2U3LmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgX2luc3RhbmNlNyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudC5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyICYmIG11dGF0aW9uKSB7XG4gICAgICAgICAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciAmJiBwZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKHJvb3QpIHtcbiAgICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAgIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsICYmIChcbiAgICAgIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgICAgLy8gSWYgd2UgZG9uJ3QgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIGhlcmUgaW5zdGVhZC5cbiAgICAgICFtdXRhdGlvbiB8fCBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gcm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaEZpYmVyKGN1cnJlbnQpIHtcbiAgICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAgIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAgIC8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbiAgICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAgIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gICAgY3VycmVudFsncmV0dXJuJ10gPSBudWxsO1xuICAgIGN1cnJlbnQuY2hpbGQgPSBudWxsO1xuICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSkge1xuICAgICAgY3VycmVudC5hbHRlcm5hdGUuY2hpbGQgPSBudWxsO1xuICAgICAgY3VycmVudC5hbHRlcm5hdGVbJ3JldHVybiddID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSB2b2lkIDA7XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBlbXB0eUNoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVySW5mbyk7XG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbiAgICAgIH07XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIHx8IGVuYWJsZU5vb3BSZWNvbmNpbGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7fSxcbiAgICAgICAgY29tbWl0UGxhY2VtZW50OiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7fSxcbiAgICAgICAgY29tbWl0RGVsZXRpb246IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50KTtcbiAgICAgICAgICBkZXRhY2hGaWJlcihjdXJyZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWl0V29yazogZnVuY3Rpb24gKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIGNvbW1pdENvbnRhaW5lcihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlczogY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRFcnJvckxvZ2dpbmc6IGNvbW1pdEVycm9yTG9nZ2luZyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2U4ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoX2luc3RhbmNlOCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKF9pbnN0YW5jZTgsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlczogY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRFcnJvckxvZ2dpbmc6IGNvbW1pdEVycm9yTG9nZ2luZyxcbiAgICAgIGNvbW1pdEF0dGFjaFJlZjogY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gIH1cbn07XG5cbnZhciBOT19DT05URVhUID0ge307XG5cbnZhciBSZWFjdEZpYmVySG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY29uZmlnLCBzdGFjaykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcbiAgdmFyIGNyZWF0ZUN1cnNvciA9IHN0YWNrLmNyZWF0ZUN1cnNvcixcbiAgICAgIHB1c2ggPSBzdGFjay5wdXNoLFxuICAgICAgcG9wID0gc3RhY2sucG9wO1xuXG5cbiAgdmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgICAhKGMgIT09IE5PX0NPTlRFWFQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICByZXR1cm4gcm9vdEluc3RhbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG5cbiAgICAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gICAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAgIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHRocm93LCByZXBsYWNlIGl0LlxuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dFxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHZvaWQgMDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIFJlYWN0RmliZXJMZWdhY3lDb250ZXh0ID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBjcmVhdGVDdXJzb3IgPSBzdGFjay5jcmVhdGVDdXJzb3IsXG4gICAgICBwdXNoID0gc3RhY2sucHVzaCxcbiAgICAgIHBvcCA9IHN0YWNrLnBvcDtcblxuICAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuICAvLyBBIGN1cnNvciB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICB2YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4gIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbiAgLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4gIC8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG4gIHZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuICBmdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gICAgfVxuICAgIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICAgIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgICB9XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsXG4gICAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0pO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gICAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICAgIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAgIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAgICEoaXNGaWJlck1vdW50ZWQoZmliZXIpICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldFVubWFza2VkQ29udGV4dDogZ2V0VW5tYXNrZWRDb250ZXh0LFxuICAgIGNhY2hlQ29udGV4dDogY2FjaGVDb250ZXh0LFxuICAgIGdldE1hc2tlZENvbnRleHQ6IGdldE1hc2tlZENvbnRleHQsXG4gICAgaGFzQ29udGV4dENoYW5nZWQ6IGhhc0NvbnRleHRDaGFuZ2VkLFxuICAgIGlzQ29udGV4dENvbnN1bWVyOiBpc0NvbnRleHRDb25zdW1lcixcbiAgICBpc0NvbnRleHRQcm92aWRlcjogaXNDb250ZXh0UHJvdmlkZXIsXG4gICAgcG9wQ29udGV4dFByb3ZpZGVyOiBwb3BDb250ZXh0UHJvdmlkZXIsXG4gICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0OiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QsXG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdDogcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCxcbiAgICBwcm9jZXNzQ2hpbGRDb250ZXh0OiBwcm9jZXNzQ2hpbGRDb250ZXh0LFxuICAgIHB1c2hDb250ZXh0UHJvdmlkZXI6IHB1c2hDb250ZXh0UHJvdmlkZXIsXG4gICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcjogaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcixcbiAgICBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dDogZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHRcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyTmV3Q29udGV4dCA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgY3JlYXRlQ3Vyc29yID0gc3RhY2suY3JlYXRlQ3Vyc29yLFxuICAgICAgcHVzaCA9IHN0YWNrLnB1c2gsXG4gICAgICBwb3AgPSBzdGFjay5wb3A7XG5cblxuICB2YXIgcHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG4gIHZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgdmFyIGNoYW5nZWRCaXRzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKDApO1xuXG4gIHZhciByZW5kZXJlclNpZ2lsID0gdm9pZCAwO1xuICB7XG4gICAgLy8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG4gICAgcmVuZGVyZXJTaWdpbCA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICAgIHB1c2goY2hhbmdlZEJpdHNDdXJzb3IsIGNvbnRleHQuX2NoYW5nZWRCaXRzLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIHB1c2gocHJvdmlkZXJDdXJzb3IsIHByb3ZpZGVyRmliZXIsIHByb3ZpZGVyRmliZXIpO1xuXG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJvdmlkZXJGaWJlci5wZW5kaW5nUHJvcHMudmFsdWU7XG4gICAgY29udGV4dC5fY2hhbmdlZEJpdHMgPSBwcm92aWRlckZpYmVyLnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgICEoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSBudWxsIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9PT0gcmVuZGVyZXJTaWdpbCkgPyB3YXJuaW5nKGZhbHNlLCAnRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNoYW5nZWRCaXRzQ3Vyc29yLmN1cnJlbnQ7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgICBwb3AocHJvdmlkZXJDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICAgIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG4gICAgcG9wKGNoYW5nZWRCaXRzQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcblxuICAgIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICBjb250ZXh0Ll9jaGFuZ2VkQml0cyA9IGNoYW5nZWRCaXRzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdXNoUHJvdmlkZXI6IHB1c2hQcm92aWRlcixcbiAgICBwb3BQcm92aWRlcjogcG9wUHJvdmlkZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZVN0YWNrID0gW107XG5cbiAgdmFyIGZpYmVyU3RhY2sgPSB2b2lkIDA7XG5cbiAge1xuICAgIGZpYmVyU3RhY2sgPSBbXTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IC0xO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICAgIGluZGV4Kys7XG5cbiAgICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgICB9XG5cbiAgICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCkge1xuICAgIHtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKSB7XG4gICAge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIHZhbHVlU3RhY2subGVuZ3RoID0gMDtcbiAgICAgIGZpYmVyU3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUN1cnNvcjogY3JlYXRlQ3Vyc29yLFxuICAgIGlzRW1wdHk6IGlzRW1wdHksXG4gICAgcG9wOiBwb3AsXG4gICAgcHVzaDogcHVzaCxcbiAgICBjaGVja1RoYXRTdGFja0lzRW1wdHk6IGNoZWNrVGhhdFN0YWNrSXNFbXB0eSxcbiAgICByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXY6IHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldlxuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxudmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHZvaWQgMDtcbnZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB2b2lkIDA7XG52YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSB2b2lkIDA7XG52YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbiAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCBzZXRTdGF0ZSAob3IgZm9yY2VVcGRhdGUpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiB0aGUgJyArICdjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QuJXMnLCBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpYmVyKSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RmliZXJTdGFjaygpO1xuICB2YXIgaG9zdENvbnRleHQgPSBSZWFjdEZpYmVySG9zdENvbnRleHQoY29uZmlnLCBzdGFjayk7XG4gIHZhciBsZWdhY3lDb250ZXh0ID0gUmVhY3RGaWJlckxlZ2FjeUNvbnRleHQoc3RhY2spO1xuICB2YXIgbmV3Q29udGV4dCA9IFJlYWN0RmliZXJOZXdDb250ZXh0KHN0YWNrKTtcbiAgdmFyIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcjtcbiAgdmFyIHBvcFRvcExldmVsTGVnYWN5Q29udGV4dE9iamVjdCA9IGxlZ2FjeUNvbnRleHQucG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0LFxuICAgICAgcG9wTGVnYWN5Q29udGV4dFByb3ZpZGVyID0gbGVnYWN5Q29udGV4dC5wb3BDb250ZXh0UHJvdmlkZXI7XG4gIHZhciBwb3BQcm92aWRlciA9IG5ld0NvbnRleHQucG9wUHJvdmlkZXI7XG5cbiAgdmFyIGh5ZHJhdGlvbkNvbnRleHQgPSBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dChjb25maWcpO1xuXG4gIHZhciBfUmVhY3RGaWJlckJlZ2luV29yayA9IFJlYWN0RmliZXJCZWdpbldvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgbGVnYWN5Q29udGV4dCwgbmV3Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSxcbiAgICAgIGJlZ2luV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21wbGV0ZVdvID0gUmVhY3RGaWJlckNvbXBsZXRlV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSxcbiAgICAgIGNvbXBsZXRlV29yayA9IF9SZWFjdEZpYmVyQ29tcGxldGVXby5jb21wbGV0ZVdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyVW53aW5kV29yayA9IFJlYWN0RmliZXJVbndpbmRXb3JrKGhvc3RDb250ZXh0LCBsZWdhY3lDb250ZXh0LCBuZXdDb250ZXh0LCBzY2hlZHVsZVdvcmssIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkpLFxuICAgICAgdGhyb3dFeGNlcHRpb24gPSBfUmVhY3RGaWJlclVud2luZFdvcmsudGhyb3dFeGNlcHRpb24sXG4gICAgICB1bndpbmRXb3JrID0gX1JlYWN0RmliZXJVbndpbmRXb3JrLnVud2luZFdvcmssXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsgPSBfUmVhY3RGaWJlclVud2luZFdvcmsudW53aW5kSW50ZXJydXB0ZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBSZWFjdEZpYmVyQ29tbWl0V29yayhjb25maWcsIG9uQ29tbWl0UGhhc2VFcnJvciwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkLCByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKSxcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMsXG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb24gPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRFcnJvckxvZ2dpbmcgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RXJyb3JMb2dnaW5nLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9IGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9IGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0O1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdGltZSBpbiBtcy5cblxuICB2YXIgb3JpZ2luYWxTdGFydFRpbWVNcyA9IG5vdygpO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKDApO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lTXMgPSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24gaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMuXG4gIHZhciBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uID0gMDtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG5cbiAgdmFyIGlzUm9vdFJlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgdmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIHZhciBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gdm9pZCAwO1xuICB2YXIgcmVwbGF5VW5pdE9mV29yayA9IHZvaWQgMDtcbiAgdmFyIGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yayA9IHZvaWQgMDtcbiAgdmFyIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSB2b2lkIDA7XG4gIHZhciByZXRocm93T3JpZ2luYWxFcnJvciA9IHZvaWQgMDtcbiAgaWYgKHRydWUgJiYgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2spIHtcbiAgICBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICByZXBsYXlVbml0T2ZXb3JrID0gZnVuY3Rpb24gKGZhaWxlZFVuaXRPZldvcmssIGVycm9yLCBpc0FzeW5jKSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgICAgYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZmFpbGVkVW5pdE9mV29yaywgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyk7XG4gICAgICBzd2l0Y2ggKGZhaWxlZFVuaXRPZldvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbExlZ2FjeUNvbnRleHRPYmplY3QoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BMZWdhY3lDb250ZXh0UHJvdmlkZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgICBwb3BQcm92aWRlcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIFJlcGxheSB0aGUgYmVnaW4gcGhhc2UuXG4gICAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB0cnVlO1xuICAgICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IGVycm9yO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgd29ya0xvb3AsIG51bGwsIGlzQXN5bmMpO1xuICAgICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gICAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBiZWdpbiBwaGFzZSBkaWQgbm90IGZhaWwgdGhlIHNlY29uZCB0aW1lLCBzZXQgdGhpcyBwb2ludGVyXG4gICAgICAgIC8vIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAgICBuZXh0VW5pdE9mV29yayA9IGZhaWxlZFVuaXRPZldvcms7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXRocm93T3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG9yaWdpbmFsUmVwbGF5RXJyb3I7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3RhY2soKSB7XG4gICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gbmV4dFVuaXRPZldvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKGludGVycnVwdGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgICBzdGFjay5jaGVja1RoYXRTdGFja0lzRW1wdHkoKTtcbiAgICB9XG5cbiAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcblxuICAgIGlzUm9vdFJlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgICAgLy8gdXBkYXRlcywgYW5kIGRlbGV0aW9ucy4gVG8gYXZvaWQgbmVlZGluZyB0byBhZGQgYSBjYXNlIGZvciBldmVyeVxuICAgICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgICAvLyBlZmZlY3QgdGFnIGFuZCBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cbiAgICAgIHZhciBwcmltYXJ5RWZmZWN0VGFnID0gZWZmZWN0VGFnICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IERlbGV0aW9uKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdERlbGV0aW9uKG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBjbGVhbnVwIGVmZmVjdHMgeWV0O1xuICAgICAgLy8gVGhpcyB3aWxsIGJlIGRvbmUgYnkgY29tbWl0QWxsTGlmZUN5Y2xlcygpXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50VGltZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpIHtcbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuXG4gICAgICBpZiAod2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMpIHtcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncygpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5leHRFZmZlY3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBFcnJMb2cpIHtcbiAgICAgICAgY29tbWl0RXJyb3JMb2dnaW5nKG5leHRFZmZlY3QsIG9uVW5jYXVnaHRFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gICAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspIHtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICAgIShjb21taXR0ZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuXG4gICAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfVxuXG4gICAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gICAgLy8gSW52b2tlIGluc3RhbmNlcyBvZiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBiZWZvcmUgbXV0YXRpb24uXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBvbkNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgZXJyb3IpO1xuICAgICAgICAvLyBDbGVhbi11cFxuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9kaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY29tbWl0QWxsSG9zdEVmZmVjdHMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIF9kaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgb25Db21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvcjIgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwsIHJvb3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kaWRFcnJvcjIpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBvbkNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVtYWluaW5nVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlXG4gICAgLy8gbmV4dCBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZVxuICAgIC8vIHBhcmVudCBmaWJlci5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgLy8gVGhpcyBmaWJlciBjb21wbGV0ZWQuXG4gICAgICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAge1xuICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCAmJlxuICAgICAgICAvLyBEbyBub3QgYXBwZW5kIGVmZmVjdHMgdG8gcGFyZW50cyBpZiBhIHNpYmxpbmcgZmFpbGVkIHRvIGNvbXBsZXRlXG4gICAgICAgIChyZXR1cm5GaWJlci5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgICAgaXNSb290UmVhZHlGb3JDb21taXQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IGVudGVyaW5nIHRoZSBjb21wbGV0ZSBwaGFzZS4gSWYgdGhpcyBpcyBhIGJvdW5kYXJ5LFxuICAgICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkge1xuICAgICAgICAgIC8vIFJlc3RhcnRpbmcgYW4gZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBzdG9wRmFpbGVkV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgICBfbmV4dC5lZmZlY3RUYWcgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgICAgcmV0dXJuIF9uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBlZmZlY3QgbGlzdC5cbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIHJldHVybkZpYmVyLmVmZmVjdFRhZyB8PSBJbmNvbXBsZXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9IGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgaWYgKGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yaykge1xuICAgICAgICAvLyBDdXJyZW50bHkgcmVwbGF5aW5nIGEgZmFpbGVkIHVuaXQgb2Ygd29yay4gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHJlbmRlciBwaGFzZSBpcyBtZWFudCB0byBiZSBpZGVtcG90ZW50LCBhbmQgaXQgc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgdGhyb3duIGFnYWluLiBTaW5jZSBpdCBkaWRuJ3QsIHJldGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yLCBzb1xuICAgICAgICAvLyBSZWFjdCdzIGludGVybmFsIHN0YWNrIGlzIG5vdCBtaXNhbGlnbmVkLlxuICAgICAgICByZXRocm93T3JpZ2luYWxFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGlzQXN5bmMpIHtcbiAgICBpZiAoIWlzQXN5bmMpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzQXN5bmMpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gICAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lICE9PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgfHwgcm9vdCAhPT0gbmV4dFJvb3QgfHwgbmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgICAgcmVzZXRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICB9XG5cbiAgICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICBkbyB7XG4gICAgICB0cnkge1xuICAgICAgICB3b3JrTG9vcChpc0FzeW5jKTtcbiAgICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICAgIGlmIChuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGZhaWxlZFVuaXRPZldvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgICAgICByZXBsYXlVbml0T2ZXb3JrKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc0FzeW5jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2VGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlclsncmV0dXJuJ107XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3QuIFRoZSByb290IGNvdWxkIGNhcHR1cmUgaXRzIG93biBlcnJvcnMuIEhvd2V2ZXIsXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCBlcnJvcnMgYmVmb3JlIG9yIGFmdGVyIHdlIHB1c2hlZCB0aGUgaG9zdFxuICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaW5mb3JtYXRpb24gaXMgbmVlZGVkIHRvIGF2b2lkIGEgc3RhY2sgbWlzbWF0Y2guXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBub3Qgc3VyZSwgdHJlYXQgdGhpcyBhcyBhIGZhdGFsIGVycm9yLiBXZSBjb3VsZCB0cmFja1xuICAgICAgICAgIC8vIHdoaWNoIHBoYXNlIGl0IGZhaWxzIGluLCBidXQgZG9lc24ndCBzZWVtIHdvcnRoIGl0LiBBdCBsZWFzdFxuICAgICAgICAgIC8vIGZvciBub3cuXG4gICAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFeGNlcHRpb24ocmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVVbml0T2ZXb3JrKHNvdXJjZUZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgLy8gV2UncmUgZG9uZSBwZXJmb3JtaW5nIHdvcmsuIFRpbWUgdG8gY2xlYW4gdXAuXG4gICAgdmFyIGRpZENvbXBsZXRlUm9vdCA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gICAgLy8gWWllbGQgYmFjayB0byBtYWluIHRocmVhZC5cbiAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICAgIC8vIFRoZXJlIHdhcyBhIGZhdGFsIGVycm9yLlxuICAgICAge1xuICAgICAgICBzdGFjay5yZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICBpZiAoaXNSb290UmVhZHlGb3JDb21taXQpIHtcbiAgICAgICAgZGlkQ29tcGxldGVSb290ID0gdHJ1ZTtcbiAgICAgICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgICAgIC8vIFRoZSByb290IHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQuIEl0J3MgcmVhZHkgZm9yIGNvbW1pdC5cbiAgICAgICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICAgIHJldHVybiBmaW5pc2hlZFdvcms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcm9vdCBkaWQgbm90IGNvbXBsZXRlLlxuICAgICAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpO1xuICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwaXJlZCB3b3JrIHNob3VsZCBoYXZlIGNvbXBsZXRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgICAgLy8gVGhlcmUncyBtb3JlIHdvcmsgdG8gZG8sIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWUuIFlpZWxkIGJhY2sgdG9cbiAgICAgIC8vIHRoZSByZW5kZXJlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FwdHVyZShzb3VyY2VGaWJlciwgYm91bmRhcnlGaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogV2Ugb25seSBzdXBwb3J0IGRpc3BhdGNoaW5nIGVycm9ycy5cbiAgICB2YXIgY2FwdHVyZWRWYWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiBudWxsLFxuICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZWRWYWx1ZTogY2FwdHVyZWRWYWx1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihib3VuZGFyeUZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhib3VuZGFyeUZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaChzb3VyY2VGaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISghaXNXb3JraW5nIHx8IGlzQ29tbWl0dGluZykgPyBpbnZhcmlhbnQoZmFsc2UsICdkaXNwYXRjaDogQ2Fubm90IGRpc3BhdGNoIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIGFycmF5c1xuXG4gICAgdmFyIGZpYmVyID0gc291cmNlRmliZXJbJ3JldHVybiddO1xuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVDYXB0dXJlKHNvdXJjZUZpYmVyLCBmaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBhc3luYyBib3VuZGFyaWVzXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgc2NoZWR1bGVDYXB0dXJlKHNvdXJjZUZpYmVyLCBmaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgICAgc2NoZWR1bGVDYXB0dXJlKHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgdmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGVycm9yKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGZpYmVyLCBlcnJvciwgU3luYyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IDUwMDA7XG4gICAgdmFyIGJ1Y2tldFNpemVNcyA9IDI1MDtcbiAgICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25NcywgYnVja2V0U2l6ZU1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVJbnRlcmFjdGl2ZUV4cGlyYXRpb24oY3VycmVudFRpbWUpIHtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gdm9pZCAwO1xuICAgIC8vIFdlIGludGVudGlvbmFsbHkgc2V0IGEgaGlnaGVyIGV4cGlyYXRpb24gdGltZSBmb3IgaW50ZXJhY3RpdmUgdXBkYXRlcyBpblxuICAgIC8vIGRldiB0aGFuIGluIHByb2R1Y3Rpb24uXG4gICAgLy8gSWYgdGhlIG1haW4gdGhyZWFkIGlzIGJlaW5nIGJsb2NrZWQgc28gbG9uZyB0aGF0IHlvdSBoaXQgdGhlIGV4cGlyYXRpb24sXG4gICAgLy8gaXQncyBhIHByb2JsZW0gdGhhdCBjb3VsZCBiZSBzb2x2ZWQgd2l0aCBiZXR0ZXIgc2NoZWR1bGluZy5cbiAgICAvLyBQZW9wbGUgd2lsbCBiZSBtb3JlIGxpa2VseSB0byBub3RpY2UgdGhpcyBhbmQgZml4IGl0IHdpdGggdGhlIGxvbmdcbiAgICAvLyBleHBpcmF0aW9uIHRpbWUgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBvcHQgZm9yIGJldHRlciBVWCBhdCB0aGUgcmlzayBvZiBtYXNraW5nIHNjaGVkdWxpbmdcbiAgICAvLyBwcm9ibGVtcywgYnkgZXhwaXJpbmcgZmFzdC5cbiAgICB7XG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH41MDBtcy4gNjAwbXMgbWF4LlxuICAgICAgZXhwaXJhdGlvbk1zID0gNTAwO1xuICAgIH1cbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMTAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIHVuaXF1ZSBhc3luYyBleHBpcmF0aW9uIHRpbWUuXG4gIGZ1bmN0aW9uIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciByZXN1bHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocmVzdWx0IDw9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24pIHtcbiAgICAgIC8vIFNpbmNlIHdlIGFzc3VtZSB0aGUgY3VycmVudCB0aW1lIG1vbm90b25pY2FsbHkgaW5jcmVhc2VzLCB3ZSBvbmx5IGhpdFxuICAgICAgLy8gdGhpcyBicmFuY2ggd2hlbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIGlzIGZpcmVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAvLyB3aXRoaW4gYSAyMDBtcyB3aW5kb3cgKG9yIHdoYXRldmVyIHRoZSBhc3luYyBidWNrZXQgc2l6ZSBpcykuXG4gICAgICByZXN1bHQgPSBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uICsgMTtcbiAgICB9XG4gICAgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IHJlc3VsdDtcbiAgICByZXR1cm4gbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gICAgaWYgKGV4cGlyYXRpb25Db250ZXh0ICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEFuIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0O1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICB9IGVsc2UgaWYgKGlzV29ya2luZykge1xuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICAvLyBVcGRhdGVzIHRoYXQgb2NjdXIgZHVyaW5nIHRoZSBjb21taXQgcGhhc2Ugc2hvdWxkIGhhdmUgc3luYyBwcmlvcml0eVxuICAgICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgICAvLyB0aGUgd29yayB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQsIGFuZCB3ZSdyZSBub3QgY3VycmVudGx5XG4gICAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAoZmliZXIubW9kZSAmIEFzeW5jTW9kZSkge1xuICAgICAgICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJhY3RpdmUgdXBkYXRlXG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgICB2YXIgX2N1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihfY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB1cGRhdGUuIEtlZXAgdHJhY2sgb2YgdGhlIGxvd2VzdCBwZW5kaW5nXG4gICAgICAvLyBpbnRlcmFjdGl2ZSBleHBpcmF0aW9uIHRpbWUuIFRoaXMgYWxsb3dzIHVzIHRvIHN5bmNocm9ub3VzbHkgZmx1c2hcbiAgICAgIC8vIGFsbCBpbnRlcmFjdGl2ZSB1cGRhdGVzIHdoZW4gbmVlZGVkLlxuICAgICAgaWYgKGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPiBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBleHBpcmF0aW9uVGltZSwgaXNFcnJvclJlY292ZXJ5KSB7XG4gICAgcmVjb3JkU2NoZWR1bGVVcGRhdGUoKTtcblxuICAgIHtcbiAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyhpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSBlYWNoIG5vZGUnc1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5vZGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbm9kZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKCFpc1dvcmtpbmcgJiYgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgICAgICAgcmVzZXRTdGFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZSwgd2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHJvb3RcbiAgICAgICAgICAvLyBmb3IgYW4gdXBkYXRlLCBiZWNhdXNlIHdlJ2xsIGRvIGl0IGJlZm9yZSB3ZSBleGl0Li4uXG4gICAgICAgICAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmcgfHxcbiAgICAgICAgICAvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGRpZmZlcmVudCByb290IHRoYW4gdGhlIG9uZSB3ZSdyZSByZW5kZXJpbmcuXG4gICAgICAgICAgbmV4dFJvb3QgIT09IHJvb3QpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGlzIHJvb3QgdG8gdGhlIHJvb3Qgc2NoZWR1bGUuXG4gICAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZU1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtb3N0UmVjZW50Q3VycmVudFRpbWVNcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN5bmNVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IFN5bmM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBpcyB3cml0dGVuIGFzIGlmIGl0IGhhcyBiZWVuIGxpZnRlZCB0byB0aGVcbiAgLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgdmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gIHZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbiAgdmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBjYWxsYmFja0lEID0gLTE7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgdmFyIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gIHZhciBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICB2YXIgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICB2YXIgZGVhZGxpbmUgPSBudWxsO1xuXG4gIHZhciBpc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB2YXIgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB2YXIgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IGZhbHNlO1xuXG4gIHZhciBjb21wbGV0ZWRCYXRjaGVzID0gbnVsbDtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lID4gY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlcXVlc3QgY2FsbGJhY2sgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLiBEb24ndCBzdGFydCBhIG5ldyBvbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY3VycmVudE1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBhZGRSb290VG9TY2hlZHVsZShyb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogR2V0IHJpZCBvZiBTeW5jIGFuZCB1c2UgY3VycmVudCB0aW1lP1xuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gU3luYykge1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgICAgLy8gVGhpcyByb290IG5vIGxvbmdlciBoYXMgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlci5cblxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgaXMgcmVkdWRhbnQsIGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBicmFuY2hcbiAgICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgICAvLyBmcm9tIHRoZSBsb29wIHJpZ2h0IGFmdGVyLlxuICAgICAgICAgICEocHJldmlvdXNTY2hlZHVsZWRSb290ICE9PSBudWxsICYmIGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGEgcHJldmlvdXMgYW5kIGxhc3Qgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGZpcnN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChoaWdoZXN0UHJpb3JpdHlXb3JrID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBoaWdoZXN0UHJpb3JpdHlXb3JrKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5V29yayA9IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgICAgcm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gICAgLy8gdXBkYXRlLiBUbyBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AsIGluY3JlbWVudCB0aGUgbmVzdGVkIHVwZGF0ZSBjb3VudC5cbiAgICB2YXIgcHJldmlvdXNGbHVzaGVkUm9vdCA9IG5leHRGbHVzaGVkUm9vdDtcbiAgICBpZiAocHJldmlvdXNGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBwcmV2aW91c0ZsdXNoZWRSb290ID09PSBoaWdoZXN0UHJpb3JpdHlSb290ICYmIGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIHRydWUsIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1TeW5jV29yaygpIHtcbiAgICBwZXJmb3JtV29yayhTeW5jLCBmYWxzZSwgbnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtV29yayhtaW5FeHBpcmF0aW9uVGltZSwgaXNBc3luYywgZGwpIHtcbiAgICBkZWFkbGluZSA9IGRsO1xuXG4gICAgLy8gS2VlcCB3b3JraW5nIG9uIHJvb3RzIHVudGlsIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrLCBvciB1bnRpbCB0aGUgd2UgcmVhY2hcbiAgICAvLyB0aGUgZGVhZGxpbmUuXG4gICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcblxuICAgIGlmIChlbmFibGVVc2VyVGltaW5nQVBJICYmIGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXhwaXJlID0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVUb01zKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHdoaWxlIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG1pbkV4cGlyYXRpb25UaW1lID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpICYmICghZGVhZGxpbmVEaWRFeHBpcmUgfHwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSwgIWRlYWRsaW5lRGlkRXhwaXJlKTtcbiAgICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbWluRXhwaXJhdGlvblRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgY2FsbGJhY2tJRCA9IC0xO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24obmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG5cbiAgICBmaW5pc2hSZW5kZXJpbmcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJykgOiB2b2lkIDA7XG4gICAgLy8gUGVyZm9ybSB3b3JrIG9uIHJvb3QgYXMgaWYgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZSBpcyB0aGUgY3VycmVudCB0aW1lLlxuICAgIC8vIFRoaXMgaGFzIHRoZSBlZmZlY3Qgb2Ygc3luY2hyb25vdXNseSBmbHVzaGluZyBhbGwgd29yayB1cCB0byBhbmRcbiAgICAvLyBpbmNsdWRpbmcgdGhlIGdpdmVuIHRpbWUuXG4gICAgbmV4dEZsdXNoZWRSb290ID0gcm9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgICAvLyBGbHVzaCBhbnkgc3luYyB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZCBieSBsaWZlY3ljbGVzXG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgZmluaXNoUmVuZGVyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmcoKSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGNvbXBsZXRlZEJhdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIHZhciBiYXRjaGVzID0gY29tcGxldGVkQmF0Y2hlcztcbiAgICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmF0Y2guX29uQ29tcGxldGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gdW5oYW5kbGVkRXJyb3I7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzQXN5bmMpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICBpZiAoIWlzQXN5bmMpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgICAgY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBiYXRjaCB0aGF0IG1hdGNoZXMgdGhpcyBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGZpcnN0QmF0Y2ggPSByb290LmZpcnN0QmF0Y2g7XG4gICAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGlmIChjb21wbGV0ZWRCYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBbZmlyc3RCYXRjaF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZWRCYXRjaGVzLnB1c2goZmlyc3RCYXRjaCk7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RCYXRjaC5fZGVmZXIpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGJsb2NrZWQgZnJvbSBjb21taXR0aW5nIGJ5IGEgYmF0Y2guIFVuc2NoZWR1bGUgaXQgdW50aWxcbiAgICAgICAgLy8gd2UgcmVjZWl2ZSBhbm90aGVyIHVwZGF0ZS5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21taXQgdGhlIHJvb3QuXG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAgIC8vIGR1cmluZyBhIHRpbWVvdXQuIFRoaXMgcGF0aCBpcyBvbmx5IGhpdCBmb3Igbm9uLWV4cGlyZWQgd29yay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oYSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbihhKTtcbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCB3aXRoaW5cbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IGNhbm5vdCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4nKSA6IHZvaWQgMDtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuLCBhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKSB7XG4gICAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMsIHN5bmNocm9ub3VzbHkgZmx1c2ggdGhlbS5cbiAgICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAgIC8vIHRoZSBwcmV2aW91cyBldmVudCBtYXkgaW5mbHVlbmNlIHdoaWNoIGhhbmRsZXJzIGFyZSBjYWxsZWQgZHVyaW5nXG4gICAgLy8gdGhpcyBldmVudC5cbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZyAmJiBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICAgIHBlcmZvcm1Xb3JrKGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lLCBmYWxzZSwgbnVsbCk7XG4gICAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gdHJ1ZTtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzKCkge1xuICAgIGlmICghaXNSZW5kZXJpbmcgJiYgbG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgICBwZXJmb3JtV29yayhsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgZmFsc2UsIG51bGwpO1xuICAgICAgbG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hDb250cm9sbGVkKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgZmFsc2UsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVjYWxjdWxhdGVDdXJyZW50VGltZTogcmVjYWxjdWxhdGVDdXJyZW50VGltZSxcbiAgICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgIHNjaGVkdWxlV29yazogc2NoZWR1bGVXb3JrLFxuICAgIHJlcXVlc3RXb3JrOiByZXF1ZXN0V29yayxcbiAgICBmbHVzaFJvb3Q6IGZsdXNoUm9vdCxcbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICBmbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlcyxcbiAgICBzeW5jVXBkYXRlczogc3luY1VwZGF0ZXMsXG4gICAgaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gICAgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM6IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuICAgIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb246IGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24sXG4gICAgbGVnYWN5Q29udGV4dDogbGVnYWN5Q29udGV4dFxuICB9O1xufTtcblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5yZWNhbGN1bGF0ZUN1cnJlbnRUaW1lLFxuICAgICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgICBzY2hlZHVsZVdvcmsgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zY2hlZHVsZVdvcmssXG4gICAgICByZXF1ZXN0V29yayA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnJlcXVlc3RXb3JrLFxuICAgICAgZmx1c2hSb290ID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hSb290LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZmx1c2hDb250cm9sbGVkID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hDb250cm9sbGVkLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzLFxuICAgICAgc3luY1VwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zeW5jVXBkYXRlcyxcbiAgICAgIGludGVyYWN0aXZlVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmludGVyYWN0aXZlVXBkYXRlcyxcbiAgICAgIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMsXG4gICAgICBsZWdhY3lDb250ZXh0ID0gX1JlYWN0RmliZXJTY2hlZHVsZXIubGVnYWN5Q29udGV4dDtcblxuICB2YXIgZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQgPSBsZWdhY3lDb250ZXh0LmZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0LFxuICAgICAgaXNDb250ZXh0UHJvdmlkZXIgPSBsZWdhY3lDb250ZXh0LmlzQ29udGV4dFByb3ZpZGVyLFxuICAgICAgcHJvY2Vzc0NoaWxkQ29udGV4dCA9IGxlZ2FjeUNvbnRleHQucHJvY2Vzc0NoaWxkQ29udGV4dDtcblxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICAgIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gICAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjdXJyZW50VGltZSwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gICAge1xuICAgICAgaWYgKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPT09ICdyZW5kZXInICYmIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuICAgICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAge1xuICAgICAgIShjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBwYXJ0aWFsU3RhdGU6IHsgZWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVkVmFsdWU6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuXG4gICAgcmV0dXJuIGV4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY3VycmVudFRpbWUsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICB7XG4gICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjdXJyZW50VGltZSwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVySW5mbywgaXNBc3luYywgaHlkcmF0ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY3VycmVudFRpbWUsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cblxuICAgIGZsdXNoUm9vdDogZmx1c2hSb290LFxuXG4gICAgcmVxdWVzdFdvcms6IHJlcXVlc3RXb3JrLFxuXG4gICAgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbjogY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbixcblxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlcyxcblxuICAgIHN5bmNVcGRhdGVzOiBzeW5jVXBkYXRlcyxcblxuICAgIGludGVyYWN0aXZlVXBkYXRlczogaW50ZXJhY3RpdmVVcGRhdGVzLFxuXG4gICAgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM6IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzLFxuXG4gICAgZmx1c2hDb250cm9sbGVkOiBmbHVzaENvbnRyb2xsZWQsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgZmluZEhvc3RJbnN0YW5jZTogZmluZEhvc3RJbnN0YW5jZSxcblxuICAgIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgaW5qZWN0SW50b0RldlRvb2xzOiBmdW5jdGlvbiAoZGV2VG9vbHNDb25maWcpIHtcbiAgICAgIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKF9hc3NpZ24oe30sIGRldlRvb2xzQ29uZmlnLCB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGlmICghZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIE1pZ2h0IG5vdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDFcbn0pO1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMyA9ICggUmVhY3RGaWJlclJlY29uY2lsZXIkMiAmJiBSZWFjdEZpYmVyUmVjb25jaWxlciQxICkgfHwgUmVhY3RGaWJlclJlY29uY2lsZXIkMjtcblxuLy8gVE9ETzogYnVuZGxlIEZsb3cgdHlwZXMgd2l0aCB0aGUgcGFja2FnZS5cblxuXG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0UmVjb25jaWxlciA9IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA/IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDM7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLFxuLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjMuMic7XG5cbi8vIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBzdG9yaW5nIHRoZSB0aW1lIGZvciB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lLCB0aGVuXG4vLyBzY2hlZHVsaW5nIGEgcG9zdE1lc3NhZ2Ugd2hpY2ggZ2V0cyBzY2hlZHVsZWQgYWZ0ZXIgcGFpbnQuIFdpdGhpbiB0aGVcbi8vIHBvc3RNZXNzYWdlIGhhbmRsZXIgZG8gYXMgbXVjaCB3b3JrIGFzIHBvc3NpYmxlIHVudGlsIHRpbWUgKyBmcmFtZSByYXRlLlxuLy8gQnkgc2VwYXJhdGluZyB0aGUgaWRsZSBjYWxsIGludG8gYSBzZXBhcmF0ZSBldmVudCB0aWNrIHdlIGVuc3VyZSB0aGF0XG4vLyBsYXlvdXQsIHBhaW50IGFuZCBvdGhlciBicm93c2VyIHdvcmsgaXMgY291bnRlZCBhZ2FpbnN0IHRoZSBhdmFpbGFibGUgdGltZS5cbi8vIFRoZSBmcmFtZSByYXRlIGlzIGR5bmFtaWNhbGx5IGFkanVzdGVkLlxuXG57XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIG5vdyA9IHZvaWQgMDtcbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG4vLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byBjYW5jZWwsIGJlY2F1c2UgRmliZXIgZG9lc24ndCBhdG0uXG52YXIgcklDID0gdm9pZCAwO1xudmFyIGNJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGNJQyA9IGZ1bmN0aW9uICh0aW1lb3V0SUQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfTtcbn0gZWxzZSBpZiAoYWx3YXlzVXNlUmVxdWVzdElkbGVDYWxsYmFja1BvbHlmaWxsIHx8IHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdCA9IHZvaWQgMDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAvLyBXZSBjYW4gc2lsZW50bHkgc2tpcCB0aGVtIGJlY2F1c2UgaW52YWxpZCBET00gbmVzdGluZyB3YXJuaW5nXG4gIC8vIGNhdGNoZXMgdGhlc2UgY2FzZXMgaW4gRmliZXIuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICB7XG4gICAgaWYgKHByb3BzLnNlbGVjdGVkICE9IG51bGwgJiYgIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMoKTtcbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpIHtcbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdGlvbnMgPSBub2RlLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWVzID0gcHJvcFZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJCcgKyBzZWxlY3RlZFZhbHVlc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbX2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgdmFyIF9zZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgdmFyIGRlZmF1bHRTZWxlY3RlZCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgd2FzTXVsdGlwbGU6ICEhcHJvcHMubXVsdGlwbGVcbiAgfTtcblxuICB7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG5cbiAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZVxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSk7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiB2b2lkIDA7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gIHZhciB0ZXh0Q29udGVudCA9IG5vZGUudGV4dENvbnRlbnQ7XG5cbiAgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG4gIGlmICh0ZXh0Q29udGVudCA9PT0gbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgIG5vZGUudmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG52YXIgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG52YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSQxLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07XG5cbi8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxuICAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcblxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLiBGb3IgdGV4dCB1cGRhdGVzLCBpdCdzIGZhc3RlclxuICogdG8gc2V0IHRoZSBgbm9kZVZhbHVlYCBvZiB0aGUgVGV4dCBub2RlIGRpcmVjdGx5IGluc3RlYWQgb2YgdXNpbmdcbiAqIGAudGV4dENvbnRlbnRgIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBleGlzdGluZyBub2RlIGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgIShwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJXMnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcblxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICAnaW4nOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICAndHlwZW9mJzogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIGNvcnJlY3ROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG52YXIgd2FybmVkVW5rbm93blRhZ3MgPSB2b2lkIDA7XG52YXIgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nID0gdm9pZCAwO1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IHZvaWQgMDtcbnZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSB2b2lkIDA7XG52YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMgPSB2b2lkIDA7XG52YXIgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gdm9pZCAwO1xuXG52YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gdm9pZCAwO1xudmFyIG5vcm1hbGl6ZUhUTUwgPSB2b2lkIDA7XG5cbntcbiAgZ2V0U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDM7XG5cbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZVxuICB9O1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0KSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1RleHQgY29udGVudCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6IFwiJXNcIiBDbGllbnQ6IFwiJXNcIicsIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LCBub3JtYWxpemVkQ2xpZW50VGV4dCk7XG4gIH07XG5cbiAgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09PSBmYWxzZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lciwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3AsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gdm9pZCAwO1xuXG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpO1xuICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgIShpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCB0eXBlID09PSB0eXBlLnRvTG93ZXJDYXNlKCkpID8gd2FybmluZyhmYWxzZSwgJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCB0eXBlKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRUeXBlcykge1xuICAgICAgICBpZiAobWVkaWFFdmVudFR5cGVzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRUeXBlc1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzID0gdm9pZCAwO1xuICB2YXIgbmV4dFByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5ID0gdm9pZCAwO1xuICB2YXIgc3R5bGVOYW1lID0gdm9pZCAwO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG4gIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuXG4gIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRUeXBlcykge1xuICAgICAgICBpZiAobWVkaWFFdmVudFR5cGVzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRUeXBlc1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIGV4dHJhQXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgd2hpdGVsaXN0ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IHVzZSB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMDY3Ni5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRydWUgJiZcbiAgICAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhwcm9wS2V5KTtcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSAmJiAhc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgICAgICB2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG51bGwgJiYgc3RhbmRhcmROYW1lICE9PSBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIC8vIElmIGFuIFNWRyBwcm9wIGlzIHN1cHBsaWVkIHdpdGggYmFkIGNhc2luZywgaXQgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4gICAgICAgICAgICAgIC8vIChhbmQgd291bGQgYmUgaW5jb3JyZWN0bHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCkuXG4gICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIGFscmVhZHkgd2FybiBhYm91dCBiYWQgY2FzaW5nIGVsc2V3aGVyZS5cbiAgICAgICAgICAgICAgLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMVxufSk7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyQxID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICAhKGNoaWxkVGFnID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpIDogdm9pZCAwO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyQxID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG4vLyBUT0RPOiBUaGlzIHR5cGUgaXMgc2hhcmVkIGJldHdlZW4gdGhlIHJlY29uY2lsZXIgYW5kIFJlYWN0RE9NLCBidXQgd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgb3V0IHRvIHRoZSByZW5kZXJlci5cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSB2b2lkIDA7XG52YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IHZvaWQgMDtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSBmYWxzZTtcblxue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxuXG4gIHRvcExldmVsVXBkYXRlV2FybmluZ3MgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyICYmIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaG9zdEluc3RhbmNlID0gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuX2ludGVybmFsUm9vdC5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgIShob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgISghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJykgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcbiAgfTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAhKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuaW5qZWN0aW9uJDIuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50KTtcblxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gUmVhY3RCYXRjaChyb290KSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IERPTVJlbmRlcmVyLmNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKTtcbiAgdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICB0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX2RlZmVyID0gdHJ1ZTtcbn1cblJlYWN0QmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAhdGhpcy5fZGVmZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5yZW5kZXI6IENhbm5vdCByZW5kZXIgYSBiYXRjaCB0aGF0IGFscmVhZHkgY29tbWl0dGVkLicpIDogdm9pZCAwO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZhciBpbnRlcm5hbFJvb3QgPSB0aGlzLl9yb290Ll9pbnRlcm5hbFJvb3Q7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShjaGlsZHJlbiwgaW50ZXJuYWxSb290LCBudWxsLCBleHBpcmF0aW9uVGltZSwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgaWYgKHRoaXMuX2RpZENvbXBsZXRlKSB7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21wbGV0ZSk7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5fcm9vdC5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICAhKHRoaXMuX2RlZmVyICYmIGZpcnN0QmF0Y2ggIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2guY29tbWl0OiBDYW5ub3QgY29tbWl0IGEgYmF0Y2ggbXVsdGlwbGUgdGltZXMuJykgOiB2b2lkIDA7XG5cbiAgaWYgKCF0aGlzLl9oYXNDaGlsZHJlbikge1xuICAgIC8vIFRoaXMgYmF0Y2ggaXMgZW1wdHkuIFJldHVybi5cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuXG4gIC8vIEVuc3VyZSB0aGlzIGlzIHRoZSBmaXJzdCBiYXRjaCBpbiB0aGUgbGlzdC5cbiAgaWYgKGZpcnN0QmF0Y2ggIT09IHRoaXMpIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIG5vdCB0aGUgZWFybGllc3QgYmF0Y2guIFdlIG5lZWQgdG8gbW92ZSBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gVXBkYXRlIGl0cyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgZWFybGllc3RcbiAgICAvLyBiYXRjaCwgc28gdGhhdCB3ZSBjYW4gZmx1c2ggaXQgd2l0aG91dCBmbHVzaGluZyB0aGUgb3RoZXIgYmF0Y2hlcy5cbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZTtcbiAgICAgIC8vIFJlbmRlcmluZyB0aGlzIGJhdGNoIGFnYWluIGVuc3VyZXMgaXRzIGNoaWxkcmVuIHdpbGwgYmUgdGhlIGZpbmFsIHN0YXRlXG4gICAgICAvLyB3aGVuIHdlIGZsdXNoICh1cGRhdGVzIGFyZSBwcm9jZXNzZWQgaW4gaW5zZXJ0aW9uIG9yZGVyOiBsYXN0XG4gICAgICAvLyB1cGRhdGUgd2lucykuXG4gICAgICAvLyBUT0RPOiBUaGlzIGZvcmNlcyBhIHJlc3RhcnQuIFNob3VsZCB3ZSBwcmludCBhIHdhcm5pbmc/XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLl9jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICAgIHZhciBwcmV2aW91cyA9IG51bGw7XG4gICAgdmFyIGJhdGNoID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoYmF0Y2ggIT09IHRoaXMpIHtcbiAgICAgIHByZXZpb3VzID0gYmF0Y2g7XG4gICAgICBiYXRjaCA9IGJhdGNoLl9uZXh0O1xuICAgIH1cbiAgICAhKHByZXZpb3VzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLmNvbW1pdDogQ2Fubm90IGNvbW1pdCBhIGJhdGNoIG11bHRpcGxlIHRpbWVzLicpIDogdm9pZCAwO1xuICAgIHByZXZpb3VzLl9uZXh0ID0gYmF0Y2guX25leHQ7XG5cbiAgICAvLyBBZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIHRoaXMuX25leHQgPSBmaXJzdEJhdGNoO1xuICAgIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IHRoaXM7XG4gIH1cblxuICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCB0aGUgd29yayB1cCB0byB0aGlzIGJhdGNoJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICBET01SZW5kZXJlci5mbHVzaFJvb3QoaW50ZXJuYWxSb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgLy8gUG9wIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICB2YXIgbmV4dCA9IHRoaXMuX25leHQ7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2ggPSBuZXh0O1xuXG4gIC8vIEFwcGVuZCB0aGUgbmV4dCBlYXJsaWVzdCBiYXRjaCdzIGNoaWxkcmVuIHRvIHRoZSB1cGRhdGUgcXVldWUuXG4gIGlmIChmaXJzdEJhdGNoICE9PSBudWxsICYmIGZpcnN0QmF0Y2guX2hhc0NoaWxkcmVuKSB7XG4gICAgZmlyc3RCYXRjaC5yZW5kZXIoZmlyc3RCYXRjaC5fY2hpbGRyZW4pO1xuICB9XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuX29uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9kaWRDb21wbGV0ZSA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICBfY2FsbGJhY2soKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RXb3JrKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21taXQgPSBmYWxzZTtcbiAgLy8gVE9ETzogQXZvaWQgbmVlZCB0byBiaW5kIGJ5IHJlcGxhY2luZyBjYWxsYmFja3MgaW4gdGhlIHVwZGF0ZSBxdWV1ZSB3aXRoXG4gIC8vIGxpc3Qgb2YgV29yayBvYmplY3RzLlxuICB0aGlzLl9vbkNvbW1pdCA9IHRoaXMuX29uQ29tbWl0LmJpbmQodGhpcyk7XG59XG5SZWFjdFdvcmsucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25Db21taXQpIHtcbiAgaWYgKHRoaXMuX2RpZENvbW1pdCkge1xuICAgIG9uQ29tbWl0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBjYWxsYmFja3MucHVzaChvbkNvbW1pdCk7XG59O1xuUmVhY3RXb3JrLnByb3RvdHlwZS5fb25Db21taXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tbWl0ID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUT0RPOiBFcnJvciBoYW5kbGluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NhbGxiYWNrMiA9IGNhbGxiYWNrc1tpXTtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2syID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjazIpIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjazIoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaXNBc3luYywgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGlzQXN5bmMsIGh5ZHJhdGUpO1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhdGNoID0gbmV3IFJlYWN0QmF0Y2godGhpcyk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGJhdGNoLl9leHBpcmF0aW9uVGltZTtcblxuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCA9PT0gbnVsbCkge1xuICAgIGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gYmF0Y2g7XG4gICAgYmF0Y2guX25leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIEluc2VydCBzb3J0ZWQgYnkgZXhwaXJhdGlvbiB0aW1lIHRoZW4gaW5zZXJ0aW9uIG9yZGVyXG4gICAgdmFyIGluc2VydEFmdGVyID0gbnVsbDtcbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlICE9PSBudWxsICYmIGluc2VydEJlZm9yZS5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGluc2VydEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLl9uZXh0O1xuICAgIH1cbiAgICBiYXRjaC5fbmV4dCA9IGluc2VydEJlZm9yZTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgIGluc2VydEFmdGVyLl9uZXh0ID0gYmF0Y2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIERPTVJlbmRlcmVyID0gcmVhY3RSZWNvbmNpbGVyKHtcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB2YXIgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICB7XG4gICAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICAgIHR5cGUgPSBjb250YWluZXIudGFnTmFtZTtcbiAgICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgfSxcbiAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogZnVuY3Rpb24gKHBhcmVudEhvc3RDb250ZXh0LCB0eXBlKSB7XG4gICAge1xuICAgICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgICB2YXIgX25hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbzIgPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IF9uYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbzIgfTtcbiAgICB9XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHJldHVybiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpO1xuICB9LFxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuICBwcmVwYXJlRm9yQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgICBzZXRFbmFibGVkKGZhbHNlKTtcbiAgfSxcbiAgcmVzZXRBZnRlckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB7XG4gICAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMSh0eXBlLCBudWxsLCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgIH1cbiAgICB2YXIgZG9tRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICByZXR1cm4gZG9tRWxlbWVudDtcbiAgfSxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICByZXR1cm4gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gIH0sXG4gIHByZXBhcmVVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICB9LFxuICBzaG91bGRTZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiYgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiAhIXByb3BzLmhpZGRlbjtcbiAgfSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gICAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9LFxuXG5cbiAgbm93OiBub3csXG5cbiAgbXV0YXRpb246IHtcbiAgICBjb21taXRNb3VudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbiAgICAgIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAgICAgLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4gICAgICAvLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbiAgICAgIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgICAgIC8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbiAgICAgIGlmIChzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIG5ld1Byb3BzKSkge1xuICAgICAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21taXRVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvcHMgaGFuZGxlIHNvIHRoYXQgd2Uga25vdyB3aGljaCBwcm9wcyBhcmUgdGhlIG9uZXMgd2l0aFxuICAgICAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gICAgICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgRE9NIG5vZGUuXG4gICAgICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSxcbiAgICByZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xuICAgIH0sXG4gICAgY29tbWl0VGV4dFVwZGF0ZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGh5ZHJhdGlvbjoge1xuICAgIGNhbkh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSAnJyB8fCBpbnN0YW5jZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBub2RlID0gaW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSkge1xuICAgICAgdmFyIG5leHQgPSBwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuICAgIGh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpO1xuICAgICAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gICAgICAvLyBnZXQgYXR0YWNoZWQuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgfSxcbiAgICBoeWRyYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpO1xuICAgICAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6IHJJQyxcbiAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjazogY0lDXG59KTtcblxuaW5qZWN0aW9uJDMuaW5qZWN0UmVuZGVyZXIoRE9NUmVuZGVyZXIpO1xuXG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKSB7XG4gIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cbiAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHZhciByb290U2libGluZyA9IHZvaWQgMDtcbiAgICB3aGlsZSAocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghd2FybmVkICYmIHJvb3RTaWJsaW5nLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdFNpYmxpbmcuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKSB7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKHNob3VsZEh5ZHJhdGUgJiYgIWZvcmNlSHlkcmF0ZSAmJiAhd2FybmVkQWJvdXRIeWRyYXRlQVBJKSB7XG4gICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgIH1cbiAgfVxuICAvLyBMZWdhY3kgcm9vdHMgYXJlIG5vdCBhc3luYyBieSBkZWZhdWx0LlxuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIGlzQXN5bmMsIHNob3VsZEh5ZHJhdGUpO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgLy8gVE9ETzogRW5zdXJlIGFsbCBlbnRyeSBwb2ludHMgY29udGFpbiB0aGlzIGNoZWNrXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBUT0RPOiBXaXRob3V0IGBhbnlgIHR5cGUsIEZsb3cgc2F5cyBcIlByb3BlcnR5IGNhbm5vdCBiZSBhY2Nlc3NlZCBvbiBhbnlcbiAgLy8gbWVtYmVyIG9mIGludGVyc2VjdGlvbiB0eXBlLlwiIFdoeXl5eXl5LlxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICBpZiAoIXJvb3QpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICByb290LmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xuICAgICAgICBfb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIFVwZGF0ZVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgcm9vdC5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gIC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgIXdhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgICEhcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID8gd2FybmluZyhmYWxzZSwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICAhIWhhc05vblJvb3RSZWFjdENoaWxkID8gd2FybmluZyhmYWxzZSwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ1RoZSBSZWFjdERPTS51bnN0YWJsZV9jcmVhdGVQb3J0YWwoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0RE9NLmNyZWF0ZVBvcnRhbCgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEksICcgKyAnYnV0IHdpdGhvdXQgdGhlIFwidW5zdGFibGVfXCIgcHJlZml4LicpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfSxcblxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyxcblxuICB1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6IERPTVJlbmRlcmVyLmRlZmVycmVkVXBkYXRlcyxcblxuICBmbHVzaFN5bmM6IERPTVJlbmRlcmVyLmZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IERPTVJlbmRlcmVyLmZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5SZWFjdERPTS51bnN0YWJsZV9jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIHRydWUsIGh5ZHJhdGUpO1xufTtcblxudmFyIGZvdW5kRGV2VG9vbHMgPSBET01SZW5kZXJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzWydkZWZhdWx0J10gPyBSZWFjdERPTSQzWydkZWZhdWx0J10gOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz84YmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFLQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/BrowserRouter.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-router-dom/es/BrowserRouter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createBrowserHistory */ \"./node_modules/history/createBrowserHistory.js\");\n/* harmony import */ var history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router-dom/es/Router.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\n\nvar BrowserRouter = function (_React$Component) {\n  _inherits(BrowserRouter, _React$Component);\n\n  function BrowserRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, BrowserRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = history_createBrowserHistory__WEBPACK_IMPORTED_MODULE_3___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  BrowserRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');\n  };\n\n  BrowserRouter.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { history: this.history, children: this.props.children });\n  };\n\n  return BrowserRouter;\n}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);\n\nBrowserRouter.propTypes = {\n  basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  forceRefresh: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,\n  getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BrowserRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcz9hMDUxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cblxudmFyIEJyb3dzZXJSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQnJvd3NlclJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnJvd3NlclJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyb3dzZXJSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPEJyb3dzZXJSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VyUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Ccm93c2VyUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZvcmNlUmVmcmVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/BrowserRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/HashRouter.js":
/*!********************************************************!*\
  !*** ./node_modules/react-router-dom/es/HashRouter.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var history_createHashHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createHashHistory */ \"./node_modules/history/createHashHistory.js\");\n/* harmony import */ var history_createHashHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createHashHistory__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router-dom/es/Router.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\n\nvar HashRouter = function (_React$Component) {\n  _inherits(HashRouter, _React$Component);\n\n  function HashRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, HashRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = history_createHashHistory__WEBPACK_IMPORTED_MODULE_3___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  HashRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');\n  };\n\n  HashRouter.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { history: this.history, children: this.props.children });\n  };\n\n  return HashRouter;\n}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);\n\nHashRouter.propTypes = {\n  basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  hashType: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOf(['hashbang', 'noslash', 'slash']),\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (HashRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcz8yMGRmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIYXNoUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxIYXNoUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEhhc2hSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gSGFzaFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuSGFzaFJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgaGFzaFR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ2hhc2hiYW5nJywgJ25vc2xhc2gnLCAnc2xhc2gnXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBIYXNoUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/HashRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Link.js":
/*!**************************************************!*\
  !*** ./node_modules/react-router-dom/es/Link.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_2__);\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar isModifiedEvent = function isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n};\n\n/**\n * The public API for rendering a history-aware <a>.\n */\n\nvar Link = function (_React$Component) {\n  _inherits(Link, _React$Component);\n\n  function Link() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Link);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {\n      if (_this.props.onClick) _this.props.onClick(event);\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && // ignore right clicks\n      !_this.props.target && // let browser handle \"target=_blank\" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n\n          var history = _this.context.router.history;\n          var _this$props = _this.props,\n              replace = _this$props.replace,\n              to = _this$props.to;\n\n\n          if (replace) {\n            history.replace(to);\n          } else {\n            history.push(to);\n          }\n        }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Link.prototype.render = function render() {\n    var _props = this.props,\n        replace = _props.replace,\n        to = _props.to,\n        innerRef = _props.innerRef,\n        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars\n\n    invariant__WEBPACK_IMPORTED_MODULE_2___default()(this.context.router, 'You should not use <Link> outside a <Router>');\n\n    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);\n\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));\n  };\n\n  return Link;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nLink.propTypes = {\n  onClick: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  replace: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object]).isRequired,\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func])\n};\nLink.defaultProps = {\n  replace: false\n};\nLink.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n      push: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n      replace: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n      createHref: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired\n    }).isRequired\n  }).isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Link);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qcz9kYTIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcblxudmFyIGlzTW9kaWZpZWRFdmVudCA9IGZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaW5rKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNsaWNrKSBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBpZ25vcmUgcmlnaHQgY2xpY2tzXG4gICAgICAhX3RoaXMucHJvcHMudGFyZ2V0ICYmIC8vIGxldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBpZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICAgICAgKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHZhciBoaXN0b3J5ID0gX3RoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgcmVwbGFjZSA9IF90aGlzJHByb3BzLnJlcGxhY2UsXG4gICAgICAgICAgICAgIHRvID0gX3RoaXMkcHJvcHMudG87XG5cblxuICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByZXBsYWNlID0gX3Byb3BzLnJlcGxhY2UsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvLFxuICAgICAgICBpbm5lclJlZiA9IF9wcm9wcy5pbm5lclJlZixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ3JlcGxhY2UnLCAndG8nLCAnaW5uZXJSZWYnXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciBocmVmID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5LmNyZWF0ZUhyZWYodHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHsgcGF0aG5hbWU6IHRvIH0gOiB0byk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBocmVmOiBocmVmLCByZWY6IGlubmVyUmVmIH0pKTtcbiAgfTtcblxuICByZXR1cm4gTGluaztcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTGluay5wcm9wVHlwZXMgPSB7XG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHJlcGxhY2U6IFByb3BUeXBlcy5ib29sLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWQsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pXG59O1xuTGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIHJlcGxhY2U6IGZhbHNlXG59O1xuTGluay5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBjcmVhdGVIcmVmOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IExpbms7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Link.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/MemoryRouter.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-router-dom/es/MemoryRouter.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_MemoryRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/MemoryRouter */ \"./node_modules/react-router/es/MemoryRouter.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_MemoryRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanM/ZjYyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IE1lbW9yeVJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/MemoryRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/NavLink.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/es/NavLink.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route */ \"./node_modules/react-router-dom/es/Route.js\");\n/* harmony import */ var _Link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Link */ \"./node_modules/react-router-dom/es/Link.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n\n\n\n\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nvar NavLink = function NavLink(_ref) {\n  var to = _ref.to,\n      exact = _ref.exact,\n      strict = _ref.strict,\n      location = _ref.location,\n      activeClassName = _ref.activeClassName,\n      className = _ref.className,\n      activeStyle = _ref.activeStyle,\n      style = _ref.style,\n      getIsActive = _ref.isActive,\n      ariaCurrent = _ref.ariaCurrent,\n      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Route__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,\n    exact: exact,\n    strict: strict,\n    location: location,\n    children: function children(_ref2) {\n      var location = _ref2.location,\n          match = _ref2.match;\n\n      var isActive = !!(getIsActive ? getIsActive(match, location) : match);\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _extends({\n        to: to,\n        className: isActive ? [className, activeClassName].filter(function (i) {\n          return i;\n        }).join(' ') : className,\n        style: isActive ? _extends({}, style, activeStyle) : style,\n        'aria-current': isActive && ariaCurrent\n      }, rest));\n    }\n  });\n};\n\nNavLink.propTypes = {\n  to: _Link__WEBPACK_IMPORTED_MODULE_3__[\"default\"].propTypes.to,\n  exact: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  strict: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  location: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  activeClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  activeStyle: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  style: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  isActive: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  ariaCurrent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOf(['page', 'step', 'location', 'true'])\n};\n\nNavLink.defaultProps = {\n  activeClassName: 'active',\n  ariaCurrent: 'true'\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (NavLink);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcz9iOGQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYuYXJpYUN1cnJlbnQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnLCAnYXJpYUN1cnJlbnQnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbY2xhc3NOYW1lLCBhY3RpdmVDbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgICdhcmlhLWN1cnJlbnQnOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudFxuICAgICAgfSwgcmVzdCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5OYXZMaW5rLnByb3BUeXBlcyA9IHtcbiAgdG86IExpbmsucHJvcFR5cGVzLnRvLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGFyaWFDdXJyZW50OiBQcm9wVHlwZXMub25lT2YoWydwYWdlJywgJ3N0ZXAnLCAnbG9jYXRpb24nLCAndHJ1ZSddKVxufTtcblxuTmF2TGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIGFyaWFDdXJyZW50OiAndHJ1ZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5hdkxpbms7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/NavLink.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Prompt.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router-dom/es/Prompt.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Prompt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Prompt */ \"./node_modules/react-router/es/Prompt.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Prompt__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanM/MjcxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFByb21wdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUHJvbXB0JztcblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Prompt.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Redirect.js":
/*!******************************************************!*\
  !*** ./node_modules/react-router-dom/es/Redirect.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Redirect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Redirect */ \"./node_modules/react-router/es/Redirect.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Redirect__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzPzk5ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSZWRpcmVjdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Redirect.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Route.js":
/*!***************************************************!*\
  !*** ./node_modules/react-router-dom/es/Route.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Route */ \"./node_modules/react-router/es/Route.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Route__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzP2Q4ODMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSb3V0ZSBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGUnO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Route.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Router.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router-dom/es/Router.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Router */ \"./node_modules/react-router/es/Router.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Router__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanM/Njg5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Router.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/StaticRouter.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-router-dom/es/StaticRouter.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_StaticRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/StaticRouter */ \"./node_modules/react-router/es/StaticRouter.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_StaticRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanM/YmFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/StaticRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/Switch.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router-dom/es/Switch.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_Switch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/Switch */ \"./node_modules/react-router/es/Switch.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_Switch__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanM/OGNhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/Switch.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/index.js":
/*!***************************************************!*\
  !*** ./node_modules/react-router-dom/es/index.js ***!
  \***************************************************/
/*! exports provided: BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Redirect, Route, Router, StaticRouter, Switch, matchPath, withRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _BrowserRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BrowserRouter */ \"./node_modules/react-router-dom/es/BrowserRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BrowserRouter\", function() { return _BrowserRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _HashRouter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HashRouter */ \"./node_modules/react-router-dom/es/HashRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"HashRouter\", function() { return _HashRouter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _Link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Link */ \"./node_modules/react-router-dom/es/Link.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Link\", function() { return _Link__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _MemoryRouter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MemoryRouter */ \"./node_modules/react-router-dom/es/MemoryRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MemoryRouter\", function() { return _MemoryRouter__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _NavLink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NavLink */ \"./node_modules/react-router-dom/es/NavLink.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NavLink\", function() { return _NavLink__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _Prompt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Prompt */ \"./node_modules/react-router-dom/es/Prompt.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Prompt\", function() { return _Prompt__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _Redirect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Redirect */ \"./node_modules/react-router-dom/es/Redirect.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Redirect\", function() { return _Redirect__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _Route__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Route */ \"./node_modules/react-router-dom/es/Route.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Route\", function() { return _Route__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router-dom/es/Router.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return _Router__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _StaticRouter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./StaticRouter */ \"./node_modules/react-router-dom/es/StaticRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StaticRouter\", function() { return _StaticRouter__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _Switch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Switch */ \"./node_modules/react-router-dom/es/Switch.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Switch\", function() { return _Switch__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./matchPath */ \"./node_modules/react-router-dom/es/matchPath.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"matchPath\", function() { return _matchPath__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _withRouter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./withRouter */ \"./node_modules/react-router-dom/es/withRouter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"withRouter\", function() { return _withRouter__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzPzc4ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/index.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/matchPath.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-router-dom/es/matchPath.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_matchPath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/matchPath */ \"./node_modules/react-router/es/matchPath.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_matchPath__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanM/NTQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoJztcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/matchPath.js\n");

/***/ }),

/***/ "./node_modules/react-router-dom/es/withRouter.js":
/*!********************************************************!*\
  !*** ./node_modules/react-router-dom/es/withRouter.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_router_es_withRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router/es/withRouter */ \"./node_modules/react-router/es/withRouter.js\");\n// Written in this round about way for babel-transform-imports\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (react_router_es_withRouter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qcz9jMDhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgd2l0aFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhSb3V0ZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/es/withRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/MemoryRouter.js":
/*!******************************************************!*\
  !*** ./node_modules/react-router/es/MemoryRouter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history/createMemoryHistory */ \"./node_modules/history/createMemoryHistory.js\");\n/* harmony import */ var history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router/es/Router.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\n\nvar MemoryRouter = function (_React$Component) {\n  _inherits(MemoryRouter, _React$Component);\n\n  function MemoryRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, MemoryRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = history_createMemoryHistory__WEBPACK_IMPORTED_MODULE_3___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  MemoryRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');\n  };\n\n  MemoryRouter.prototype.render = function render() {\n    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { history: this.history, children: this.props.children });\n  };\n\n  return MemoryRouter;\n}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);\n\nMemoryRouter.propTypes = {\n  initialEntries: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  initialIndex: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MemoryRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyLmpzP2YxNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5Um91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/MemoryRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Prompt.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/es/Prompt.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_2__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n/**\n * The public API for prompting the user before navigating away\n * from a screen with a component.\n */\n\nvar Prompt = function (_React$Component) {\n  _inherits(Prompt, _React$Component);\n\n  function Prompt() {\n    _classCallCheck(this, Prompt);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Prompt.prototype.enable = function enable(message) {\n    if (this.unblock) this.unblock();\n\n    this.unblock = this.context.router.history.block(message);\n  };\n\n  Prompt.prototype.disable = function disable() {\n    if (this.unblock) {\n      this.unblock();\n      this.unblock = null;\n    }\n  };\n\n  Prompt.prototype.componentWillMount = function componentWillMount() {\n    invariant__WEBPACK_IMPORTED_MODULE_2___default()(this.context.router, 'You should not use <Prompt> outside a <Router>');\n\n    if (this.props.when) this.enable(this.props.message);\n  };\n\n  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (nextProps.when) {\n      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);\n    } else {\n      this.disable();\n    }\n  };\n\n  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.disable();\n  };\n\n  Prompt.prototype.render = function render() {\n    return null;\n  };\n\n  return Prompt;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nPrompt.propTypes = {\n  when: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  message: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string]).isRequired\n};\nPrompt.defaultProps = {\n  when: true\n};\nPrompt.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n      block: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired\n    }).isRequired\n  }).isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Prompt);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzPzJkNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXlcbiAqIGZyb20gYSBzY3JlZW4gd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUHJvbXB0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb21wdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUHJvbXB0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9tcHQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQcm9tcHQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykgdGhpcy51bmJsb2NrKCk7XG5cbiAgICB0aGlzLnVuYmxvY2sgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuYmxvY2sobWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB7XG4gICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgIHRoaXMudW5ibG9jayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxQcm9tcHQ+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMud2hlbikgdGhpcy5lbmFibGUodGhpcy5wcm9wcy5tZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMud2hlbikge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLndoZW4gfHwgdGhpcy5wcm9wcy5tZXNzYWdlICE9PSBuZXh0UHJvcHMubWVzc2FnZSkgdGhpcy5lbmFibGUobmV4dFByb3BzLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQcm9tcHQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblByb21wdC5wcm9wVHlwZXMgPSB7XG4gIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICBtZXNzYWdlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWRcbn07XG5Qcm9tcHQuZGVmYXVsdFByb3BzID0ge1xuICB3aGVuOiB0cnVlXG59O1xuUHJvbXB0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBibG9jazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Prompt.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Redirect.js":
/*!**************************************************!*\
  !*** ./node_modules/react-router/es/Redirect.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! history */ \"./node_modules/history/es/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for updating the location programmatically\n * with a component.\n */\n\nvar Redirect = function (_React$Component) {\n  _inherits(Redirect, _React$Component);\n\n  function Redirect() {\n    _classCallCheck(this, Redirect);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Redirect.prototype.isStatic = function isStatic() {\n    return this.context.router && this.context.router.staticContext;\n  };\n\n  Redirect.prototype.componentWillMount = function componentWillMount() {\n    invariant__WEBPACK_IMPORTED_MODULE_3___default()(this.context.router, 'You should not use <Redirect> outside a <Router>');\n\n    if (this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var prevTo = Object(history__WEBPACK_IMPORTED_MODULE_4__[\"createLocation\"])(prevProps.to);\n    var nextTo = Object(history__WEBPACK_IMPORTED_MODULE_4__[\"createLocation\"])(this.props.to);\n\n    if (Object(history__WEBPACK_IMPORTED_MODULE_4__[\"locationsAreEqual\"])(prevTo, nextTo)) {\n      warning__WEBPACK_IMPORTED_MODULE_2___default()(false, 'You tried to redirect to the same route you\\'re currently on: ' + ('\"' + nextTo.pathname + nextTo.search + '\"'));\n      return;\n    }\n\n    this.perform();\n  };\n\n  Redirect.prototype.perform = function perform() {\n    var history = this.context.router.history;\n    var _props = this.props,\n        push = _props.push,\n        to = _props.to;\n\n\n    if (push) {\n      history.push(to);\n    } else {\n      history.replace(to);\n    }\n  };\n\n  Redirect.prototype.render = function render() {\n    return null;\n  };\n\n  return Redirect;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nRedirect.propTypes = {\n  push: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  from: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  to: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object]).isRequired\n};\nRedirect.defaultProps = {\n  push: false\n};\nRedirect.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n      push: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n      replace: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired\n    }).isRequired,\n    staticContext: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object\n  }).isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Redirect);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcz85OGJjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJ2hpc3RvcnknO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciB1cGRhdGluZyB0aGUgbG9jYXRpb24gcHJvZ3JhbW1hdGljYWxseVxuICogd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVkaXJlY3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWRpcmVjdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5pc1N0YXRpYyA9IGZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm91dGVyICYmIHRoaXMuY29udGV4dC5yb3V0ZXIuc3RhdGljQ29udGV4dDtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSZWRpcmVjdD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICBpZiAodGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcHJldlRvID0gY3JlYXRlTG9jYXRpb24ocHJldlByb3BzLnRvKTtcbiAgICB2YXIgbmV4dFRvID0gY3JlYXRlTG9jYXRpb24odGhpcy5wcm9wcy50byk7XG5cbiAgICBpZiAobG9jYXRpb25zQXJlRXF1YWwocHJldlRvLCBuZXh0VG8pKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnWW91IHRyaWVkIHRvIHJlZGlyZWN0IHRvIHRoZSBzYW1lIHJvdXRlIHlvdVxcJ3JlIGN1cnJlbnRseSBvbjogJyArICgnXCInICsgbmV4dFRvLnBhdGhuYW1lICsgbmV4dFRvLnNlYXJjaCArICdcIicpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIHBlcmZvcm0oKSB7XG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHB1c2ggPSBfcHJvcHMucHVzaCxcbiAgICAgICAgdG8gPSBfcHJvcHMudG87XG5cblxuICAgIGlmIChwdXNoKSB7XG4gICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgIH1cbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZWRpcmVjdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVkaXJlY3QucHJvcFR5cGVzID0ge1xuICBwdXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkXG59O1xuUmVkaXJlY3QuZGVmYXVsdFByb3BzID0ge1xuICBwdXNoOiBmYWxzZVxufTtcblJlZGlyZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJlZGlyZWN0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Redirect.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Route.js":
/*!***********************************************!*\
  !*** ./node_modules/react-router/es/Route.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matchPath */ \"./node_modules/react-router/es/matchPath.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.count(children) === 0;\n};\n\n/**\n * The public API for matching a single path and rendering.\n */\n\nvar Route = function (_React$Component) {\n  _inherits(Route, _React$Component);\n\n  function Route() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Route);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props, _this.context.router)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Route.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        route: {\n          location: this.props.location || this.context.router.route.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Route.prototype.computeMatch = function computeMatch(_ref, router) {\n    var computedMatch = _ref.computedMatch,\n        location = _ref.location,\n        path = _ref.path,\n        strict = _ref.strict,\n        exact = _ref.exact,\n        sensitive = _ref.sensitive;\n\n    if (computedMatch) return computedMatch; // <Switch> already computed the match for us\n\n    invariant__WEBPACK_IMPORTED_MODULE_1___default()(router, 'You should not use <Route> or withRouter() outside a <Router>');\n\n    var route = router.route;\n\n    var pathname = (location || route.location).pathname;\n\n    return path ? Object(_matchPath__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;\n  };\n\n  Route.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');\n  };\n\n  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n\n    this.setState({\n      match: this.computeMatch(nextProps, nextContext.router)\n    });\n  };\n\n  Route.prototype.render = function render() {\n    var match = this.state.match;\n    var _props = this.props,\n        children = _props.children,\n        component = _props.component,\n        render = _props.render;\n    var _context$router = this.context.router,\n        history = _context$router.history,\n        route = _context$router.route,\n        staticContext = _context$router.staticContext;\n\n    var location = this.props.location || route.location;\n    var props = { match: match, location: location, history: history, staticContext: staticContext };\n\n    return component ? // component prop gets first priority, only called if there's a match\n    match ? react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(component, props) : null : render ? // render prop is next, only called if there's a match\n    match ? render(props) : null : children ? // children come last, always called\n    typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.only(children) : null : null;\n  };\n\n  return Route;\n}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\nRoute.propTypes = {\n  computedMatch: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object, // private, from <Switch>\n  path: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,\n  exact: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,\n  strict: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,\n  sensitive: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,\n  component: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,\n  render: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node]),\n  location: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object\n};\nRoute.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.shape({\n    history: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n    route: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n    staticContext: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object\n  })\n};\nRoute.childContextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Route);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcz9lMjllIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG52YXIgaXNFbXB0eUNoaWxkcmVuID0gZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIHNpbmdsZSBwYXRoIGFuZCByZW5kZXJpbmcuXG4gKi9cblxudmFyIFJvdXRlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMsIF90aGlzLmNvbnRleHQucm91dGVyKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGUucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHRoaXMuY29udGV4dC5yb3V0ZXIucm91dGUubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2goX3JlZiwgcm91dGVyKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgICAgc2Vuc2l0aXZlID0gX3JlZi5zZW5zaXRpdmU7XG5cbiAgICBpZiAoY29tcHV0ZWRNYXRjaCkgcmV0dXJuIGNvbXB1dGVkTWF0Y2g7IC8vIDxTd2l0Y2g+IGFscmVhZHkgY29tcHV0ZWQgdGhlIG1hdGNoIGZvciB1c1xuXG4gICAgaW52YXJpYW50KHJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG9yIHdpdGhSb3V0ZXIoKSBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciByb3V0ZSA9IHJvdXRlci5yb3V0ZTtcblxuICAgIHZhciBwYXRobmFtZSA9IChsb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbikucGF0aG5hbWU7XG5cbiAgICByZXR1cm4gcGF0aCA/IG1hdGNoUGF0aChwYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBzdHJpY3Q6IHN0cmljdCwgZXhhY3Q6IGV4YWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSA6IHJvdXRlLm1hdGNoO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMucmVuZGVyKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5yZW5kZXIgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgcmVuZGVyPiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgIHdhcm5pbmcoIShuZXh0UHJvcHMubG9jYXRpb24gJiYgIXRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbWF0Y2g6IHRoaXMuY29tcHV0ZU1hdGNoKG5leHRQcm9wcywgbmV4dENvbnRleHQucm91dGVyKVxuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5zdGF0ZS5tYXRjaDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wcy5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wcy5yZW5kZXI7XG4gICAgdmFyIF9jb250ZXh0JHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXIsXG4gICAgICAgIGhpc3RvcnkgPSBfY29udGV4dCRyb3V0ZXIuaGlzdG9yeSxcbiAgICAgICAgcm91dGUgPSBfY29udGV4dCRyb3V0ZXIucm91dGUsXG4gICAgICAgIHN0YXRpY0NvbnRleHQgPSBfY29udGV4dCRyb3V0ZXIuc3RhdGljQ29udGV4dDtcblxuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMucHJvcHMubG9jYXRpb24gfHwgcm91dGUubG9jYXRpb247XG4gICAgdmFyIHByb3BzID0geyBtYXRjaDogbWF0Y2gsIGxvY2F0aW9uOiBsb2NhdGlvbiwgaGlzdG9yeTogaGlzdG9yeSwgc3RhdGljQ29udGV4dDogc3RhdGljQ29udGV4dCB9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudCA/IC8vIGNvbXBvbmVudCBwcm9wIGdldHMgZmlyc3QgcHJpb3JpdHksIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IG51bGwgOiByZW5kZXIgPyAvLyByZW5kZXIgcHJvcCBpcyBuZXh0LCBvbmx5IGNhbGxlZCBpZiB0aGVyZSdzIGEgbWF0Y2hcbiAgICBtYXRjaCA/IHJlbmRlcihwcm9wcykgOiBudWxsIDogY2hpbGRyZW4gPyAvLyBjaGlsZHJlbiBjb21lIGxhc3QsIGFsd2F5cyBjYWxsZWRcbiAgICB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihwcm9wcykgOiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbCA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZS5wcm9wVHlwZXMgPSB7XG4gIGNvbXB1dGVkTWF0Y2g6IFByb3BUeXBlcy5vYmplY3QsIC8vIHByaXZhdGUsIGZyb20gPFN3aXRjaD5cbiAgcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICBjb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ub2RlXSksXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGUuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KVxufTtcblJvdXRlLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Route.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Router.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/es/Router.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n/**\n * The public API for putting history on context.\n */\n\nvar Router = function (_React$Component) {\n  _inherits(Router, _React$Component);\n\n  function Router() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Router);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props.history.location.pathname)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Router.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        history: this.props.history,\n        route: {\n          location: this.props.history.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Router.prototype.computeMatch = function computeMatch(pathname) {\n    return {\n      path: '/',\n      url: '/',\n      params: {},\n      isExact: pathname === '/'\n    };\n  };\n\n  Router.prototype.componentWillMount = function componentWillMount() {\n    var _this2 = this;\n\n    var _props = this.props,\n        children = _props.children,\n        history = _props.history;\n\n\n    invariant__WEBPACK_IMPORTED_MODULE_1___default()(children == null || react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.count(children) === 1, 'A <Router> may have only one child element');\n\n    // Do this here so we can setState when a <Redirect> changes the\n    // location in componentWillMount. This happens e.g. when doing\n    // server rendering using a <StaticRouter>.\n    this.unlisten = history.listen(function () {\n      _this2.setState({\n        match: _this2.computeMatch(history.location.pathname)\n      });\n    });\n  };\n\n  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(this.props.history === nextProps.history, 'You cannot change <Router history>');\n  };\n\n  Router.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.unlisten();\n  };\n\n  Router.prototype.render = function render() {\n    var children = this.props.children;\n\n    return children ? react__WEBPACK_IMPORTED_MODULE_2___default.a.Children.only(children) : null;\n  };\n\n  return Router;\n}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\nRouter.propTypes = {\n  history: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node\n};\nRouter.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object\n};\nRouter.childContextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Router);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGVyLmpzPzllYmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChwYXRobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiAnLycsXG4gICAgICB1cmw6ICcvJyxcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0V4YWN0OiBwYXRobmFtZSA9PT0gJy8nXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuXG5cbiAgICBpbnZhcmlhbnQoY2hpbGRyZW4gPT0gbnVsbCB8fCBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDEsICdBIDxSb3V0ZXI+IG1heSBoYXZlIG9ubHkgb25lIGNoaWxkIGVsZW1lbnQnKTtcblxuICAgIC8vIERvIHRoaXMgaGVyZSBzbyB3ZSBjYW4gc2V0U3RhdGUgd2hlbiBhIDxSZWRpcmVjdD4gY2hhbmdlcyB0aGVcbiAgICAvLyBsb2NhdGlvbiBpbiBjb21wb25lbnRXaWxsTW91bnQuIFRoaXMgaGFwcGVucyBlLmcuIHdoZW4gZG9pbmdcbiAgICAvLyBzZXJ2ZXIgcmVuZGVyaW5nIHVzaW5nIGEgPFN0YXRpY1JvdXRlcj4uXG4gICAgdGhpcy51bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgIG1hdGNoOiBfdGhpczIuY29tcHV0ZU1hdGNoKGhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHdhcm5pbmcodGhpcy5wcm9wcy5oaXN0b3J5ID09PSBuZXh0UHJvcHMuaGlzdG9yeSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT4nKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmxpc3RlbigpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICByZXR1cm4gY2hpbGRyZW4gPyBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5Sb3V0ZXIuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Router.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/StaticRouter.js":
/*!******************************************************!*\
  !*** ./node_modules/react-router/es/StaticRouter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var history_PathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! history/PathUtils */ \"./node_modules/history/PathUtils.js\");\n/* harmony import */ var history_PathUtils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Router */ \"./node_modules/react-router/es/Router.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n\nvar normalizeLocation = function normalizeLocation(object) {\n  var _object$pathname = object.pathname,\n      pathname = _object$pathname === undefined ? '/' : _object$pathname,\n      _object$search = object.search,\n      search = _object$search === undefined ? '' : _object$search,\n      _object$hash = object.hash,\n      hash = _object$hash === undefined ? '' : _object$hash;\n\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nvar addBasename = function addBasename(basename, location) {\n  if (!basename) return location;\n\n  return _extends({}, location, {\n    pathname: Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"addLeadingSlash\"])(basename) + location.pathname\n  });\n};\n\nvar stripBasename = function stripBasename(basename, location) {\n  if (!basename) return location;\n\n  var base = Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"addLeadingSlash\"])(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return _extends({}, location, {\n    pathname: location.pathname.substr(base.length)\n  });\n};\n\nvar createLocation = function createLocation(location) {\n  return typeof location === 'string' ? Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"parsePath\"])(location) : normalizeLocation(location);\n};\n\nvar createURL = function createURL(location) {\n  return typeof location === 'string' ? location : Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"createPath\"])(location);\n};\n\nvar staticHandler = function staticHandler(methodName) {\n  return function () {\n    invariant__WEBPACK_IMPORTED_MODULE_1___default()(false, 'You cannot %s with <StaticRouter>', methodName);\n  };\n};\n\nvar noop = function noop() {};\n\n/**\n * The public top-level API for a \"static\" <Router>, so-called because it\n * can't actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\n\nvar StaticRouter = function (_React$Component) {\n  _inherits(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, StaticRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {\n      return Object(history_PathUtils__WEBPACK_IMPORTED_MODULE_4__[\"addLeadingSlash\"])(_this.props.basename + createURL(path));\n    }, _this.handlePush = function (location) {\n      var _this$props = _this.props,\n          basename = _this$props.basename,\n          context = _this$props.context;\n\n      context.action = 'PUSH';\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, _this.handleReplace = function (location) {\n      var _this$props2 = _this.props,\n          basename = _this$props2.basename,\n          context = _this$props2.context;\n\n      context.action = 'REPLACE';\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, _this.handleListen = function () {\n      return noop;\n    }, _this.handleBlock = function () {\n      return noop;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  StaticRouter.prototype.getChildContext = function getChildContext() {\n    return {\n      router: {\n        staticContext: this.props.context\n      }\n    };\n  };\n\n  StaticRouter.prototype.componentWillMount = function componentWillMount() {\n    warning__WEBPACK_IMPORTED_MODULE_0___default()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');\n  };\n\n  StaticRouter.prototype.render = function render() {\n    var _props = this.props,\n        basename = _props.basename,\n        context = _props.context,\n        location = _props.location,\n        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);\n\n    var history = {\n      createHref: this.createHref,\n      action: 'POP',\n      location: stripBasename(basename, createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler('go'),\n      goBack: staticHandler('goBack'),\n      goForward: staticHandler('goForward'),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n\n    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(_Router__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _extends({}, props, { history: history }));\n  };\n\n  return StaticRouter;\n}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);\n\nStaticRouter.propTypes = {\n  basename: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,\n  context: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired,\n  location: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object])\n};\nStaticRouter.defaultProps = {\n  basename: '',\n  location: '/'\n};\nStaticRouter.childContextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object.isRequired\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StaticRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzP2M5Y2MiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIGNyZWF0ZVBhdGgsIHBhcnNlUGF0aCB9IGZyb20gJ2hpc3RvcnkvUGF0aFV0aWxzJztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG52YXIgbm9ybWFsaXplTG9jYXRpb24gPSBmdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbihvYmplY3QpIHtcbiAgdmFyIF9vYmplY3QkcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUsXG4gICAgICBwYXRobmFtZSA9IF9vYmplY3QkcGF0aG5hbWUgPT09IHVuZGVmaW5lZCA/ICcvJyA6IF9vYmplY3QkcGF0aG5hbWUsXG4gICAgICBfb2JqZWN0JHNlYXJjaCA9IG9iamVjdC5zZWFyY2gsXG4gICAgICBzZWFyY2ggPSBfb2JqZWN0JHNlYXJjaCA9PT0gdW5kZWZpbmVkID8gJycgOiBfb2JqZWN0JHNlYXJjaCxcbiAgICAgIF9vYmplY3QkaGFzaCA9IG9iamVjdC5oYXNoLFxuICAgICAgaGFzaCA9IF9vYmplY3QkaGFzaCA9PT0gdW5kZWZpbmVkID8gJycgOiBfb2JqZWN0JGhhc2g7XG5cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG52YXIgYWRkQmFzZW5hbWUgPSBmdW5jdGlvbiBhZGRCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKSArIGxvY2F0aW9uLnBhdGhuYW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgdmFyIGJhc2UgPSBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpO1xuXG4gIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2UpICE9PSAwKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHIoYmFzZS5sZW5ndGgpXG4gIH0pO1xufTtcblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgobG9jYXRpb24pIDogbm9ybWFsaXplTG9jYXRpb24obG9jYXRpb24pO1xufTtcblxudmFyIGNyZWF0ZVVSTCA9IGZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/IGxvY2F0aW9uIDogY3JlYXRlUGF0aChsb2NhdGlvbik7XG59O1xuXG52YXIgc3RhdGljSGFuZGxlciA9IGZ1bmN0aW9uIHN0YXRpY0hhbmRsZXIobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChmYWxzZSwgJ1lvdSBjYW5ub3QgJXMgd2l0aCA8U3RhdGljUm91dGVyPicsIG1ldGhvZE5hbWUpO1xuICB9O1xufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG52YXIgU3RhdGljUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGljUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nU2xhc2goX3RoaXMucHJvcHMuYmFzZW5hbWUgKyBjcmVhdGVVUkwocGF0aCkpO1xuICAgIH0sIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1BVU0gnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wczIuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVMaXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGhpcy5oYW5kbGVCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjoge1xuICAgICAgICBzdGF0aWNDb250ZXh0OiB0aGlzLnByb3BzLmNvbnRleHRcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxTdGF0aWNSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgU3RhdGljUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZW5hbWUgPSBfcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgIGNvbnRleHQgPSBfcHJvcHMuY29udGV4dCxcbiAgICAgICAgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydiYXNlbmFtZScsICdjb250ZXh0JywgJ2xvY2F0aW9uJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiB0aGlzLmNyZWF0ZUhyZWYsXG4gICAgICBhY3Rpb246ICdQT1AnLFxuICAgICAgbG9jYXRpb246IHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSksXG4gICAgICBwdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICByZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXG4gICAgICBnbzogc3RhdGljSGFuZGxlcignZ28nKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcignZ29CYWNrJyksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoJ2dvRm9yd2FyZCcpLFxuICAgICAgbGlzdGVuOiB0aGlzLmhhbmRsZUxpc3RlbixcbiAgICAgIGJsb2NrOiB0aGlzLmhhbmRsZUJsb2NrXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7IGhpc3Rvcnk6IGhpc3RvcnkgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGF0aWNSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN0YXRpY1JvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSlcbn07XG5TdGF0aWNSb3V0ZXIuZGVmYXVsdFByb3BzID0ge1xuICBiYXNlbmFtZTogJycsXG4gIGxvY2F0aW9uOiAnLydcbn07XG5TdGF0aWNSb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY1JvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/StaticRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/Switch.js":
/*!************************************************!*\
  !*** ./node_modules/react-router/es/Switch.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"./node_modules/warning/browser.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! invariant */ \"./node_modules/invariant/browser.js\");\n/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./matchPath */ \"./node_modules/react-router/es/matchPath.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\n\nvar Switch = function (_React$Component) {\n  _inherits(Switch, _React$Component);\n\n  function Switch() {\n    _classCallCheck(this, Switch);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Switch.prototype.componentWillMount = function componentWillMount() {\n    invariant__WEBPACK_IMPORTED_MODULE_3___default()(this.context.router, 'You should not use <Switch> outside a <Router>');\n  };\n\n  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    warning__WEBPACK_IMPORTED_MODULE_2___default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n\n    warning__WEBPACK_IMPORTED_MODULE_2___default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n  };\n\n  Switch.prototype.render = function render() {\n    var route = this.context.router.route;\n    var children = this.props.children;\n\n    var location = this.props.location || route.location;\n\n    var match = void 0,\n        child = void 0;\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.forEach(children, function (element) {\n      if (!react__WEBPACK_IMPORTED_MODULE_0___default.a.isValidElement(element)) return;\n\n      var _element$props = element.props,\n          pathProp = _element$props.path,\n          exact = _element$props.exact,\n          strict = _element$props.strict,\n          sensitive = _element$props.sensitive,\n          from = _element$props.from;\n\n      var path = pathProp || from;\n\n      if (match == null) {\n        child = element;\n        match = path ? Object(_matchPath__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;\n      }\n    });\n\n    return match ? react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, { location: location, computedMatch: match }) : null;\n  };\n\n  return Switch;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nSwitch.contextTypes = {\n  router: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({\n    route: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired\n  }).isRequired\n};\nSwitch.propTypes = {\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node,\n  location: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Switch);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N3aXRjaC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzP2NhODIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyB0aGUgZmlyc3QgPFJvdXRlPiB0aGF0IG1hdGNoZXMuXG4gKi9cblxudmFyIFN3aXRjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTd2l0Y2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3dpdGNoKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFN3aXRjaD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBjaGlsZCA9IHZvaWQgMDtcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2VsZW1lbnQkcHJvcHMgPSBlbGVtZW50LnByb3BzLFxuICAgICAgICAgIHBhdGhQcm9wID0gX2VsZW1lbnQkcHJvcHMucGF0aCxcbiAgICAgICAgICBleGFjdCA9IF9lbGVtZW50JHByb3BzLmV4YWN0LFxuICAgICAgICAgIHN0cmljdCA9IF9lbGVtZW50JHByb3BzLnN0cmljdCxcbiAgICAgICAgICBzZW5zaXRpdmUgPSBfZWxlbWVudCRwcm9wcy5zZW5zaXRpdmUsXG4gICAgICAgICAgZnJvbSA9IF9lbGVtZW50JHByb3BzLmZyb207XG5cbiAgICAgIHZhciBwYXRoID0gcGF0aFByb3AgfHwgZnJvbTtcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgZXhhY3Q6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSkgOiByb3V0ZS5tYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaCA/IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyBsb2NhdGlvbjogbG9jYXRpb24sIGNvbXB1dGVkTWF0Y2g6IG1hdGNoIH0pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Td2l0Y2guY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuU3dpdGNoLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/Switch.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/matchPath.js":
/*!***************************************************!*\
  !*** ./node_modules/react-router/es/matchPath.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-to-regexp */ \"./node_modules/react-router/node_modules/path-to-regexp/index.js\");\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path_to_regexp__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = '' + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  var keys = [];\n  var re = path_to_regexp__WEBPACK_IMPORTED_MODULE_0___default()(pattern, keys, options);\n  var compiledPattern = { re: re, keys: keys };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options === 'string') options = { path: options };\n\n  var _options = options,\n      _options$path = _options.path,\n      path = _options$path === undefined ? '/' : _options$path,\n      _options$exact = _options.exact,\n      exact = _options$exact === undefined ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === undefined ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === undefined ? false : _options$sensitive;\n\n  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),\n      re = _compilePath.re,\n      keys = _compilePath.keys;\n\n  var match = re.exec(pathname);\n\n  if (!match) return null;\n\n  var url = match[0],\n      values = match.slice(1);\n\n  var isExact = pathname === url;\n\n  if (exact && !isExact) return null;\n\n  return {\n    path: path, // the path pattern used to match\n    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\n    isExact: isExact, // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (matchPath);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoLmpzPzRhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG5cbnZhciBwYXR0ZXJuQ2FjaGUgPSB7fTtcbnZhciBjYWNoZUxpbWl0ID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCA9IDA7XG5cbnZhciBjb21waWxlUGF0aCA9IGZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gJycgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0ICsgb3B0aW9ucy5zZW5zaXRpdmU7XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHBhdHRlcm4sIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0geyByZTogcmUsIGtleXM6IGtleXMgfTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkUGF0dGVybjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGggcGF0dGVybi5cbiAqL1xudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykgb3B0aW9ucyA9IHsgcGF0aDogb3B0aW9ucyB9O1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIHBhdGggPSBfb3B0aW9ucyRwYXRoID09PSB1bmRlZmluZWQgPyAnLycgOiBfb3B0aW9ucyRwYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0LFxuICAgICAgX29wdGlvbnMkc2Vuc2l0aXZlID0gX29wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgc2Vuc2l0aXZlID0gX29wdGlvbnMkc2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHNlbnNpdGl2ZTtcblxuICB2YXIgX2NvbXBpbGVQYXRoID0gY29tcGlsZVBhdGgocGF0aCwgeyBlbmQ6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSksXG4gICAgICByZSA9IF9jb21waWxlUGF0aC5yZSxcbiAgICAgIGtleXMgPSBfY29tcGlsZVBhdGgua2V5cztcblxuICB2YXIgbWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcblxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgdXJsID0gbWF0Y2hbMF0sXG4gICAgICB2YWx1ZXMgPSBtYXRjaC5zbGljZSgxKTtcblxuICB2YXIgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG5cbiAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsIC8vIHRoZSBwYXRoIHBhdHRlcm4gdXNlZCB0byBtYXRjaFxuICAgIHVybDogcGF0aCA9PT0gJy8nICYmIHVybCA9PT0gJycgPyAnLycgOiB1cmwsIC8vIHRoZSBtYXRjaGVkIHBvcnRpb24gb2YgdGhlIFVSTFxuICAgIGlzRXhhY3Q6IGlzRXhhY3QsIC8vIHdoZXRoZXIgb3Igbm90IHdlIG1hdGNoZWQgZXhhY3RseVxuICAgIHBhcmFtczoga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSwgaW5kZXgpIHtcbiAgICAgIG1lbW9ba2V5Lm5hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/matchPath.js\n");

/***/ }),

/***/ "./node_modules/react-router/es/withRouter.js":
/*!****************************************************!*\
  !*** ./node_modules/react-router/es/withRouter.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hoist-non-react-statics */ \"./node_modules/hoist-non-react-statics/index.js\");\n/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Route__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Route */ \"./node_modules/react-router/es/Route.js\");\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n\n\n\n\n\n/**\n * A public higher-order component to access the imperative API\n */\nvar withRouter = function withRouter(Component) {\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);\n\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_Route__WEBPACK_IMPORTED_MODULE_3__[\"default\"], { render: function render(routeComponentProps) {\n        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));\n      } });\n  };\n\n  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';\n  C.WrappedComponent = Component;\n  C.propTypes = {\n    wrappedComponentRef: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n  };\n\n  return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(C, Component);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (withRouter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanM/ZjQyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgWyd3cmFwcGVkQ29tcG9uZW50UmVmJ10pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHsgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywgeyByZWY6IHdyYXBwZWRDb21wb25lbnRSZWYgfSkpO1xuICAgICAgfSB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgJyknO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router/es/withRouter.js\n");

/***/ }),

/***/ "./node_modules/react-router/node_modules/isarray/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-router/node_modules/isarray/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lZDA3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/react-router/node_modules/path-to-regexp/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-router/node_modules/path-to-regexp/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isarray = __webpack_require__(/*! isarray */ \"./node_modules/react-router/node_modules/isarray/index.js\")\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzP2YyZDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzYXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW11cbiAgdmFyIGtleSA9IDBcbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgcGF0aCA9ICcnXG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLydcbiAgdmFyIHJlc1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIHByZWZpeCA9IHJlc1syXVxuICAgIHZhciBuYW1lID0gcmVzWzNdXG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cbiAgICB2YXIgZ3JvdXAgPSByZXNbNV1cbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl1cbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pXG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKVxuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2VcbiAgdmFyIHJvdXRlID0gJydcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJ1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonXG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSdcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKVxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlclxuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nXG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJ1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-router/node_modules/path-to-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.3.2\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\nvar invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\nvar emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\nvar warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\nvar emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\nvar checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.3.2';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol['for']('react.strict_mode') : 0xeacc;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol['for']('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol['for']('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol['for']('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol['for']('react.forward_ref') : 0xead0;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warning(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n  {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown = void 0;\nvar specialPropRefWarningShown = void 0;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName = void 0;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\n\n  var propName = void 0;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps = void 0;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar ReactDebugCurrentFrame = {};\n\n{\n  // Component that is being worked on\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      return impl();\n    }\n    return null;\n  };\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child = void 0;\n  var nextName = void 0;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step = void 0;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.toarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    _defaultValue: defaultValue,\n    _currentValue: defaultValue,\n    _changedBits: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  context.Consumer = context;\n\n  {\n    context._currentRenderer = null;\n  }\n\n  return context;\n}\n\nfunction forwardRef(render) {\n  {\n    !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render) : void 0;\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'ReactFragment';\n    case REACT_PORTAL_TYPE:\n      return 'ReactPortal';\n    case REACT_CALL_TYPE:\n      return 'ReactCall';\n    case REACT_RETURN_TYPE:\n      return 'ReactReturn';\n  }\n  if (typeof type === 'object' && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || '';\n        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n    }\n  }\n  return null;\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nvar currentlyValidatingElement = void 0;\nvar propTypesMisspellWarningShown = void 0;\n\nvar getDisplayName = function () {};\nvar getStackAddendum = function () {};\n\n{\n  currentlyValidatingElement = null;\n\n  propTypesMisspellWarningShown = false;\n\n  getDisplayName = function (element) {\n    if (element == null) {\n      return '#empty';\n    } else if (typeof element === 'string' || typeof element === 'number') {\n      return '#text';\n    } else if (typeof element.type === 'string') {\n      return element.type;\n    } else if (element.type === REACT_FRAGMENT_TYPE) {\n      return 'React.Fragment';\n    } else {\n      return element.type.displayName || element.type.name || 'Unknown';\n    }\n  };\n\n  getStackAddendum = function () {\n    var stack = '';\n    if (currentlyValidatingElement) {\n      var name = getDisplayName(currentlyValidatingElement);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n    }\n    stack += ReactDebugCurrentFrame.getStackAddendum() || '';\n    return stack;\n  };\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n  }\n\n  currentlyValidatingElement = element;\n  {\n    warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\n  }\n  currentlyValidatingElement = null;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step = void 0;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var componentClass = element.type;\n  if (typeof componentClass !== 'function') {\n    return;\n  }\n  var name = componentClass.displayName || componentClass.name;\n  var propTypes = componentClass.propTypes;\n  if (propTypes) {\n    currentlyValidatingElement = element;\n    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\n    currentlyValidatingElement = null;\n  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    !componentClass.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  currentlyValidatingElement = fragment;\n\n  var keys = Object.keys(fragment.props);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\n  }\n\n  currentlyValidatingElement = null;\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    info += getStackAddendum() || '';\n\n    var typeString = void 0;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  createRef: createRef,\n  Component: Component,\n  PureComponent: PureComponent,\n\n  createContext: createContext,\n  forwardRef: forwardRef,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: ReactCurrentOwner,\n    // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n    assign: _assign\n  }\n};\n\n{\n  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3['default'] ? React$3['default'] : React$3;\n\nmodule.exports = react;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcz83MmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMy4yXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4zLjInO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gaGF2ZSBwcmVzZXJ2ZSB0aGUgZm9ybWF0IGFuZCBwYXJhbXMgaW4gdGhlIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICVzLicsIGVsZW1lbnQpIDogdm9pZCAwO1xuXG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgdmFyIG5leHROYW1lID0gdm9pZCAwO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgICEoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IG51bGwgfHwgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2NoYW5nZWRCaXRzOiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG5cbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICBjb250ZXh0LkNvbnN1bWVyID0gY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgISh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUmVhY3RQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdENhbGwnO1xuICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UmV0dXJuJztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IHZvaWQgMDtcbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHZvaWQgMDtcblxudmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge307XG52YXIgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXG4gIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyKSArICcuJztcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgdmFyIHByb3BUeXBlcyA9IGNvbXBvbmVudENsYXNzLnByb3BUeXBlcztcbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudENsYXNzLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA/IHdhcm5pbmcoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLiVzJywga2V5LCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiVzJywgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpO1xuXG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIGluZm8gKz0gZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuXG4gICAgdmFyIHR5cGVTdHJpbmcgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcbiAgLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgY3JlYXRlUmVmOiBjcmVhdGVSZWYsXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWY6IGZvcndhcmRSZWYsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gIFN0cmljdE1vZGU6IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX0FzeW5jTW9kZTogUkVBQ1RfQVNZTkNfTU9ERV9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBRUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/resolve-pathname/index.js":
/*!************************************************!*\
  !*** ./node_modules/resolve-pathname/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction isAbsolute(pathname) {\n  return pathname.charAt(0) === '/';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var toParts = to && to.split('/') || [];\n  var fromParts = from && from.split('/') || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return '/';\n\n  var hasTrailingSlash = void 0;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === '.' || last === '..' || last === '';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === '.') {\n      spliceOne(fromParts, i);\n    } else if (part === '..') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) {\n    fromParts.unshift('..');\n  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');\n\n  var result = fromParts.join('/');\n\n  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';\n\n  return result;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (resolvePathname);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzPzQ2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRobmFtZSkge1xuICByZXR1cm4gcGF0aG5hbWUuY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkge1xuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICB9XG5cbiAgbGlzdC5wb3AoKTtcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBoZWF2aWx5IG9uIG5vZGUncyB1cmwucGFyc2VcbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZSh0bykge1xuICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgdmFyIHRvUGFydHMgPSB0byAmJiB0by5zcGxpdCgnLycpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcvJykgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gIH1pZiAobXVzdEVuZEFicyAmJiBmcm9tUGFydHNbMF0gIT09ICcnICYmICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpKSBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlUGF0aG5hbWU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/resolve-pathname/index.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz9mNmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/value-equal/index.js":
/*!*******************************************!*\
  !*** ./node_modules/value-equal/index.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction valueEqual(a, b) {\n  if (a === b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return valueEqual(item, b[index]);\n    });\n  }\n\n  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);\n  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);\n\n  if (aType !== bType) return false;\n\n  if (aType === 'object') {\n    var aValue = a.valueOf();\n    var bValue = b.valueOf();\n\n    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);\n\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) return false;\n\n    return aKeys.every(function (key) {\n      return valueEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (valueEqual);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanM/YzNhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZUVxdWFsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/value-equal/index.js\n");

/***/ }),

/***/ "./node_modules/warning/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (true) {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcz9lODM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/warning/browser.js\n");

/***/ }),

/***/ "./src/app/about.js":
/*!**************************!*\
  !*** ./src/app/about.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nvar css = __webpack_require__(/*! ./css/about.css */ \"./src/app/css/about.css\");\n\nvar About = function (_React$Component) {\n    _inherits(About, _React$Component);\n\n    function About() {\n        _classCallCheck(this, About);\n\n        return _possibleConstructorReturn(this, (About.__proto__ || Object.getPrototypeOf(About)).apply(this, arguments));\n    }\n\n    _createClass(About, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                { 'class': 'about-me' },\n                React.createElement('img', { 'class': 'img', src: 'http://mpggw.com/data/wallpapers/57/WDF_1035619.jpg' }),\n                React.createElement(\n                    'h2',\n                    null,\n                    'Hello, I\\'m Misha'\n                ),\n                React.createElement(\n                    'p',\n                    null,\n                    'Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.Why do we use it? It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using \\'Content here, content here\\', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for \\'lorem ipsum\\' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).'\n                )\n            );\n        }\n    }]);\n\n    return About;\n}(React.Component);\n\nmodule.exports = About;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Fib3V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvYWJvdXQuanM/ODMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xubGV0IFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvYWJvdXQuY3NzJyk7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmNsYXNzIEFib3V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybihcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J2Fib3V0LW1lJz5cbiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPSdpbWcnIHNyYz0naHR0cDovL21wZ2d3LmNvbS9kYXRhL3dhbGxwYXBlcnMvNTcvV0RGXzEwMzU2MTkuanBnJy8+XG4gICAgICAgICAgICAgICAgPGgyPkhlbGxvLCBJJ20gTWlzaGE8L2gyPlxuICAgICAgICAgICAgICAgIDxwPkxvcmVtIElwc3VtIGlzIHNpbXBseSBkdW1teSB0ZXh0IG9mIHRoZSBwcmludGluZyBhbmQgdHlwZXNldHRpbmcgaW5kdXN0cnkuIExvcmVtIElwc3VtIGhhcyBiZWVuIHRoZSBpbmR1c3RyeSdzIHN0YW5kYXJkIGR1bW15IHRleHQgZXZlciBzaW5jZSB0aGUgMTUwMHMsIHdoZW4gYW4gdW5rbm93biBwcmludGVyIHRvb2sgYSBnYWxsZXkgb2YgdHlwZSBhbmQgc2NyYW1ibGVkIGl0IHRvIG1ha2UgYSB0eXBlIHNwZWNpbWVuIGJvb2suIEl0IGhhcyBzdXJ2aXZlZCBub3Qgb25seSBmaXZlIGNlbnR1cmllcywgYnV0IGFsc28gdGhlIGxlYXAgaW50byBlbGVjdHJvbmljIHR5cGVzZXR0aW5nLCByZW1haW5pbmcgZXNzZW50aWFsbHkgdW5jaGFuZ2VkLiBJdCB3YXMgcG9wdWxhcmlzZWQgaW4gdGhlIDE5NjBzIHdpdGggdGhlIHJlbGVhc2Ugb2YgTGV0cmFzZXQgc2hlZXRzIGNvbnRhaW5pbmcgTG9yZW0gSXBzdW0gcGFzc2FnZXMsIGFuZCBtb3JlIHJlY2VudGx5IHdpdGggZGVza3RvcCBwdWJsaXNoaW5nIHNvZnR3YXJlIGxpa2UgQWxkdXMgUGFnZU1ha2VyIGluY2x1ZGluZyB2ZXJzaW9ucyBvZiBMb3JlbSBJcHN1bS5XaHkgZG8gd2UgdXNlIGl0P1xuICAgICAgICAgICAgICAgICAgICBJdCBpcyBhIGxvbmcgZXN0YWJsaXNoZWQgZmFjdCB0aGF0IGEgcmVhZGVyIHdpbGwgYmUgZGlzdHJhY3RlZCBieSB0aGUgcmVhZGFibGUgY29udGVudCBvZiBhIHBhZ2Ugd2hlbiBsb29raW5nIGF0IGl0cyBsYXlvdXQuIFRoZSBwb2ludCBvZiB1c2luZyBMb3JlbSBJcHN1bSBpcyB0aGF0IGl0IGhhcyBhIG1vcmUtb3ItbGVzcyBub3JtYWwgZGlzdHJpYnV0aW9uIG9mIGxldHRlcnMsIGFzIG9wcG9zZWQgdG8gdXNpbmcgJ0NvbnRlbnQgaGVyZSwgY29udGVudCBoZXJlJywgbWFraW5nIGl0IGxvb2sgbGlrZSByZWFkYWJsZSBFbmdsaXNoLiBNYW55IGRlc2t0b3AgcHVibGlzaGluZyBwYWNrYWdlcyBhbmQgd2ViIHBhZ2UgZWRpdG9ycyBub3cgdXNlIExvcmVtIElwc3VtIGFzIHRoZWlyIGRlZmF1bHQgbW9kZWwgdGV4dCwgYW5kIGEgc2VhcmNoIGZvciAnbG9yZW0gaXBzdW0nIHdpbGwgdW5jb3ZlciBtYW55IHdlYiBzaXRlcyBzdGlsbCBpbiB0aGVpciBpbmZhbmN5LiBWYXJpb3VzIHZlcnNpb25zIGhhdmUgZXZvbHZlZCBvdmVyIHRoZSB5ZWFycywgc29tZXRpbWVzIGJ5IGFjY2lkZW50LCBzb21ldGltZXMgb24gcHVycG9zZSAoaW5qZWN0ZWQgaHVtb3VyIGFuZCB0aGUgbGlrZSkuXG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBBYm91dFxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFHQTtBQUNBOzs7Ozs7O0FBSkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFIQTtBQVFBOzs7O0FBWEE7QUFDQTtBQWVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/about.js\n");

/***/ }),

/***/ "./src/app/css/about.css":
/*!*******************************!*\
  !*** ./src/app/css/about.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./about.css */ \"./node_modules/css-loader/index.js!./src/app/css/about.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9hYm91dC5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Nzcy9hYm91dC5jc3M/OTBjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hYm91dC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYWJvdXQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hYm91dC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/css/about.css\n");

/***/ }),

/***/ "./src/app/css/home.css":
/*!******************************!*\
  !*** ./src/app/css/home.css ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./home.css */ \"./node_modules/css-loader/index.js!./src/app/css/home.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9ob21lLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvY3NzL2hvbWUuY3NzPzFhYzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaG9tZS5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaG9tZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2hvbWUuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/css/home.css\n");

/***/ }),

/***/ "./src/app/css/images/ac.jpeg":
/*!************************************!*\
  !*** ./src/app/css/images/ac.jpeg ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9pbWFnZXMvYWMuanBlZy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvY3NzL2ltYWdlcy9hYy5qcGVnPzAxNGYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELzRneFlTVU5EWDFCU1QwWkpURVVBQVFFQUFBeElUR2x1YndJUUFBQnRiblJ5VWtkQ0lGaFpXaUFIemdBQ0FBa0FCZ0F4QUFCaFkzTndUVk5HVkFBQUFBQkpSVU1nYzFKSFFnQUFBQUFBQUFBQUFBQUFBQUFBOXRZQUFRQUFBQURUTFVoUUlDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkZqY0hKMEFBQUJVQUFBQUROa1pYTmpBQUFCaEFBQUFHeDNkSEIwQUFBQjhBQUFBQlJpYTNCMEFBQUNCQUFBQUJSeVdGbGFBQUFDR0FBQUFCUm5XRmxhQUFBQ0xBQUFBQlJpV0ZsYUFBQUNRQUFBQUJSa2JXNWtBQUFDVkFBQUFIQmtiV1JrQUFBQ3hBQUFBSWgyZFdWa0FBQURUQUFBQUlaMmFXVjNBQUFEMUFBQUFDUnNkVzFwQUFBRCtBQUFBQlJ0WldGekFBQUVEQUFBQUNSMFpXTm9BQUFFTUFBQUFBeHlWRkpEQUFBRVBBQUFDQXhuVkZKREFBQUVQQUFBQ0F4aVZGSkRBQUFFUEFBQUNBeDBaWGgwQUFBQUFFTnZjSGx5YVdkb2RDQW9ZeWtnTVRrNU9DQklaWGRzWlhSMExWQmhZMnRoY21RZ1EyOXRjR0Z1ZVFBQVpHVnpZd0FBQUFBQUFBQVNjMUpIUWlCSlJVTTJNVGsyTmkweUxqRUFBQUFBQUFBQUFBQUFBQkp6VWtkQ0lFbEZRell4T1RZMkxUSXVNUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdGbGFJQUFBQUFBQUFQTlJBQUVBQUFBQkZzeFlXVm9nQUFBQUFBQUFBQUFBQUFBQUFBQUFBRmhaV2lBQUFBQUFBQUJ2b2dBQU9QVUFBQU9RV0ZsYUlBQUFBQUFBQUdLWkFBQzNoUUFBR05wWVdWb2dBQUFBQUFBQUpLQUFBQStFQUFDMnoyUmxjMk1BQUFBQUFBQUFGa2xGUXlCb2RIUndPaTh2ZDNkM0xtbGxZeTVqYUFBQUFBQUFBQUFBQUFBQUZrbEZReUJvZEhSd09pOHZkM2QzTG1sbFl5NWphQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJrWlhOakFBQUFBQUFBQUM1SlJVTWdOakU1TmpZdE1pNHhJRVJsWm1GMWJIUWdVa2RDSUdOdmJHOTFjaUJ6Y0dGalpTQXRJSE5TUjBJQUFBQUFBQUFBQUFBQUFDNUpSVU1nTmpFNU5qWXRNaTR4SUVSbFptRjFiSFFnVWtkQ0lHTnZiRzkxY2lCemNHRmpaU0F0SUhOU1IwSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWkdWell3QUFBQUFBQUFBc1VtVm1aWEpsYm1ObElGWnBaWGRwYm1jZ1EyOXVaR2wwYVc5dUlHbHVJRWxGUXpZeE9UWTJMVEl1TVFBQUFBQUFBQUFBQUFBQUxGSmxabVZ5Wlc1alpTQldhV1YzYVc1bklFTnZibVJwZEdsdmJpQnBiaUJKUlVNMk1UazJOaTB5TGpFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhacFpYY0FBQUFBQUJPay9nQVVYeTRBRU04VUFBUHR6QUFFRXdzQUExeWVBQUFBQVZoWldpQUFBQUFBQUV3SlZnQlFBQUFBVngvbmJXVmhjd0FBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBbzhBQUFBQ2MybG5JQUFBQUFCRFVsUWdZM1Z5ZGdBQUFBQUFBQVFBQUFBQUJRQUtBQThBRkFBWkFCNEFJd0FvQUMwQU1nQTNBRHNBUUFCRkFFb0FUd0JVQUZrQVhnQmpBR2dBYlFCeUFIY0FmQUNCQUlZQWl3Q1FBSlVBbWdDZkFLUUFxUUN1QUxJQXR3QzhBTUVBeGdETEFOQUExUURiQU9BQTVRRHJBUEFBOWdEN0FRRUJCd0VOQVJNQkdRRWZBU1VCS3dFeUFUZ0JQZ0ZGQVV3QlVnRlpBV0FCWndGdUFYVUJmQUdEQVlzQmtnR2FBYUVCcVFHeEFia0J3UUhKQWRFQjJRSGhBZWtCOGdINkFnTUNEQUlVQWgwQ0pnSXZBamdDUVFKTEFsUUNYUUpuQW5FQ2VnS0VBbzRDbUFLaUFxd0N0Z0xCQXNzQzFRTGdBdXNDOVFNQUF3c0RGZ01oQXkwRE9BTkRBMDhEV2dObUEzSURmZ09LQTVZRG9nT3VBN29EeHdQVEErQUQ3QVA1QkFZRUV3UWdCQzBFT3dSSUJGVUVZd1J4Qkg0RWpBU2FCS2dFdGdURUJOTUU0UVR3QlA0RkRRVWNCU3NGT2dWSkJWZ0Zad1YzQllZRmxnV21CYlVGeFFYVkJlVUY5Z1lHQmhZR0p3WTNCa2dHV1FacUJuc0dqQWFkQnE4R3dBYlJCdU1HOVFjSEJ4a0hLd2M5QjA4SFlRZDBCNFlIbVFlc0I3OEgwZ2ZsQi9nSUN3Z2ZDRElJUmdoYUNHNElnZ2lXQ0tvSXZnalNDT2NJK3drUUNTVUpPZ2xQQ1dRSmVRbVBDYVFKdWduUENlVUord29SQ2ljS1BRcFVDbW9LZ1FxWUNxNEt4UXJjQ3ZNTEN3c2lDemtMVVF0cEM0QUxtQXV3QzhnTDRRdjVEQklNS2d4RERGd01kUXlPREtjTXdBelpEUE1ORFEwbURVQU5XZzEwRFk0TnFRM0REZDROK0E0VERpNE9TUTVrRG44T213NjJEdElPN2c4SkR5VVBRUTllRDNvUGxnK3pEODhQN0JBSkVDWVFReEJoRUg0UW14QzVFTmNROVJFVEVURVJUeEZ0RVl3UnFoSEpFZWdTQnhJbUVrVVNaQktFRXFNU3d4TGpFd01USXhOREUyTVRneE9rRThVVDVSUUdGQ2NVU1JScUZJc1VyUlRPRlBBVkVoVTBGVllWZUJXYkZiMFY0QllERmlZV1NSWnNGbzhXc2hiV0Z2b1hIUmRCRjJVWGlSZXVGOUlYOXhnYkdFQVlaUmlLR0s4WTFSajZHU0FaUlJsckdaRVp0eG5kR2dRYUtocFJHbmNhbmhyRkd1d2JGQnM3RzJNYmlodXlHOW9jQWh3cUhGSWNleHlqSE13YzlSMGVIVWNkY0IyWkhjTWQ3QjRXSGtBZWFoNlVIcjRlNlI4VEh6NGZhUitVSDc4ZjZpQVZJRUVnYkNDWUlNUWc4Q0VjSVVnaGRTR2hJYzRoK3lJbklsVWlnaUt2SXQwakNpTTRJMllqbENQQ0kvQWtIeVJOSkh3a3F5VGFKUWtsT0NWb0paY2x4eVgzSmljbVZ5YUhKcmNtNkNjWUowa25laWVySjl3b0RTZy9LSEVvb2lqVUtRWXBPQ2xyS1owcDBDb0NLalVxYUNxYktzOHJBaXMySzJrcm5TdlJMQVVzT1N4dUxLSXMxeTBNTFVFdGRpMnJMZUV1Rmk1TUxvSXV0eTd1THlRdldpK1JMOGN2L2pBMU1Hd3dwRERiTVJJeFNqR0NNYm94OGpJcU1tTXltekxVTXcwelJqTi9NN2d6OFRRck5HVTBualRZTlJNMVRUV0hOY0kxL1RZM05uSTJyamJwTnlRM1lEZWNOOWM0RkRoUU9JdzR5RGtGT1VJNWZ6bThPZms2TmpwME9ySTY3enN0TzJzN3Fqdm9QQ2M4WlR5a1BPTTlJajFoUGFFOTRENGdQbUErb0Q3Z1B5RS9ZVCtpUCtKQUkwQmtRS1pBNTBFcFFXcEJyRUh1UWpCQ2NrSzFRdmRET2tOOVE4QkVBMFJIUklwRXprVVNSVlZGbWtYZVJpSkdaMGFyUnZCSE5VZDdSOEJJQlVoTFNKRkkxMGtkU1dOSnFVbndTamRLZlVyRVN3eExVMHVhUytKTUtreHlUTHBOQWsxS1RaTk4zRTRsVG01T3QwOEFUMGxQazAvZFVDZFFjVkM3VVFaUlVGR2JVZVpTTVZKOFVzZFRFMU5mVTZwVDlsUkNWSTlVMjFVb1ZYVlZ3bFlQVmx4V3FWYjNWMFJYa2xmZ1dDOVlmVmpMV1JwWmFWbTRXZ2RhVmxxbVd2VmJSVnVWVytWY05WeUdYTlpkSjExNFhjbGVHbDVzWHIxZkQxOWhYN05nQldCWFlLcGcvR0ZQWWFKaDlXSkpZcHhpOEdORFk1ZGo2MlJBWkpSazZXVTlaWkpsNTJZOVpwSm02R2M5WjVObjZXZy9hSlpvN0dsRGFacHA4V3BJYXA5cTkydFBhNmRyLzJ4WGJLOXRDRzFnYmJsdUVtNXJic1J2SG05NGI5RndLM0NHY09CeE9uR1ZjZkJ5UzNLbWN3RnpYWE80ZEJSMGNIVE1kU2gxaFhYaGRqNTJtM2I0ZDFaM3MzZ1JlRzU0ekhrcWVZbDU1M3BHZXFWN0JIdGplOEo4SVh5QmZPRjlRWDJoZmdGK1luN0NmeU4vaEgvbGdFZUFxSUVLZ1d1QnpZSXdncEtDOUlOWGc3cUVIWVNBaE9PRlI0V3JoZzZHY29iWGh6dUhuNGdFaUdtSXpva3ppWm1KL29wa2lzcUxNSXVXaS95TVk0ektqVEdObUkzL2ptYU96bzgyajU2UUJwQnVrTmFSUDVHb2toR1NlcExqazAyVHRwUWdsSXFVOUpWZmxjbVdOSmFmbHdxWGRaZmdtRXlZdUpra21aQ1ovSnBvbXRXYlFwdXZuQnljaVp6M25XU2QwcDVBbnE2ZkhaK0xuL3FnYWFEWW9VZWh0cUltb3BhakJxTjJvK2FrVnFUSHBUaWxxYVlhcG91bS9hZHVwK0NvVXFqRXFUZXBxYW9jcW8rckFxdDFxK21zWEt6UXJVU3R1SzR0cnFHdkZxK0xzQUN3ZGJEcXNXQ3gxckpMc3NLek9MT3V0Q1cwbkxVVHRZcTJBYlo1dHZDM2FMZmd1Rm00MGJsS3VjSzZPN3ExdXk2N3A3d2h2SnU5RmIyUHZncStoTDcvdjNxLzljQnd3T3pCWjhIandsL0MyOE5ZdzlURVVjVE94VXZGeU1aR3hzUEhRY2UveUQzSXZNazZ5Ym5LT01xM3l6Ykx0c3cxekxYTk5jMjF6amJPdHM4M3o3alFPZEM2MFR6UnZ0SS8wc0hUUk5QRzFFblV5OVZPMWRIV1ZkYlkxMXpYNE5oazJPalpiTm54Mm5iYSs5dUEzQVhjaXQwUTNaYmVITjZpM3luZnIrQTI0TDNoUk9ITTRsUGkyK05qNCt2a2MrVDg1WVRtRGVhVzV4L25xZWd5Nkx6cFJ1blE2bHZxNWV0dzYvdnNodTBSN1p6dUtPNjA3MER2elBCWThPWHhjdkgvOG96ekdmT245RFQwd3ZWUTlkNzJiZmI3OTRyNEdmaW8rVGo1eC9wWCt1ZjdkL3dIL0pqOUtmMjYva3YrM1A5dC8vLy8yd0NFQUFJREF3TUVBd1FGQlFRR0JnWUdCZ2dJQndjSUNBMEpDZ2tLQ1EwVERBNE1EQTRNRXhFVUVROFJGQkVlR0JVVkdCNGpIUndkSXlvbEpTbzFNalZGUlZ3QkFnTURBd1FEQkFVRkJBWUdCZ1lHQ0FnSEJ3Z0lEUWtLQ1FvSkRSTU1EZ3dNRGd3VEVSUVJEeEVVRVI0WUZSVVlIaU1kSEIwaktpVWxLalV5TlVWRlhQL0FBQkVJQTVJRkxRTUJJZ0FDRVFFREVRSC94QUdpQUFBQkJRRUJBUUVCQVFBQUFBQUFBQUFBQVFJREJBVUdCd2dKQ2dzUUFBSUJBd01DQkFNRkJRUUVBQUFCZlFFQ0F3QUVFUVVTSVRGQkJoTlJZUWNpY1JReWdaR2hDQ05Dc2NFVlV0SHdKRE5pY29JSkNoWVhHQmthSlNZbktDa3FORFUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2ZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJoNHVQazVlYm42T25xOGZMejlQWDI5L2o1K2dFQUF3RUJBUUVCQVFFQkFRQUFBQUFBQUFFQ0F3UUZCZ2NJQ1FvTEVRQUNBUUlFQkFNRUJ3VUVCQUFCQW5jQUFRSURFUVFGSVRFR0VrRlJCMkZ4RXlJeWdRZ1VRcEdoc2NFSkl6TlM4QlZpY3RFS0ZpUTA0U1h4RnhnWkdpWW5LQ2txTlRZM09EazZRMFJGUmtkSVNVcFRWRlZXVjFoWldtTmtaV1puYUdscWMzUjFkbmQ0ZVhxQ2c0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaTQrVGw1dWZvNmVyeTgvVDE5dmY0K2ZyLzJnQU1Bd0VBQWhFREVRQS9BUHh2a2UrdkdMc1dZMTNHa2VHcDdwMWRsSUhIQUZlbHdlRXJTeWxTYTh1RkRzbnpSS2ZsQjlxMnJyeFhwOWpFRmdWQ1FNWUF6WDA5UER4aTcxcFc3cStwOGZVeG5ORlJvUjV1elMwTmZTZkI4TWFoM3dDT21hN1UzbWlhZEUzQ0hhQnllSytaZFE4YmFwY0FoRHRIT0s0NGpVcjA3bUx0bnQyelhWOWRwd2RxVk8vbXp6djdQeE5XN3JWYkxzajZCMUw0a1c4TE5IRU00NkVWNVRmZU5kVG5MRkRnSHZubW85UDhHM2QwMlh5Q2VneG44NjlpMHI0Y1pHWElIMTdVN1kvRU96YnQyQlF5ekRKeWFpMnVyM1BuZnl0UnZtenVaczg4MTJGbDRRdko0d1NEa0VaQUhOZlU5cDRYMG13STgyUmZsNml0dzZ6b05qdUtCZW5jOFZzc3RoRnAxYWlYek9kNTBwSnFqU2sydkt5UEROUCtIVXo3R2FQYVBVMTdOWWVDTEszVmZPZE1CZU9ncmp0UStKVmpDUDNiS2ZZYzE1RnFueEd2NXlmSlFxT2V0YnF0bDFGV1VlWm1MV2IxdWloRi9lZldzRnRvMW1keDJqYWVPYXh0VDhZNlZacXlpUkI5SytJTGpYTmF2U04wN25QUlJrVkl1ajZ2Y2tNd1lrbmpKNmlzNVpuVTJwMFVpbGswV2xLdFhjbjJQb0MrK0tNZnpLaExEMEhyNjE1cmQrT2RWdUE2SjhxZ1pGWU1mZysvY3IrN2ZIY2dWN1RwSHc0M1Jxenh0Z3FNWk5jMy9DaldldDBqYU1NcG9MM2VWdGI2bnpxMTVyTjR4ek94VStsYUVlajZoY0lOc2JISHJYMTFZK0I3UzNPeHRuWEI5cTdaZEUwYXpnVSthZ2JqanJ4Vnd5dXE5WnlzdTl4Vk0zdzBXMUNOMzJTc2ZKZW5lRWJ4cDFSMHgwNDlLOUZ0L0FMUElkeUhISTZjR3ZhenIraDJtUUFHSTc0eDBxaGRlUDdDRXNWMkU0eVBhdWo2bmdxZXM2aVo1OVhNOGJVNVZTb3ZYUXliUDRkYWVFQmRGRGROb0dQeE5kTEg0WnNyWmh2VUQ1UXB4eHg3VjQvcUh4TWpZc1VaODV4a0N1Q3UvSHQ5THVHV1BwazhVcFl2TDRmREM0NFliTmFrbnpUY1UvTSt2b0UwcTIrVlF1Y2NuclRuOFI2ZkNzbUZCMmo3eHI0WHVQRUd1WEFPeWJia2Rxd3BKdFluM0p2bGNIcmduQi8rdlVyTkxMM0thU0wvQUxIbk8vUFd2NW4yUnFQeEh0VVVxaklGQSt2RmVlWG54TGdMWldYSUhPQU9hOEtYdzdxY3lqTnM2bjM3aXRtSHdScUx5S1J3Q2NmTlhQTEc0Mm83UnV2UkhYVHlyQVFWNXU5dXJaMDExOFFyeWRmbGhJd2VDVFhKVCtJOVh1WW04c1pIZjJyMHZUZmg4Z0pFck9XNUFYc2E2KzA4Q0pCQklvaEFMWTV6eVBXczNReDFSNnVSMGUweTJpckpSZlkrV212dFVrSUxTTmduZ0ROV1lkTDFpNGNzSUpYSHJ6WDJaWitGTE5iY1JDTk91NDhjOGU5YmNlaXcyb1k1MjdpTytSV2l5bXM5Wk94aFV6akN3Vm94MVBrZXg4SGFsTFBHV2gycm5vVGdtdXRYd0ZLejRJSXpuT09vK2xmVWNRMDlISDNTUjZtbjNHcjZSRU1GZ3VEeU0xMXd5ekR4dHpWUHhPR3BuZFp1MGFQb2VDYVg4TmJjUm43UnZKSjRBR1B6cnVySHdkcDBXQ0lBU0JqSnJmdXZHdWx3SW9Fb09QVTlhNUdieDlZSXB3Y0RkbkhVMXM2V1dVL3RLNitaenJFWnhWbnBCcVBUb2Q5WmVHN09IZnRqUmV3ei9LdXNHbUpIRkdwWk5vSVBHQlh6dGRmRUtGU2RzYmRlcHJrN3Y0aGFtemhZNGhnOU9jMFJ4ZVhRVHRHL2F5S3FZVE5xMGtuUFRyZG4yVThXbHFxN1NxWUJ5QWVhb3czR21vN2xqa1lISXI0eW04VjYzUEdDSlZYa2NIcldTdXJYOGhQbTNiSEhUQnJKNXJUV2thYk5JWk5XV3M2MnYzbjNIZStJdEh0ZzRWVkJ3T1RpdWVpOGM2UEU0VVRJdUI2NXI0MmtkcEpBd2FRNXhqa24vSXFHTzB2bnZIMlcwcFUveEJPbFkvMmxYYnNveFJVc3BwYnluSStzTHo0ajZlazdFU0ZzL2R3T1Axcmw3ajRsWEc4QllHSkk0SlBCcnhsZkMycnl4Z3BBY0U5RzY1RmRWSDhQZGRNU1Nia1hPUGtKSnhXVHhXT20wazVmSkhTc3Z3RVkzZG42eU9vUHhDMU5TNmlJRldIUnUzcVI5SzVTNjhZYXhKSis3bkVZN0hITmRKSDREMUZJbGFWOEFrOUJuOHE2UWZEeXdaTnpUU0FrQWJHSHIzRkRwNWpPM3hmZlloUEs2Ty9JbjZYUEswMWpWWnJjTTJvTm5kamc0TmN6UGQzTXJHUjd5WEdlbVRuajFyNlIwM3dIcDhlUUl3KzRuRE1jNCtsZGhZZUI3WDdRcStRZ3loR1RqQnJTT1hZdVYzS1NYcTdtMzlvWUIvRHIyc2o1RFY3aTdnMnBISXpiVGdybkpIcFZTMXM3OVpYSXNKSlA5a3FRRGpqTmZvN1orR1lyY1lFTU1SUVpJVUQ1aDY1OTZoVFE3UnBuWXpDTU1NZ2tWckhLNXQ2MUY5eHkxTTNveFNTcHY3N0h3OE5BMXE1dzQwdnljZ2JjODlQNVZvSjRDMXlXZFhnOHVKajBMTmdnKzFmYjhWaGIrV2plYXFkanVQRFk5SzJsc3RJR1hNb2ZIWWp2WFpIS2FTV3Myenozbk5WcjNhY1Y2dTU4ZTJYdzYxc3hFVDNxcXhPY0FiZ2MxdHdmQjN6OHUxekkwaEdjakFHQjdWOUhTNmpvZTJNS3ZZOGhzSDhhc3I0bTBxMGhjSUFPT1daeC9TcWVCd2tVcnQvK0JFLzJyaUoyOTJLWG9lQVFmRG5UcmU1VnBFWWxRRHRKeURtdWtrOEU2UExjS3NkaXFzL0FIWWsxdDNuaS9UR25hUTNLY2pubmdld0ZaeitPYktJcW4yaFR1SXh4bm50elZTaGwwYmZEOTl4VThWbU00djR2S3lzYVZyNEN0NHBweWJhRENqQjRIRmRpdmh1M0R4S3V4VUNnRElyeTI0K0lsa3M4NjduTXFybDFBN0R2WE9mOExQc1hHRVdSMzY1WTRxdmI0Q08zTDhrYzNMbWsxcXA3OVdlN1c5b2JhNmxpa1JXMzlIN0tQd3FRd3hSU21KaW1EaHQvWDhLK2RaUGlUYmJYZnlIemc4RThaRmNpL3dBUnBKQ3JpSHl3M0dEMXFwWmpoSTZwTjZkak5aWmpwdlYyVjMxUHRCTGF5UURkZEkyQ2NvRjY1NzVvbVhTeHd6bHNwak9NNHI0a2s4Y2ExdExSM01hNTVCMjgrNDU3MUIvd20ydXoyN0xMS2NLY2xnT29yay90T25mU0xPMldVVmt0WnhQc2xmN1BRSUkya1laNkhqOWF0VytxMmFTeXN3akdYNEJPU1B4cjg5NzN4RnJjOHVZcDVVQzQ0ejFxNURkYWpjTGhIa1dSais4WjNPQ1BVVmpMTk5YYW4rSmNNb25IWDJ5WHlQMEtiWDlPVmlUc2NuQVVNdzYrdGMxTjR3Z1NYNTdpRlpFQkhicG5wWHdmRkRyRVU3cW9rdVZ6bjVTVzRwdHZZYXhkeXlxbG5LZVFQbUI2L1dvV1pWZjVFYnl5bTZUZFYyOGtmY1YxOFFOSlJRVGR4aGlPU0JXWEY4UzlDRGIybE1oL2lmR01IM05mSmE2TjRsdVdLSFNwQUVYQk9NbmozcmJpOE02b3hVTmJYQVYxTzVRdURrZE0wbmo4VDBpdnVMV1ZVTGZ4SmZnZlNSK0xGZ2o3Q1ppakhoZ000OTZqL3dDRm5XL2tNOE1jMGpFa0ZjZGgzcnhkZmg1NG9qdDR0aFFkbDNuSndlZWF0VC9ETHhKYndBeXlGSkc2YldJSFByV2J4R05leWQvUTFqZzhGZjNwcXkvdkpIYlQvRW03dUkzWkxWY0RvTTRPZlRudlhLWFB4R3UvTURKYmhDVnlRQ1RnMUxCOE5OWUVaSnVRc2dYNW1ZWnlQOGE2VzErRzBNOXQrOXZncmpKYmpHVFV1V1BmOHhxcU9XWCt3N2Vkemg1ZmliZkNSRmlWVkhHQ1JqbW0vd0RDMXZFWG5Nd21GdXc0eW80eDB6bXV2ZjRWV1RlVFBKZXU2bklLcndjQ3R1SDRYK0gzQTVtNEl3YzlCNzBleHgwdDcvZVhLZVdSVmx5MzlHenpNZkZUeExBbDNCRGNCb1prWGY4QUxqZGc1SDVHdVFIalB4UEloWVhzcUZoajhQZjJyNlNUNFkrSG9ia2N5TndCZ25nNXJyeDhQZkRXQXYyY3YzeUR5ZnBWL1ZNWTkzK0pFYStCdjluVCs2ZkgwSGlqWENyQnI1eHRiQlhzUlZTODFYV3BKSHpkUHR6eXFuSXdmZjFyN09zZmg5NGFqbFAvQUJMUklEemx5VHpYWlJlRTlBV0hJc1lZaXpZS0ZUODMwcGZVcTk5Wkw3eW5pOEhHelNkdktKOEJuVlMxdWlyNXpJcjhCbVBmMzlheHhlWGtrYnhGSFlOMk9UajNGZm90RG9la1c4cTdyT1BZT1N1MytWYmtlbDZaTkc3dzZkRXUxdVBsQU9QV3Erb1ZrdFpJVHpEQ05xMFpOOXJINXphTjRaOFlhdTdKcDJtM055eWpMS2lNY0tPNU5RalRQRlF1TG1EN0U4WlpBakRiejh2ZlBZMTk4VGF6NCswa3lONGExT095bmtVeFBtM0RxVVBzY2ZNT3hxRzBzci83SUh2TDFydTZmUG5UT2dIbU1lcHdPbGVjc0JpM2lKUmNWN05KV2xmZCtoMFBNc0VzTkdTVXVkdHBwMi9RK010UStFL3hHMGkyanU3clNaMFM0UU5IdjZsVDN4WEYybmhIeEpkelhUZllaR0c1VjJvT2grbGZlOWhaK09ieTZnbTFmeEhmM2xyYUtZcmEya0txa2FIb1RqN3hIWW11anRFbWdXVDk0KzVwUUZLZ1pQdlcxTEFZaHhqN1N5bGZwdFlyKzBLS2hLMGJybHV0ZitBajRGaCtIL2lhTm1EYWZNQ0Iwd01qM3JVdC9BT3ZSM2FueUpNcUR5NHh4WDZBdkZmSThubFlZamhzSHJubnZUb2JLNWQ1Q1NRbnk0QjduMjlxN2ZxRVV2ak9IKzBiVC9ocytIRDhNZkYxMDBieFdvS08yQzJlbjFGVHlmQ3J4aERQSUhSQXpISExqbjNyOUI0cmVTT0pVRE1BUDRRY1lOUVQyUVdRVEFzL0JCREhQNDVwUndNSDFOSGpwT0xhcG8rQ0l2aFpycXd2TkxORUdRNTJsL3ZIMUJxT3krRit1M1V6bEpvazNaSjNmNDE5d0xvNG1NWlNOMVVqa2draHMrZ3JUK3lXbHRKdDNaVlZJSEdOdnRXcXdGSlhYTTcrcHpQTUsrN3B4dDUzUGk5Zmd6cXd1by9OdjdjQVl3d09PdnBWZTYrRGQ2c2t4VFVFeWpIT0JqUDFGZmE4ZW1XMGoyeXJIdVNNbHVUVzVMcFdueVN0SjViS2VyTnUvU245U3c2NnNsWXpFT0w5MktQaGJTZmc3ZFRPTTMxdXhBM0VTRGIrUlBXdXVmNE5XOGFBdHF5STViY0VSTWcrdURYMXgvWTFqZFJ1c2VOK1FGTEVEOHFobXRZclZ2SnpsbFlFNE9jRWRhVHdtSHZvN01wWXpFY3Z3cTNjK1ZyTDRPSklKZksxYkRjc053MjV4MkdlOVU3YjRONmRLWDgvVVpXeTN0ako3L1d2cnVTN3RESWdkRkoybmhzYzFoZmFMTVBHRnQ0K09wQjcrdEN3bUhlNy9FdjY3V2ovQU1NZk5VZndaOE9LWkZrdXBIY2o5MlF1ZWxVWi9oRG9NUVVDOW1VRS9leDBOZldXWXZsbVoxYmc0QVliaDdVNmErc2NCUVZLbkh5dGorZFg5Vnd5c3RQdk1mcjJMZDl0UDd0ejV1dVBnYm9TaEhYVTJrUWdiU25jNDV5T3RhV20vQ1B3eWdlTmIwaDNJTGJoZ3N3K3RleVR5MjRpVlk1TnZ6NTNidWY4aXRDQzh0RkNaTWJ1WHp5M1NuOVZ3cVRkNy9NcDQvRXVhK0ZMcm9mTnNmd2s4S1NmYUhNc3krWElRd3o4blBjMWNYNE8rRjQwamRubWRUeTJIK1U1NkVDdmZMeTgweUVmdXhEKzhPNWx6a2c5L3dBS3lQdHNLVEVHYUVxRjRVSEdQYXRGaHNMYlpmZWN5eG1LNXJLYWJYWkk4cXVQaDM0V1NURnZKY0o4b0RZT01rZXRhY2Z3aDhKWE1CZTVNMGt1M09TeHpnZHZyWHBNR3IyRnV5dTdJUTNCeVFlYXZYR3YyRXNpN2JwRlVjZGhuRko0YkN0cEpMMU5vNDNFdThwYStWanlWUGhONFpNR3dXa2hYYmtZYm5IdlRCOE1QQmtNQWxrdDVpQ0Q4Z1BJUDFyMVJ2RUZvQVU4Mk1jRUU3aDBxcEhyZG9KblZMbENoQXkyY2pQME5OWWZETG9pZnJ0ZHRXZnpzanlpMCtIWGdocmVSVFp6cytDeXNUdEgvd0JldFNQNGErR3BZU24yTmxRam41c0RtdlJwTlkwZkRGNW94dFFsQXB6ay9Tc0Z0UTB5YXlXVDdaR3JGZ0RIdStmMXo5S3IyR0ZhMHNqTll2RnhiZk0zcDZIUEQ0V2VGSTlxcERMc1hCKzlnajZHdEMxOEIrQmpHWTVMR1R5bGNaM1NIayt2MXF6L0FNSkpwU1NHTDdRbVdYNXN0Z0VqME5hMG11NkVZbzFlOWpDTW9VNVBRNXJQMk9HWFl2NjdpWDlwSElId0g0UEQzUDhBb0xFWXpFQ2NZeDYxbFQvRHp3ZkQ1VWsybk9yWTljZzUvcFhjblc5Rlc0TGZiSWlDbTNJUFpleHFXMDhRNlJMT1pGdW9TQXZ6S3g5T21BYUhSd245MFVjVGlwdjQydFRrRThHK0U5ck11bkZNa1l4MEE5eFdacTN3NDhJK1drb3N1cEFPMWpuSjdWNldmRVhoMDVrTTZodHVkb0l4OUtkTjRvMENhSk1HUEE1eVNPVFVLbmh1WkwzVFQ2MVhpcExuL0E4cjB2NGUrQzFuWVBadHM1K2FVbGNlMlBXa204QytIR0lSWURzZkp3Q1QvazEzOTNyWGgrY3d1YnBUc1BIT01lMmU5Ym8xdlFZUnVqblFoaU1FNDdVL1pZVFg0VE9XSnhUZWs3SThOLzRWbjRZdDRwQ3lPTng0eWVSVnJUZkEvZ1JOc3R3SkpFLzVhS1RnZ2pzZmF2VWJqVWRBbm1MR1JFeGtGODhHdWR1N2pRektNVG9NcnlCMGI2MWNhT0ZhNkwwRkxHWXFLdmUvcVlGejhOdkJOeHZaWVdSR0JaQ2paR0s1MC9DM3dXSWtaSkpabTV5T2dUMHJzenErbndoSUV1SXdvYnAweUsycmJXdE1TVjEvZHFnYkFZYzVIZm1uTEQ0VGwzaS91T1dubU9MY3JOMitSNXd2dzc4T3NDSkVrWlF2VUg3djQxaVMvQy9RQkU4MGF5cHNHTndQcjYxN25McVdsTGF4eXczMExBT2ZsR1EzNGlzdVBWTGFSbjNYQ2M5Um5BSTlNVkVhR0ZhK0dKMS9YTVhIN2IyN0k4WnR2aGI0YSt4RXl5WEFZTHVMWnhpbHQvaGI0YWVHUXhYY3drMjVHZWhGZTRTYWpwc2VXYVJDc29La0J1MzBxa2RUc0RFVEc2TEdoMmtEMG9lRndyMlMrOGxaaGlGOXBPM2tmT1QvQUE5c1ZrWkROTDgzQkFBNXJWdGZoUnBjcTVlNG1LSWZtNHdBUGV2Y1VuMHVlVGhzQmU0eVRYVFEyMm1iVnplbmE3WllNMk9Qd3JiNm5oRkhWR2J4K01sOE0wdnVQbW8vQ3pTMTh5U0RVd01EbUxPSHg2ak5iT21mQ1RRcHJXU1pyeTRHdzhLeEdOMWUxM2NPa1NYUUVkMUhJcEoya2NFWTdHcldteVdna2VOWnVNWU81czhqMXFIZ3NMdXZ6S2htbUtqTGxrMDdPMnkxUG1HNytEbWtrd2g3ODVrSnlCenRIKzE5YTVxRDRJQnBuTWQ0Y0IrVDdlbGZZN0N6aGxMaVJHRGMrWVNPM1lWREJxQmlmOTJ5WVp6MElJYW04RGgydFB6QlpwaUZPMWxiMFBqOXZoREMwc3FpKzJtUE8zakFyRmcrRnNzNlBFYnVObUp3cnNPaHI3VlpiR09aczdXY25MQXNDUm1vcmZUOVBSVGlZRm0rWXFQdkxVU3dHR3N0L3ZMaG1PS2IxdDl4OGF2OElicUdSVWU3akw3U1MzYlBwVEQ4TTlVZEpBd1JueGlOMFBVMTltZVhheVNDTmtSdVB2ZE1VeHhhcHNVU2RINStudFV5eStqcHY5NWY5cTRqVzhZL2NmRm4vQ3I5ZWhqVjJhSnR3d1FHd1Jqc2F4Yi9BT0Z2aU1iaUxjYlNBUVEyZXRmY3IyQ004ajd3d2tQeTU3RVZtWE1GdzdqRTJBdU9nNFAxcVA3T3B2cXlQN1dySnYzVWZDQitHL2loY0R5Vlk5Z0c5TzFBOEI2NWJYU2VacDdobVhJQlBJLyt0WDNxOXBNZ1YxWXI4MzNqL1NyVHd6WEUwVWswNGtjRGJ1UFpSMlB2UXNzcC93QXpOUDdWcUxhbW1mbjdQNEc4US9hREo5blpsem5ibmdWQ3ZnbnhDNy91N04xd0NXSzkvYXYwS0Z1TU9nVWdkT0J4U3hhZEpiN0dSMUkzRElKcFN5Nkg4N3Nid3phUy93Q1hhUHpXdXZDM2lLMmpJbGdsVFBmYWVhNXg5RDFLTUUrVk56MGJhUUsvVU84dHpLN0IwUXNQNGg3K3RWcExHQjdVN0FtVVlZempyNzFtc3RUdGFabzgzanJlbHQ1bjVoalJkVVFyaEpCeHV5VlBOWFRhWEtJenlRc05wMjR3Y1YraXAwaVlsNUhFYkJoZ2djbjhxRzArd2t0bEU4V1ZVOC9MeFV5eXVTZWsvd0FES09kVXRMMHBMNW41dW0xMVdNdElaR1VBRWpka2ZsVmY3ZGZycy9ldHZibmp0WDZKUzZkcDF5Z2krd3I1UzlDdzViM05RV2ZoVFJHbWZ6YkJUZ0VqajVRUGMxUDltMXY1a2J4emFoSjYwMmZBUDlyYXNpQWVlN0VuSkpZbmoycTB1dFg0bWpDeXpFRSt1TWU5ZmRsNTROMFdSUE5GdEdRT2dBNkQzeFdVL2dqdzBzZm1OcDdibWJBMnQxL0NvZVhZaGJUUnFzZGdtL2hmM0krTjUvRWVwUnNxbWVSc0RJR2V0U2Y4SlZyb3R5NW44dFg0eDZDdnFPOStIZWlYU0p0c25qeVRrNzhuajBxcy93QU5OQmtoQ2lGbFplUjgyU2NlMUgxVEZwNlA1M0Y5Y3krVzhVdiszVDVZdHZHMnVwS2NYU25IQVBxSzNrOGRhdms3WlFlYys1eFh0Y253dTBtYVVPc1Vpb1B2Yk91UlZLYjRXYVFFZlplT3Ivd2hoeVJSOVh4NmRrMzk0UnI1VzAzeXgvOEFBVHpnL0U3VVFrSk9Hd2VSakdha2I0bTNmbTdXaEdXT1J6eld4TjhLM1NWVUZ4a01QbGFxMXo4TFpZcDBNcnNId05wOWFiL3ROUDdSbEdsbE1sdEJraS9FYWVGdDhrV1ZQSEhTcjhmeFh0VzNFb3c2QTU1eFhIM3Z3ejhSeWgzRXNaaFhnQS9LTSttSzVGdmhacmFrTndTUVR3ZlNqNnhtVWJhUys0Y3NIbE9xNW9KZjRqMytENHEyVVNmSk95K29IZXQyTDRuMk1nOHhwUUNwSERjazE4cFd2Z2pWSTJ4SmJ2azVBQTduMnJJdlBDT3Z3bmkwa09EOWVhYXgyUFR1MWY1RFdXWmRzcGZpZllzZnhCdEpMdnpoT2dmSGZwelhSdDQ4MHFRcGlTSGNUeXErdGZBZzByVjR5R0Z0SUdCNmJTZW50VlNTMjFnU0g5eE1HNmphaEJyVlpwaVk3eFYvUXhlUzRkeTkyY2t1eCtoOG5pclM1SkJLU2hjOEhCR0JXaXZpV3dadHp1aEdNZGNqRmZtaVp0U0NrTTdnOU1FSE9hMDRMNjhqaEI4eCtUZ2lyL3RhcjFnbVlQSlZyYXF6OUpsMW5TcGlDQ01qQnljY2owcFZrc0xxNkVnZGM5OG12enB0dFl2bHppVmw1KzhXNllxN0o0c3ZnUjVjekJlNTduRlhITm85YWY0bUt5ZXFscFZUOVVmb3hGYmFSYzNBVGNtZHVjbkFIdldjK2w2VXNyUks0Q3NjWkhRVjhLUWVLYmtSS1JPZHc2a25yVnRmSE9xeGtFekt3SFRKcmRacFJ2NzBHUDhBc3ZFOHFTYWRqN1F2TkV0TUtCdE80NEQ4WS9HcVgvQ09XVXNhaFVRaHVHYkZmSThmeEd2Q0FDdkE1NE5kRGIvRXU4aVhoY2pPUUNhcFpoZ1pQV1A0SEZQTHN4aTdxL1RSU1BmbjhBMnNwWWZaOGoxSXdEOUs1TzQrSEdueHl0aTFIemM5RFhLMjN4T3ZKRWRzRmNZNHpXaW54VktERGJ2eE9LdjIrV3o2SmZJNkhETll3MmszNjNQaDIrMXpVYitZUE01K1hvQngxclVzTkp1YnArRTYxNnhvL2dPNHl6M3UyR0lBRlFmdmZqWHE2VGFEcFVZQUNrK3A5dTlmTDBzSkp0eXFPeXYxM1BzNnVPcFVrbzBvODd0b283SGx1bWVBcDVpcFlEbjFIU3ZiTGZ3aHA5cENubXV1Y1Y1enFQeEZ0MEJTRG5IOTNpdkw5VThXWDl5NDJPeUFqT2M1cjFJMThEUTBqSG5aNGM0NXBpbGR2MlM4ajZtbjEvUmROVDVkZ3dLOHgxUDRseFpaTGRkK2U2MTg3L1k5UnU1YzdwSlByMHJ1ZFA4QUNGL09RTmhBSTlLVHgyTXF1MEk4cThrVkRMTUhSamVyVWN1N2JJTDN4WHF0d3grWUtQZnJYTGVYcVYyZXJ2dVBHSytqTEw0ZkQ5MjdoUVIxWTl4WHBOcm9Ha1dvRFNGVzJuMUFxSTVmaWF1czVXOVRhcG11QXd5dFRncFArNmo1SXMvQzJvekQ1WThaUGZrMTZiWi9EK2VXUlNWUFFkZU1WN24vQUdycE5tU1VqWEk2SHRYRmFqOFE3U0FOdGRTZlFWMGZWY0RTWDd5cGRubS8ybG1PSWY3ckR1SzdzdDJIZ08wZ2RTK0ZJcnJsMDdSN052bmRTUWUvUDQxODUzbnhNdUpEOHFrMXlXcmVJdFZ1TVNwd3NpNUhPYWYxL0IwLzRkRzdYVmpqZ00xcTFMMWEvTEY5RDY5bjhUNkphUnNzVWFNU01aTmVlM3Z4RnRJVUtBNDcvS2ErVTdhNDFXZVFzVmtjZDYzTGJ3N2ZYRE14aXg5YTVKNWxpcWo5Mk5sNUk5Q25rK0hvM2xPYmsyN3U3Tzl1L0gxeFBJeW94N25PYTVDWHhmckV1NExJVkMvalcvYStCWjNaZVdZRWpKVGpIdFhxVmw4UFVqd2ZzNStZL3dBUnpYUDdMSFZkK1k2NVR5NmgvTGMrZC90ZW9YcjdzdVJqbkFOYVduK0g5Um1jN1k1T2M0Sk9LK3RJZkIwRUlENFZWQjZBWXJyNDlLMFNBSE1vSFRxYTNobGxWdjNwSkhGUE44TXI4aWIrUjhpd2VGTDh2KzlmaGh5TzlkcGErQThnSDVuejJQRmUrVDZub1ZtUWR5SEF3UmpPYTVtNDhlNlZBZHFxaE9PMWJQQ1lLbnBPcW16R09ZWXlxcndvc3EySGdJSkNjUmduSTVQOUs3aUR3ckRDZ0pVTHRHU2NWNU5lZkVyUHlRMjdaei9DYTU2NThjYXJjeEhhTnBIWExkcTNXSXkybXJSZzM4am1kRE1xeWZNN1g4N0gwY0xUUzQyQmRrT1NPZXBxS2ZVZkQ4QUkzamc4Z1Y4YTMyczZvWFhGMFFHNmdkcTUrZWE1ZFczU1NNeEk1QjVySjVxa3JSb3BDaGtsVnlUbmlXL0t4OWhUK01kR3QxWUkyRkJ3TTllYTVDNytKRVczQ0RJQndEMU5mTzF2YjNVbTlURktTY0VaSFd1anR0QTFJT01XNUJibmtWeVBNTVZQNGRQUkhvMDhxd3NOWlNjbjV1eDNqK1BydVRJVzNZNTdkTTF6RjE0czFzNHc1VWM5K1FhMllQQjJxeXFubXBnWUJCNkVWc3cvRDJXVWxwTGp2MnFXc2ZVL25menNiSlpkU2V2czErSjVVTmR2MkpTYTVZRW5zZldxYVhGdzJRMDBrakRJeUFUWDBwcC93MzAxcEZ5RHVIUFBUNjEzMWo0TDA2TnppUERaeU9PRFdzTXR4YzlYWmVySW5tbUJnOUx2MFI4YnRaelhDRFpDemNkTUhHYTBZUER1cXN2N3kzYU5DT29HZjUxOTN4YURaeEp0Mm9Nbkp6Z1Vza0dsSVBtSTc1WHJtdXYreW45cW9rY2NzOHA4MW8wMi9VK1BiZndUcVZ4R0ZNc1lVZ2NuazEwQitHSjJxM250OG94a2NaOTYrbVJxT2dXNjRNZUNSZ1lQZW9qNGwwbVBJT3c0R2ZtSXpWeHdHRGkvZnFMN3psbm0rTTV2M2RMZnl1ZUlXZncraFloSEJrSUhYdlhvTmo4TzlPaGpmTm1NWi9pNVA0VnNYWGp1d2lRTkcwU2dEK0VjMXlNbnhHdG1CZnpXT0NNNEZhS09XVTNxNHY4QUV5ZGJONnp1bEpMMHNlbTIzaFMyU1BmSEZHdTBkTVlyZmowQzMyTHVuVkIxT0srYjd6NGxxV0cxSGJBUEI2Zld1VW0rSTk2VytTTlRrZHpXangyQmpkS1AzSXduZ00wcXE3bmIxWjloQzMwaUVFdktqT0NmbEZSeTNWbGxNemZJTUE0NysxZkMwM2pMVkpYRE01WG5raXE5ejRrdkpqemRTTUZCempnL2tLNW5tdE5iVTJiUXlldTFhVlJMOFQ3djFEWE5KTWErVXdRTHdRY0hPYXc1L0ZtaHBJR2s4b0VLcWdrNXhqMnI0TXR0UzFHYVJsUjVRbU10d1NSN2pOZE0xbGVYamg3ZTNsZGdlY29TRyt0Wnl6YXM3Y3ROSFIvWXNITDNxamQrMmg5YnkrT3RCZzM3Wmt5UWVBUDVWeXlmRU8wQU96Y1IrVmVBSFFOYWxZQTJ6bzNROGRLNnV6K0h1c3pTRWZjVmlCa25vZmYyckQ2OWo1UDNWOXlPaFpkZ1lSU2M5Zk5uZlNmRTVWZmNzYnZnL2VKNHJrci9BT0pHc05Jb1ZVQzg3U2VhaS80VmRxLzJneUJSNVlPMGpka2JoWFZwOE1wais5bGxVN0ZHNVZINjBLV1kxTDZTL0lUcDVYU3M1T08vYzRtRHg1cmN5dEcyMzFEWjRINDFWZnhQcUU4amo3ZHRBVTVPN0hTdlpkTytHZGlJZk1ibmYySFN1clQ0ZStGN2RveUxmY1ZHV1U5RCtOYWZWY2JKZTlKL05oTEZaWEdONHBQMGpjK1BielVicG0zTGRPY2pnN3F6ZnRGMzlsZVJwSFl1Y0JlVCtOZmQ5cDhQTkFkeC9vcUJwQTNsNTVBSFd1bXRmQ21ucUZpZU9GVlVna0tvL3I2MHY3TnJOdTgwdnhJV1o0UlJWb1MrNngrZHNWanFnalIwaWVRTVJqNVNja2RxN21IdzNyODc3Ull2SGdaT2VNMTkwL1lkSkpTQ0dKRVpKQ3c0Nlo3ZlN1bnVyYUJvSGlMREk2Yzl4NzFxc3Jlem4rQms4NHBMV01QdlBnTWVCOWVhNGR6SGt5SERmUGdrZHExQjhML0Vpd3J1amlVSXhJWWs3bHo2NHI3Tmp0OVB0NVEwdlZSOTNQZjFxMWNhamF6d01KSkpOb09ZOFkzRDJOZEVjcnA2SnpkakdXY3RyK0hHL1ErVnJiNFpYYzhYbHlYQzdpdVgyamoyTmRDUGhEcG15UHo3c3JucGcrbld2ZWx1TGFLT1FoK3FaSFB6REZlbld2aGUwaTFUdzVGY1hVS3JyVWF2Rys3ZHQzbkFCOTgxdFBCWVNtclMvSHlNS1dZNDZySzBJcFdhV2k3dXkzUGx6L2hWMmdNN1lrbGxRL2RIVEJxYTMrSFdnMjhlMTdWM2ZkL2U2aXZiUEVGMm1qNjFlYWZKTkU3V3N6UkZ3Y1oyL3dBcTRaL0V0aEdFUG54L2Z3U1R6OUtTcFlDT3Q0L015bmk4eWMrVnFXL1JmNUhQcjRPMGZZR09uUmdEcmsvTmdldGQvWitFOUdTSVNMYVJFa1l3T21LNCsrOGJhVTVReTNpZ3hraFJqQXg3K3RacitQOEFUSTl5cEl4WEhWUWNIM3FuTEEyVDl3MFU4Yzc2Vkd2bWVzeTZUcDl1aGppc1kwZGlDckE4WTcvalQxczRiR05aWkkxYUtYcW1SbGo5SytmcFBpSlpTcXpZbk1hNStZRGlxSitJRVVzWk1jTE1FN25BeG5wUXNUZzQyMVQ5RVpMRDVoTnU2bHQ3dDVIMHpKZDI4ZG02RkRzbStWUnRCS25QWE5SUXZaVzZndkdIR2V2VC93RFZYeWRKOFRISVl4MmZJSi9pclBUNGpYem1NTkNySzJRQURnQnZlcit2NE5KNy9jWi8yZGpYTlh0dDNQc3hwN0E1UmJjcXJPcHh2enRQdFdwZFcxdVkwZ0NHVFlWYmNEbkE2OWErSkovSFdwaXprWWJCSXJEZ0hKRmM3ZGVOdkVUdEdWdk1BOVJ0d1FhNVhtTkJQU0xPcit5Ni9MckphOXo3WmFVSzgzbUVrWjRCL1NzYTZ2MEpVTENNNCtZa0Q4SytMdjhBaE9kWm1BRHpFTXJZejYvaFVIL0NWNm5jdVErb05FQjFJWGoyeFdiek9IOGdvNVhWdmIyaVI5c3gzVm41RVlEYlhPZDJmNGE2R0xVZFBpVVJ2Y1J5S2c0UFRuM3I4N3B0UzFVcmtYL21ZNmdFNUk5YXoxdnJwdWNUc1QvRVNlUHJVdk0zL0l2dk95T1dOU3Y3VHAyUDBldXRiMEViR2RveHhuazVJSTdpclMrTHZENlJ4WXU0MlBKS0RBeCtOZm5La1dxVEt4U0daZ0J6d2FqRmpyVDI2djhBWTVUdHlNaFRucldEekNvN1dpanNqbDBMdDgzNEg2QndlTi9Eb01qQzdpVndlUFE0cUM3K0ltaHlIZjhBYmxMcU1MMHh6MS9Hdmd4TkgxR2RWU0MwdU41Qkw3MDJqOERXbkQ0SjhWWnpEWXVmTTRBYnA3Vm04ZFdiVHQrQnFzdnB0VzFQdFJmaUpvSGtsSlpoSTRPYzQ0SDQxWFQ0cCtIa0VlRkxIT1R3Y0hGZkpzSGdYeGNYd2ROWVorK3BPT1I5YTAxK0dQalYyVXgyb1lsOGhRMk1VZlc4UStqKzRtT1gwM0w0MnJlYVBvL1VmalBvM25EN1BaRkc0VTQ1eDc4MXpmOEF3dVMxaDh5UmJFOXdjcUNwNHJIOElmQWJXL0V0M2Z4M09xV2xnTE9EelhNa2d5UWV3empnZHpYQ044STcrTFVaWTExTzFsaFNUQm5qZmRHdzc0SXJrV01yeXFTZ243eVdxOHZtZE1zRFJqQ05TY3JwdXlmTXQva2Q1QjhYSXhic0Z0Y3IwVUJ2WG52V1RZL0dnUTIreHJjSVZtazJzT1NNblBOZHY0eitCZmgvUTRyR0tEeGJaWE4zY3hLNjJxT0dZcTNkZHBQQXJ6Q3crRG11elhkMUN6eHhLcktWbVpma1lrY3Jtc2FlTXIxWTh5YmF1MXFyR3p3bUhoelJ1cnBkSlgvSTdXSDR1WDl6ZUlWaVVTS0R0ZnBnZDZiTjhZNzlKVVpJbDNwMFBYUFBTc1p2aEZmaTRlUDdlaUNNZk1WNTYraHJvYlA0UzdDcGt2RkpZaGR4SHI3MTB0NHQyMGV4aXFlRXQ4YXZmK1k1aTQrTCtzWE1zczhqTHlRTWR5UldUL3d0aldjYlcyaENSeXluajhhN09iNFMyVU12L0gwU2U1eDN6L0tyNi9DdlRHWkVrdm1VSG9kdlRQclZlenhkK3YzaVgxTlg5NVB1MjJ6a0Q4VWRlZ1RjYmtBQmZrQzl2VEZjbzN4RDhTUEF6RzhqWWx1akRKejcxOUNXL3dBR3ZDbVVXNDFDZVVuakM4NEgwOXFpdWZoSDRIZzNSLzJsSSs3R0FBYy9RK2hyVlU4WEx1WlZIZ1UwK2FGdTMvRG56bW54TThTb1FQdG0zSnp3TTlLclhIeEs4WFhwY0xlWkM0NEkyay9Tdm80ZkNud2FzeW9xU00rTXNTVGtaNzEwU2ZDendja2hDdk5LQVJ1VUpnNDlzMHZxK0lNM1V3YmpiM2JlaDh2cDQ5MTZTeFVuVUg4MHRna0RvSzVwdkhYaVI0d1JxY3JaYkJVSG12dEhUUGhsNFRTL1V6V2tyUUZ2bVVuT1IrSGV1MFg0YWZEeTBra2xqMHFUT1NVV1VjRlQzejdWbTZHSlRzNzYrWlNsZ3JhT0thOGo4L28vRWVxeXhFemFpKzdkOG9aam42Q3N5YnhQcjRJQzM4eXJuQStiTmZvVmIrQ3ZoMnNyRWFXenlweTRZRWdFOU50VDNuZ0R3Yk9xVHZwYU1UMDdWWDFiRVc2L2VkQ3E0TndkM0YyOHJuNS9RK0k3NlFBZjJqY3JJaEc1MTVYM3JPdk5jdWxpYlpxTXpldWNuQit0Zm9YRDRUK0hxR1NPVFIxV2ZabU5aSCtVazkrTzRycXJQd1Y0VGp0UXAwbUp6SVQ4blFmWG5yUjlWeE51M3pNRlh3TGRvMjAzU1d4K1lVR3YzaHQ1V2x1NVVkVkdBR1B6ZzlzVlRnMTYrRHpMOXB1Q2VOcERIcDYxK2w2K0FmRGltVmpvOENwZ2xEMUk5cWJjZUh0RmQwTU9sMitGQUhiY2VNVlN3bGZ1dnZKK3Q0Tk8vSS8vQUFGSDV2MjE3UExidk0xNWNBRnRvUEp5ZnBXSW1yWGNkNXNmejJBNjlSWDZjYWI0YTA5YmhsL3MrQmZrM1lLRGozK3RhaDhPNkkyNHBweVpZbmVYUUVIM0ZWOVRyOTBOWTNDWHVvdmZzZmwyMnBhaGc0My9BREU0TzRrMVRtdjlTNFJsbUhjZzU0cjlVNHZET2l3eUJFdGJWU0JuWVZ4bjNIclYzK3dkRU50SkkybHdUU0J2bUlYL0FEMHJOWU9zclhhTmZyZUdiZDAvdVB5WHQvdG01bmVhNEtubFZVRTQrcHJldU5XdTVVakFqa0FYcDFHUHJYNm1mMlhwZ2QwdDdPRmVSd3lCUWZvYUp0SThQUExPcDBpQlMrQXloZWpFZGF0WVNyM0puaU1JbXQvdVB5cHNyMjRXNFI1Vm1WQUc5VG1uVzl4TDlxTzROd1NDRGtFNTcxK284SGh6UzJzMVJyQ0FGQ2M1UUFtdVlrOE5XS2lZSnA4TEt4em5hQ1JnMW9zSFUxMVJQMXloWldUdGJzZm5qY3dFT2h5N0F0OHZCNkdzcGwxQkc1WTRpYjd1Q2MxK29YOWtXWmhSZjdQdFE2NHlwWHQ2MW9TYWRwdHNKdHVsV2plZW13TVVEYlQ2aWw5U24vTXJzeldLcExWcVdua2ZscGROSTVMUnBJVTR3b3puSnF2YlhOeUxSb1A3T1l5WnlYeWNxUGV2MHR0dER0L0pTVCt6b1h3eFVxd0F5YTNGMGF4aVhjTEdCQTJCa0tDZm9haDRLb25ibVJwSEcwcFJzNHlYWFkvTFd6aXYwbTN0RktxcWZmbXRDOXVaSkdpV08yS2tBN25HZm0vRDFyOVRZTFRUYmNPR3NvUG40TEdNSEh1TTF4MTlwZWh5c1k0N2VBT2hKTGtZUDA0cExCVmU2RThYaG0xbzdvL010WnJzeWVYNWMyMEhMQXFlbGJEd3ppMWlXUHpSdlk0em5QNFYrajJtTHA5cGVDT1N4dDVRNlpERk9SK05hMTZOTW10aVhzYlVpSDdqbE1IQjloMXF2cUZTKzVFc2Zoa3RuZnNmbURkUGUvWlZoSmtCRGNrWnkyYWRZUVgzMmxVTTdvTUhtVGR4OWEvUytDM3M3YWJ6VnNiZVVGQm41QmdaSHBVa1pzN2U4aWRMS0k1d1NYakJVNDZqRkgxR3IzUlAxN0RPMTR5V3ArWHN4dXhkSGU3TVVKR0JuQkhxRFVGdStweTc0OFRZWGs5Y0N2MDV1SW5TK1l3NmRhRlpTZHlpSUVBSHY3VkJlMjlrWUhCMCtGU1FGMjdRT2Z3cGZVYXVtcU5vNWhRWE11UjZQcWZtWmNTNm03cWlCa0F3dThrMHNGM2QyOGpCNW1jOGpjcm5tdjBKWFNiRzV3VnM0UXNhL1BsUUNNZGZyV28zaHJ3NDUzUTJjSkFCKzhnQlkxYndOVi9hUXY3UndyMTVaYTlrZm5ja3VwVGIyaW5rd2d6bkpINVZ6LzhBYVdyZy9QUEtNK3VlYS9SMUxUUlVtZU1hTEhsbHdTQjkzNkQxclFtMExSblJ3K21RdmxSdEpYN21LbDRLcmI0a0w2L2hwVzkxL2NmbnBiYW5xSkNxTHFZTXc2SytCajYxTU5kdjBNakpjdVZqSE9YNUo5UHBYMzVOb1BoT1RZZzBtTThjakdNK3BGUko0UzhIM1VVU0pwSTh4VG5CQXdSN21rOEZpTGFOZmVVc2RnMDJyZjhBa3ArZmsvaVBVWlk0eXNyb2NuSkRjbjNxdW11WHl0dE43S25JM0hQWFByWDNSZGVCZEVGd0JGWVFyMXlNK3RWZitFSTBQeThTYVltVWJ2NzlxbFlMRXI3Uys5bWM4WmczdXIvOXVvK0xadkU5K0ppa1Z3NGpaUU56SEovS3FhK0xkVXNwbU1WMjdqR1FXNlorbGZjRS93QVB2QzB0eEVEWUtvMjVPMDlRS3N6L0FBMjhDbGZtMDVnQ3dFWkdSdTljMGZVOFRkNjllNG5pc0MydE5GcHNmRWNQamJ4RXJ5bjdTZHpjbkMrbElQSFBpS0ZmTlc2WlpDVHllZUsreU5RK0gzZ3hwb2hGYm1NZ2pvZUdBcXlQaGQ0SnZSSWpsMGt4OHVCZ0FpbThMaWtyMy9FcFluQXQyMCs0K1JrOFlhOCswTmZodmx5MlIxcHc4YTYyeGRVbUJDai9BRGcxOU5mOEtyOE5wYlNoSmNNR1BiY2VLd0crSEdoS1VDS3lzZUNSM05ROFBqVTlHL3ZOWTE4dG10bHAvZFBuK1B4NXJrY29SbmRjblB6RWdmZ0s2TnZpSHJjWmRSdGtYYms3VGc4VjdGTDhNOUF3U3l5RmovR1dPYytuMHJNUHdxMHFQOTU1N01TTWNuN3VhZnNzY3Jhdjd6Snl5dU43S1A4QTRDZVhqNG9hdEtrU0tnQU9SZ25wVEYrSmVzeEZUNWFzTW52NlY2TEQ4SUxHYk95OGRXQjREY1ZSUHdtVmJwb3BMbmJnRTV3Q0RqM3JSeHgvZVczY0U4c2FUZkw5ek9UdVBpL3E3RkFZTnVUMVVubXRpMCtMdDF2SDJoU3Fuc1JuZ1V6L0FJVTdlUnpuL1QwUlpQbVhQWVZVdS9oWE1xbFV2a205SHhqbW8vMjlmeldIYkxaZkRiOFYrWnNKOFdqTEtDYmM5K1J4eDZVa1B4WXNpVEdiUmdwUExBYzFreWZEVy9pdE1qWXprZHVCbjFybng4Sy9GTXFLWTlya0Q1c2RCVktwajEzKzRuNnZsMTlaTC93STlBVDRyMnNjZ2N3dUY5Y1ZDM3hWc1dUQytaM3lNZnpGY0JKOEtmRmlxcU1GWTV3Rko2VnlkejhNL0ZSTHErMk1vY0huZ2lsOVl4NmYybjhpMWdjdWE2Vy94SDBiSDhTdEgrekFTZ1JiaGtQeU1uNlZvRDRuNkhKYkxHSnNGVHllbTRlbGZNRGVCOVppaURYRUprQTR5R3FHejhDNis3L3ZMRmdTQ3lqMVgxRlg5ZHhrZW4zb3grbzRKN1NzdktTUHFZZVA5QkVJYnpGM0hJMmc5S3N4ZU85RmtpWGMzekxrWnoycjQ5azBIV1kvTWpXd2tMWkF5QjA5cXFuU3RURWdqTURxeDZyZ2pHS0ZtT0lXOEY5d2YyVlFhMHFTUjluUStMZENMczZTbkJHQ1R4azk2MVlkYjA3ek42elJuUEs1YmtWOEpUZmE0SEtDQnp0NzRKeFdiZDNPcW1NVGJIQVhvQUNNQ3JqbVZWYndURThwUytHcS9tajlEWWRZcy9PT0xwVnd4WXFHQUJOUHZ0UTB5NlJHRWl4U1pPU3B5R3I4NzRidTZYTWtnZGNqa0hPVG1vbThRYWpBU2drY0tBY0FucFdxeldWMWVtakQreUwzL2VhK2graDF2ZDJNQkJjYmlSOHVUMDk2dmZhN0dmWTdnSEFJeDEvS3Z6dy90KzlrdHR5WGtqSEhxY2crMVU3YnhMckViRUxmdXVCems5SzJXYXJtMXAvaVpQSnFxV2xSZk0vUm1XZXlrR3poRjY1UFdvM05pOHlNSlVNZlFybkIrdGZuOS93bVdyTW1mdEg0anZWMjE4WmFxSjAvZUJsQU9hM1dhMFg5aG1WVEtNVHkvRkUrK1Z0N1JXTHBJZ3dPNTdWaU5ERVhiZXU0ZFF3NzE4WlMvRURWQXdVbmNENkQrZGF0djhRZFRXTDVrQlFuQkpQR2ZhcVdaWWUrc1dqa2VWNDZLVnBKdS9jK3FHc1luQ3NxcmtqcFZnYVZZN2dXTzE4WVU4YzE4eldYais0alIyZFN4WWZkVnZTb0crSisrTVppSUFPQjNGYUxNTUUvK0dNL3FPWngreTIvOFI5RTNQZzJ3ZHZsaVJtenp3QWF6WlBDbWp4UXRuVG84alBMRFA2MTVaSDhUN05mSzNsZzNmRmF5L0Vxd2ZreUU3ajM3MEt2Z0hMb3ZWRGRETmxiNC9TNXN3ZUJkR3VKUS8yUldVazVVakFOY3RQOE9kTjg4TExiZER3QWNacnJQK0U3dEVqQUVpN1FNam5wVDRmSEdtemdPN3FjTm5qcm1uL3dteWVyZ0h0YzJqQjJWUzZmcWNqYy9DdlNKWXNxWGlPZU9jL25YQzNQd3FuUlF5c0N1ZVBwWHZOdDRxdFhETmxGK3A2KytLMDRQRXVtek1VM0xrNTZIaW5QQjVkS09rbzM5UlF6WE5JUDNvdjA1VDVQbitIRjJpZ2hnRDlPT1BlcTh2Z0RWU3lrT24zZWdGZlhFK3VXaGpFU2hNRHFQODk2bGh1OVBjQUZzSHQ2VmdzdHdjbHBQOFR1ZWI0MVJ1NlMrYVBoOXZBZmlGQ3poTXJuMU5jOWRlSE5jTXAvY09NY1YrakVDMmtoVldkTVpKSFBYRlBlTFMyT2ZNUWZYSE5adkthZlNiTklaL0xrVjZTZnpzZm0zcW5qalViczdveVZYbjYvalhISkxmWDdrTVhZOXE5RDhPZUVidTlTUnBMWmtRTmhXYmpOZTAyMms2WFlZRWhYQzl2ZXZucVZHdldkNXlhWGRuMU5ldmhjSkMwSWMwcmJMVm5nVmw0UHZibGs0eC9zZ1Y3ZHBmdytWRVJwbFVZNXdlZUszWmZHZW1hZEZoRVVFakdmV3ZPTlErSWNqaGhDckUvbGl2VFVjRFEzZk8vSThtT0l6SEVOcU5Od2owYlBvRzMwVFJMRlBuZENjZmxXZGQrSnRLc2xJUXFOdGZJdDM0bjFTZVJpMHpMdTlLeDdlejFhK1lmZUpQYzBubWJUNWFOSkkxV1dPY1c4UlViK1o3dHF2eEYzQjFqTE1Ud3VPQlhsTng0dDFTZHNESXlmWHBXbmErQ05TdVNOM1RIUWRUWHBPbmZEeVJpaEtZd08vRmN5ampxOHQ1TTJmOWw0WkpTNVVlQTNGenFFN0VHU1JtOUJuRldZdEExR1k4d2tIZzVKNjE5ZHdlRDlNZ3h1d0NPdGJEM0dnNmRrT0ZQR0JqbXV1R1dQL2w1VVNPVjV4VFMvZFUzTDBWajVuc2ZBMDBoUm1WbTU1QUhINTE2OXBuZ0pnQVdnWEI1Q250NzFzVCtPdE10VXhGc3hrbm11RzFINGxYcnArNFRiOVBTdFZETEtVWGVmTS9JNVpZak9hOC9jcEtFTzhtZXZXM2hEVDdmL0FGcFVMNitsYUVrbmhtelQ3eVpBNzE4bVhualBXN2dFR2ZBSTdjZm5YR1NYMTlPRHZsWnMrOVp2TWFNRmFuUVhxelJaWmk2cnZWeEwrUjlqWFBqYlJMUFBseHBucDE0cmlyNzRvbmtJbU9PMWZNTFFYY2hDQ0ZqbnY2MTIxcDRiMUdkRkN4bmxjWkF6aXVXV1lZdXBwSFQwUjF3eXJBMHRadHQ5Mnp1Ym54M3FVOFJBWWc0ejFyZ3B0ZTFTY2dOTmpPYzgxM0duZUF0UlovM2pNUVIweGl2UUxENGF3bDFMakdUeU90UkhENCtxMThXdmRtc3ErV1VOK1Mva2o1NDN6TWRyek94UHZtckVPbTNEc0NrVG5uQko2ODE5ZXhmRCt5Unp1SU9CMHlCaXVpdHRCMDIxMjVkQmpuazVOYi8yVFhUWE0wa2NrYzd3ZXZLbTdMWkh4L0g0ZTFhV1Jka1JCQjZpdXl0UEFHdHp5QXlNMFpQYzlPZld2cXdYMmdXOGZNdWNIbkdPYXlyM3hwb0VZajh0Z01EOHpYU3NCZzRmSFcvRTVYbXVLbmYyVkRSOWJObmtkajhNNUJBZDdna2NZSXorTmQvYWVETFdLMlZUYnFlZm1ZL3pySXZmaWZhckdFaVZRVDFJcmlibjRoWFJnTzE4azhjZjFyVlZNcXBMUmN6OUxuSkpaM1dlL0t2V3g5QlJlR3RMaUNTbDQxT0FDTTg0RlhKQnBjSkdaRmNEcHowRmZHRng0djFTWE9KaGtqcFhOUytJTmJjTVBNSkI2OXE1djdTb3hmdVVWWTMvQUxKeE0wdWV1NytwOXp6NnpwVWNaVUJTVDFPZWE1UzQ4WTZMRGtLVjU0NVBUNlY4WHRlYWxPVlYyZk9lRG5JL0dudHBWL0pJQUluWW5nbi9BUFhXVTgwclBTTUV2T3gxMDhrb3IzcFZKTStwbitJMENraEdHUjM2MXg5OThVYmhkaXBsd1NlYzE1VForRDllbGI1SUQxOWUzdlhXeGZEM1Uva1NaQjZnZ1p4V2Yxbk1aclRtdDNTT242amxkSGRSK2JMVng0LzFHUmdBZHVSa1ovcFdkUDRvMVNWSXlKaUF4eGxhOUF0ZmhkT3lLelNiaVQ5MDhWM0ZwOFA3S01Ja3Fid0RucndLbDRiSHozdjgySjFjc3BSdkZ4WG9qNWd1OVIxV1ZHVW1RbFQxeldXVzFSOE1JNVdQR1JnblAwcjd4ZzhKNlFpOFFKam41VDAvT3VxWFJkQ2h0WWdRZ0o0K1FjNUhyVzlQSzZzdFpUUy9FeWxtMkdwcEtOTnlQZ3l4MGZYTHVWZjlFZmFCbGowQS9PdXBpOEthb0xwY0JTRzQyazE5dVNSYUU0d0VVTjN3TUExbmx0R2haV01DbmJubnY5YTFXVnhUMXFHUDl0d1M5Mms3cytYMytHZDNjN0E4aFFkeXZwWFMyWHdoaUtJenp5dG5KQXhqcFh2ZzhTV1NJVlRhQm5JK3RSdjRsdDJpS3ZjRGdFZmV4alAwcnIrbzRDR3NwMzlXZWJVelBNS2kvZDA3ZWFpZVNRL0RyUmsyU1N3eU9NN1crYnJqclhaMi9nbnc0czdHR3h3QXVWWmh6eDYwUDRwMGkzaUphNGpiQjR5MmF3TGo0Z1dhSDVaQ1ViKzZPRFZwNWJCWDkzOHpHTTgxblpYbXZ3UFZySHd0cHloWGUxajU5QUFTSzZ2VHJUVHJOUXF4cHZJUFVjQWY0MTgyUDQvZzQ4dFg0UFE4VnpHcC9FZVViU2tMY24rSTBQSFlCYmEraUg5U3pScE4vakkrdDBTelJHWjNVWk9ja0Fra1ZwQ2F3R0NYQnljblBIODYrRkpQaUZleURDN0ZBUGZrNHB0MTRyMTY1Q0w5clFaandPT01Db2xtVkZLeWc3RHBaUmlIZHlra3o3ak9zMjBLUzdVVTdpQ2VjNXhYTHdheEFMMXBYYkdSakdjREhwWHdXL2lUVi9LRWZueU9Cd2R2SEZYUHRHb1BERTVhWFB1U1Fhdy90VzE3VXZ4T3A1Rk9hWE5XU3QyVno3eW04WDJFTE4rOVJFMjRyRi80VFhTSW93R3VZeUNEZzlhK01Xc2RVbGdDclp5c3JFRXNNa2o4NjNvUENXdXlibWl0SkRnZ3NTTUFWazh5cnQ2Ulg1bThjcG94U3ZQOUQ2SW0rSkdrQ1RFY2hZOC9kQklGYzllZkUyeU1UWWlPZWk0SFgzcnltRHdSNHJrdWo1ZHNxazhnRHZuMXJTUHc5MWtJM21MRWo1NXljbk5aeXhXT25zbjhvaldBd1VOWEs3ODVIVFFmRURDR1ZJM0RaeHoycUUrUDlUZFdlTmdGT2NrdDNxeGJmQy9VM3RGbGE1WDVSODJCMkZiVWZ3MXNra0x5VHU0d0N5THhTNXN4bi9NdndOWTA4c2h2eXQ5dHp6V1h4MXEwc2lsM0NydXd6TnpqUGMxV3Z2Rm1yQ01vTHdCc2dmS3Z5bjhhOTVzdmhIb3p3YnpkVEVBaGloSEJyZGgrR1hoeDdtUmt0M1pJbERzQzNINVV2cTJObHEyL3ZIR3ZnSXRKTkx5c3o1Rk91YS9JcGVXNWsybm9RY1pweDF2VmdJbGE5bi9kNDhyY3hPem5QeStuUHBYM1JiZUZQQzBicjVWa0dRbkN4c2VXUHB6VzdCNFowV1pnaWFWQ2tpdDgzOFF4NmZXdFZnTVM3WG4rSnp6ekRCUmRsVHUvS0tQejh2SDFtNmtTZmRjNWNFeVNQbGl6SHVEM3FTQ0xWNUVhS1JKbWpVY255OHR6M0Zmb3BjYVRBakdPTzFSUkdNNXdGQVBwVmRMR09TRm5XTkFUbkNqcU1lOWFMTGFqM212dUplYVlkcTBhY3RPK2g4Q1IrRU5hbEc2TzBtWUx6dllFQWozcm8vOEFoR2ZFOHNhZzJoS0VBYlJ4ajZWOTgyVWpRNmU4TWdWVzVBMmdIT2U1TlJTUVJDS05ZNUVWazQzSHVEMW9XVjY2MUg5dzNtMExXalMyL3ZId2ZIOFB2Rkw1V09KRlE4QlEzU3UxZytFZmloblFPOEFMS0JnTmpwMnI2c211b2tHR0NzcWtiUURqajYwNmUvZ01nWHkyMjQ5U1NEN1YxZjJiVFVkWnY4RGtXY1RiMHBLNjZhbnlhdnd0biszcmF5WGlxenNRMjBjVjJrSHdudFk1REc5OFBsajNaUEdjZjFyM3g3aXhFd2RZaXBBQURuNzJmVVZRYlViQlVuV1FDVXNRRGs0STl4VlJ3R0g5Zm1SVXpQRkozMFdyNkhsK20vQ0xURnNkOGwyekNXVElCNEk5ajdWcXgvQ2Z3cVpwSG5hWUtPNEpJeUs5SWcxS3k4MVVFZ2pEQURjeDRGWGJyVUxhRnpISmRSdU0vZVZ1b0hjVTVZVENMdDk1TWNmalpKU1hTMTlFY0hIOE8vQ3J4eU45bFZZbzhFRnMvTWFuUGdqd3pGL3g3MlNNQXU1aHh3ZjhLNjZUeFBwS0lzY2M0WXR3VmJIOHE1R1h4SnBnU1Q5OUhqK0pGT01nOXF6VkxCODJ2TG9PZUp4MGt0Wlg4dERmaThPK0hmSWo4aUNEWVYrY2hRVG52VzFIcE9uSkdxSmFLRnh4bUlBaXZPeDQxOFB3aENseWlZSXhHTWNZOWFtYjRuYUN5c1RldDB5d3huSDRpdGY5bGphM0tQMnVMZXJjMC9LNTZsSFo3VDhscW5JNXlvSEhxYXNUMmNTV2l0RkdubUJja2hSalB1SzhOdXZpbm9VcGZZWmZMSy9MdHoxL3JXZkY4UzlLWmNZbDRIVURyanVhU3I0Uk5heHZmc1I3UEdUYjkyZG4xZHozZExkcHZLRHhJTnE4a2pBT2ZYRmJjVUVXRjJYQVRiNjhxSytZZitGc2FmNUhscEU3YzRKWWV0Wmx4OFVUSEdObGhrUmo1aURqUHVhVXNYaHI3L2dkRlBEVjlOSmVkejYybEVoM0RlcmpxV1BHZm9LZDUwSmhBODBxNmc4QTR6OUsrTmYrRndDU0NRaTBaWlIwTzc1VG1zUzcrTFY4TXFJWTBZWU80SE9jL1dzWGphRnhTd1dKYjBSNzM0cDhKNmRyY2Nheks4bUNjN0daVHRQVUVyakk5UlhRYVZvbW0ydGhiMk5xckxGQ29DcU9tTzRBcjVJaitMV3FtVkVDcmsvZTJOakkrdFZJZmlmcVl1R1lCUUd5QWU0cko0ekRKdHFtdVpyVjIxWmNjSmlsQ01XM1pQcTl2UStyTEh3VDRlc0wrNHVvTEtLQ2VYL2xxRitZSDhlZytsZDhsMjV0a2ptZll5RTV3Y0J2ZXZnSi9pWnJlSEFsUm15ZUNLaWkrSS9pUmtZRzRVdGtnQXFCajJGWXh4MUdFYktqYlcraDFQTHNSVWZNNmpkMGxxejlCMXQ0SGVIRndRNVhqbmcvV3JrTm1JNUR1dVBsMm5LWkI1OWErQ3JqeHI0Z1MwdDVSZDVMQWs4ZENPMVovd0R3bm5pS1ZsUG5Ndm1MZ250K0ZTOHhqL0t5Rmw5U1Aya2ZvUEJhV2UyTmhjcVhEY3FjZEQzK2xkTWZzVXJaWXhzYzRMZytuYXZ5NG44WDZ5TW90ODhqS09PNSttYXJRZU50Y1MyNHZKUVNPUUNmbE5EekM5dmRORmdwOWJmZWZwek85bzF6R3lTTEN5RGJrYzU5aldiTmFhVUoya04wQ2M1ZFFlcDl2U3Z6VkhpaldiaUtSdjdTbVdiSVpUdXlHeDJJckpieFhxMGU5V3VYQWs1T0NUbjZHcldZUG9pS21YNjlOK3JaK3MwQnNKWnd4bWkzSW9VQmlBY24vQ3JGemVhZkhuZlBFZHBBWXF3eU0xK1NscHIxOUtnRHl6Rnl4d3dMRDZaclRGemZ2dkgrazc4WUozSEhIdWVvckw2N0p2WTdGZ3BLbW5kYW42Wng2dnBzYzdPbDVIeHdNbkorb3pYVWY4SkJvenhEekwyTmhuNzJjZ2ZuMzlxL0poeHI4cUJrU2NwR2Ryc21UL2sxck5hYW04Y1lsVzZhTEJ3UURrSDhPOVRMR3pmUkV4d2FqcXVwK296YXpvYzBMeVIzY0pLdGhtM0FZQXJGdWZGM2grT05RdDdEbnJ0M0Q4K0svTFNYUzlZTGdRUTNld0Q1dk1VakkrbGFZWFUvdFgvSU9rMmxCaE5yWXlPT3RUOWNxRzZ3azdhdGE5a2ZwaEw0bDhOeTJ3M3p3YncyVlppdU1IMDk2cEh4bHBGdEVjNmtwaUh5N2dCdHlmUW12enRtdC9FRHlJQm9zMlFwQ2hsT0I5S3hrMEh4aEpINWY5blhKUU5uYVZPT2FheHRhMnhDd0N2ZloyM1NQMGpqOGZhRVVsQzMwVHFvNHgwcksvNFR6dzBxWkYwb2M1eVV4Z0QzRmZuakg0YzhZd3pNaDB1NTZjZ0ljWTlhNm5TZkMvaStVTXphRmRPR1VxQ1Yyamp1S1N4bGJzVExBYlhiKzQrei93RGhQZEFlVGFtcFlZSGdzMkFhdEQ0amFNeFdFYWtqbnFBTzJQWE5mRUZ4NFc4WVc4bTFORm1FaFhjVk1aT0NlNHFTdzhBK01WU080bTBhZHdRYzU0WTVyWDY3VzZxeGxIQWE2Y3pYWFErMmJyNGhhRUZYN1JkS0NGeW55ODRxUmZpWjRjaWppM2FncERnZ0RKR1ByaXZpYVh3SDQ2bmxYL2lWM0NnZktnSzV3djFxeC93cmZ4bGFNank2Vks0UTdqMDVIMXBMRjFXdGpXV1hkZWZYMFByK2Y0aitHWk1lWGY3am5EOVIwK3RYby9pZDRhaVkrWmQ0S3FUdDduMHI0amw4SCtMak9QSTBxNEdXQkRrQWo2VnJUL0Q3eDVGSUxpYlNIbE0wWkh5NHdDUFdwK3MxbjZGckFwTFZ1L3BZK3JUOFRmRGtrYVl1Q1dZampCQkhOVHkvRW53aXNKVTNIbHNHeWNFNTRyNUgwLzRkL0VLUll6RHB3YVVOaFZ5TTVQVDhxcnI4Ti9pUGRYZHdrOWd6VHA5NEFBRDhoUjlaci8wZ2VCZzFHeldwOWN5ZkVmd3FNU0RVVVlPZmxHZHhIMXFTVDRrK0ZwWTFWcjVVQk83ZVFjRWowcjVVWDRZZU9mS1NKZERacE0vZkdCakZVNWZoaDQ4dW0yalRHT3cvZFVnRWZoUyt0WWpUVDhDbmc0N1BUb2ZZamZFZnczYjJ5dUx0WkE3YmhnOUIwd2ZyV2ZIOFQvRDVKY1hzU3FXKzUzcjVGdGZoaDQ4eTBhYUxLV1U0WlNRQnh6VUwvQ3p4eEx0STBhU01rNXlwQkdDZTFZZlc2LzhBU0srcFJXbjZIMTJmaVZvZmtseGRCb3dlUmdzS29MOFJ2QzhjWlpRU0Njc2NWOHFOOE8vaUpiTzhSMDJUeTVCOHdHTUhIZW9COE4vRzRKaU9sdWlqbjV6Z2ZTdFZpc1ExdGY1R1VjdmdwZkV6Nm5rK0tIaDd6Q1VJYjZaRzM4YWd0ZmlMNGFNa29ua3lycmovQUhUMXI1YVg0YitPbm54RnBNc2dPTXF2UUFWdVczdy84VFMzRWtjZWpNb2JvckhxUjZWVWNYaU8xdmtZenkrbmZXYmYzSDAxZGZFWFEwYTFWWnZrM1o0UEpIdlZwL2lMNGRTVVJQS29ERW5lekhBcjVlaytHL2k2SmtqVFRaUytPUTNIemV4cUhWUGhuNDFVS2Y3SWx3UmhnZjRUL2hWZlc4UmJXUDRGTEw0TjZTUHA2WDRrYVJiU3VxWGtSQVg1V1Z1dWUxVUQ0OTBHY0tXdWNFbmtubjlhK1MwOEErTFZrMnZwc2hBT2NnWkdhM3YrRUU4U0lqeE5aVEFsdzZuR1FmYW45YnhGcnFLKzRsNWZCdjQ1THlQcGEzOFkrSHZOYkY2QTVHQ2M4RWVncSszam5RUE1YRTZvb0dNOWM0OWM5NitQTG53ZDRvVWxocGNtVUdBRjY1UGY2Vnp6ZUVmR2FrelBwTjE4cmM1ako2OXFVY2RYN0ltV1hVMDB1YlJlUjl6eCtQdEJEREU4VW5PUVFjSDhhUnZpTnBETzRkeHM5Qlh4bXZoYnhHWTFLNlBkQm13eHhHUmluWEhoL3dBUkNVT2RMbVdOaUJuYVFBZmVrOFpXdnRmNUdpd2ROYVhaOXEvOEpiNGRkcmVTTzdnWElPVURaSVB2bXJiZU12RGtTS3d1QUpjL01CamozRmZBVjk0VzF5SWovUkpaTU1EbEZQR2ZTcXNtbWFvaklaTkt1ZHY4UklJM0gxOXF2Ni9Wc3RFVi9aMVB1ejlBeDQ0MEZsSkZ4R2R3R1MzQnovalRHOGI2T0kxRytNeUYrUWNFWUhldno3RmpyOXd6R0xTcFNpdDk3YVJqNjFiaDByVllaTjB0cGNFOHNNSVNCNlp4VWYyaFZUK0ZFTExveVR0S1NYZXg5L3hlTHRHY0wrOFhjQ3hKVWMxVkd2V1d6ekhuUXhnNHdYNDU5cStEYldUVlJQSk5KYXpBS0RnK1cyS3o1NXRSbGNuK3o1VXl1Q3dWc0Urb0hhdGxtTlMzd0l3bGxhMHZOL2Nmb3JKcUZncXg1ZEZDcUNNWU9NMUJGcWVra1RIelZMQmVNSGdBOTYvTjU3alZsbFlvdHpzNEIzWnpUMXVOU2psQ3BKSXVSemtuUE5IOW95L2svRXIreUhKZnhMZkkvU1pOVHM0QXF4K1h0ZEJram5KcWhkNnJaeUxHelRCV1ZzREE1NHI4NmpxV29vREJOTk9XVDdySVNDQjcxQ3VxWCs5TXlTNUJ6eVRVdk1XdnNHbjlsTzJrN2ZJL1J4YjZLVnN0TUQ4dVFEV2lYaU1HMVNoM25PQ2M0cjgxcjd4SnJLS1Fsekl4VUFBWndBS3N3ZUxmRUZ1WTVEZXlmZDZCczR6UXN6dnZBaFpYS043eVR1Zm96RmNXNnRMbVFBcUFTU2NENmZXc2ovUTN1U1k1ZmxjWTJaeno5YS9QaC9GK3VOa204WTdqODJldVBhcmc4WDZwSElxdzM4bUNPU3k4MXQvYWV2d1hNRmxVMnZpVzUrajJUQTZxQ0M1SEhSK0tnYTJqT1dra0dlb0FVQUROZm5WRjQ3MStLZGMzamtqN3ZINjAvd0Q0V0pyeU1RYmpjQ2NuUHRTL3RHRDNnV3N0cXE2VWtmb2tpV0xKODR5TWpIb3ByVHRGc011c2x3K0ZCSS9oL2xYNTJRZVB0VWVQY0oxSHpaMjVQNjFveC9FL1dJZ0NZa0l4Z3FTZnpyVlpoUnMwMDBaVHk3RTZOY3ArZ2hpaGRkN0hPNXZsT2VNVm1mWmtDeXhrQm1sQnkrY2tEOGErSFYrTEdweHhLcGpVOXlPUnQrbFZ6OFY5UVpXRWk0VnZ1a2RSN1ZmOW8wUDVXWkxBWWxKM2luOHo3SEdrMjA3K1c2YkRqNWNuQVB2V2tiQjRveXZuQXZHdUZJUFhQYk5mSk1ueE9uamloRFJtUTR5QVQwOXFzZjhBQzJKa3VRMFZyamFjN1NlaC9HdFZtT0h2czE4amwvczNFTmJQeVZ6NjJPbnpzV2tBaVZ0Z0JHUjh4cERvWmxnK2RZeEllb0NnbjZacjVuWDRyRHlDMDl2dGR2dXFwQi9PcWtYeGRXVHpmM1VvSXdCbnRpcSt0NFJyVi9nYlJ3ZUtpN2V6ZjNudDM5aFFyUHpFb3czS2xSeWFzM2Vod1hFcWlXQ0Rqb05vQU9LOEpiNG42ZkxodDBpdWVjVm94L0VyVFpHVVNPeXRqcUJWeHhXQ2ZWZmNZU3cyWUozWE10ZTU2MjNobXhaM0pzWWR6RHFWL2xXUlA0TDBZczNtNmVwRzNzdnJYSnY4UmJPTGdYaWtkY250V292anUxbEtrWDZZUHFmNlUrZkJTZXJpemErWVFpdVZTOVRKL3dDRUowZUpGUkxGVjNIQllEQnJtYmp3Tm9pVHNEcDRJQjY1em4zcjBhWHh6cDZxTjExRzJEejBQSHRRL2pYU0pWUWVaRjk0SE9SbkZOVTh1YjNoK0JpNitacU9ybmY1bmtoK0dlaTNNdUZSbFVua0wxcWpjL0MvUzBrWkkxbWpHY0ZqL1d2b0dEeGZwcGtCQ1JNRDN6Z2o4cWlpMWZUSkxsMk1oRFB5VTNBZzA0NFhBU3Y4UDNqL0FMUXpCYVhiVit4ODRYSHdtczQySGxYMGpIR2M0eU1WeXcrRmVxUEl3VzdHeFRubnB6NlY5aFBxdHNIK1ZsVUFjOUJrVmJ0TlcwY1c3cTdZYlBHVFNuZ01IS09qdDZNaisyY1hHYVhLdHVxUGl5YjRaYWdpeXFMcGR5REFHTVp6WEtyOE05ZVFPTjZsVkhRVjk2UGZhYTVBM0FEUEp4bXRWVHB6QWtiU0NNVkg5azRicE4vZWJ3enpGUGVtdnVQejBoOEFhNnU5L3M2dXErOWN2UDRPMXBHQ20wY0VjZ2MvNXhYNlQzQXNWaFVLRkdld1A2bXN4N2UwWUp0T1dPQnVKNmo2VXY3SXB0YVRhT2lPYzFsOFZPTmo4NHpvZXR3eEZaYk53QzNBcVd5dHRSdGVsczRKOVZPUlg2THk2ZmF0RHh0SjNWU0doUlhDNStYalB6Y0E0cmxlVTY2VlB3T2g1M1R0clMvRS9PbTVHb2lVaVJYWHZrWnJDaXU3Nko4Szc3czhaeU1pdjBodU5Bc2xYNW9VUEl5ZG9OWWsvZzNUNXBXemJ4a2prWVhIV29lVlYrazB5SVo3aEhLenBTUGhodFd1NDFMbWNxZlRKelUwWGlMVnJkVUpuSkxEY1BZMTlqNmg0RDAyV0hFbG9Cc3h5QmdHdVRtOEJhSDVXRmhaQzNjOUt3ZVhZcGFwcjd6cmVhWmZKV2tuNldQbXlQeGJxelNialBrak9PZTVycG9QRk9xTkVwODVDZlFuQkZlb1QvRGJTU3dNS3NOeThqcnpXTlA4SHc4bTZPNmRWSUhEY0VVTERZOVBUbStUTlZYeXVhcytYNW84MzFiNGdvSUk0N1hPY2M0NEE5aFhsVStzNmhlRWt5RURyeDFxRFJOR1MvUUdJa2dISEZlODZQNEpoVER2OG96ZzU2MTVsT0dKeEhYUzU3ZFQ2cGhkNDIrVnp3Q0xTYis2WUFJelo3dFhvV25lQzdtVWdzVG5weC9Xdm9oWXZEdW54Ym1ZTVFNWXordGM1ZWVQdE10NDhSUnFTT0FCWG9Sd21IcHRlMXFxL1phbmwxTWZpWnhmc0tMZm0xWW9XSGdHMVJmM2lqZzhFOXE3dUhTdEYwODdwWERGZTFlQmFoOFE3K1lueWh0R09NMTU1ZGE3cWR5QjVzeE9leW10M2pNSlQvaDByK2JPZjZuajYzOFNweUo5RWZXOTU0MTBheGpQbEtyT0RYbk9vZkZDZDFPeE9UNkN2bnRJN2liN2tMTWY3eHJxN1R3eHF0d0ZBandTZW1LNVhqY1pVZnU2THlSdXNwd0ZPem5lVm5xNU0wcjd4anFsMnVjaFJYSVRYMXpNeEx6czNIQXpYdW1uL0RhZVdJU1NodTN0WG90dDhPOUtoWlRKamJnSG5pcldCeDFYV1YvbXlKWmpsV0hseXBwTmRFajVJaHRMbTZBMndrZzEwOXQ0UzF1WXFCQ3dCNEJ4NjE5Z3hhWm9GanRKQ0FDb3JqeFZvZG1wd1JrSElIVHBYU3N0cFEvaVZrdkpISFV6bXJOcjJPSGswK3JQQzdENFUzcjh5elpQQUlyMDYxK0cxcmE0QkM5czFrNmw4VW9BcEVLNEIvblhuTjE4Uk5RdXVraktQWTRBcEtlV1VwYk9WdW8vK0ZldlRka29OK1ZqNkloOE42WENBR2FQR2M5UFN0Q1hWZkQxZ2loWEJJSElGZkZWejRuMVNaMkJuWWozcm5wYm04a2x6dlpzampKcVpacENOL1owa3ZVZFBKcThrbFdydlhWcEgyWko0KzBxQXVVUUgwelhLWFh4R2ZMRUFBKzFmTnNXbjNjMlQ1VGdZNEo2VjJWajRSMTZjYmhDMndyeWVvUDBybC90REhWUGhUWG9qcWVUNEtuWnlkL1ZuU1gzajYrbEQ3V1kraHJrWi9GT296S2YzakJ2ZnJYb0ZqOE83aFNQTWJibkh2eDcxMjhQdzZ0ak1tUG5PUm5QcFVld3g5WFZ1WHpac3F1VjBuWktDOUVmTjM5cTNzazR5ekZTdkl6MHpTeDZmcTBvWjRra1lqdWZTdnRPRHdMWXhLMGZsS3JLZnZZOWE2VzMwZXl0NG5WblFBREJ6MytsYjBzcXJ6bDc4ckx1Y09Kem5DMHZnamZYWStITFh3NXFjc3F5dERnSGdnZHZldTZoOEFYTTREbzNKNWI4YStza2swS0NFQWtjOVJXRko0aDBlMkxDTUFEblBPSzdWbFdHaS9mcW5BczVyMUUzU29hOU9wNGJIOE45a2tSYzRIVTk2NzIwK0gxcXlrc21jSEdRTVZlazhhYWVvMjdsNzg1cm1yajRoaEFWVndRZlExRGhsMUxyZjhTb1ZzenFyWnI1V081dC9DR21XOHVURGtnZlRGYkFzTEtCVjRRbmRrZTFlQlQvQUJDbVg3b0pCNFB2WEN5ZU5yMmVSL1FjSG1sOWV3a1BocEMvcy9IMVhlZFJwSDJ4QmY2WkVBOGpLRzc0SFdwYm5YZEoyQWhnb0FPVUhUbXZoS1h4UGVQZ2ZhTnlrZndyeVBVVmxHL3ZyaWNMbVFnL2Q1cVhtcit6VC9FNm9aTkxsdktyZjVIM2FmRitsd29nR3pJR0NTZWE1VzU4ZldYbU1nS0FrajA1cjVJK3g2cTRYRVVwVnVwN1YwN2VGdGJsV0NSYlJ1TUU4ZGE1L3dDME1WTFNNZndPbit6TU1vcm5sNmEyUFg3dng3R0hPV2JQYjBybFgrSUZ5U1BLUmhnNXllaHFoSDRFMWVVZzRVRThqdmpOZE5iZkRTNTgyUGZjTGowVWQveHJOVmN3bTlPYjVLeFAxYkxvVzV1VDV1NWt2NDExSm8yMmhGYmozTllNdmkvVkpDeEV1ZU9jRHRYdHFmQytCVkx1Mkdib0ZPTnVPLzQxMU5qNEEwaUhadVJtTEE3MUk1TmFmVmNmTjNiZnpadjdiTEtVTEpSZm9ybnltZFN2V0xmTVdYQVBQSFgwK2xaZm1YMkFzVWNqNVBYazhWOTdMNEkwVlhVZlo0L21VRURISnovaFc3YmVHdEtqVXhyQkd2QUc3R1B4cldHVjEzOFUwdnhPUjV0aG9MM2Fiazc3Ykg1K3c2THFrNkhiYk1lZWhIYXVrdHZDSGlXYmFWZzJqc3JESEh0WDNSSG90ckVHQmFQNVQxemdWYzh5eWlkV015OFpCOWg3VnQvWlBlcitCblBOcjZxamIxWjhlV3Z3NzE2VlhFaDh0YzlDYzRyVGY0UzNqQlBPdWlOcEFZZXVhK3VGdnRNQXlzek9TT3BGWEJyTmdyWmFNYmNBWlp1OWF4eTNDd1dzbS9WbkpVelhGVFM1WXBMMHVmTE1Id210WXBNTGVHUmNjbkhHUFN1N3MvaHRvTWlBK1U1SUdNbHZsL0N2VmJyeEJZdkk1eW4zTUVaQXJsRzhWYVlvTzY1akNqdG5INVYwUncrQWl0YmZObk45WnpPYnVsSkt6MlJhc3ZCT2lXZ2VJMkViQURBSjlUWFNXbmhYU29uamRyY0FLMkFnQTcrdGVmZjhMRDAwQmlia2NkTWl1ZnVmaUpackhrU3V4SkpIQnpUVlRMNExSeE1KUnphcE5hMUxldWg5R1M2UkRiZ3pCVlplT0ZBNHJvd2QxanNSMFNPUTg4REpJcjQrSHhNWmtRUlJ2NkhQQXdhcDNmanpVRWFRSWcycmpJQnpVUEhZWHBkL0k2WTRISDYzalplY2o2bVpiVjB4Sk1Wa0hHOVJqT0txdEpZSXJJeFYrRHp0NVB2WHhMY2ZFSFZURkt3WENad3hBSndmZXEwL2pIVkxpQlBMdUZPMGpjQU1IYWFsNW5TV2lneGYyVGliSnVVZnhQdVdMVTdlSWhGWUdNQTVWaHdUV1hGY1dwTThubkFzejhBOU1lbGZDVWZpZlU1cFhYN1RJTThqbk9QclZXSzgxRW1VdExPeFBBWUVnZ2l1ZisxZDdVMGRNTXBxTnJtbXJkajlDWmRkZ2lpWlEwWU9CbjVzVmpwNHUwaEpHYjdRc2JsUXJMa1ljVjhFeHJxclJ1WEV6bGlkejRKQU5iVUdsK0kyRURmMmV6cXZBS29RVG4xeldiektvNzJpamRaVkc2OTluMkJONHIwZnpremNSYlJJR1pGYkJJQnllZlhGZXg2SDhSL0FVL3hLc0o3WlJCcDZ5eGdSdHpnQmNaYjN6WDUxRHdQNHN1Vkx3MkV3Ty9KenhnZWxkSFovRHp4aEhNVDltOHBoOHlPMGdHQ09jWXJLZUx4ZFNQd3Y0V3RGM05xV1gwYWMwK1pYVTR5MXR1djBQcFh4YjhUTkR1UEVHcTdYWXFMbVQ3cTRHQWVLOHptK0tPbXhzRldHVTllUU1DdVFId3E4YjZsZGwyTUNOSSs0cnV4ak5XYmI0T2FzMDh5WEY5SEhzNjRHUmoycXZhNDF4aWttdEVMNnBnNHpiY2syMjliOVMvYy9FOXlqQkxjcmtaQkxkdldtemZFTzdTM1RtRnNFbk80bkE5T0szWCtEY2NkcVhmVmxENUFqVEhPTzV4VmEzK0ZGa29jU1hqTVA5bGNjL1dwNWNmSjM5NjNxVEtPVndlOGIvTm5uazN4TjFBc04xdW9Ra1lBemtuNjFTbStJV3JTRldnbks3VGhsY0RHVC9uaXZldE8rRlBoNUNYTHpPVU9RcC9yWGFSZkRQd21tMTU5TzNEcU9UZy9sVDlqamVzbjk0M1Z5Nkt2cDZXUGsxL0YrdjNFVVNmYUdqZkxibjdIUGVzQmRZMXA1M0wzRXNtMGtNZW5IWWl2djNUUGh0NFk4bVYxc29TZ2I1VVp2bS9DcmxuNGEwYUc1Qi9zMk5GeWR3UEovR21zTGlaTjNuK0pmMW5CUmpGcU8va2ZuZ2IvVUdrQjgyZHVUbE54eFZSMzFaeGt4UzlmdWpMSEZmcUxCNGU4T09yQTZaR3NwUERLQUI5Y1ZPK2x4UW93anRJbFVNQUpBbmIwclA2alY1dFpqbGpNTkZKOG4zSS9OTzMwN1dya2t4V2s0WlVCQjJNT0tzdjRhOFRDTmR0aGNIZHhrTCtOZnBkQk16V3MwYlJxZ1g1VndvQmIzckhnKzBLeWxtT0JuYmdnWXJSWmZMclA4REI1bFR1bW9QNXMvT21Ed0o0cXVGYVFXTXBLSEpKWERITmJOaDhPdkY4cXNXc21DS1FNaGgrZU85Zm9oYXFHWmhLQXg1SStmRlRLa01jb2Nwc1hIQjNad2ZlcVdYMjNteFBNRkxsYXBwYTl6ODk3ZjRTZU01TGpFVUtvcGJvNzR4NzEwYy93ajhYVzFxd1NXTnNObGdXNnFhKzdtOHVCek9aTjVIUVo1T2Y2VkcrcExKYkF5eERlR0dOcDRJOURWckw0YWFzciswdVc2Y1VudjFQaDlQZzlyd2pWbXVZOHNPVDJXdXhqK0Irb3k2WjV6YXVnWm4ybm5BUHNQU3ZyR1c4dG55UUNwUDhKSFNvOXhraGFQY3hYakFBL0dxK29VbDFZUE1aNjJoSGJRK1I3VDRMckhLUkxlNVhPUVZYT1BjL1N0TWZBYlM1N3MzRnhxc3lvTWJqdDZqMnI2VlhlOXdyeFRzeUJNTUdJL1N0NGxKb09Uekd2OS9IWGo4YXFXQ3d5dC9tRWNmaUZleVgzSHpqQjRjK0FmaGEzdVcxMGFqZFRQRVRaN0lHY013NEsvSi9FZTJheWRQK0czZ09lTjcveXIzN08zenBFNHc2b2VjRmZXdllOVFcxZFVoWkVPeGhnK252eldsYnZESEErVkpCK1VuUEFybWpsOUdOU1VuVmNrOWwyTGVaVjUwb3g5bWs0OVVscWNSckZuOEV2RUxRYWJvdmgrL3RaTGRVOHk1a2hNWVk5R0dTZVQ3MXlXa2ZDdlM3UFVESmQycnRaM2dKdGpJT0hLY0VqK3Rlblc1MDRTU1NLVllnRVlMWXJSVHhMRmV3MlVOeGR3TEhaSTZXeTVHRkRISkJQYzFOUEEwS1VFblU1clNidTNyYTJ3cW1hVjZrNVBrNUx4U1NTMHVtdHpqcm53SDRNdDduYk5wM0FCQ0VNZHZOUWp3aDRRRHA1ZWtGMVFFajVzZzU2NEZkMUpmNlJDZ0VsNWJ1U092bUE4KzFOc3ZFZmhtT1lrM01NYmo2RUVWMWV5d3E2STVYaWNTNXIzekJnOEsrRDdpNGlTTHc4a1JUNzVQOFdhNnlUd3I0TnlmTDhQMndZTUFDQ0Fvd1BTdEJ2R0hoS09aaDlxUmhqSlpTT2xWcmp4NzRMQ0lWdTEyZzlWQTI1OXhXZHNKekt5UnQ3VEZPTFh0bTlRWFJkQmp0b25iUWJLVWs0QlVjcVFlNDdpck45cG5oN2RHVTBlMGprR1BsOG9FRW44T2xZVC9FVHdaQXNiSmRvekJ6bFJ3Q092QnFsZC9FM3c1R0E4bHpoVHl1d1pLbit0YVh3bDlrUzZ1SlN0N1NUdlk3VFRvYkNCcmQvN0l0R2sza09naHdNZGpXcGN4eDN0K1pwTkt0b3dlQVBMRzNBcnp4UGlsNFRXUGVMcVJ1QVMyemtHcVkrS2VnYmhtU1JrSE80REhYNjFTbGhyMzVWZnVTNTRqa3Q3V2RyN1daNmZDMHVERkhwOXMwWVBKamlBSkgxcSt0eGM0RVMyY2NjWkIyNVFFajJOZVF5ZkdId2VvaVZCSys0ZW1NWXF2TDhhdkNwY0lzRWdQRzdIT1Q5S3lsVXczOHNiRlFWZHh0N1dkL1Juc2gxQy9oVW1DQzNrS0RMS3lBa2p1UHBXcXR6SGNHS1JyU05EdHkrSTFLL2hudlh6MWVmR2Z3dXFGQllzR0IrZHY0dnhyS3VQak5vSWd4RmF5SGdaSVAzYVNyNFhza1dvVjBtK2FiOHJNOTB1SUhXU1JpbTlYUEcwZk1vOU1WcldmbXZCamQ1WkhLa2puajFyNXJIeHc4UFBBVDlpa2FWR0FCTFlYSDA3MVRsK051aFNJaFMyY0hCeU01clQ2elFlaHlleHFwdVNVMzVXWjlXR0hVb0VrbDgzZnZRK1p0QVBUKzdXUEYvYVVnaVkzWlZBRGhBTWNkcSthN2Y0M2FhWTJWdFBkY0grOWdrKzFWVDhiTlBtWFAyUmsySEFKSTVJN1VLdFFWNzIrNDZsVHJjcXR6clRiVSttMSsyU3pDU2VlU1RBd004YlI3Vm9OY3ZKRVZtTDRCMnhnYzRIWTE4aXA4YXJWU1MybnlIc1FXQUIrbFhMWDR6MlU4N3dKcG8zQlNjaCtRQlZmV2NQcG9pS2RHdTAvaXU5NzNQcjJBRlhZRzZjL0pnaGpuSDBybjc2YVdiQ0NWbURINXlNQWJSMnI1YmcrTWkzTGlLMzAxSW1YQkprazI1Qit0VlI4WXJDT2VTTjRBV1hJQkRaVWs5d2FuNjFoNy84QXpuU3I3V2t1NTlVeEdNQlNOKzREQTdiYW5na3U1RWNOTVdBSkM3bXh3ZTFmSDBmeHVFTTdoOUxqMmtuYVdicVI2R2x1L2pJd1hldW1vUmdFa05ncjlhdjZ6UTdmZ1ZDaGlMYUtYcGMrcWJWSnJhWjR5eEdNNDJ5WndmYjNxVkpYdGJ0NVZFdTl1Zk0zWkpCNmcxOGZKOFhtZVZXRmtBQUR4dXdhMFkvakpFUUpScDVkVGtiTi9mcGswUEdZZnF2d0llRnhLdG8xWjNYa2ZXalRYa3hjdGRTQ1BxQnV4K0hyVWlva1ozQ1NRdGpxRDkzUHA2MThiWFh4ZEQrWDVkcndxODdtSU9hbVg0M2xGR05PUnhIMU9jQSszdlI5YXc5djhrWDlXcTlVMno3SyswcTVKKzBUYmxITzFzRmxQdlVhdVRLaXgzRzFFUTVpYzgxOFozM3hnWjNMRFQ0NGpJTjM3dDhyOVBhdE8xK05VeUlzaVdzVEZlVHZJd3YwSjcxRHhPSCtZMVFyMlYwN1g2SDFrWlNJNVFYTHIvR2R4M0FkaU0xWm5FVXNTYnJxUXNSa2QrbnJtdmplRDR4M1gyeTQvMEdGMlpTemM0R0RUbStNTTh4VUpheG9Ua0tvYlBQcFVQRlVMLzhBcU9HcjI2K2pQcjZXNzFrN1JCY2JFNEJYb1Q3NUZaVnhiMzg4bzJ1SXZMVDcrNC9NUnptdmtpSDR5NmhDN2JMWlZkRGhqMDYrbFN5ZkdUVWo1aU5aS1NSMFBiNllxbGlhUFJMN2pKMGF6ZnZSbS9tZlZwdXI2WUlzbHkyOFI1R1QwSTkvV3RzWFdvaUU3cHBDeEh6dHZCQkI5YzE4YnI4WUpFVlZlMVJwRk9ObWZtQTlzZFJXcFkvRlFYeDJtQUp0R2M1d0ZQdlZmV2NOZGFMN2dXR3hTMVYvdlBxRzh1N3RtRFFxSXBBdUVZRUVFRDErdFpjdHpQY3lqOTRJM0hZK3dyNWlIeG1RVE9rMXNnYnVEOTM1ZnA2MVRsK0w4Y2poZjdPaUdUMUhVQ245YXd6L3dDR0Q2dGlkYjh6MVBxcWRKSGEzMm5LZEdJNy9TckV0MWYvQUdrYlppaTVHQjF5Qlh6WEY4WVlQTlJmSXlWWEhVZmxXYy94a3NacGR2MklxUVNNczR3UHhxRmljUGRYcy9rWit4cmN1aWwwOGo2dHVIdnZPUll5dzNKOHgzQVp4N1ZLaGphRHk1SkNRVXlCeDE5RFh5L0Y4VzlNOHpjTlBlVmx3VHoxVWRlYWJmZkYvU1pGRWdzVER1WTU0NTU3WjZWcjlZdzcwdWkvWVlwZThveXYwUjlQU1I2ZkZFcDh4Qm5uMzRySWt0eVVhUWZjWlRoc0E0eDY1cjU2WDR1NlFpcUh0dk1KWEdNNXdEM29sK0xXZ1hFYzBhUk5GbnAxd1I2VVJ4R0VYVkV6cDRtVHU0eTIyMTNQbzJLRjBpZC9PUm5rakF3cWNFRHY5YWdkTHNZMndxY0FobDJoU1FPNHJ3U0Q0c2FMYnhJaFY5MnpxQ0RpcGJUNHI2SEtHWmZNSkhMRmpqaXIrc1lWUDRrUDJWZHhUNVpMVHpQY0Zabk1rY2UyTU1DeHlnTGNkczlLZ1RUa3V6SHNqandzZldSQXBCOXE4Yi80V3A0ZG5QeWtncVBtVG9lUFNtU2ZGand6djJtV2RUMEs3VFE2K0dmMm9uR3FHSms5Vk4yMDZvOWhoZ3RwR2FPUzJnREsvd0F3WkFTZnAyL0dwWnRHMHRvNXBuMHUyd29BQ2daSlByN1Y0cW54TDhOek1vRXpsczl4eVJXeEg4UmZEaFRiOXRaRGdoZ1JUbFZ3anRyRTZvd3hVVnFwK3VwNlZIYmFQY1d4Uk5LdG93Q2Q3K1dNayttYTVtVFJkTGlUblNiZllDU0RqSU5jdmIvRUh3ckRidkdMMXQ1Zk9UNmVsUGs4ZCtIL0FDQ3kzWXpubFc0eUtoendsM1p4c2JLV0w1VjhWN0d5K2grSEpnODB1ajI1d056cnR4a1VscDRSOFB6WG5tZjhJOWJDSE80b1NBZHA5TTF6MG5qTFFtenR2bFZXOWV2ME5ha2ZpdlNaRUpUVUE1R0FQclV0WVI5WWtlMnhzSHRQWUw3d0w0UGVScDAwT0xDTmtwdndTUFRpdVJQZ3J3WE5lY2FVMElkeGhRMjRqUG9hN1NUeExvL0RQZXdxRSs5bHVNL1N0RFQ5ZDhOb1daTlFpWnlOM1BadjhLMFVNSnk3Ulp5UnhHUDlwck9TMTF1Y0pkZkMzd2pGT1dXQnR1Zm01emozcWhlL0Nud2N5TUk0NVdJVUVNbzRJTmVtWEd0NllqS3Eza0pFcWdrRjg0ejYrbFg3ZldiQ0k1RXNSVkUyZ0tSamlsN0hDMjJpYnJHNHB5a25OcFB5UERyRDRWK0Zsbk1Va2M2cmtjbmhzbXExeDhKdkMwa3JwRTk0SWxPQWM1T1IxeFh0cjZ0YlRTcEo1cUtUeVBuemtlbE5oMWxsM3F1eGh2SkdUeUswamhzSTF0SDd6RjQzSFIwVXBOWDNhUG5hWDRMNkhKT1NrMXdwWWNiaHpTWGZ3VTBsYmRmK0p0SVpsYmxmTHhpdnAxcm1LNEN0Sk9jamtMdUhJOXFhYnlDYUp1ZVI3NTZWS3dlRmIyVy9jRm1HTlNsZDNYb3RQdVBraVQ0UklpLzhoZkFCK2JjdVJWUS9DUVRzaU5xYXB1SjJQczQvRTE5WUc1dG5mWXk1SFU5dnpxMUg5bGtVNE8wRE9NNEkvQ3RIbCtGNkovZUVjMHhidDcwZnVQalcvd0RoTHFVU3hpRFVZWENuNzRCNm50NzF5LzhBd3F6eEpFVkprallzMk05L3hGZmVvUzIyb3FsY0JnZWVTZnBUYnhyZjdTQWg2QVpiR2NWbi9aMkh2dkw3enBXYlltMTdRKzQrQ0xyNGRlSTQ1VkFpak9Uako0L0txSC9DdWZGZ3lUYm9WVVkzQnhtdnZtU0cza0lJa0I5UzFWN1cyalFGWDJBeURCSHA5S2w1WFI2VGtPT2IxZHBVNHMvUGVYd2Jyc1cvenJDVTR3RktFRWMrdFp0M29IaVl0SEdOT2tLOGM3ZUNQd3I5RUxtd1Q1bzAyNHdNTVRqTlhQN1BpaGdVdklOekx3VmJvZmVzM2xVVmExUi9jYmYyeEpYdlJWa3I3bjVuWEdrNnZFZHE2ZE53T1FxRWpOWXIyT3NqWVh0cFk4OUJ0UEh2WDZoVzhiUlRHTXJ1aWRja2djajhheUJwbHZGZU1UOHk5c3J6OUtUeW1YU3ArQkx6bW1sZDBYOTUrYlhrM2lTRkZNbU9wWWtnOFZYdDlZdjdhY2xISmJvY2drZ0d2MHVzdEJ0bnlyMnNiRnlTcDJaSDQxV244TGFjTU0ybndKak81dG1DZmVwZVYxRTlLaSs0bFp4aHBhK3ltcnZ5WitjemVLOVJFejdwSk00QVhPUlYwZUk5VWRISXVkbTVobEFjazQvbFgzL0o4UDhBUjdxekxpeGhPL3EzcCtGYzVCOE9QRDRTUU5ZUnRqSkRkOGlzbmwrSVRkcWlmeloyckg0TnhqelUzZDdYU1o4VHkrSjlaMmtTVDVBd0I2L2pXeXZqbldJa1BsWEN0Z0FZeHpYMDNQOEFEdnczUEhJc3RtOGUwNTNJZlgyOUs1ZTQrRk9rUlFOSXNMZ053UG01eFVMQjQ3ZFMvRmlXUHk2MXJXLzdkUEVvdkgyczRWbVZXN0U5NnRwOFI3MHpzakl5aE1jRG5Idlhva0h3cTAzbVJidTRRZ1pIb0QrTlpsMThMWm1oWXczSjNrL1B1WHIrTkNwNWxIYm10NU1PZkthbldOMzZvcUo4U201MklYVHJuUFdtL3dEQ3oybjNqeTJBVURrY1Z6Ny9BQXUxTUp0VzdVSHIwNjFVWDRZNjRsdkxrb3hQQXczNjB2YVppdWsvUFFxV0Z5dVN0N3YzbmJMOFQ0R0EzRjFicGpOZExIOFJZRThwdnRPUFZldGZPc3Z3MzhSSUJ1Uk4yZWdiSk5OLzRRN3hQRXhRV2JNUmpucU1WcDljeDhkSEdYM0dFY295NXU4Wi9jejZoaytJZG5NWFUzWTJFY0w5YXZKNHRzSGdYTWtiQUVEQnI0d244TitJVmtMZlk1TWcvTUFLaWd0TmFUbHJhWWJUeUFDUnhTV2FZcUsxaitCcFBKTUc5ZVpyNW4zOGZFMWtBaC9kanA5M2pCTmFBOFIyWjVQbHNUM0pyODc3aTQxRjNabjgyUElBNHlLeXJyVUwySjFRUEsrQjE1RmF4emV0MWdqbS9zR251cHM3NGVKTkdzQzR0b2xCeWNBRGl1YnZmR09wM0trSTJ3SG11QnROTHZKSlYySUR1NkhyWHJ1aytDYnFiYUpPZndyeDRUeEZSV2lySjlqNjJWUEQwMm5PV3k2czhuZTh2TG1VNzVYZlBibXJrR2szODVaVmhZWjdtdnJUVHZBK25XbTFwSFFFZGMxdHRkK0hOT0JHVVlpdlFobHJldFNvb3IxUEtxNXBUVjFTcHVkdHJMUStickR3QmYzSVF0bkdPZTFlcGFkOE9iVkFESU1janIzRmFtby9FWFQ0RllSN2ZiSEpyeHJVZmlCZjNKTzJUYU93eml0MS9adEZ1OTV0SG4xSloxWHR5MDFDRDg5VDZOVFF0QnNNZVpNZ1A0R25TK0pkQnNGK1hia2Q4NHpYeHZQcmVvWE9NU01jbXFNY1YvY1NCQ0hiMnhXRHpPMmxPaWtkTWNwcVRkNnVJbGZxcm4xSGVmRXFQREpGd282QVY1WnFYai9VSmdRcFB0elhLMi9oUFY1MkJ3UVBvYTlGc2ZoemVTQUZsSUJIek1UVU9wbU5kL2F0OXlOSGhNb29heWNYTGU3WjVOTDRpMVdZL3dDdmJudDZWVHpmVHNyRkhiMS94cjZyMC80ZjZaR1Azc2U1dlVHdTZ0ZkRlaldXU3lMa2NjODFjY3J4RXRaU1NIUE5zSFRqN2l2YnNqNHJYdzdxVjBNaENxOTY3KzE4QmFoNVViRkd3d3lUamcxOU55U2FMYkZqdlRhQjBGYzdONHowaTNVYkZ6dDRBSjRINFZvc3Z3c1A0bFZIRFBPTVpVYVZLZy9tamxiRDRackpFcGxud0IySTVQdFhvTmg0SzBxREllSU1BZXByenE5K0lwSmJhUW9QVEZjWGMrT05RazREUGduclZlMXkybGJsaHpXOGduSE9xeitOUVhsby93QUQ2aGwwelE0WTloOHYvZDlLdURWZEJ0NEZVVHFObzRYdHg3VjhXeWVJTDJVWk12SUJHUjFySGErdkpuQUx1U1JtcGVad1h3VVlvbUdVWWlUVHFZaVRQc08rOFg2VkdXMmprL2wrRmNkTDhSWUk4aU5Sa2ZuWHpqY1d0K2RnRVR0a2RldGJFR2dhaE9BRnQyVWZ4YzUvR3VaNWhpNVBUVDBSMlJ5ckNVOTNmMVo2cGMrUGIyZGNxekQzeml2UHIzeGRxY3VBSlR6eG5PZnpyYWk4QjZxeXg3OTJEL0t1NXRQaHZGeHZKdzNITkpMTUt6KzErUmJwWlhSMWx5ZlBVOE5uMWpVbUpCa2JiOWU5UWxyK2RGWXBJd1BHUVRYMU5IOE43Q0VZWWxsSFBUUFh0WGNRZUV0S2hpanhBcDRISFN0bGx1TWw4Vmw2c3dsbTJDaHBCM2ZaSStKazArOWRnQkF4RERBeUs2NGVFdFZNWE1KUWxjakk2aXZzMFdXaklBREZHaFRrSDMrbFNHNjB1SURmTDVub0NlbGEvd0JscGZGVU9lV2ROVzVhUjhmVy93QU9kWGNEelh4azU0NzEwc0h3dGRZOTd5L01lTWVtSytnN3p4UnBjUkcxdndyQ2s4WTJBVHF1Rjk2MFdGeStIeFR2OHptam1XWjFMMm9xM2ZsT2IwcndEcGtUcHZRTXhPTUFkYTlNaDhFYVRIRUNscWlsVG5wbjg2OHhsOGYyS0FiRzJsZjRoem4yckxuK0lwWmdCS2M0K2xhZTJ5eUgyVS9rSjA4NnF4ZHBTaXZXeDlBVzJreHhoMEN4aFQ3REEvT3I3TFl3UklQTUhCNUhYTmZJZHo0L3VXMkxrZ00yTWs5S3AvOEFDVTZydlpReWsraDV4OUtVc3p3eXR5d2JDamxPTWRPMDZpVDlibjJNdDdwVzhzWkZ6am5qdlZOdGMwOU1NT01mbG4ycjRkYnhGZUZ0eHVHSnllQitvckxtMWJWSnlDclRiUWVCeWZ4ckwrMTVXMHBwRnh5V1RsWjFmd1B1dytNck5NS3hYQysvclhPemVQYllGOXR3b1VmZUFJUEZmSU1WbmZYTzRKYnp0dkhIeW5GYjl2NFMxdDVUdHNtQUk1M2NIbjJybGVZNHFUMFMrU1BRZVY0WlJWNXY1cytnWCtJbHVxc1RNMjQ5TURtdVNrK0pyckxsVmtKOSs5Y3BEOE85YWxNYXNGallnbGR4clppK0dXcU82bHIxY1p3eWhlbGFlMnpDYStHWDNFTENaWFMza3ZteW5MOFI3a2tNSTl3WnVRVDB4V0xONDUxU1JXUHlwbm91UDU1cjBjZkNPMzZ2Y1Nna1p3QnhYb05oOExkRWJ5bGRKSExEbmNjWUlyTlVNZko2OHkrWnRHdmwwSXRjMGJlaDh0anhSck1qTUZ1R0dPbTA5UGF1ZmsxN1ZKcFBtbmxjQTh0azRHUFFWOTgyL3dBUGRNdGt5TENGMkp3T004KzFkSlplRTdDS1FPYktKV0I1RElCK2xiTExzVEpYYzdlck9TV1k0R0RTaEJ2MFNQZ215ajFXOHVuZFRLeXlJRUFLbkJKOWM5RFdnZEE4UnV5SkhZU3NwNFlzT0JpdjBGdE5IaFM4ZVNXQ05BV0lWT2crdGE4VmxhaDJ6T2dDcVQxQU9md3JSWlhKN3orNGw1ekdLdEdudjNQejdQZ0h4UTF1Slk3WUtOMjNhVGcvWG11M3MvaFo0b3ViZU5aWmJmY3B5RkxZNis5ZmFnbjAvd0NVTSs0ZzQzZXc5cVNQVVVYQUtyd0RnN2UxYnJMS2Eza3puZWJUc3JVMWMrVExmNFU2emJ6eHhUM2tlSEE0VVpJK3RkZ253bHRKbklrdXBoa2psQjFQNDE3OUxxc0pNYk1lbkp4M0lxN2NhN1lIWXA0NXpuT0syK280V05yL0FKbWY5cDR1bzNaSkxwWkhpZytGbWsyMXVBL21Td2tZa0pQSit0V2o4TWZEalNKSkhZU0tBb3gyM0QzRmQzZWVKdFBoTGJaSWlHNmt0ay8vQUZxeUx2eDNZcWh4ZVFodW0zUHBTOWhnWXJWeCs4emVLekNvM2FVdHRMS3lNMkR3TnB5eXF3MHhGQXp5M1VqM3J2eDRkMHdOR0k3YU5VSzlkZ3J6Z2VPZE9NUmxXNmFSaC9DT01WbGo0bGFZVHRLUzVDODg0Rkxtd1VkdVZmSVVmN1FlajUvdlBjNUxLRzNzNUlZN1BKWlFRNVFERlJSUjZoNUVTczZScURueXpqdDNKcjUybCtMRmpKdVJZcFNvSEIzZE1mMHJIVDRuMmJLM3liY2QzWTlmU3JqaWNKRmJxL29ZencyUHFTVHRLMXJhdXg5ZENTSU5PZk1Da01CMTRZVkJjTXNzN1BnRnd2cmtld3I1T2wrTDEvTnBrTnJEYlFOSERJN0tRUG4rYnJrMWgyM3hZMVFFaG9vd3JBaklHR0dLei90Q2drL2Rabzh1eExhOTYraTMwMVB0VGZBbXp6bnd5amxWWEFQNDFBYm15V01sVkk1QTlBUjcxOFA2aDhSdkVEc1VobndwK1pTRnlTSzRxYnhwcklVU05lUGx1Q3VNQUgxcVA3UnBMN0xaMVF5MnUxdXREOUJaamJUNGI3TnVZWUliUDNSL2hVTWR6WnJKbG1DSURsc01LL1BXVHhWckR4eUJiMTNVcjEzSGo4dTFWWk5TdlhFTExLNUJVQWpjU0Nhd2VaZjNQeE5WbFVycDNSK2lBMXZUUkcrMmFNbmVjWmNBWXJDbjhXMm9WNDF1WVVVREdBMytOZkJOMUxxa3NxZ3hTamNBVVJWT0NCNyt0TUZockxTcDVkbGNaSXp0S0huSFdzM21VcmFRWHpOZjdINXQ1djVJKzZwUEcya3d4eGxMeEE0WEhIUUNxMC94STBwZ29ONzBBR0ZYdlh4MUQ0WDhTVHF4VFQzWThuQlVqQTY0cWUwOEJlTHJwd0YwNlZldTBuakdQclMrdjRoN1UxNjJIL1pWT05rNmoyNm4xQS94SDBuejFDWE1qUGc5cWdQeFEwNmRtQ1BQdGl4dkIvd3J3S0w0Y2VOak1yL1pGVmx6blBHZTJSNzEwdW5mQ0R4cExCSTZtRW8rYzdtK2JPZmFzM2pNVStuNEZmMmJRdHJKMjczTzdsK0psaXl0SmJXYzdJT1NTZVBmNlZnUy9GblQ4aGtzV3l2WXNlOVVZdmdsNG1abTg2NThwamtnSmtaSGMvU3RYVC9naE5QTTl2ZGFySEZsUjViZEFUNmZXcCtzWXhwdDMrNHVHRXdTa2xkZmVWcHZpek41ZVk3UlBRWlBQMXJMdVBpM3FtMEh5NHQ2NHdwejgxZDkvd0FLTEFDUXo2b2k3U2NsTWJ5S1ovd29tMUZ3SUpiOHNPQ0NSemcrOUpWTVkrc2pXVkRMMG5hMTcyM1o1aFA4WDlkdVlqaUdFTmdZQUhXczI2K0t2aVF4Q09KaDh3QklFZU1ZNjE5RFIvQWZSMGpFc2VwYmxBMnR5TWYvQUs2NkJ2Z3A0V2l0WXBEcVV4WmpoZ3B3VjlLbGZXMzFZL1pZWHJ5N1gxZlErU2g4VC9GVWpBZmJBTURna2MwMisrSXZpbU5ZVisxeUU0SmZQVG50WDFQRjhJUEJVTVV4WXl5TnVHT1R6aysxZFhKOE9maC9Hc2FUV2JPVzZIZG5CRkwyT05iNi9lVk9XWHhpbGVIM0h3OGZIdXR6UXFCZGJTT2hCeHo3MVRsOFlhNmhZZjJoSVNvemdPZWErNzdYd0Q4TzRwYmhackpYZmNCR0ZXdHovaEF2QnNWdytkTGlKMjVVbmtmalZld3hUM3Y5NUh0Y0UwdVZyZnNmbkEvaXpYNVdDbzF3eGJra1phbVhYaVBXekkyenpFR0I4blBVZDYvUksvOEFFYy9obUc4aDBmd1hwK28vYkxZd3M4N0NMN1BJT2pBNE81T2VSMXJFdDdmN0ZvOEV0elkyY2wyVkVnQWp5b2RlZW5YYjJ4WENxR0xsVm5IMmI5MVhUdm96cVZYQlJwcDgrKzZ0c2ZDTFNlS0dWWnJxT1dOSCs1dVZrRCs0cXZZMzkrclQyOXVoWWx0cjhienVQY1o2VitpOHZqL3h2citzUVRhejRjMHV5MHFKQW9TMlV5TkkzVGNXY2ZLTWRxOUFqOFBhUm9CWFViYXh0bWErSm5YT09VVTdSK05aMHNOaTVLTHFVK1J0dFd2Mk5KMXNDblU1SjgwWXBPOWxwZjB1ZmxVTkwxNXIxWVRiVHR0UHovS2VNMXRTYWJxNGxpaGlzN29Ia0RLOVQyeFg2b1d1dnJiM2pOTGFXeUxJQVhiRzdBSjc0N1ZGYzNkdjlxayt6V2NVa1VoRzA0enQ5MTcxMnJCMWI2bzRIaXNQYlJ1L1kvTEpOQThTTkhLRFlYTW5sajVpcUhLNXJUdFBCK3ZNaU4vWWwxSnVQM3dTTWUzb2EvVVlMYzJjdm54QlE3SU93STQ3RUdtM0hpVzlpVlkwV0tNazdtR3dISlBwanBYUkhCVkw2Tk1Iak1QR041S1IrYWIrQWZIMCtmTDB4eXEvZEJ3cllIb0tZdnczOGR6aUtTUFM3c3hoVG5kaklQZnIycjlRTGZWcnBvMW1pWkE0YkovaHgvdTFtdnFPcGVaTWl0d3d5UjBYbXFqZ0o2Kzhpbm1GRlJqKzdsOGo4MGJyNGIrTjR3aXlhUmNqY0FWYlAzdnA2MWVnK0YvaitRYm0wbVJzakdIYmFlT2hBOUsvU0NPOW5FUUYxZHl5T25DREFDajZIdFd6UGYzZDdFaStmSUZqd1FUeVdQdWFmMUYzK0luNi9TYXY3T1M4cnE1K2NyZkJyeDgwZm1EU2hGdUdBeGZ2VlcwK0VIeEFSZzMyQmNaKzhXd0FSMXI5TTlUMXlTNXRHaGE1bGprWERSakl4bFIyeFhPMjAyb1JHVXRkTzJGQjJGc0RMRG1wV0JrNDZ5c09PUHBPWHV3azEzUHp3VDRHK1BMdThsMlJvek8yY0JzWjkvcFc0ZmdQNHppU1F2RDVTcWNGbWtCK2J1T08xZmRWdExkck9aSG5kTUJpcksyU3ZIVGlsdkx2V0pkclBkZWJHd1VjRXFlTzVCNzAxbC92SmM2c0R6R0toTDkzSy9RK0JvUGduNDRNSm5pRUI4dHlBK01qSDA5YWZGOENQRnNKOHg1TGNpVG9OMk9mWGl2dXBiV2RWRHkzeE1aQkxScmtNVFZlSkZzNUFWbG1sREg1U1d3QVBmTmJMQXc2VE9kWmkxdlJTK1o4Y1EvQVh4amRSN0VudFl4M3c1T2Z6N1ZITit6eDRxVkd6cUZwdFg3K1c0Qjk4Vjk4eHlBd2hmTTJsbHdTcHpuUDBybWJPdyt6eU9pVE5NWEpKem5IdUFUU1dCaTczbnQ1R3J4N1hLMVNUdnZyK2g4U3Y4QXZGY2NhTTJxV25BQlhENUI5czFhc2ZnVnI2M0JsbHZyVU9mdTRiT2MxOXJlVFpySjViNHlDY2dOa1ZpNmdMVWlNUnhzby92QTRxbzRHRGZ4R1R6R1VZODNzMTZYWjhnMy9BTUR2RmR6Y0V5WHNDdXEvS01jYk93SHJVMGY3UHVvNFQvaWRRZVllb0tuajJ4WDJuWlErWWx1V20zNEo0M0Z1UFNvTDIzdVRPMGxxNFFsY0ZTU09ub2FQcVVISzNNRHpDU2hmMk4xMnZxZkhVWDdQdXNORXhtMTIxalJjbFl5Q1diNkN0SnYyY3RXbENmOEFGUVduNzFRRlZnVTZkcStxNExlSHpVWW41c0VrWkp5ZlVFMCs0S1RSa1NTQmdWYkdlQ01lbUtQcUsyNTlBcDVrMVord2o5N1BsZHZnRHFGakpHa3VxUXJ2VmdONDNiaU9NREg2VlFpK0FtcEMzekhyRnVxaC91dDhyQWpzYzE5VW9rVFJSc3JFcVJnS3paSTlxMlJEWW0yamtsS3V6WlJ3UVNjQ2o2bFRTVjVNMVdZVGszKzZXM1ZzK1JQK0ZHWFU3bGY3V2lEOVd3TWcvU3JBK0NGeEpGSkdtcDI2bVA4QWhZWTNFOXg2bXZvYVRUV3RycGpETXdYR1Y1cm9YbGFVSzhzV1dYaktxTS8vQUs2cjZsVDZTME9lT1BxNjgxS3pUKzgrUll2MmYzTTVSdFVRWlhKT09BZmJGYXNQN095endNZjdaaitUNVNDTUhKNTRIZXZxK3pLUjI3R05TMGhZakhYODgxUXUxbXUwYi9sbGdiUmc1M3NlMVovVXFmTjhWdk0yK3Z5c202VjIxc2ZLVnIrenpleW1VUmF0QyswNEliNWZ5cUc0K0FsemJlV1Rxa2NaQnkzYy9VZTFmWVVHbm1PVkhNZUdDNFBPY0gwcDk5RmFURmxrWGUrM2h1aHFmcVZLL3dBVjBKWTJvNDZ3U2R6NDhrK0FhemhWaDhSeE81SVAzRHlmclVsejhBTmFsZ1dXMzFDUHl3MnhuNSs4T3ZXdnF6YkZIY0kwT1ZhSmVvT0R6MTRxM3FMTzFvMXVzMGhEbmVWQnh0UHJtcldFaGRKUGZ1VDljYlVtNDdkajQ3UDdPbXF3MjgxMCtyd2JrVUVZUEp6eHhWZC9nQmZ5SzVUV29rWmRvNkhCSkhRMTlUSFQ1cEZRTGNNa2U3Q3F4eU0rcElyU2lpV0c1VXp5aDhBakdlRDc1cFBCUlRmdmxMRzFYS1A3dXk2Nm55dC93elo0aEdIWFZyWGFBRzl6K2RjNU44RmRjRTAvbDNrWmtDSExjZzQ3OWEreVpKSVMyV2xPOWR2bGdFNDY5NnQzR29Jems3QXJNTVBHVCtvTkpZSkpmRmNtV1lhdjkybFo5N253OWEvQXJ4QkxHekxlUU9vUUVrbm5uc2F0V1B3RzhSM0cwL2FiVk5yWVlFOEgvd0N0WDE4em55eVdSakZnRmdweCtkWk1DU1NiNUdrZFkzYklBSkFPM3Q3MWF3TVduN3hqUE1wUmEvZDcrWjhuSDRHZUpKcFBMaXZiYzdpZmwzRWMrZ3JRL3dDRkErTDJCa3VaSUVpVGdqZjZkeFgxQkpPVmxEQ0l4S3JjSEpKYXRzenhUYytjY01NNWR5TzFEeTlLelUvbFljTTJrMDA2Vi9POWo0U2Y0TmVKNFdkNGZLa1VITzdkd1BmTlZwdmdqNDNVeXVZSVZHQXcvZUE1QjdpdnR5MHQ5dUdTNEJqRERjcFk4KzliNGQ0YjZkamNia01lRkdjOGowRlM4Qkcra2dXWlRzbTRMVS9QcTMrQ0hqNlcyZGdrSUc3dStLeTdyNE1lTkxjdVdNQXhqSVY5MlQrRmZveGFhcERjeVNCMVpkcWNPVy9UQXJHbmhqTTN5L2RJSEJiRk5aZXIyYlpzOHlUamRSVCtaK2VVUHduOFpBc3dzOXdCenV6ajhxbi9BT0ZhZU16dmRiTGRLZXZ6WlAxNXI5RG8zZzhob2tsbVNZTm5ibks0OU0wK09lNUZ5V2tsMmdMeVIxNDdZb2VBU2Z4TW1HUGpkZTdlNStjVTN3djhkcXZ5YWE0ZEUzWlhuOGVLb3lmRDN4cWlJMGxoTGxqOTRkNi9UZXh2cnd5eTNNVEFDY2JXWE9PT21LcFJXMTJsdzIrUjlnUDd0RDBIcjFwUEwxcmVWalI1aTJsYUYxYy9ONkx3TjR5aWprSTA1cEE1NVlnVmpTK0R2RlVHMTU5S3VRcnRoQ09uNWVsZnFaZFhNOFRRaUY4bHlDQWNjWTdZOUtobjFWNTA4cTR6dkRnc1VYQzRIcFVmMmY4QTNuWWorMDRKdE9HeCtZTno0TjhUUEI4dWszS25jRHV3Y1krbFpENkQ0cGpEQVdGeUdIUUJDTS9sWDZWVGExZUZKTW1SMGpZcm5hRGtIcG4zcXBaYWhLZkxUenNNemY2dGgyOVFhSGxyV3ZNT0diMGVhM0w5NSthZHhvV3JpMk82enUvdExIREFxY0QzckxXejE2emVOdnM3dU1ZeUZZL2hYNjJPWVV1UkdybzRZWWVVcUR6N1ZRV0cydFpDREZDNUdTdVk4dDdWS3dFcmZGdjVIUkxNYWQvaGR1cnZzZmxaYlcyc3ROdjhtV01ucmxUeFZFdnJLVHpJczhuSFZRRHpYNmp3eVEzV3FieGJ4SENuZmxlRng3ZDZ4cmkzMDZLL2VSYkczY0hJSHlmS1NlOVArejUzc3BITC9hVkNLdTQzVForYkVGL3FFVVJqS3lxeFAzZ1RuOWF6ZjdWMVJwWkVTV1JRVHl4WTErbmwvcG1rYllwVHA4RGtvQVVWY2RheUl2RG1qUEhLeDA2QlFUeGxSblBvS24rejZxZHVaRy8xL0R5MXM3SS9PaE5ZMUtMT0xxUmlvNXdUK21hdEo0djFHTHlvL3RyZ0hKeUNUalByNzErbUMrQi9DUXRGRTJqUW1SbEQ1SXg5YTRLZndKNE1NczJkTWoyaGR3Wk9DUHJVUndOZHZTV3hjc1RnOUc5UCszVDRibDhYYXRISXFpOGtKWVlKOUtvemVNdGZpYkF2Sk1IdHU3Vjk2djhBRHZ3bWxpN3Bwd2t3Z1pYQjZrK29yQVQ0WStENWpINW1ueXhzdzVaVDhwL0ExZjFURXJhWDRzajZ6bDdUNW9xMytFK09UOFF0ZXRmTFpibG5rYkJVOWRvSFlpdG9mRXZYbllrU2NrODhjNXI2VHZ2aGI0WTNxZklaTmc3SEhIdldQL3dxN3cyaUZvNVp0MjRGUm5qTko0WEdyM3VaL2VUQ3RsanNsR092OTA4YmY0bWFzcnBFc2tiTTNKTzNrZTMxcXpEOFR0VlZzTEd1UTIzTER1ZlN2VXB2aERvMG05L3Rzb2tia2NkRFhKRDRTYWVwWm0xTjk0WTQ0cEtPUDZOL2VPVWNzVWszeS9jektQeFN1bzRWQmhCS3NjWjYwMy9oYVFrdzdRODRKS2c4RDYxU3ZQaFJLMHZscnFJQ2s1empKL09xMFh3bnZJWkNpMzZ0bmduYjFCcHhsbU1mNXJDblJ5eWU4by9lZFlmaWpiSmFSeWVVNVpzL0xuajYwNlA0cDZhMFdaWTVGR09vWUhtdlBydjRUNjdHR0MzTWJsZWlrNHJCdWZobHJ3MmZ2SWlTdWNkaFd6cjVqMmw5eHpMQlpadDdWVzg1SHR0bDhVdFBVNFh6RkM1cnE0UGl2bzgyQkpLNDlEMXI1WmwrR3ZpaU1odkp5aktkcDM0eldETjROOFZxa1NyWWtxdlFCYzVxZnJ1UFQxaS9uRWY5bTRCcjNacTNsSk0rMUxmNGwyRWVXanVnRnp6a2Z6RlJqNGk2WkpNeEYyZ0o3bmdaTmZFY25oWHhQQ0JteG01STQ5ZnJWTnRIMTRNNnRwcytEMVFLYWF6SEZKM2NGOXhUeXVnNHBlMGRrZmZmL0NXMkNTdXhtaVpqam5kbmlsSGlqVDdpWW56NDg0NEFhdnp0dUxYWFltQVdHVkJuSVVxU2VLYXQ5cUMzR1pJNUZCNjhFSDZWcXMwclIxNUVZLzJMU2NXbFVhUDBkYlhkTUNwa3FTL2ZQUUNyRU9zMkxzeXgvTURqSXlLL055UFVOVFluTFNZSjQ2a1ZQQnJPb3dPVzg5d2MrdGEvMncydGFYM000LzdBbkZwckVmZ2ZwYzJwMmp4bFFpZ2pBT1JuaWtXZlQzaE83YUNNNHgxcjg2b1BGZXNoSk1YajRIWG51YWxYeHRxOGF1RGRFOGl0WTV4QmIwL3hDZVNWR3RLdXA5MzdiSm1Za2IvVG5BRmIwSTB4MFViZHBBNml2Z2VIeDdyMGJFczY4anVNNEZhVVh4SDFiSkpLZS9IU3JlYVlkMjl4a3h5bkd4dGFjWDh6N01mVHJjek0rN0l4MnFHTFRyZUxjZG5CSE9NWkdmU3Zrci9oYU41RUNyUUJ5VndTVDYxcXhmRVo1bVRFZUFQOXJ2V3F6SEJQcGI1SExQS2N4NXZMMVBwQWVHSVpqdk1jTDhuS2xlbU81cmticndkcDd5WmExWEo3N2V0ZWN4ZkVpT1BkdkRBc09NSHRXOUg4U3JVS015TjdmTldxeGVYU1d0dnVPYVdGenhTc3BTc3UwanhuVDMwSFM0UUZmekFvd0NUZy9uVWQvd0RFVllmbHRvMEFIY0N2bWFJM2N6NE80bXV6c3ZEZDljb3AySG5pdms0NHV1MXkwNGNxOGtmbzlUQVVPZm1xemNuNXN1WC9BSXkxTzdkaTBqQWM0eFhJeTNkOWRER1hQcml2ZE5NK0hraGozeURPT3hyMC9UL0NXbVdpZ3loVkE1T2E2WVlURlZHdWVUUzgyY2RURjRHaEdYTEZYWFpIeWxwK2dhbmRBQVJNTW5xYTlFc1BoL09aRjNBNVBIVGl2cEg3Zm9GZ2pCZHZBeG5OY2ZlK083R05TSWRnSS9PdXY2cGc2YVRxVmIrUzFQUG5tZU5xcmxvMEdyOVdVOU4rSGNVV1MzQnp6a1Y2SGFhRnBOaW5MSVdVOWNqSnJ3V2Z4L2V5dXdFaEFINFo5cTRtNjhUWGswalpud2UzTkN4bUNwZkJTdjVzdVdFekd0RzA2dkwzc2ZXbDVyZWoyeUVLd0pVY0N1TnV2SDhLUmtJeXFEMEJOZkwvQUo5M2NTRmlYSXgwelVjV2s2amN0OGtCNVBGWnp6VEVTVm93UzlCVThqdzBIelRxT1dtdDJleFgzajZkeGhOMmM4RWNBL1d1RHVmRm1xU1NjeUhIMXpWcXk4RWFuT0ZHMWh6enhYcW1tL0RGMlJXa0dUNmQ2NXVUSDF1a21kOXN0b0pPOU9Odk04RnVkVXZweC9yR0lQQjVxakhhYWpLVktLNUh2WDJoYi9EM1Q0V1FiQmdldGRNZEQwTzFVSEtaSFhPT0s2b1pWWGZ4U1MrWndWYzh3a2RJUmxKcnNqNHUwL3d0cTEyMkFwNVBRMTNGdjRBMUYyQVlOZ0huUEhTdnB3NnRvVnFGeDVmSFVMMXJPdS9IT25xcE1jWUE5VGpOYmZVTUhCcFRyWHR1Y2l6ZkhWRis3dytqMnVjTnAvdzBpUlZhVDVpUUs5RnN2QWRnQ3NqUmRPRFhFWEh4R1NMYXFTSml1T3Z2aUhlU095cTdZSTdWWHRNc3A3UXZieUNVTTRySzdrbzM2WHNmUWY4QVl1bVFTZ3VzYTdUamRubkZTTk5vZHRLQWpxRGpuNm12alc3OFhYek8yRzRIcWV2dldFZFgxS2NqOTZRVzQrWDJxSlpyU2o4RkZFUnliRXpYN3l1N2RWdWZkTno0czB1MmpDcktNaXNCdkhka2c2eGdIMU5mRnFKcVV6bGkwakhwakZXTGZSOWNrZmkyYkRIcVJXQ3pURnlkb3hWdkpIWERJc0hHUHYxRy9uWStrNzc0alNOSTIxempuZ2Z6cmtwL0hzK3draG1YMmJtdVRUd1JxbHc3WmtDWUhiMTlLNlMzK0cxMGNDU1lnRWMxUHRzd3E3Y3gwUnd1VVVXMjVRYjgzYzUyVHhsZVNCMlJEd1JrNTZBK3RaRTJ2YWhJRDh4NUdlT3RlOTZmOE1iS0tCWGQzQmNqanNhNjZMd0JwTWJLMzJkU0ZBejN5YWo2bmpxamFkL215Wll6SzQvRHl2MFI4UlMzT3BUSEFMa0h2MnFXMXNOYlo5b3RwaUNPRGc0RmZmNDhMNldoeDVDcnhrbkFCd2ExbzdMUzRWWElCQzhZeld5eWl0cGVhTVo1emg0YVJwdG54SHB2Z3ZYNXcyKzNLZy94SGcvV3VxYjRaNm9rU3U4dWQzYm9hK3ZMZWF3aWtVNTNMazVYMCtsVFQ2dHBZeHVrR1Y1QTlxNlZsZUdqYm5xUDc3SE04NXhMVm9VcmZLNTh1bjRUbHZKZVM1WWJ3UGxBcjB1eStHbW5wSW00U25iamNjOGtldGVsVGVKOU9VSTNtSVFPUG1PVFdKZGZFSFQ5cmZ2SStPNEhRVS9xK1hRM2NYNnN4V1labEp5U2cxMmZLTXRmQXVpTHVZV2F2Z2tBbm44YTYrMzhONmZFcWxiZFZQUTRIVVY1ZEo4UkxPT011a3B3T20wWTVyazduNG9oY01xTXgrdklyWlY4dmd0RkYvSXk5bG0xVkwzcGE3NjJQcVpkSjA2TlZBS3FjWmZnREgwcHFTNlpDeDh1WGNjYzg1NUhwWHgzTjhTM2szRHkvbUM4RW5JeFhPSjQzMUZqOGtvVW4wSE9meHFYbU9GVzBYOGtKNWJtTXJYY1V1dDVObjNhZFEwOWdIbFVGaWNLUjAvRVZCSHFWbkRFeElKQ25JemdWOEYzWGk3V0RjUmVkSzhpQWpkR3Ayay9RMVF1L0VWM0pJNnh5em5kMDNFNS9Hc2Y3V1NUNWFmNG0wY21xVGE1cTF2bGMvUUdUeFhwOFFMNzRRU083YzFqU2VQTkxoQ2t6SmdIbkE2Wi9yWHdTSU5VbEs3TGVhUnNmd3FTUHhyc1l0SDhSVFI0YXhmQkE1eGpHS3kvdEt2TDRhZHZ4T3RaUFJTOStxNWZnZlVkeDhUZElqa3l0eTJBYzVBcmxKUGlYcDd5U09zcnZ3VHpYaEZ2NEM4VDNETko5a2ZHZUFlaEh2WGF3L0MvWGZNVWxZbzFWZVNPVHo2MG5pOHdrdmRnL3dEd0V4bGwyV3hmdlZOdW5NanBKZmlmSTd4N0lHSjZEY2VQeHJHbitKTjk1cE1VS2NBaGd4NlZmc3ZoWGNONU1iMzRWbTdGY0JmcWE3NlA0TFdrVnNibTQxQWJjNCtYQXorSFdzNzVoSmF1U3Y2RzhLR1hKdTNLMGwzWjQyL2ovWGl3Q1NCZDNPQU9uNDFTdVBGZmlQS0dTNFp0NjUybzJDdzcvalgwWGJmQ1hSb1NqSzdzTWM3bTZpdGlENGNlR0ZjckRGTEk3TU9IKzZCN0hzYVgxZkd5M2svdk5GV3krRXJMbDA4djh6NUp1ZGIxR1I4cmN6S3VCeGs3cXhaZFIxSHpTQ2JpVEFIVW5CcjlFNHZBZWdXODQzV1VZTGdCV2JuQjlEVm03OE5RSzZsTE9BbFdYSzR6V3NjdnJTM21rVFBNTU5DL0xCdjBTUitjYXRxVTBnVklKemtncUFwNi9qVy9MNGM4VTNwak10ZzYrV3B3UU1FLy9YcjlKbzdPM2paQkZiUkt3T01HTUVmaFUwMEcxVkkyNVZpQ01EcFZmMlk3YTFQd0U4emdrN1UzOHo4ODdmd1I0MWtnaFpMVjJROHJ6dDYrMWI0K0huaXFhZjVZQWluZ2htNXpYM2hKTExLRlo3bFVDdHh4Z2pIcFZlYWVJa2t6TWNrTVRqMDcwNFpkRy94czUzbXJXMU5IeGZiZkNEWDVBWmhjUUltZHJNZXVmU3RxSDRGMzhUSUh2L2treVZPM0krdGZWVWVvSmJ4UklqYmh1Sll1TWc1OXFvWEdxQnJxR1ZaQ0hVNEEvaHg5SzdvNWJTNnY4VGhubTFWTldpdW5ROEYwejROMlhuUEpOcUorVDcyQnR6bjBQYXVwMC80UytIMGwzdFBjU0JBY0JlUmoxcjMyUzdFTUNPNmdDNFFzcmNIZ2NjaXNpMDFhSUtBcloyOVRuSDhxaFlQREs3dW44em9qamNTMnJxM1hZNUEvQy93akVvWi9OMzdmbUFHZUQ2L1ducDhPL0JxcEdIc0JKdXhna2NBanNhN0dYWFVKKy9IbFQzWUQ2WnJMbThVVzhrTWltNGlVSURuR0J6N1ZQMWZDcTN3amxpOFM5bTE2YUUrbStFUENVQ1J5UWFRcVNNV0RISVpWQTlqVGswblNERzVqMDZBOGxjN1FPbnRYR254anBFVVN0OXFWU01nN2ZXczY1OGFhVUc0dUFkNjhNT0JuM3FyWUtMM2laMUt1T25CWGxMMHVlcVdpaU1vbjlsd3VNYlJJL0d6NlZ1ejN3TTBVY01VUlFMaHdCazU5Yyt0ZUNueHpwc1lXTjd0Z09wNzlLeGg4U3RJUUFCNUFDY1o0d1FmcFZTcllLL1JzNS9aNDl4Vm5MWGMrcFV1WXhIY1N0Q3NRS2dLT0Q3Zm1heXRQa2pSVEpIY0VFRWxRMzh6bXZtNlg0ZzJlNTFDTXdLZ0QwUDBOWWwzOFJMV0pHWHlXRFl5cEM3Z3g5L1NvK3M0UlJaU29ZMjhicDlkZk0rbTdUVzlRV2VXT1daWFFzdzlRY2p1SzJHbnNsc09Kd1dLL2Q1QnI0NXZQaUZkV2lKL29ZTEZjNFBVVmt2OEFFL1YwVUFXcUtHVWxTZWNqdmlvbmpjTnB5d3Q4aW80SEcyZk5OdnRkM1ByKzExdVNHOVhLSTRkVGtzVHg3WnA4VjFCTTdsbFZHVWtxMzN1YStJZitGazNNc0JmWW9jQWpyL0tucjhSTDlFZm5lSkkrQ09DdWU5WXZIVWJOOHVwMVJ3RlpXNXBYMzBaOXdLbGxGYy9hUk9TKzM1aXdKSko3aW80TlNSWkgvZU94Yk9Uam44SytEejhRdFVXTndsMHhmc0g2NHJucFBpQnJNc29QbXNDT1NSd01kNkZqNDJ2eTNJbGw4Mi9kYVR2ZDlqOUF2dGtDN1R1Ym9TUVR3ZnJWNmJWQVllWFBLNHljY2V3cjg2bjhaMzVoY0pMS1dkdUMzSnhVc3ZqSFZwTFB5dzB1eGw1WUFna2owejBwU3pIdEEycDViT3p2SytuUSsvNDd0aEd2K2xKNmJjOVFmV3RMN2RaYkZCMmpxZHluK3RmbTBOYTFyN01XM1NQdFBQSDg2enpyR3NyQ3dCdUZCSTVHUUtuKzBKZnlvdFpZcmF5UDBvR3M2UkFaSExvV0pHM1BKQnF2SDRnMHlSem03UmZsSlppZjByODVMUjlaa2xCemNiV3prbk9QcnpXaDltOFFDNlpnWFpUa0hJUFExenZNS244aGF5eVdqNXJhOWo3eXZQRm5oMXpHalhrWmRUZ29EMStwclBtOFJlR1VTTjFuREVFNUdjZ2UzMHI0OTBMNGRlT2ZFU1QzV21hWmNUSkF4RXpkRlhQYko3bXNCZkJuaThYRFc3V2s2TXpoZGdVOVNjQVo3MWwvYU03dEsybSt1M3FkSDlteXNuSmFTMmZMMjdIMnpKNDUwQTRpRjJnQkgzU2VNK3RjZHBuam5UN2hWTnhJVkNTU1JSdVd6OGlOeGdkcThsMTM0Sy9FVFFvb1h2ckNOVEpqeWh2M09DUjB3SzgvdGZBWGpCSldpZXdrTzF5SDJqT004L05qcFV4ektyT0s1V25IeTZsMWNyZ3BlOG56SzE3OUQ2OGZ4N29aQkFsM0x0QWJiL1dwby9pVm84YkpzWGVxTGhnRGd0anY5YStaSS9oNzRzSy9McE15a0E0ZkJ3d0hhclVQZ0R4YTJGT25IZWVuOE5hTEUxM3BiOEFXQ3BMWHFmVEZ6OFh0TlZGVXdOdUhQek1DQ0t5bitLMmxOZFc1K1JCeGtxTWtEM3pYaDYvRHJ4TzZDRTJPRDNicnllMWFVWHdQOGFYRVhtSlpnWUI0RWc1Tlp1dmlJdnI5eG84SFNrbDd6dnBwcDBQV0x6NHA2ZHZJU1VGUWNsZ0NNL2xTZjhMVDBtR055c2pTTVA0Y0g2NXJ4MjIrQmZqWWVhOGtCU005OTRQSnErbndSOFZSUS9Pd1FzeEFZT0RWS3ZpSDFaSDFLbXJ5dnYzYTBQU1grTFViTW0yREc5TjJlR29oK0xKTWNndy95NEtyMFUrdk5lWGY4S1Q4WFJPZzgrQlF6Y3NXNy9oWGQybndCMXk2dEhSOVJSTm5BVVNqRFordEtWWEVmM3JlZzFoSVBSVFRmcWpucm40dXhTQUZZeUpBU1hDOUJWeVQ0eWw0eGdaSEF5Umc4ZFFmZXBmK0ZJYXZHQmFYRThHSXljWUlENDl5T3RLbndBMURPNDZuYmc5TnBQT094SXFuVXhMUzBkdWhuR2hRdS9mU2ZyWWhsK054U1dNd1doOG9BWnlmbXozNXA5ejhheVprOG41eHQzRlQzei9EOWF1SjhBYm9tVEdzVzdMajVodXdPTzlhNi9zKzJndDh2cXNRSzg1eGtBZTFUZkVYVzRTbzBYdk5kL2kveU9iVDR5NmxKSzdyWlFxaFg1UStjOGRUV1hkZkdpWm9Zd29CYkpKQ2pnVjNNUHdQMDB5S3N1dHB0WDd2QkE1NzFOTjhDL0RzVEFyclNIY1NXSUJJelZSV0t2c3lKMHNHMWR6MC93QVI1M0I4Wk5Ya2QxV0ZZNDBHUnhobSt2dFdmUDhBRjdXSTVDdVE0RGRqakZldFIvQmp3NFdCZldDeWtiV2JieitGUlQvQWJ3NjEwQ05meEh3UVNNSDZVbkRFdmRNMHRndVZKVFgvQUlFZWJYbnhwdVJLQlpRL0tGK2ZjTXNUM3g3VmwzWHhrMUNhMmo0QzRZRWNjS1BjZDY5MXV2Z2g0UmpnT3pWUE5ZS01PRndUNmppcThQd1k4S2dLbjJ5UUt3QllnRHQzclJReEZ0SXN4bERDWHQ3U1AzMy9BQ1BIbitJWGlLMnNvNWkreEp2dXlEdG11ZjhBK0ZuNjA4c1VhemVXcS9LejUzRnZmRmZTYS9CWHd0YzNLeHJxVSt4UVNDZWh4MkFwbHg4R2ZCVVVnMjNzcWtEQjNKem4wRlFvNHB2Vk0xVU1FbzM1bzIyM1BuVFVQaXA0aGl1RlF6WUNvTmh4dFAwSTlhdG40blRoSUM5NjBrbkFiNWRxcUcvblh2MXo4SVBDRWtUdExmeWVZQU5qQURISHJXREo4SHZDY2FJLzJpVmwyQnM3Y1pyVDJlSmVpVE1Hc01rL2VpdE81NDlOOFR2RVR5Q0tOb3hHT1ZiYjFxM0Y4VE5ZK3dreU1RUXgzYld4K25wWHMzL0NvZkNrNnF6M2NrVVlYb0JubXNsdmhMNGQ4d2hicVlyNjQ2Ly9BRnFhbzRwdDNUSzlyZzR4VjVyWFMycDVMTDhUdFVNSkN5NGJaazU2Zmg3MWxUL0U3WHdrUTgxdUR3K01mbjYxOUUyM3djOExBbnpidDFCSEdSazgrbGJWejhLZkE2d2ZKZW5idENzR1U4bi9BR2FtVkhFM3RxWC9BTEU0M2JqOTlqNWtmNGhhd1lta2h2WkNxQWJ3QjBZMUZIOFJkYVNaUTEwNXh5VzZEOEsrZ1UrRjNnWkkrTlNtVkdiNWh0d3Y2VmVsK0VQZzhBU0xxY3I3Z0ZYYVAwcVBaWXBicVEvOWhhdXBSZm96NTUvNFdqNGhSV1Q3WEd3T09TUG1CTlJING5hM0tIRE1NaitMUExmU3ZvWmZnNTRLdU1ML0FHaXdjdGhzZ2pwVlkvQnJ3cXNqUngzMHJEUEF3T0FPK2FQWllyc3laUXdicythTy9jK2VZZmlicmtTSzdTRmcyUVNQNVZabCtMV3UzS3hnT3FyR0NOeS9lUDhBdlY5R2Y4S2o4QkFyblVwRDh3UEtZSUI3NHJVLzRVOTRFSHl3NmxJQTZrc2RnQVAvQU5ZMUtoaWV0L3VLalR3alRzNCtlcDh5ZjhMUDFPTlYzTU1NTWpQcWU5T1B4YTFWWEJhM2lZN0NCN0gxcjNOL2cxNFZCNDFFeU5uN29YNVF0Vkp2Z3Y0WmJMdHFoaVA5MExuR0t2a3hIbVl4amgrYmRmOEFnUjRFUGlqcWVDWkgzcmp0eFZpSDRtWDAwT1VpSlpXNGN0Z2ZTdmN4OEd2Q3Zsd3ROcThlMWowMm5keDlLclhmd2U4T1JGd21xUHQ0SVhIU3BWUEYzMmthVGpoYjN2RmZNOFpUNHU2d1NRWUJncHRaUngrZFRXM3hQdm9wRkVtNW9oeVFveUQ3VjdSYS9Cdnd1NmJWMUQ1aHcwZ0I2SDFGT2krQzNoZGxrUjlXSXdUc2tBSlg2bWtvWXJ6TnVYQU5MbWFmelBKbStMRjgwS2VTbzJnL05HM1E4OGRhYmVmRmEvbENNMXRIQ1BST000OU0xNmxxUHdjMG1NUXBIcVN2dlhsZ01na2U5WU9xZkIrMExXeUhVUE0ySnd1UHVnOXEwVWNWWkxVNXByQzNmdldXbDlUemVING9hajVtQkVNc2VCMC9DdDcvQUlXdnNrVXoyNFpRQ0NBY0hOZFZMOEh0T2pFU2pVZHdZRHBrRWZuVmErK0FsckdVZVRVaXU4NVU5UmoxcXBMRmFYdWEwMWhWcW1seTJ1NzdIbnRuOFZwNG5ueEY4ckFoYzhqMkJxeEI4VjVab2lYWUt5RVp3TTEyODN3VHQ0WVFWMVdKeXg2REl4OWFyTDhDTGt3U3l3NmhFQXE1WVk1ck8rTFZ0WkRjTUU3cE9QM21kYWZHRkJGSkg1S001T1F4TlNENHVnT3huaEIzSDVkb3p4VlZQZ05jaGxZNnJiL055Y3RnajYxVkh3VjFTVnB6RnFOc3ZrZzQzdDk3SDkzUFd0SFBGOW1acWhoVzlKL2lYNGZpNHFTQXRicXk1NVJUZ211anR2alJieXpzMzJKMlRxdVd5ZUs4L1g0STZ3b082L2dpSkdmbUdNL1RGWEUrQ3ZpUmhzaXVJbCtYNWZtMmpqdm4zbzVzVXI2Uys0eTVjS3JKVFYreVp1eS9GdTFNKzk0Qmc4NHpqaXVyVDRsV1VzUmtpZ0xIcWN0OHYwcnk2TDRLZUtZVlBtR0VGbjQrWUhKOVBwVTYvQ2p4VkdTcnFxcUQxVnMvbUt6OXRpa3RMbWtjUGhMTnVWbnVkM2NmRTNSdnMwZVlpSmkyMWxVOFk5eDYxRW54UDBueXdHZ1FFZnhWNXczd2U4V1RUdXhWWTE2SzJPV1A0MVJUNFFlTFRPMlYyeUoyZitLajZ4akV0bjl3L3FXRWJiVXZ4UFlJL2licFNCMmVBdXBpK1JsUDNTVDFOYk1YeEkwS1l3ZVhLT1I4eFk4aHZRMTRGZS9DZnhxc2JQOEFaamxpQUVBNFkrMVlKK0ZuaktNRHpkT2x5M1JzY0RIclQrczRxMnQvdUJZT2c5cFdYcWZUMC94QThPd2x0MGlaT1FHWDE3NXFsTDhROUJWaTBVNlNjY2tEcCtGZk1GMThOL0Z5aHQybmtqcnZBNEh1YTU4K0JOZitaVnRKRGtkUU9meHhXbjF6RVJmdzcrUkVzc3cwcmUvZTNtZlg0K0lHbE1tOHpjY0RqR2NWci84QUNkNkpkRUxGSUNSam5HRFh3OGZCbmlwRng5aW40Nm5ZY0NyRnRvSGlHeVF5R0NZYlIvZFBXa3NiaVU3Mi9BU3k2bXYrWG1qUHVCZkZtbEtyYjd3amIwRG5uQlBhclkxblR3aWszS0w1dlFaeHVBcjgvYnEzMWVRcVhnbllnWjVVazVIdjZWaHlRYThKQWRzeWdIZ2Mvd0JhMC90Q3N0ZVJFU3kyRXBhVk51NStqRDY1WUVLbjJ0RXdPUURnbXRjYTlaVFhDYmJwRDVhREIzRHJYNTg1dVJjd3UwY3pGVXcrYzhtcysrbTFocEF4VjlwT0FNWTRxbG1VOW5GQy9zaE5hVFgzSDZKVGF6cERzUzA2SGRnQWc1eWZTaURVTEFzVlVLT21SOUsvTnFPL3YwZFR2a0FERGdqaXVyaDhRYTdtVm83OXgweWR1VC8rcXRQN1RsYjRFSlpQcGIyaCtna21xYWNaV0FPQ01jNTdpc3FlNnRwbWtMT29PZnZIcFh3U3ZpUFUwbFBtWEVyQWc1T09TMytGVm8vRnVzRXVGa08wQThaNCt0Q3pKTC9sMmpKNVRQclZQdklUMk1LbDFrQllEQUJISFBlbjJrOEVreGFTUkR1R01CZW1QU3ZnRi9GMnFZSTg5bDI0NHp3YTJrOGRhbnhpWlcyOEhBd1JtdW1PWjB1WFdEK1J6UEtxN2tuelJzZmRVNldVcU9vazh0K200amhzVkRCYjJ6aU5XbFRjUWN0MUZmQ1Vuam5XTnJLWmM3RzY5YXRMOFF0UzJLeWpKNlpHYXVPWjBiMzVHVC9aZFo2T2FaOTdyQllLVUJaV0FCeWZVZlNtWEZwQ3MwVEwwSTUybnRYeEpIOFJkU0xBT0FDdkpKN0NyRS94T3VFOHBtYmVRUHU5Q0JXaXpMRE42cG5LOHR4a1ZKUlYvbWZZMDFpRElvWW5yV2JOWkNObllRdTJSZzV4Z1Y4eXdmRXUzYU12bDhrREFQT1RVeS9FaVZtK1ppc1pIQjlhZjEvQnZYOUNmN1B4MXZnZjNuMDFCbzBFK0RKRkdveDhyWTVOVVovRFdtRGI1MEVMaGdTdTVldGVDUmZFUzJlWmxXYjNCSXgwOUt2bjRuUXBjS0pTNUM5QVJ4V2l4V0JhK0tQM0VQRDVuRjI1WitUNWowQ2ZSTklrdUk0aHBjQ3JqQklHQWZyV2JONE4wVmd5bXlneHU0NEZaMXY4UU5QdXBGVkpGeVNlTVlxNjNqZXpDc0daTW5qcFRsUEFTNncrNDZvU3pPS2VsVDd5a1BoejRlbWJQMk1mTmpBWHVhNXk5K0ZXaGt6U0phdndQdXQwRmR2YmVOYkxkZ3R4anF2YXRsZkdHbnlOeElXWG9mOEE2OVNxV0FsL0lROFZtRVY3enFKOUR3dVQ0VWFhOEJJYVZXNDJxQjArcE5aWitEMXZIQzdmYVpRNVBRamdpdnFIL2hKN0V2cytYUFljVmRrMXl6MnJHNUhUZ0hyaW9sZ3NDM3BiN3plR1k0K0sxdnA1SHhSZS9DZVFPQkhkbklINGcvNFZqeGZDM1VBMjM3ZkdlNFhCR1Q2WnI3Z212ZEJBUjBsSmM4c0NNWTlxeVduMGxwaS9tcm5id2ZUUDlhVHl6Q1MxaS9sY0paMWpGTFdPbmRvK0xyajRaK0psa01hTEc0QXp3M1Q2MXlGejRDOFZKSnNOb3pBZENEeCt0Zm96YVM2ZXhrM3VQdW5CejE5NmVWdFdWZjNvSEhUUCtOVC9BR1RTZTAyaHJQcXNVcjA0dS9xZkMyazZEWVd1SkxtUkdZREJJSFUxdnkrSWRIMC9PeFF4ejM3VjhzdnJkOUxIL3JHSGI2MUpIYTNsMG9PR2JOZk9ReGZMRktuRFh2dWZhVjhEejFGS3BVMDdMUTl3di9pSGNTTHRqT09lb3JnYi93QVdhakx0K2ZINDFWc2ZDV3BUdU1JMjA5T1AwcjF6VGZoNmpqZExFU2NkTTRGYXFPTnJYK0szNEVXeTZpclBsK1o4OHZlMzF5Y2JuWTU5NjA3WFJkVHVKTUxFZTNhdnNtejhJYVJhUkFsVkhzVFd1YjNRN0xPMEpsY1pBcnRqbHI1YjFLMFVlWld6bUVIYWpRY242SHpOWitBYitUYVhpSXoxTmVwMlB3enRtRytSZnc5UlhVeitOdE9qRGJWWDhUL1N1RXZ2aVEyTnNiSEdPM2VseVpkQi9FNUdmdHMzcTdRVUVlc3dlRWRFdElnVEdwSVBVMHBiUUxWdHhJVmxQeTQ3Vjh4M1hqWFVadWpZSDE5YTQrNjFmVUpTTnpzUWMxcC9hTkNEOXlpdnVPZDVUanFzdWFyaVplblEreDVmR0drMjRIbHhna2M1SjcxeWwxOFNFQVlLNmpqK0d2bFNDRFVibjVWaWM5c2s4NXJZZzhMYTFNMmZLWVlCT0RucFdFc3h4ay9oMDlFZDhjb3dVWWUrN3ZxMnoweTkrSUU3a2haR0p6eFhGM25pYThtQk83K0gxelc5WWZEaStuVkdlWURKNEdLOUhzdmh6RXJqZGhnT005YXpWSE1LdHQ5ZTdLbFV5dkR4K3pwMlI4ek5xRjdOS1FKRzNIcFZ1M2gxV1J3cXhPMjRjZ2cxOW4yUGdMU29rTzZJRSt2U3VwdDlJMHkxbVZpcUx4akJyZU9VMTlIS2FYY3dlY1lWSjhzRysyaDhaV1hoUFZwNFhMb1FRZmxCcnM5TThBMzVrUjNKUFRyWDFnMTFvTWNKSTJnNTU3MWdUK0p0SHQxNGNFayt2U3QxbCtGaDhkVDhiSEZMTmNSVVQ1S0d2VFE4OFQ0VXd1MjZaOXVlVngzOXE3U3c4QWFaRXZFUStVWnpqUFNzZWI0aXd4NXhJbkhUMXJrSi9pYmh1R2JPT2RweCtGWGZLNExvL3ZaaTVaMVZTdEdTWHlSN21mRHVtaUZGMkJTTUhvTVlyZmhqMHlGY00wZUIwSHJYeDVmZkVTNlppSTR5RGpxVFhIM1hqRFZaRUlMbjhLdDVwaElmRFQrZGpQOEFzak1hcS9lVnJlVjduM0sxOW84WlB6QkJuSnhnWUkrdFVydnhUcFFPQkpHU0IxSkdmclh3Tk5xbC9LY3ZMSnRQYnRVaTI5M09oWklwR3lPUlhQTE9LbC9jZ2tka2NoanlXblZiOUVmWVUvanV6aEl4TXJBZE1jMXlOeDhUbHpnU0VrY0FBVjRKYStHZFpsaTNmWjVBdlRuaXVqaStIK3JaWG9ySG5QcUs1WGpzZk42Si9KSFZUeW5McWNmZWQvTnlPbnVQaU5JN2hkMlNUamtuaXVidXZIT3BiblNPUWRjNTYxMGx0OE41MkFFajRIOTdHY2ZURmRqWmZEUFRsQUVzakYrb2JweDZHbzVjeXFkWmZmWTFrOHFwYnFuOTF6d2lYeGZxNWt5Sm13YWhmVkx5YVJRWkdKWWRRZlgxcjZvc3ZoL3BLYmQ4TzdhZWM4ZzEza0hoRFJGa0lXMVg1ZW5HYXBaYmk1YXVTWHF5ZjdYeTZDZkxGdjhBd28rSHJLSFZGdTAzUlN5TG51TWcxcEw0YTEyZTZrVVd4QUpPM25pdnUxZEJ0STFiQ2ZkNmNZcmZnc0xDS053ekFFY3FNanJXeXlxZldaenZPcVQrR2svbm9mQzhYZ0xYMWI1MUhBOWVNR3VodC9oWHJkd2hrTTZya2dMamdmOEExcSt4UzJucHVMT2hQYm5PQlQwMVBUa0pVWVlkZ0JnVjFSeXpEcldVL2xjNXBaelcwVUtLKzVzK2FMSDRVTWpLOXhJWDRJS0wzcnNiRDRkYU1GREZEbFNjYzhpdldManhGcGFONkVkOTNjVmtMNHJzbGtSVlZCa2tsaWVwUGMxcEhEWUNLMWFmek01NDNNcFc1WTh2eS96TWlEd0pwZ1k3YlJKUE1YSjNjLzhBNnE3YlRmQ21rckJLcXdSRmtQUURGZWZ6K1A4QVQwblpVbVJUbmtqak9Lb3Y4UmJKSDJxekhKNGNEaXI1c0JEV1BLYzdlWjFKSlM1bCtCN1BaYVZERGwwaVVZNGJBeCtOYnNsdGhvdHhEWUdjNXhYenAvd3NKZHBabGRobmpGWk1ueERqblptUWtFQTRWajF4NlVQR1lSYkw4QmZVY2M0NnZYMVByWmdvRXlKdERIb3c0d1A2MVd0TG0zaWtJeWgrVUtmd3I0bmsrSXVwdEt1MEFLVGc1NDZVbi9DYzZtL21GRlVER0RnN3NHaiswNktWdVJzaFpQaVpTNW5OSzNRKzQ1N3JSbWNCbHlGOURpcTMyMnlhWDVWa2ZaOTFTZmxHSytFRDR1dlRHcUs4Z2MvTnZ3V0gwTlZKZGUxa3MweTNVdVFRVkhRRWVoRmNrc3l0dEU3cWVXVGZ4TzNvZmJ0MTRtdDVUc0xxTWRod0txVGVMckNEYWdaQVZIODYrSFV1dFZuZG4yemZNZm5ISjYrbFhrc2RldUpveWxySTI0ZFhPUXhIZjJxUDdScXV5VUVYL1pGTnpiYzI5RDdIbDhkMllVczgyNWdlRnhuSXJsNVBpTFo0Yk1qWkhQV3ZuaTI4S2VLTGlRcDVCaWtCeUhKemovRVZadC9oMTRybTNoa0tuMkdRYUk0ckZ5dmFMKzQzZUF3MEZkMVB5UFpwZmlYcDhZREt6WkF6em5uNlZ6OTU4UWpNcXlEekFybmhoMEI5SzVWUGhONGtoY05jekJRVndBNHdNR3QreStIRitDTGRwVmFOK0NPM3RpcDU4ZTE4TXJQeUY3TEwwOVpSdjExQnZpVTBaV05vR1p1Um1wSS9IMTQ2UDhnVlJ3Q0s2dVg0U1FSc3UrNDVJT2NFbkgvNnEwYlA0VzZTMFlWNzEzMm5BSzhmaGlzdlo0NTdYKzgwZjlueGw4VWZROFgvQU9FMzFOcFNGbEl5ZmwzSEhTcXJlTGRhbUc3elZBSGZwK05mU3Y4QXdyZnc5RGwzQUlWZUMvVSs0RmJKOEJlSGZJRWtkcVNRTnhIUmZyVi9WY1cxckw4U1BiNWZHK2lkbGY0VDQrbDhTNjk5cmZGMDdBSUFSbmlxZHRxK3FlZHY4NllNL1hHZHVLKzZOUDhBRHZoMHdFU1dpS1FlQ1FDRFhTVzJqK0hVYUx5dExoem5CazlEVCtvNGkveC9pUkhHWU8xMUhmeVB6b2IrMmJwMk1adUpIQkpZWUp3UFdyWDJieEEzeXBiU3NBdzV3UmoxL0d2MHVjYWJIT3hpc1lnY1lZNEcwa2RqVUt5U1Rxa2kyRVVRei9EeG5IdFZmMmZVZThnV1kwSXlzb3RuNTN3ZUdkY3ZUTTBkdkpHbUJnT0R3UlYrNDhIZU9MaGxBdGdrV01EYXB3Sysvd0NUVTdlQkpHS1JwanJ4d2NWUTA3eE1tbzJzald0eEdBamxHWUVPRkkvdlk3MVN5N1JYa0VzenB1WDhOMlBpQ0g0ZWVMNUNoZXprWlF1QWUyZTNXdWdnK0RmaktkZk9CVlR3RlhoYzUrdGZhTTl4ZEdGTnQza1pHVDB4VVJuUVJ1enp5TG5nRUU5dlN0UDdNZzE4Yk1ubXJpM2FuYytUclQ0UTYyTGVWNWJsRVpHMk5Ga2NlaEZXVDhKdFRsUXA5dEcwSERFOWpqOWEra2JlZUNLU1Z3N09jWXl3NVB1YTVQVXZIR242VmVXaVhjTWdqa3VCQ2JnTG1NU3NNaFhQclRuZ3NMU1M1NTZPeVRic1JUekhGVmRJVXJ1MTJrcjZkenkrMitEOXRMSEdvMU5neW5BREhPVDBxNU44SVlyWXdKTHFVWktjQnNaMkJ1dlN2b2ViVWJHVnRyb0FjNStYZ0hIUTFGSkpiUzNLTVNFVUx5RjdtbThEaGUvNGhVekRFOUVyNmREeGE0K0RIaGVQOTRkVlVncGtBTHczMDk2dTJId3Y4R1J3N1paNXVEa0FMMXo3OXE5RGp2NFNKa0pqWUt4R0RqSXFqSHFtbC9hWVliblVvYk9PU1VLMTFNZmxpVTkyOWhTZUV3a0l0eWVpMXVEeHVMbk9QTEZYZWlWdXZ6TUt6K0hIZ3llNUFVT3l4dDh3UFVqL0FCcXdQQVhnS080WlpZWmdubWxkdVJuQjk2cjJuaTdTRXViNkNIVjdHZExhNGtoKzAycmJrazIveFo5NjNIOFVhR1VVcmN3eWs4a25qazBRaGc1SzhaSnA3Rnl4R0xVVnB5dnJwb1hXOEFlRGRQV1F4NldaVGdFYm0rYkhyVm16OE5lR2R1K0RRaElDUDRtNkU5VGlzdSs4WTZUSW01cm9IYW9YNUdHUlVscjQ4MGN4cnR1MFFLdkdSMXgvV2kyRFNTZkxjbVZiRmMyN1N0dlk5QXQ5TzhNd3E4YjZIRGtrWllnQU1LclhsdG9xTEVnMGFORTM0QjJnNXoycjR3K0lmeFJ2b2I2eGEwdWJxUXU2TEhIRW02S1Fsc01yNTZjZEs5TmcrSTlrcW5kR0kyVTVZSGtBait0WXdxWUJ6bXVWTGxkdGRuNkRyUE0xU2pMbms0eTJ0dXZVK2k3NVlKSlkyaTArQ01JZ0NnUmdaK3RWM2tsWm0zUVc2QlI4ekJBY2UySzhLZytLZWx5RUtGa0lVRWx0M1R2MHFtL3hMMG1UeldXVEJBSHk1d1cvK3ZYUXEyRGlrdE5QSXdsREd6MVVwL2tlazZ4TDQyRnRjMm1qK0paTk1zNzFkdDRzVVNscEZIOXdubEdJNEpGVUlYMUFhSXRqSGNzU3FydGJkbVpTdlFrK3VlYzE1eFA0N3Nia0ZZbFlQc0lCOXpYeFQ0Rmg4YjJYeEh1YjY3dW5TRE1ubXlHVWxabGY3b0MrMWVYT3ZnS1ZkY2xEbWRWMm5MYXg3V0h3ZU54R0duelloVS9ZeHZDTFYzSjlqOUVkTmc4WC93QnJ3YXRyWGlPKzFHNGFQeXJmem1HSTBVNXh0WEF6NzE2TGIzRjFEZTMxM0RkYlpMMXcwcFBPZG94dDQ2VjRkTDhSeWtJamFDTnRuQllyeWZmTmNsYmZFMlI3R09OYllNY3Z5bzkrNHJvaFZ5K25HTVl4Vzdka3IvbWNLb1k2MHJPUzBWL3Mva2ZUeTZ4cnFoNGt1QU1uSVh2anVCVUkxQ1NOMWVWOXFJQ1hhUTRCUGZuMHI1b0h4R3VoSVNzU3hsbHdTUjI5cXpQRS9pM1VOVjBWcmRKb0VZeDdVSjR5YzUrZlBVK3RhU3h1R1NiVVB3c1l3d1dMY2x6VGx2MTFzZlRlbDYvcDk0MjdUOVZTUkZmYk0wVENRcWM5T0s3MXA3bHJpVXgzQlFkRkpZZ3NQL3IxK1puZ2E4OFNXV3A2dHErcFBaV1VseVVqK3oyb1ZJeXNZNGNLRDFOZTFYWHhMMUVSbGc4S2s5Q1pGSS9IbXNhV1kwM0NMbFR0THFkTlhMcHhxeVVLamxIU3pQc0FDNytWSHVwWTB6a0xuY0d4VzNIREhIdlZXWmcrQ0dKNy9TdmdTUDRtWHdNY2o2amJLQjIzcjYxYi93Q0ZzbUtXWVM2akU2T3BNWkVneWxiU3g5THNTc0hXVnJKdjVuM0JjUDVUK1lZNVptWTdWaWpVdXpzT2VGSFUxUzAvVnRPMVMyTnhiU0hja2pLeXNDcFIxNElZSGtFZTlmQm1vL0V6Vlp0UGdheDhXeDJOMUJLWllKbFlia2NqQlB1Q090Y1Y0WjhZM3VsV0Z5SnZGTWQxY1hVN1QzTTRPNXBaWE9TZWxjYXpHWHR2aGo3UGwrZHpvV0F2UmNuektmTnRmU3grb2RuRWo3NUNpdVZ5ZHh6a21xcXc3NVpKQXpidW5QZlAxcjg4bitLdXFnTWk2cXlvUmc3QWY4S3IyL3hHdVErRTFHYVFGVDhwVmlRU01kTVZ1OGZEVnFQNGtMQTFMSk9PM24xUDBOZXpWV0N5eloyaklVREJCOWozcnhUNGtmRTN3NzRVdFlIMUlzeVRPRlNHTVprT091UGF2bE1lT2JwWElmVUp3Q09Sc2Z2NjVydy80Z3JwL2lleWpTYWU0V2VJNWpsRWJFRFBCeU1WelZjMGxHTDVFdVpiWDJOc1BsVVpWNHFxMnFiZnZjcjEvRkg2ZytFZGIwM1g5THRiNnp1RWtpdUV6R01kQi9kNTcrdGQzZEkyTUNTTlN1TVpBQS9Ldnl5OExhNGRGMGkwc0xWN3NSd3JoV0VUWkxkeUJYVlNlSzlYZVJqdnZXeWVOMGJaTmJ3elc4WXVVVmUydHU1ejFNbmFjNHdiNWJ1emU5ajlLV2VJcXFpV01nbjVnQ0NQL3JWVXVYdFhUekpWak9UMU9PSy9QU3g4WDYxYk52VmJnbmtGZkpKM0tmWDNxdEI0dTFacEdWNDcyUlMyU0RFZUthek9ONzh2NGllVjFXclhSOU4rTnZpUnBQaHllMHRJYk9lOW5sRFNDS1BBSWpYN3pFbnNLOWE4UDYvcHV0NlZhM3NPRERNb0tZR0dBOUQ5Sy9ML0FNYVc2K0pHdC9PWFVJNUlpUWpSUjdXMk4xUTg5RFhZV0dzYW5aV052YTJkcGV3TENnVkZXUHJqM3oxckNPYVZmYlQwVGhweXJxanBubGRHT0hwcU4xVXY3NzZmSS9TK1FxNzcwbTI3R3lxQWZoejlhMTVMdTBlT1FYTHF4OThaeDZDdnpWYlh2RXpTSXkybCtHeDh4WGduOWFKcnJ4Rkt3a0ZscUxIZ2xqMXgrZGIvQU5wS3k5MDVJWlhOdDJsdjh6OUR0MmhTdGlSTjNUQkw4REhianRYeUw4VFBqYm9YaFBWYmF4aXNIbjNEZSsxK0VRbnRtdktyZTc4UXhoZ3RoZkU1K1lFOXZ6cnlqeGQ0VkhpSzZ0cHJuU2IzeklXMnNWeHl2OTBuTmMxZk1xM3Mvd0IzcExUVjZucVlUS3NON1ZlMzFoWjM1ZmRiZnFmcC9wT3U2ZnFHbFc4OEJWSWJ1RldHOGNnTU90ZGZQRnBUMmV5TzhqUmdtQms5Ulg1OHhYL2lXT0syamlzcnhGamdXTkFGVUFLb3hqclJGZCtMVkh5Mmw4dlAremhsL0d0NDVsSjIwMU9lZVVMM3VWcHJaWDZJKzcxdkxCWVVpYTVqazhzY01EajhxaHU1ZEs4aUlpOFVrNUl3UVIrSTlhK0FHYnhLWnNmWXJ6blBIR2VmYXJscmVlSUF1MzdIZG55eVIyNHo3VlR6T1g4ak9iK3lwSld2RitwNm44UVBqZDRTOE1hbEJwVTF2ZFN1Nm81TVFVSWdZOVd6MS9Ddm9uUzd2U3BMZUdlQzlER1JGSlJ1U3U3bklyODJmR1hoS0xYcGRQdWJ2U3IvQU0yQTQzaFI4NmpuYWZhdlNMVzcxWFpHc2RsZUtFWGFnMkFFQURISE5jME16cktjK1pKeHZva2owNjJWWWYyTktWTlM5cGEwcjdmSSsvQkpiUkl3KzF3Yzg1QnllZXRXSWpwYlFzUmZJN2M3aUc1NHI4LzJrOFZja1dWNkJqK0pSL2pTUlhIaUtGMWtOaGU1WHFkb3graDZWMWYycGRmQXp6RmxWU0xUYlZ1MnA5enBKcEJsK2QxTDlOeGJuajI5SzhvMWo0aldlbTZ6ZFFKcEwzVVVFSWU3bDgxUXFJeDQyWjZrZWdyNTR1cm5XYmdlYXRwZUtXNmdKMEg1MTVIckhoa2F0ZVJUVDJ1cGtxQXJMSGxVY0Rzd0I1RmNsYk1ha2w3aXMrNTZHRnl5Q24rOGQ0MjJXaCtvZW5YdWx5dzJ0eEM4WWhsQVlaT1R0YmtWYW50Tk9udUhtRjVIdVpnQkgwejcxOElXMnFhelpKQVA3UHV2S2lVQlZhUGFvQzhBRTU2VjBWMXJPdVhxdDVPblhhdElCd2tmR0IzSE5ieHpLUzE1VW1jc3NxU2U5OWREN0l1YlMwaG0zRjR3VXl2QkJ5U1A1VlV0NWJUeW1qM0t3eDY1eG51SytLZlA4VGovQUYxcGZaSEF5bkEvV3JBMWpVckpzdmEzYWpybnkrby9BMVg5cWFmRCtKTXNxbGZtdWw1Q2VOZmpqbzNodnhaSHB2bHp6TjhvbWtRZ0xIdTQ2SHI3MTlWYVpkdlBieFNMTkd5dWd4empnalBOZm10NGk4TGFQcnVyUjZqZHdYU3lCdTBSK1lEa1pyMWF6MWU5amdNVnJEZU1vQUgrck9SWExTeldyN1NwenBPTi9kc3JXTjYyVVlaMHFUb3VTbnkvdkx0dE4rUjk0bVVDTlpBVS9kbkF6eU9mYW1KZXdsWkZkVmZjYzVEWWI4Ni9QYVR4TnFtOW8vTHVtY0hyNWJFWi9DcGg0Z3Z2bElqdWR4QnlDakFnL3dDRmRuOXJVLzVEaFdTNGxLL010ajlIZ0xTUlZ4TEY5ejd1NEZnZmZOZkxlcmZGWHdocC9pbE5HdmIrVVNsZ3Z5OHhxekhveDdacndxUHhMZEJpSGx1RkRaeWRqWkZlRDYzNFUwelVQRW8xSVhrd1VsV2tYeTIrZGw3ODlLNTYyYlZJeFhzMUc5MWUrdWgzWVRKS001VCtzVG1rb3ZsNWUvbWZzdEQ5bG5DbnpBaWxSdDZjY1ZITmJvYms0bE9DdUh3L1lkL2V2ejdUeFhkbTJoajgrWDVNRGdNT0IrRk9rOFhhbTJ3TGRTOFpPQ0c1eitGZFVjenA3OHJQUHFaVlh0MC9FKzl6Yld6a2tFU0pnYy94RWoxcVBVRVJRUjVVU25ibEFQWDYxOEgvQVBDWDM2TXBGMHlFQUUvZXgrSXhWYWZ4ZnFNMHJ0OXUyZ2pPUG1BL0FZclZablR2ZmwyOHlmN09xcURTdGMrMlk5VHVaa012MlIyamlrV0o3allURUhib3U3cG11b2t2VmtIelJaWUxqYm5IRmZtTWZIUHhGampmUno0bS93Q0pBOXdMbHJZWTNtUUhPM09NNHlNMTN2OEF3c1hXaTBQK2t3NHhnbGVwSHFmZXVham1xbHo4OU5LMG55OHI2ZWZtYVZNbG1rcFFxTjNpdWJtczlmS3g5dUMwa244MENBcVNoMktIempIclZ0WG5ZUndyTXNHMUNTUVRuSXI0emgrSU55cXd5UjNKM3JuY0MrQitGV0p2aVZmVFBrdEg5MGpJWUE1OWE2bm1WRjd4Wnh4eWpGUjFWdnZ0Yyt1SHVaaGFLOXhxRDdRY3F1ZW1PNXJqYkR4enAxOWZUV3R0ZkxjUEVSeHY1QTcvQUZ4WHpYL3dsMS9jYVRjUlNYRUM3bDR5NEJPZlN2RS9ERGVKN2ZXSVB0ZC9iZlpiVXlmWnhFRkRIZjEzbXVlZVp3VTRjdE5PTGZ2WDNTOGp2cFpUVWRDbzVWWEdhWHUyZDAzNTNQMUZobnVwQTBqdnRYT0ZBYzdpZlVWbXBOcWpTUnFrMHlxWHh1NUlBOTYrVjR2SHQrbHdpdU4wYWtLVHVIQXJZdlBpWHJLcUlyVWZ1eWVjRVpOZGl6TEMyK0g4RGhlVjQzVFYvSjduMUZNMDBrVGI3eGQvVGJubHNIamlzVnJpNGljaGVDQWNrZXRmTWY4QXduZDR6TDVrYkJnY3QwUDhxNUx4QjQ0MXE1c0xpS0lTSzdvd0J4ZzhqMm9lUHduSzNxMzJzTlpkanBTVVhHMTM4VjcyUHRhdzFUVnJpSm8zdVZlSWRTTUVqMS9HaThrbHQwL2QzSVoyNFZQTDNjZXVhK0YvQVhqanhCOWliN1pwRnZZUldscUlRaWs3cmx5ZjlZdy92VjdUSDhTeERhaHpicXpxY0RPY2tWblF6RER6Z25PUEkrc2QwYVZzcnhkS2JqR282aVMwbC9UUGFJYjI1Z0lIa3hGZXAzUmdtcXR4R2psbE5uRVM0M0Q5Mk9NK2xlRlhYeFdqa3RpSHRBdVg2S0tpL3dDRnIyNnhvb2lZbGM1SDE2VjJ2RzRMZTZ2MTBPRDZsajA3V20wZStOb3NDTENYMCtETWk0SkM1NmVvRlVaTkwwOGY2elRvR0JPRDh2VFB0MnI1TytJbnhYOFFMNFRsT21TTkErNUE4aURNZ1R2dHFEd0I4VXIyYlNvMjFHV1Y1TTRFMGk3V2tIcXc5YTVJNWhnblc1R3RMWDVyYUhkVnk3SHh3OGFzSExWMjViKzhmVmIrR05LTW9VMmNXTnVmdThZTllvOExhSEVXQ1dzWVZzN3R2Rlk4ZnhPMHRIYU1vU3JyZ1A3MURMOFFkSmFNSEI5T1FLN2ZhNWUvNVB1UE1VY3gxMHFyN3pabThGYUhLcU90a3BVcnlNODRyTGJ3Vm9nUXF0akdxbmpOV2wrSUdreUpER3g2SEtxQmc4ZjByNWcrSWZ4ejFIUS9FdW4yVnRwc00xdTZvMGpQbmN3WTR3dU80cmtxMWN1aEhtZkx2MFI2MkZwWm5WYmpHTS9kamQzMC9NOW0vd0NGYStHQzdGeVFSenR6bXJDL0RudzlJWkZpaExPUndRT0s2aXc4Y2FKZTJTTEtZMGNBSEQ5Y0hubXQ2MjhTNlpDV0Vkd3FxVGdnRUg2MTFLbmdKVTdyays4OGI2M21QdGJmdkxkbkU4WHV2aE5haFdDekZTVHo4dmVzaVQ0VTJzSVhiZEhjT1NNZnpyNktQaUxTbm13a3pOMHh1UEg0MVd2TmQwdFJJNEtCVkdXT2QzQXB4d21CYTZmK0JHc01ianVkcTd2MDkwK2FKdmhiRzdqZGRiaStmbFBCOXF4WCtFVXhMQVhnWW5nQWpHSzlJOE9mRS9RUEVHc1MyOE1UeENESWpMWS9lQUhCSXIzdUc1c1FBUGtaeTI3Zm5QSHBpc0tPR3k2dkZ5cHlVa25iUjlVZE9LeGViWVN0eVZvT0w1Vkt6aXRuNkh4ai93QUtrMW5EaEpJc3FNbmMyTS9Tc0IvaG40aFVxUTZFcWNiTjFmb0ZKUGF6WEhNeW5DWUE0cW5LTE5ZMUd4V0lQM2p4bjhxMS9zekRQdXZtS09jWXUyMFg4ajg5cm53SnI2TzdpREpic3ZPS3k3cndmNGxqMitkYnVUanAxcjdrMWZWL0Qrbkw1bDdlUVdxYjhLelBqazl1YW5WTGU1amplT1FNQ055a0hJSVBjVmxIS3NQS1RTcXU2NmFCVXpyRlFTYm9weGIwZG1yK2pQejZQaGp4TkNkd3RKZzM5NERHQjdHcXN0aHJBSURSU2hjWjdrNXI5SEliUm16dWt6czZET2NpcWpXWGNxb0FZbmtEdlV2S0kzL2l2N2lLZWV0L0ZTWHlaK2Q4a09yeDRTUlpGQkFQR1FjSHZWUmI3VUxZbU5QTU9UeG12MFZOZ2k1UDJkQ3JkMlgrVmM3Sm9saDVvZHJLRWpQWGFPYXkvc21vbmRWZndQUS90ZWhKZTlUYVBnbE5Udm9tM01qNUo5VFZ5VHhEcUNTaVFOSXVBRGdzVG44Nit6YnJ3dHBzajhXaTRiT0JqcDdWbjNmZ0RUcElFM1cvQk9NMWxMTE1Vbm8wYUxOc0JQVGxmM0h5UmQrS3I0dXBNaE9lZUJqSDFxWStNYjFpQU1EanQzcjZUdlBoNXBLaFNzWjRIWHRXTGRmRGJTekg1bVdUUG9NODFpOERqWTZKL2liZlhzdTZyL3lVOHBnOFg2cDVJd0ZVQUhMRThtcDE4ZFhDZ0RhN2U0Yk5keE44T0kxalhNei9BRERoU0s1cC9oZ1diS1hKQTlNVWV3ekNQODMzbGUxeWxxNmNOZkk0ZlJQQ0VNaXE4c1JSVHp0YnNhOVl0N0hRckFxWGFML2RISnI1N244Y1hVb0lCT08xY2RQck4vTXhHNDg5QU85WVU4WGg2VWJRcDh6N3M5YXBoY1hXazNPcHlyc2ZYMXg0dDBlM1RiQ3E0L0t1RHY4QTRpN1FGakg1Q3ZuK0N5MVdkOExHNSt0ZHpaZUI5VnVWK1pXVWtkTy8xclY0dkcxRmFDYXYyUnp4eS9CVWxlcEpOcnV5Sys4YTZqUHh1SzgrdGNiSnFkL01jWmRpZXVPOWU2MlB3eVliV2xZazk4MTZ6WmVDZEl0Z003Y2xhdU9YWTJwYm5sYjFaRHpEQVViOGtMdGRrZkhWdnBXcVhCRENKeVBVMTNObDRGMWFmYStjb1IySFROZldLcG9kbU5wSzlNRUFkYVpQNHEwYTFVRUZSampqR1B4clpaZFFwdGM5WmVhT09XYjRpcHBTbytoNG5hL0RkaXdNcWhWNDcrbGVrMmZnblM0RVhjZ0p6MzZWaFgveEd0aGxVeGsrbGVYWC93QVJicG5PelBCOWVLMzU4c3BiUjVtWktPY1loYXk1RjIyUHBtTFJORXRsVmxFWVBlcHA5WDBtQlZVRmNxT3ZyWHhaZGVNZFVtT2R4Q2tWenozOS9QMExuSTRPVFVQTklKUDJkSklUeWF2T2FkV3U5VnJiYysxcFBHZWtXMFp3d0pCT1JYRnlmRWFGUWRoVUx6eFh5bEZZNnJNY0NLUWpPZnlyckxQd2hxYzY1OHNxUFUxeHl6SEdUK0dOdlJIYkhKc0JUVnB6Y3ZWbmVYdnhDdW5sK1F0Z2c0R2E1bVR4YnFsd2pnU3Q5TTlxM3JINGN5VE9yYjI5OGNjMTNrSHcxdWhFVzhna0h1eHhXU3A0K29ydHkxOHpzNXNycEswZVc2UEJYMVRVWE9USzJEeFVRaDFPWE9JM2NlMlJpdnNtejhDMjBNTWFsRlpoMUJIUTEyYStIOVBRczRBRGNEQUdCWFJISzhRL2lsWTRwWnZnNmE5Mk4vUkh3bmErSGRhdUhBTWJESEdDSzdtMitIMm9Gc1NIQTZuMXI3RE1XaVc2OE9oZkdHNTVyUGsxYlJJZHFlZU9CbnBqbjYxdXN0cFJYdlZFWVN6aWNtbENrL3VQbjNUL0FJYlBQTWdkaWVPVDZDdXV0dmgxYklTREU3QlQxUFN2VUg4WmFiRTQ4cFFBT1NEM3JrcnI0Z1FvR0tNTUUrdjlLM2pSeTJHOGt6aG5pODJxSzBZTko5bFl1Mi9oQ3hRSXJ4Ui9kNEdPdGRWQm9PbnFpZ1FxaERmZUF4ajYxNC9kZkVLVTR3K2NkTWRxNVovSGNwUW56V3oxNXF2ck9Yd1Q1WVgrUjU4c0xuVlNWM1ZhWHFmVjBkdHA4YXQ4eWsvNzNUSHRXYmNYZW5vVnl3TzBZUG9LK003bnhwZnlNVHVIcG5IU3VmazhUYWtReXRKa04xR09md3JONXBUajhGTTc0WlJpSkplMHJldHRUN25ieEJwbHZFdzNBSUQwNy9wWE96ZUx0UEJHeEZCN0hOZkVkeHFlcFRIY0dreGpIVEZNanQ5YW53dTJUSFVFMXl5eldzM3BCZmNkeXlHaEpYZFJzK3VaUEgwS0tSakZaYi9FSmxWakZJUFQwTmZQY1BoalhYMi9JMjNQVTEwOGZnUFdKZ0VFaEdmWG9mcFdieG1PbnRmNUkwaGxXWDBtMjJ2bS93RE05U1Q0Z21RN1Q1bThkY054WEp6K09MdVZqNUl5VlBjNUpBOXF2MlB3dXZvdHMzbWpKSFBQTmRkWS9EYTBWa01zaEJZOGp0ajFvNU13bDBsK1JxcDVaSFJPUDNIbEV2aTNVbmpEZVlBQ1NDQjdWbFRlSk5VTGIxbmNIR0J0OWErcFUrSG1neHlFSzdQa2Roa2ZqV3JaK0VkS2dsdzBLa2RneTlEUXNEaTVieS9FeW5qOEZTZTE3ZGtmSkVWM3E5MU1kM21TQXJuQkdENzFmRm5xcnRHWTRIT0NRT2M0K3RmY1ZqcE5oYndOKzVqQVBJeUFjWXEvQW1rc1hWWGhCWEh5cWVSbXRmN01xYVhxSXpXY1VKM3RUZGtmQ24vQ0wrSUpIM0cxWVpQWEhhdWswLzRkNjNjWmN4c25QeUE5ODE5d0NlMmpoQVVxQm5JenlDYVpKZVF5L0w1NnF1MGJWSEhKcnFqbEVFdFpzODZybmpVclJwTDVzK1Q0dmh4cThlWTVYMmM4Z2Mvalc2bndwSVhMM0lKd0Q2L3lyMHZ4WDR1MG5RZFBudkxxU1NSWWlNTG5jVDdDckhnN3gvbzNpRFNQdHR1TmlNMk5ySERESGFoWVRBS3B5U3ErL2EvTGMwbmpzMGxSOXJDaCs3dmJtNWRMbklyOE5ORVlEUHlrZ2NqSkkvT3VudFBoMW9FS1lBWjJCNFBUOEs3Tzk4VjZiSGhXbWlRRG9POVlzWGkvU1l0NkM1VnVTNUdjZ1o5SzYzUnkrSzFjTCtwNW4xdk5KWCtQWHRFMXJid1ZwRnJsNDRDcnR3NEk0clpqOFA2U2pEZlpSa25xV0EvQ3ZCdkd2eEV1N2ZUNURZbVpwQ1ZDaUpkeE9UL0Y2REZiVWZqbTRGdkFIWXlFb0dJN3FQZXVXR0p5NVRsQzIzVzJqOUQwUHF1YVNweHF1VytuTGZYNW4wTU5Mc3Q1RWF4YmNBRWhRTUgzRkZwYk9qeHFWUUlRZVFvSElyNWp1dmlQNVpIbFFjNTVQWG1yMWg4VXBMUzlzN21HTmZOaEljZVlNcHVIWmdleHJWNDNCcFBsZDNidFl4bmhjZEtVZmRrbGZYWDlEM0hVL0VYaC9TSGlTOTFHQzJlVnRxS3pBTXhKeFhRd2lCSkZrZVlPakE0WU5nRS9oWDViL0ZNbnhUckZycUJsamluU1lDV0lNQXBRdG5LK2hGZXQvd0RDYXJGREhERnFLN1l3QW9MWjZESGJ2WEJUelplMHFLZE5LS2Z1dFBWcnpQU3JaSFAyR0hsVHJjMDNyVWpKV1Nma2ZjVW5relJJMGtwMkl4UDNpU2MvNFZqVHZZU0ZZNEppcllPQm5rMThYeCtPN3hZaWh2V2RDeCtRUnNlZnlxaHAvaTYrdHBua2ppbmszZzdTWXo4cC93Qm5OYnZPSWZaaHA1bkgvWU5adE4xRjhqMm40Z2ZHclQvQ1UrbDI3MmswN1M1M0ZXR0FnT0QxNzE3bHBmaWJTcmkxaG1obTJwS0Evd0F4R2ZtNXI4NlBFbGpIcnF3L2I5THZKSFI5NnlZQ2tFODR6bm9mU3UwdHJqV0JERkRGcEUyRUdGM3lBRGFQcFhreHpYRXFjN3hpNHZaV3RZOTJlVFlUMk5MbGxKVkY4Y205SDk1OXphajRoMGhIeEpOR1QyNTNBVm12NHcwejdPOFl1U3BPRngwL1BOZkhrV25lTEhiY3Vub09lcFptR2Z3RmE2YUY0M3VXZG10SWxaK00rV3h6K2RiL0FOcDRoN1FTK1J3UEpxYmV0UnUvWm5zL2pueDlvK2o2VEo1azEwdVlHRysxUU00a3g4dWM5czlhbThBZU9XdnREMDlybG5qbWtqRGZQaGQvditOZVBTZUFQSGw0R0w3VGhlZjNHY0QzeWExTFA0YmZFQjRvczNES3FqQ2hZMVhBOXE1dnJlTWRXVS9lMVZ1WHA5eDZTeXZDTER4ZzFIbVR2eldzejFDOStJTVVOMVBHZDJWSkdNNTZlbUtwcjhTd1ZSZkxZbitIR2NmaldCSDhFL0ZySVdtdjdoVG5rNVVEbnVjQ3RHMStBV3RTN2QrcE1WUFlTbm44cWJ4bU9sMWYzR01jcndjV3RyK3YrWm0rSXZGOS9mYUpkV3dpOHA1RWRBdzY1STROZk8vd3lzL0Z2aHlMVjVMaDFpU2FRWVVPQ3JoZjRzRTE5ZGY4TThUckZpZTdBUFBWM1BBL0d0S0Q5bXZUL0xFalhTTXBIVWs1L1Uxd1NqaXAxb1ZHbnpSVms3bnQwM1JwNGFyUlRqeXlhbEplaHhzZmpreHhJNzNjSklYTzFuQXlhNCs1K0p0OGJ2ZTExYUNQSStVUHdNK3VLK2pkTy9aNThMN2Q4azZxdU9XMmdIUDQ5cTZlMytDM2d0WkVHOEFMeHZ3by9HdXZteDd1cnkwOHp6L1pZQ3lkbzZueHJmOEF4TDNTSjVkNUdtQWQ1Uml3SnoxSEZlZWVJTHpSTloxWFRMMmJYcGd0czRra3R0amxaV0hSc0FZM0QxcjlKbStEdmc3eThmYVNybmdPdVA1WXJYc1BoWjRFaHR5WjEzdW9IUEkzZmdLem5TeFZSZTlycWFVcFlXbkxScE8yOTBmblpxWGpnejNLeVJ5M1V5cU1LcXdzdVIrT0tqdC9GK3ErVzRGdHFISUdDSXp4N2NucFg2Z2Y4SU40QmkyR1BUeTVBeVMyZS9hdEgvaEYvQkNpTURUZHhHTjJGeHorTk5ZYkV2ZTRTcllGTjZ4YnY1SDVTMjNpYldqUE0zOW0zaEI2a0FBL3JUYmg5VnUxZFpkR3VKVWtCNGVSUm5QWnMxK3NoMFB3NUVITnZwY2FNd1VLMjBIT09veFdrYmJTQkp6cGtlTWZkS2daTlA2bmlIMUJZdkJyeTlFZmtGb3R0cW1uNmZOWjJYaGNKQzVkZ2hrR1ZZOThnY2dWTWRIOFl5UUFqU2NmUm1QOUsvWCtLVFRCNXFqU0lodXhoUjJ4NzEwY1Yyc1VKQXNvNHdEa2ZqU1dDclJWcmt2RzRXVDB1KytqUHhkdFBDL2pWMzNMWnFNWXlOam11blR3ZjQvdW1kNFlFQXpoaXNEWTU3YzErdVVlb3pSM0Vra050YWdTTGdqSDYwNXJ5OUVJUllZNDBqN0lNRjgrdU85UDZoVlRUNXZ4SEhHWWV6MGszNkg1Vi84QUN2dmlkYklzS1F3a0hsZjNIUDFHVFdwYS9CLzRnWDJYbHVCRXc1SThsYS9UdiswN3hwU01RcU51RzNENXNuc0tqRnpJczIvem8yYnlpaEFHQUZQWVZUd00xdklqNjVRdHBGdFg2MlB6VGgrQ25pNlJXeHFUSEJLZ2lKRlAweldsSDhCZkZoVWJkU3VOeVp5QnMvbGl2dmFKblZKR2prMktEa0QzOWVhcVc5M3FBZG1sbE1iTVNVT2V2dlZmVVc3cm4vRWxZNkNpcjBsOXg4UVJmQUQ0aVhrdXkyMTJXTUtjUHdnY24weml1aWkvWlk4ZWJTMG5pR2REazUzVEFmb0JYMWpEcXQzNXpiTHRnVzZuZGpKSGV0TWxneGxhN2tZbjcyWEpKb2VXeVgvTHo4MlZETnFkbWxRdSs5N0h4YWYyWjlldUpXVzUxcTZsMi9LQ1p2OEFEdFhiV3Y3TGEyOXJnM2JLNkFzWGFabUpyNlhGN2hUKy9ZWTRHQ2VCVk5ybUp0amZhWFlodWRySEdmZjFyV09YUjM1dndNbm10bC9EWDMyUENvZjJhdEtJMnZlUm5NUWJPV0kvTFBCcVJmMll0QmUzTFNYc2FZeVNwTzdPTy9YcFh2U3lJK0dMdnlmVTUvR3RSWWJZb2R6TU9QdkVIOUtwNENGdmkvQXpobWNwUFNrbXY4UjgvVzM3TG5nMFJobjFLUHBrZ1lQOHpWNlA5bTd3UEhLRU41R1JqTzRvQnlld3I2RVd4RFcwazNrWmpSbFYyejBMZE0vV29uRnBHRkNLRDF5V1lZL25VeHdOTy94dDY5alNlUHFXWDdwTDV2VThTdFAyZWZBU1NQNTl6Q0NwK1hZRjV4NjFwTDhDZmg2MGlIN1NxOC9NUnQvUUVWNng1bWtBcVdDcTJEM0IrdEx2MDlpcUZsQ2s1QkxMK1lyVjRHbDFsSXovQUxRcVJTU2hBOGpUNEdmRGRaSnZQdWNSa2ZKdENqbjM0cld0L2c1OEw3ZkE4d2JCMU9lUjc4Q3ZTR3ZOTEoyNVFnOXk0NTk2cGk3MHdnN1RIaEFja3VLYXdOSCthUytaTHpLcjBqVFprLzhBQ3RQaHFJY3Bra0hPYzlSN1U1Zmgvd0RETzNHRlZwQXg1eVRubi9DckV1c2FRSTFEWE1hK256aXAwMXpTMnRma3VZQVEzT1dITlU4RlJTK0tUVis0TE1xemIwcHAyN0ZaZkJId3plVTVpeVFSZ2JUL0FETllkNzRKK0hnazNOYVBrTmdoUVJ3ZTlkTVBFT2lLclA1MEFPZVR2Qi9HcXA4VGFLekFtNWdJWS8zdWFTd2VIWGY3MFY5ZnJ5KzFDL2tpRzM4SGVBSTV3VFkrYkNSN2hsUGF0Yi9oSFBoMUFDdzAxM1BRRG1zV1R4WG93WHl4Y1c0T09tN21xcitNTkJSOXB1NFNPTWd0eG1xV0ZvZWYzbWYxMnBGTlhoODRuVHgrSFBBd2ptRGFRNmJobFh4bGx6OUt2eDZYOFBXSVZkTktsZXBLZmY4QXJYTXY0eThOR01zTCtGbUFBQVZxZ1h4cDRaVW5OOWJaeDNQVE5MNnJoN2FwcjVrZlhxeWRsT0RYb2padmRJOENxZk9oMFlaR0FXVmY4YTBJZEs4Q1krZlFpeWxlTUpnL1d1Qy80VGp3eUZaUHRzT3pQellPYXZKNDg4TWVVeGJVWVZBQTJqazVCcXZxMkd0dCtKbDlkcjMrS092a2Q1QmErQllmblRRTjJGd0YyOGlwb1c4S3ZNMG45aWxFSUFDbFJ3ZndyeXVQNGdlR0VEc2I2QnVTQWFSUGlMNFZqY2tYY1EzY25IYzlxVHd1RjEwK2R6UlkvRXJsdFVTOGxFOVF1Ymp3Z3FPUjRlVThja2dmblZGRzhLU3dTR1B3MmdZNEF3b3p4M3J6ZTQrSlhoQ09UWUwyTXJ0eVR0NCtsUVcveEg4TEY4aS9peDJJR0JWTEQ0WGwyLzhBSmhTeG1LY3J1ZjhBNUtqMGxOUzBnQkQvQU1JOURnTmdLc2VTZndOYTh0ejRjbG1CazBDM1lSamlNS040SjcxNUgvd3REdzJTVWErVGJucUZ6K1JxWi9pTjRNRDVGNUU0SFNUYnlhZnNjTHA3cStVZ2ppOFJiU3MvL0FiSHJhYWxvYjVLZUg0WFFqajVSa0VWbnp2cE55TmcwRzNnQllGc0lDV0E2alB2WGs2ZkVud3EyQ0xwVHp6aGNZclgvd0NGaStDMVhJMUJTMlB1aFNDVCtOUDJPR1d5L3dESmhSeGVJYnM2bjRJNnVXNDBlRUZUcENzWGY1ZjNZS29CMjRyVk4xbzBzTWFyNGJ0U2NmTWVtUGNkNjhyUHhGOE1PVG5WSTQ5dlJTbWMwNjErSVhoRXpBeVg4U0tlTiswdFI3TERXMlYvVmxmV3NWekw5NjdQKzZqMDVMalNvREl3MGVKODRCM0xrWUhvS21sazhQdmhQN0ZpVkR5NUNEa2VncnpHSDRqK0VHbEtOZGRUOTRKa0gzeFZPNitJbmhRQ1JWblJqbnNwNXg3ME9qaG52RmV0eUZpOFJHL3YvTGxQVkVuOE14aEYvc2lHVUJtT1NnSEI2QS9TcytXWHc0Wk1yNGVqUWpQM01CRzlqWGs1K0kzaG9ndHUyaE9tNFp5ZndyVWkrSS9oaVMzRzZSVU9QVEl6U1ZIRGIyLzhtRDYzaUdyT2RsMDkwOUhlWHc1UEV5dm9VYXMzVUFaVS9nYXNKTDRiZ3Q0ME9tRGVQNHR1TWZURmVad2VOdkNyS2gvdENJTWM4RWZvYXV4K09mQnN6RkRkcW8yak9mVWVsVTZPRjdYWHFKWXJFcmFhVHQyTzB2YnJRUGxLNmFyQmhodHdQNWl1QjFQeExwMmhYVU13OEZMcXNNaU1yd3hrSzRQWnN2eGlwdjhBaE5mQ1JJVjcyUEFPQTNmSGFxcy9qRHdwSURtN1Roc1Z6MXNIaGFsTndUNWI5VTlTNmVQeHNLaW5mbXQ1SEIrRmJDekNYaytwNmJIR0xobmRJZVdNSVk1Q0Qxd09wcmFYeExwRjNaV21rMjNnaVczbXQ3Z21iVVdkZGp4K3E0NUpiMFBTdFNQeFo0YW5KalM0UXQwWFBRL2pVcmVLdEFqSUpraTJrRE9DT0c5cXluZ3FMZFAzbjdqNzdtbFBNS3FqSkpwS1dteTBHSHdycEVWc2twc2dQTlptd1d6MU9LejE4TTZDU1MxbU4yNGNnOVFLN1c4MXpSenBsbElMbEhEN2lCbnB6M3JHYnhSNGVnbUtQY1FibFBVTnVINEd1aFVhVnJKTHFYVXhsWnkrTnZSRWNtZ2VFc1oreVliT1NNSCt0WDVkQStIODJ6RnN5YmZ2WkdkeHFzZkUyZ3pMNWkzdHV4N29QdjRyUGoxclNtbVVMZXdBRWZOdU9NVlgxVEROYmZpYzMxN0VwdjNscjNPbS9zUDRlTkdXVzNkWHhqN3VWejYwK0R3NzRBTVh6d2dNV0pIMDdZOTZ5TGp4RHBFTWNZODIzZmVNN2xZRUR0ejcxTkZyWGgxOXU2NXRWSVBHNXVmeXJUNnBoN1cxKzlHYnpLdW5yS09uM0dsUDRkK0crM0xRTXNuVGNlbFlNbmc3d0JJR3lqN2ljajVkb3JWdWRSOFB2RXJtK2dKSk9BRG5rZXRXb3RUMGlYelJIY3dNTnBPQS9JQ2pQU3ArcTBFdExsUXgySWw5cUJ3OFh3NDhBbFN6ejd2bUpZWTVIdFRIK0gvZ1h6Y3dxeW9EL0VCaXVqR3M2WVNIVm9tM0U1K1lVNFgybEl1ZDhSQlBVUHorTmFMQlVmUDhCdk1Ldkw4VU5EbDMrSFBnbHl1U3BQZGdveG1yTjE4TFBodEpHQWJqSVVFamFxOWE2QVh1bUVBSkpHZWVnSXppcHBMalN6RDhyeDVBd2VSa1o5cVR3Vkp0Ym1VTXdxMmZ3czhsZjRQK0JaWFVDZUpFYklKWkJ4OUtvM1B3TThESWtlTGlPVGMrQ1J3UjduMnIwMTIwOGtMdlg1aUFTV0hGWExhR0R5M1pYWEc3dVFlUGFpV1gwTDMxOUJMTUt5VFN0NnBubDhYd0c4SHlsMWkxRkFRdWNNZ3dmcFZHWDluN3cxdUxyZVJ1YzhxQVJnL25YcnJQWUNVN1hMZktEdDcvQUlWWXhiU3ErMW1JNjRKeHlhbit6YUt0L2thZjJwVjVYYUtiL3dBVFBCMy9BR2ZORlVQaTlqWW5KQURFRWZrYTVPWDludUtUaU81dzNVQVNzT0IrTmZTeVFXcXlnL2FEa0hCNS9tYTJEYTJqTnVTNFlxU09CbmcxTHk2akhxOWZKbFJ6T3ROWDVFbXZOSHhrZmdKSUxsb3Z0TTYvTG5mNWhwNy9BQUUxTlVPMjhsSTdabE9lYSsxVnRZSkpDRGNNdU9weWF0RzBnVXFVdkpNRGdFdDYrbFI5Um9wOVRyV09xN3VNV2ZDcCtCZXRoU0hsbEhYQkV1VHg5YXpuK0NtdHJIa1R6WmI3dnpMMi9DdnV5ZGNPdysxampvR09LZ0t6ZnV3dDJjREpBM0RITkg5blUydDJMKzBaM2Z1by9QZWY0U2VMa1VMOXJrR1I4b0txd2Fzay9DbnhSR29iZkp1QjZpTmNDdjBOamh2WTVqbTQzS1RtTWNmTG4zcSswVno1VWdFcURrQWppby9zK0NYeE1uKzA2cjA1RWo4M0pQaGQ0eDJzVEtObzU1akhQdldKYytCUEYwWlZGWkdic1BLUElyOU96SmZsY01WYkk3Z2RQZXFIa1R1TXNrWVpWSTRHT3Z2UTh1ai9BRHNwWmxOUDRGOXgrWUI4SCtPRVlPSTQ4NElIN3RoWElYM2hQeFROTkcxeHBjTTBrVGZ1bk9jcWZiTmZyOHFYYzhTbG8wQlFZNEhHQlhNUzc0N2tSdGFSWmZKSGV1V1dXcVZrcWpPeisxZVJYOWx2NW41VnlhSjRvZ0g3M1MvbWJvZk1OTUVIaUtGRHQwMXdwNmtTWi9uWDZ4VHdNWTFWdE9qT1I5N2pqRlZmN1B0OXBCc1ZiamdGUWE2RmwwN2Z4VGplWjBubzZiUHlia20xOEJ2OUF1Tm80UHpDbzMxVFZZWWZudEx0RkEya2hmWDFyOVZEb1dtdlAveUMxeG5raGNmbldKcWZoZlJwRVp6WWdMbm9GclA2aFh2WlZFYUxGNFRrdTRQUS9IclFMYUxTTlV1cnFFM2F2S1R0ekdmbEI1SUdLOVVqOFczRUVtL3pwZ1IzTWJWK2dVbmdydzAwWUlzaUc2SGlvejRFOEx2R3ltSmdUMzU3VVJ5N0UwMTdza3ZRcXBtT0RxdTg0dVR0MVB6L0FKZkhGMEZ3Ynh3YzlTR3ovS3RGZmlGY2tKaS80eDBMVjlwbjRZZUhaSXl4azZkaWVwUHJXUGNmQ1R3N09oRytOZnIxb2xoc2N0cGZpY2thMlYzMWhiNUg1dC9FUzdtOFFHMU1kMmpGRzVET01ZUGV2WnZEdmplYlM5SXRMTkpkNWhqQ0Z0d3g5Qlh2Vjk4RjlIWWdKNVp6MU8wWXJIaCtCbW15c1d4SGdEZ2RLd2hoY2RUcXVvbHExdmM5S3JpOHZyNGFuUmNrNHgxU3Njckg4U3J3RlZ3RHh5UWEwNC9pUGRseHRqeVFmclZtZjRFeERJUngxT05yR3VlbCtDdHpHVzJ6eURIY09SWFc2bVpSMWZOOTU1MzFQSjI3UjVEZXZmaWRkUFlYU0JTcEVUTkdjOUd4eHhYeTk4TWZIUGllUFZyK2E5dlpwYmRtSklkc2dQbitIUFN2VnJ2NFNheWdQbDNVeFUvN2VRYXc0UGhacjhJK1dhVmNuUDNRYTgrZFhIdXJDVjUzanR1ZXZERFpkOVZxVXYzYjV1dWwxYnNmVDF0OFE0N2hvaU92UUhybk5hazN4QzB3U0ZHWWJrNGJ1Q2ErVFc4RmVMN2R5STdna2puL0FGZFk4M2hueGZHckZnbkRkUExJNS9DdlVXWjQ1YnI4RHhZWkZsM00ycWwzL2lQczJieDFwWGxxdzI0MmNqMXJ3SHhMOGRMYlQ5ZnNiQ1BURmEzYmI1OHBZNStZOVVIdFhqVTJuK0swWWo3S25HTWo1aFhKWE9nNnBQZXh6M0dtK1k4WXdNTjArbGM5Yk5NWTB1WFIzM3Nlamg4bndTbEp6YmtuR3lWN0g2STJuaXpSTGdMKytCN3JrNDROYk1lcDZWSXVUTUFSeHdSWDU2dGM2c29SR3NwZ0Iwd1FhbE9zYWl1RmFHNFhBNll6WG9SenVhU3ZUVC9BOEdmRGQ1YVZuNWJNejlKOEczTjNPUmpkR0FDRzlhOTYwandKYVJLRElFWGI2ODF6dXBlTnJTMm1rUzNDWVRqNVJ3ZnBYbmQ3NDYxQ1JTQVNPZld2TnB2QjBWcXVkbjBGWlpsaUpQbHRDTnZtZlVpMmVnMmFnbDB5Qnp6em1xMXg0czBhMUdGSzVIZk5mRnJhN3FOMUtTMHJmUWRLaWF6MVNmQlJIT2VudlhWL2FjcldwMDBqbGhsS1d0U3M1UHJjK2xkUStKTVFMYkQzN1Y1dmUvRUMrbExCWHhtdU90UEIycTNHQytWSHBqSi9TdlZOSytHN05objNOa2M1RlpLcG1OYlJPU09uMkdWVUVwT3o4OXp5NmZ4QmZUS2N5c1RqdFZLS0xVN29INVhiSHFhK3NMVHdOWnhnQm8xUEhKeFhkVytpYUxib29LcjZrRWdWcEhMTVRKM25KTDVtTTgwd2tZKzdGdjBSOGFXdmhmVmJnOHB0eDAvR3U5dFBoemN5SExodU91ZW40VjlOeWF0b3RsR3dSVUpCOUJXTy9qdXlpVnZsR2NkeHhYVEhCWU9Ddk9yYzgrZWFZeWVsS2hhKzExcWVlMlB3NXQxUmNnSEl5QWZYdlhlMlhnbXhnVUYwUW5PUnh4WENhaDhRTXNCR3dCQ2sxd0UzanU5TWh4SWZvVHhXbnRjdHB2U0hNWWV5em1zdmVueUkrblA3TzBtM1AvTE1EQTQ0R0toKzI2TGJxMjExeDE0R2ErUEw3eGZlU05rTVc3MWpOck9veThBdHljOEROVExOWVIwaFNTc0VjbHJOcDFLOG5mYyt4WDhYYWZBMkVUNzM0VmxUL0VNcWpCZVBUSjZWOGxScHFVcmNCbXo2OXZhdW1UUTlWa0hFVEZUN1Z3U3pMRnplaXQ2STlTbmxHRHB2VjM5V2V4WEh4QXV3eHhKeGpnaXVPUGptN2xZbDVtNFBUUEZRV25nUFZKaXJFRWNjRTEybHQ4TUpXZFdrY0hQM2g2Vk44eXFQYVpmczhxcC9haGY1SG10eDRpdUhVbFEyYzR6bnJXRkxxbXB2S0dJWTU0d0srcjdYNGFhWXFnRWtuajJGYnFlRGRIallLMFF5RCtkYXJBWXliMWxiNW5QL0FHaGwxTjZhdnlYK1o4WnF1b3loZHF2MTcrOVhZdEExU1lCVmpZRUVaR00xOXhMb21qMjU0aVRyeG5tckx5YVpFVndZMVlkU1A1MTJVOG1kdmVxbkpVenlsSGFpM2ZiVStPNC9CR3J5cnljWTZFakhYc2E2eXcrRzkwVGlVakpIVUhwWHZzSGlYUWJ0N3JiS2YzRGhaQVFBUWUzRlN2NHYwZUxjQXF0L2Q1NlZTd2VBU3U2eWE5VVoxTXh4N2RvNGV6YS9sWjV2YmZEQzBWU3p1V09mNGNacnJvUEFtanJFR01XV1gxSFBGWjgzamkyVVlpVEpKNHhYejliZkVqeGhKNDBtdHBEdHR0cCtVcGhSNkVHc0t0YkxLVTZjVkZ5NW5hNlY3ZXBwUm9aMWlhZFdUbEdueXh2WnV6ZnBZK28vK0VXMDVQbFcyakE3Z2l0bVBUTFNOQUJGR0JnY2pGZUdYSGkvVVF3Wm8yYlBCeFhPUDRxMU44c1hDam4rSUN1aVdPd0VGN3ROdjVIQ3N1ek9vN09zbC8yOHozdTg4UmVHYkM3dDdPNXU0a25sZkNJZmYrVmRvYnZSSXdoODdrYzErYit0MkVlbzYxYTZqSmVnUEU0THAxM1k5TVY2c05jbm1qWkZpbGZrbFdWRDM3ZlN1T25uVWs1cDBvMnY3dnA1bm8xZUhvS0ZQbHJ5Y212ZnYzOGo3RGw4U1dLeHNxbGNFOE1PdjUxNW40eThmUTZYcEx6MjdJelJMd0g2QS9oWGhscXV0UzVSTENZdDJKNHg5YWZMNGE4U1hhTkcrbUl5a1lJY2tnMWhXelRFMUtjbENObTlFMHRqcHd1VVlhbFVoS2M3MnRvN2FudC9oejRsTGZhVGJYVWtDYnBFQklUT0FlK0ttdWZIY2JFNEI0Nlk2Q3ZLOUs4RStMVmdXS0tPT0JGUHlxcWNENlpycjdiNFgrSkpWUG5Yallia2hRQmcwcWVOekZ3U1NiMDM1VFdybDJXdXJLVGFTdTJsekZ5WHh2Y1BFRlVOZ25INTE4bTZLdXU2ZDQ2dmI5N2x6QTRkZ3hmaHNuSUJCOUsrejdYNE9BeWZ2Ymgzd0NlV09Lay80VWZwRHllWkl6NVA4T2NqOWE1NmtNZlduR1VsSnVMdXVoMVlhV1hZYUZTTUpRU21yUHFlV1RmRUkrVGd5SXZybVFjZlFWeTgzank0TDd4ZkFxQ0FBRkpQSDByNjRzdmhONFl0MFhkYWhpbzY0RmRUYmVBUERrT1F0bXAzZjNxMytyWmhQZWIrODVYWHl1TDV1UlA1SS9QTFd0WlRXTFdXSzRGek5HNjRJV0k4RDJKcXQ0Zlc0c05OU3pzdE52MlJTVGtnS1d6M3I5TXJYd2ZvNERLYk5PdkIyMTE2ZUhOUGhWU2xuR0dCNmdEZ1VsbGVJY3J5bXIyM04xbTJGVlBsakNYTGU5cldQelF0N2Z4RlAvcTlJbEJ4L3dBdEpNL3lyVmc4TmVPSml5eDZZbno4N1NDZW41VittTWRra2ZTTlI5RjYxcHBZL01wS3FNSHJXeXlxWFdvYzBzM3BXdDdKL2VmbmxaL0Qvd0NJVzNmdVdFa0VFQ01FZ0gxeWE2QzErRW5pNlVaazFHWHJ5dVZYK1ZmZnB0TUlwa0txUjJGS0hpK1llYU9UMk5iTExLZTdsSi9NeGVhUGFNVXZVK0dvdmdmY3ZscHJ1VVk2bHBEajlLM28vZ1ZwK0FYdUJrZTViOHdhK3ZDdGs3amZObmpqUE5STGM2ZXJFTVNjZHg3VnVzc29XKzBlZkxOcTE3ZTZqNXEvNFVwb1BsSWN4WnlQbVVBWit0ZFhhZkNYd3pBQnZZRTVIM1FNR3ZiQnFPaXdvdUNwNTdrWnFuTDRuMFdOUCtQaUVEUGRoMitsVXNEaGw5bjhUUjVsWGNVdWI3bGM0OGZEM3d4NWVQS0oyOGdjODFzcDRTOE5SeEp0c092VmR1ZXYxcUc2K0lXaFI4TGN3c1NPY0dzWlBpWm95SEp1bzhEZ0RyeFM5amhZcjdQM2tmWE1ZM1pPZTNSSG9NT2dhRU9CcHNad0FEbEIxcmRUUzlOaUk4clRvMUk0SklCNHJ4Q1Q0cGVIQVBsdVd5T21GM1p6V1kzeGYwVkZ5b21ZK29HQWFsckNkNG1pcVl5VzdtL2t6NkJpdC9MbGJaQUJrZzhEaXJyaWRwQ3lLcTU0MjR5SytUNXZqRmJHNEpTQ2ZHM3FEL09zay9HQ2ZkZ1dic2V1U3hGV3FtRVZuZGZjVEpZdVNzNHorYlBzZU9DUlpwWFpsRzVRcHdQU3JpeE9rV0RNQVZBQVBGZkVBK0srcE1NcFpxZVRqSjlQclZDYjRyYStTUUlZbDQ3ak5EeFdHWFg4Q0ZReFRWbkIvZWo3cjh5ZVZWUjcxc0VjamNNRWVsTWc4ckh6VHNOb09Cbkg4cS9Qai9oWW5pZG5McklpNDY3UlZWL0huaTUyWUxkZ0ErdllVdnJXSDZKL2RZRmhzVW5xbC80RWZvU3NsanN3WjVUbis4U3hwenoyY1NaWTdrQTVCcjg1NVBGL2lwaHpxRFp4MkdLb1RhNTRnbGlMdHFFcHllbWNDcGVOcHA2UVpid2xlUzNndnZQMGlhOTAxb2R6azg0eDIvblQwMWpUVlRMTkh3UU9XRmZtY0wvVTJEbzE3T1IzeS9yM0ZaN0c0SUgra1Q0STZiaWM0ckdXUGovejdmM2pqZ2F2L1B5UDNINmhyNGkwYllmMzhJQko2U0RqRlUvK0VzMFNKaURmUU1Pd0xWK1ljVVY4NEtrU2U1NXlLc3g2THFrNmhoQkkrUjEydC9Tcy9yai9BT2ZmNG5YREF5NWZlcWErU1Awam0rSVdnUkxnWFZ1UjBIUFN1V2srSm5od3l0dXUwUFBPT2NWOE1RK0ZOWWtWczZiT1QySVE0TlR3K0IvRmJTSHl0S25Jd2NEeWlPUHhyTlk2ZDlJSVVzdmJ0KzhsOXg5c1RmRmZ3OUdkaTNZQUFQSVhOWlRmRmpRQis5RjRTUnhrQ3ZseFBodjQzblZRMmt6TGtkU25PS25nK0Z2ak9VQlJwVWh4azdNRFA0MHZybFRvb25Rc3VzbHpTbWZTcmZGelFta0RtU1ppblRIRlZHK05XbE1UdFdaZ2M1RmVOVy93YThhU296TllQR1ViT0c0UFBZMXQyZndROFlOY0JXU0dNbGNuZTNRSHZVUEYxZXkrNGNjQkZTM2xxOTduVWY4QUM1N0VZQzJjeE9lZm1yT20rTStKVzh1MmtVSHVTU2FnSHdGOFlDWWdDMitVL0t4azYvVEZkUEYrei80a2ZZWHVMWWJzNEliT2NmMXJKNHV2M1gzRy93RFoxSGYzdi9Bams3ZjQwWlpzMkdUN3QxK3RJL3hldkdrL2QyRVlCSDE2VjE4SDdQdDlLQXcxS0FiaVFDQjZldGRKQjhBcDA4dGY3VmlkOXBaaUU3VkgxaXUzckovY1I5UnAyVmxwNXlQTm0rS0dwUGFsVnRWeWVuUEZjVmNmRkR4REppTXhScnRQQnI2VUh3WnRrdC9uMUVjREh5OWF5MytEV2lzaE0yckZXeDhxN2Nidng5YWZ0TVEzcEtRdnE5Qlcwajk1OHlqNG5lSWkvd0FxQmNIcGl0bVA0bitKR1gvWG92dGpGZTlXL3dBRnRGVXNXMUZtQ3FXQTRCT0s2V0g0S2VEWjFKZS9lTVpCRzV1U0Q3VlVwNG52SXVOSEJ2WlF1L094OGpUZkVMeFVISkZ5cTU1eGppcVZ2NDU4VHV4UnJwUU92eWpIOHErejMrRC9BSUdUQUY3SktnUEpQeWpqdFd6YS9DandGRXJGNUpPZ1BMWTIrM0ZQL2FHbDhRZXh3djhBMDcvTStKditFdThSeXZocjU4Y1ZxVCtKL0V6TEVyNmpPUW93Qm5nQ3Z0aUw0ZC9EeEdCalNSbkE2NU9Ldld2Z1R3WXM4Z2xzMmRUZ3huY2VENkVWUExpTGZhTGpERFhYOFBYUzZzZkE1MTd4S0UySFZKd2pISlJXUE9PNTlhcFhHcGF5NkhicVUzSG8zU3YwZ1R3YjRBYklhejNFY0RhRHhWdVh3eDRCaWpDSm9YbWtqRzhudjdpa29ZaTY5MlFwMDhHbGR5cHI1WFB5emsxVFdRZ1kzc3paOVdwc2VvYXF6SEU4NDIveEZ6WDZyZjJGOFBFaVBsNkNvWTR3R1VjRWRxdFI2SjRNVXd0L3dqOXVTUHZmTDFQdlRkUEUvd0FrdnZKajlTWDJvZjhBZ0orVXJYT3B1V1AyaVkvOEROU2VkcWJESG1URUVBNTNINlYrdDVzUENvai9BSFhoKzFHM24vVmpqOGFkY0pvWDJZcWRIdDR0d0l5cUR2NmVsVkdsaUxXNUg5NDI4SXIycUxhL3duNUNTd1h6TW9ZVG5QUEpQUVU5Ykc1azNIRXVjY0RtdjE4amwwcTFodyttUU1NRERGQWNrZWxWUmNXTDhKcE5xQ3JaVi9MQk5IMWV0ZjRkTzl5dmE0UldYdEhmdHluNUp4NlZxSUgrcm01R2VRYW5sMGpVdmx4Qk5rOUNBM1AxcjlkbnZkeU9qYWRhRU12SjJBWjlxVWFxdTVSL1pkdHVJemtMZ0RBNkhGQ3cxZjhBbFgza0tlRXY4Y2wvMjZma04vWkdyN2YrUFNmYjB5Vk9jMUYvWWVvZ2dOWlRaN25hMzlLL1l1VFdYbFZvenA5dVIzd2dINGRPYXAvMmt3ay9kMmtLWkJCWFlPbjVWU3cxZStzVjk1b3F1RlRzcWovOEJQeWdoOE5hZzdqRmpNT09wUmhqNjFFdmh6VnZQZEJZemRPVzhzNE9hL1dTVzlta3QwaThxUEN0bktyak5YVHE5NG9LaUdBSGJ4bFJuQW8rclZYMFgzbVh0c09uZHlrMTZINUZ5ZUZOZUV6ait6NXp3TWJVUFB2V2dmRE90c2taL3M2ZHVCL3l6UEJIYXYxZkd0M0NuYWxyRUhQRzhEUDQ0cW8rczZpeGVJTEhuK0o5ZzQrbFdzUFgyNVY5NE90aFhxcFR2Nkg1WmY4QUNJNjhPUnBzd0dlbXdqbW9qNFI4UURBT20zSk9PZ2lKelg2dy93QnEzY2NZSGxSRWdjTXk5QlZkdGJ2d0JoVTQ1T0Y0UHNLdjZ0V2EyWDNrT3JoRTk1MzlEOHBVOEZlSldkLytKWExnZXNacllUd0g0alVZL3N1YzVIS2lNbk5mcElkWTFVU00vUm13Qjh1UUI3aXQzKzNkVVpVSGx4bkJ3TWNmaWFYMVN2Mmo5NVVhK0ZsZldhK1IrV2NYZ254RVF3L3NhNlJWT1A4QVY0L1ExYlh3UDRtM1pYU2JuYjd4OFYrb0NhbHFiQ1VNeWd1M1VDb0RxbXBveUtKeHpuS3NPb0hwOUtyNnZWMnRIN3llZkRidDFQdVIrWmplQ1BFYThwcFU1WWRRRU9SK0ZEZUIvRkM3TTZYT04zUW1NaXYwelhWdFFhZGlDaDMvQUhzWUhTb2hlNnNBeWVmaEF4SzQ1SXo2VkgxZXErMzNrS3JocjZPZlhvajg0RjhEK0pXVU1kSm5ZZXFwVk9Ud1g0Z1FvdjhBWk4xZ2tnWmlKRmZwTWRUdjBZaHNOdVVnc2VPUHBVeWFwcWkyNlI3MTJyMCtucFZMRDFsL0tFcXVIN3orNC9OdFBBdmlOaVNOTXVPZUI4bmVuSjRJOFJveHpwVTJRUG1KRmZvekpyZXBpTGFtUGJBeFdUSnFXdXZLeE15cVRnWVVBWXhWTEMxdXZLUzZ1SGNkUGFQNUkvUGwvQW5pTUFzTk5uMm5zRUpOUnhlQ2ZFaXFBMmxYSGNBYksvUXVQV2RYV1JsWGpLNHlSazFvZjJscW1ONEFWc2RRTTgwL3F0Yis2TlluRHZwVWJYa2ZuYVBCR3RyRUdiVHA4WndSczVyTWJ3ZnJQSk9uekZldzJHdjBYdUx6VTdqQWxjN1FRY2RCK05WWlo3eFdSQzZqWmtxTVVsaHA3WFExWHBhdjMvTFkvUGovQUlSRFhHVEg5blRISTZiT2hQcldjdmdyWDJuTVM2Yk83N2NoVlFsdVBZYzEraTZ5MzVZc3VNazdqOWE4MzFxNytJdHBxbHRxV2hYOXRhM1NLeVNDYUR6WTNSdU1FWkJCOTZ4cTRldkdEY0VwUzZJZFBFWWQxRXBjMFU5M3VmRnA4TTZraVpOcklPb0kyK244cWhmd3ByUVZKSmRPbVdOaGdTRlR0UHNEMHpYMkZwZGpyOFZzejMxMTlvdkpXZHBwY0JRek9jbkNqZ0N1UmpoK0tOejluMDI2MTJKOUZ0cnNYTWNTd0JKOXdPUWpQM1htdWFyUXhkNlRqQzZmeCtScFRyWVorMFRidXR0bGY3em1KUENsdkQ0UDBHYUpKZlBsRTVtUW5PTnJZQkE3VjQxZWVIcjN6Vkl0M0dUa0hiMXI5TTlXRnVmRCtocXFRaVllYjVoWEdUazhBanRYQVc1bVUrV0ZVcW1TRngwSnJvcFllbzQ2MjNmNWhVclVZeVhLbnJHUDMyUitlczNoMi9VeU9iZVFZN2dIbXNxRFJiNldOMkVFM3k5eURnMStreVhrMFlkVmdqem5xVkI2L1dyWTFPODNCL3M4QlljWTJBQTQ5cTBlRnEzdm9SSEZVYk83ZjNINWluUjdydGJ5ZE9tRDFwcmFUT3dWUkZLQ0Q2R3YwL3U3NmE0WldGbkNnWG9RZzVQb2FtanZpcU1Gc29nU2VteFRnaW04TFZ0cWw5NWlzVmgrWisrL0wzVDh2ZjdMdkFRTVNBOXM1cXU5amVXNkhhWk1rWXprak5mcDFOOHdrSDJLRnQyTUhBem4zck9lTU53ZE90ZUFNN294K2ZzYVN3aytnbmlLYmFkMzl4K1phV2Q0bi9QVWQrQ2VhaGphOEpiNTVWNFA4UjVJcjlRbE9uczhxLzJaYjRBQjI3UVFENlpwekpvMjUyYlJMWVpIRzFRTUUwbGhheVpicjRkcXpmNEg1YU1kVVJnZlBrd080SnF1OHVwTGhqUE1QcXhyOVBwTGZRWTVRNTBPRXFSOHlFWUdmVVZSbXN2QzhyRW5Rb2lwNTljWnJkWVd1dGsvdk1IaWNQYTNOSDdqODBGdWRTM0Z2dE11YzhFdFMvMmhyZk9MeVllaEJOZnBMSnBYZzFBdi9FbWlJNzRXbGswUHdZOXNoWFJHTEJ1UjdmV3ArcjRoZC92TkkxOEc0dlNIZTFqODJvOVQxbFppd3ZaMXdPTXRWdHRiOFFLbUJxRXVUMUdlUHpyOUNqNFc4SEhrYU9xdm5KSjU0UDhBV3FiK0N2QmNqODZhVVFuNXVmWDA5S1RvNGp1L3ZFNTRON3doL3dDQW8vUDJMeEo0aFB5cGV1YzlqelcybmlmeFFzaWJiK1FFWUdLKzFIK0gvZ241MlNGdytjQmM4WSt0VXo4UC9DUUljMjdBbmdOdXB1bGlMZkUvdlk0dkJwNlFoOGtqNVZ0ZkduaWhRYzNqWndlb0IvS29QK0U3OFZidDMydk9EOG82Q3ZwKzQ4QWVHZ3lDSVBqSnlmU2h2aGw0YmsyNGxsQllkTTlQZXNsSEZMWnY3elYvVlpOKzdGcGVSOHVTL0VqeFNpazdsWWtjOTZ1eGZFbnhFeXg3a2pISDNqM3I2RWI0UmFGTElGRjIrMWVnSndhd1pQaFhveUNRaThJWkRnS2VTYzFvL3JsdEpQN3pKd3dDVjJvL2llVHA4VXZFTWFiVEhESmdIZzlxdEo4VXRZTVRLMXBIbkkrWlR5SzlGWDRRd1NqSzNwVVlPT01FNHFtdndsUllaQjl2QlBPZmw1elNqUEZwYXliTGRIQk5LeVZyZDJjR3Z4ZDFTSnNteVJ5ZStjR3JCK0xGL04xc3lvSFpUV3Evd2p1SlpNQytqM2JmbHlPdytsVkkvaFZxRUlZQzhoWmZVZXRFcW1OOC91UktvWUx5L3dEQW1XN0g0dVBGS3l2YnlkT2hPYVpmL0ZxR1M1aURSTW0zb1FEeFdlUGhicTRMTjUwWkE0VTkvd0Fhd3JqNFo2MTVpcXBRdWNuR2VvcVBhNHRkUHdKZUh3cSsxWmR1YTZPMlg0djJNWitZem4wSHIrZGF5ZkdMVFNWM05JT25hdkZwL2hsNGxmS2lBZkwxNTcxbXkvRHp4RmJ2aVNEbGhsY0d0dnJlS1MrQmYrQW1Dd09IZXZ0SGJ5a2ZTQy9GZlN4S2MzQkM0NEdPYTF6OFZkRFpBUHRBQjdncURtdmxBK0NkZERLWHRIQXpuT0t4Wi9DV3Q3WkN0bktjRHFGcExHVjc2MDE5eHY4QTJmQzFsVm45NlByRmZpSm9aa0pNNkRuanNLNkswOGVlSG1BQm1oenU2azErZTcrRzlaakRiN1NZWkp6bGFRYVJmb3Z6MjBvSjdrSFA2Vm84ZlZ0L0RSbXN0WFNzL3VUUDBqaDhYNkE3RUV3bmtqY0d4V292aVBSQ3dQN3RsSEhVWnhYNWV2REtoQStjYysrYzFlaVc2SklMeTdWUEh6SHJTZU91djRmNGtMTFpxWDhYL3dBbFAwWXU5WDBNU2d4a0ZUMFU0eVBwVVkxSFNHY0tneGo4eFg1cVhWenFDejVXNGtBLzNqVkU2bnJLa2Y2VklPM1d1aUdZd1M5Nm0va3pubmxXSVV2Y3F3MTdvL1RWYnJUV0xCbnhnOWY4S1pJOWdRU1pjYzkrNHI4Mm8vRW5pQkdBKzJ5RVZwUWVML0ZBUC9IeVR6eGtaNHJmKzFLTCt4SXlXVllxK3RTSHl1Zm80WUxONDk3WEVaNStWZXY4NlczczdYWU5zeTVJNUhCNjE4QXcrT3ZFWUpCZFRqMnJSWDRoNjdDRkJWU094cVByMUMrdk45eFR3R0s1cmNzV3ZVKzdXMDBPNDI3Q2ZmQnpWWjlGM1pMd3BnWnllb3pYdy9EOFVkWFdZN291YzhFSEZkT3Z4ZHZ3R0RXbVF4N0dtc2JoMzlyVHpSRXN2eEsvNWRYOUpJK241OURpSkk4aEQrRllVMmdXUkJBdFZYdngwcndHTDRxZ01HYU9aVDdITmFDL0ZmVHlQM2pTZ0hyeFdxeE9DYjFhKzQ1SllMTkk2cFNTL3dBUjY4UEMrbk5saFpidm9vck1tOEg2VVh5YlpRZlFvSzVDMitMR21pRUtibDhidUN5NTRyb1YrSytqc0J1dVViQUFCSzFmTmdXOTZaMEtXT2pGWGRUOFdmbDlZNlJmWFU3cHNJeGpuRmV4Nlo0RGFVS1hKSTc4VjZjdC93Q0diQ0JGdDAzYlVHU2VweDYxalhmankzaWJFS0lvN2duTmVIUncrRHAyOXBPNzdJK3JyNHpHVkcxU3BOTHV6ZDAzd0ZaUWxTUU1ucnhYZkxwdWoyY1lVbERqazE4MGFqNDd2WnlRcmtlZ0JyaEp2RVdveW5sbUh1ZWE3UHJ1RXAvQlNUdDNQTmxoTWZYYVU2cmluMlo5Z040aDBlelVyR29PUGJwWEpYZnhCaWo1aUtnQTkrb3I1U054cU55MjM1MitsZEhaK0hkWHVBZjNad2F4bG1XSm12Y2paZVNOYWVWWWFtL2ZuemVyUFRiN3gvZHlzV0V6ZGY0YTQ2WHhiZnk3dm5idmdubXR5dytIMTlLdzNnajE5NjlRc3ZockdyWmNucDNxRlN6Q3R2ZlUybFd5dkQyaXBSMCtaOCt5YXJmVGdFczJlbnlqQXFDS0RWSlpNaEdmUFk5Syt4b1BCK2cya1plWWdBS2NsaUFNaXRLMWg4T2VRWmJlU0oxSTI3aGdpdDQ1WlZidE9wR0w5VGlubTlDRVhLRktVbGUxN1dSOGl4ZUdOV2xQRVRZUGF1MnRQQU42VXkrY250WDBaL2Jlald3Mk15NUhBUDhBaFhreWZGRUw0aXVMRDdQR1kwVEt1VDh4L0N0cFlUTDZITDdTczIyN0szUXdqbUdaNHEvc0tDU2pGeWQrcThoMW44TWg1aXV6Y2VtSzcyMzhFNlRDbnpCVndlU1RpdWN1UGlCSnRKalE1L092TnZFV3Y2aHFtbDNFQWxFVHV1Qms0NXB5cjVaUmczQ0hPN2FMdjh6Q05ETzY5V1BQVTluQzZ2M1NQcG1EUmRKaTJsUkVWN2REa1ZzUVNhUEh4aEJ0NjU2VjhVYU5xNXQ5SXQ0SjczOThpNFlCcy9saXRWYjlwQ3dVelA4QWdjZnJXZjhBYTFKUlhMUVNkdTVUeVhFU3FQbXhEYVQzczlUMjN4SDhVZEEwUFZiUzBFTWt6VE9BV1hBVlFmcjFyczV2SE9uQ0Zpa1pCNmtWOG0zZWkvMm5jVzQrd2ViSkQ4Nmt1QVIvOWF1bHQvRCt1WGlYUWhqakRJT1Y1T0c3WnpYbS93QnFZdm5sdFp2UlcyUGEvc2JBK3pwcTBrMHZlZk51ZXNUZkVWOG55MTR3YStlcHZGUGlpWHhoSE8wMHYyWXFRY044by9BZEs5WTBuNGI2NUxiN3J1K0VlUUR0UlIrcHJzcmI0WjJpTmw1V2M0eWVhVTU1amlPVjJsbzdxMmhWS2psbUdsUDROWXRPK3U1NTdmOEFpZlV3KzFaZmxHT1QzelhMdnJHb1RsOHVmeUpyNmh0ZkEybVJ0a3hidnJ6WFcyL2hYVEkwK1cyWEk5cTIrcFpqVStLYitiT0g2OWxWSzZqQmZKSHdqcDJtWEVHb1hWM0hiM1VyM0FBWWR1Ty9OZHBiYUZyOXpKbE5QYms5WGJGZmNJMFdCZHY3amJoZXZIRlgxc280dXBIL0FOZXRvNVJVNjFQdU1hbWZVRmI5MjcvNUh4NG5nanhDNFhDeFIrcHdTUlVzWHd6MWVlVW1TOUtrZE1LQlgyWWlXWWpINzVBZTROVi90dWxvNXpPdU85ZGF5cWxiM3BTT2IrMjYxcnhoQlhQbTIzK0YwT1VFdDVLL3I4eC9sWFlSL0RIUm90ckNJdHhuNXVlbGVzUzY5bzBaL3dCWWh3ZURrVmozSGpMUjRWejUwZlE5OC95clJZTEJRM1MrYk9lT1laalUxanplcWlaMXA0RDBnQlNMWk9tU2NaNlYyTUhoblMwSjIyNi9YYmdWeDMvQ3k5TWl0L2tJd1BRVnpNbnhYaElZeHh5TUd5QnhpcS8yQmZ5RXVlWnlhVjZubXIyL00raWJYUllVSktRS1BsSjV3TTFkV3dRakpWUjllSytWUCtGbDM3cDhrTEhyalBOWk0zai9BRmlUYnNBWDFCenhTZUp3c0hvN3J5US9xK1BucDdPUzgzSkgyWTluYmJHQmxVZXVLcHlOWlJnS0xnako0OTYrTHBQR2V2dURtY0JjODRybjV2RWV0ekJRYjF5TzJlS2w1aFJXMEd6VllERWRaSkgzaU5RMDljaHBNbnA2Vm5TYTlwQ0g1bVhqMVlDdmhIN1pmelJ1cjNNaEtrZnhIbk5VSTRMdHkyUXpFSG9TYXgvdEZXMHAvaVgvQUdWTnlUZFZMMGlmZUUvalB3K2hIK2tJTWU5WVUveEIwRUFFWEtkOFk3MThaUzZkZGh4L29qdG4ySnJSUGh2V3BWUGwyakFBWkIyNHJGNWxXMmpUWDRzM2VWMDcrOVdiK1NSOU52OEFFM1NZWEpTVm16MDJqaXNkdmk5QUhJV0YyNTQ3Q3ZDby9BL2lWOW9GdUFEMTV4V3F2dzYxOE1vYll2b0NhWDE3RnZwLzVLV3N1dzYwOXBKLzl2SHFVL3hidkdiRWRxVHozckxsK0oyc1NvdTJHTlJuRGV2NDFRdHZodGZzbzh5N1ZSeDBHZnpycFlQaG1nR0d1eWZtNXd2K05OVk1mUGEveVNJbGhzRFRhNTlmVnRuTHllUGRiWjJIbUtneDJyQ2Z4ZDRpa1UvNlh0UGJIRmUyRDRhYWUyR2FXVnYweitWYjhQdzUwVUlNcEszc1cvd3BLR01lN2w5NXRmQXF5aW9IeSsydmE2OGd6cVVnQnhrQThHcXo2anFtZm52SnNIcDgySyt5YmY0ZmFJc2kvd0NocU1jK3hIcFhacDRRMFpBZitKZEYwd0NSbitkSHNNUytyKzhoVmNISFhsWHlpajRCM1hETmhwWkNXeWNzVDFxdjloZmFEdGtaajF3Q2Z5cjlHSS9EOW9pQUxheERPTVlRVk8ya1c0QnpESDB4OTBWb3NGVjdpZU5vS1MwZjNINXRqUzdwbFRGcEprbkgzRG1yMFBoZlhIQ3NsaEtGeVJrcitYRmZvZUxFWXdTQmpHT01mbFRJZE9VdUI1bWNuSjU0cTNsODJ2aVNKL3RhaXBXNUg5NThEVGVDUEVoWVlzNUF2ZkhGYmNQdzk4Unl4eDVod2V4SngrZGZkZDFCYkxoVE1xa0VmeFVpQ3dEWU02WkF6eWFoWmMybDc1VHpTQ2xwRDcyZkU2L0REeEJ1VXQ1YURucTJhM29maFZxYllaN3lFSzNwWDFvOTNwZTRqejF5QjYwMWJ6VFZYSG1ESS9HdWhaZEZMV1J6eXpPN3VvbytkYmI0VFNqQ20rVWpQR0Y0R2E2aTMrRDlrWC9lM3JFZDhDdmNvOWIwdUlFYnNuSEkyMUovd2sybFF3ek1pbHp0OVJVZlVxYTYzTC90Q2JzMGtyZVZ6eG9mQ2JSQWNmYUpDTy9ZMXVRL0N6dzBnRzRTeWJoanJYVGp4ZFlFL2NJUHV3SFdtU2VPTGFMSkpqQXgwTER0V2p3bEZidjhUUDhBdEtyTFZwZitBa1Z2OE4vQ1NLQWJKcENEL0VmNTEwVWZnVHdvcTQvc3FOdmJubXVaYng3YkFCdk5nQys3ajlhcHovRXpUMUJQMnUzVWpyem1zM1F3NjE1bDk1WDF1cTFyRi9LSjZJbmhYdzJnMnJwVU9RUjFYcCtQZXVxajBqUWtqSy8yYmJrQURHWXhYemhOOFZMRUtRTlFpeDY3VFdNZml0cDRYNXJzK255clFxZUY2eWlLR0t4Y1crU0UvdXNmVzBZc29tK1RUcmJIUWZ1Z00rMmExak5GaFZGbENvMzdodFRHTWZTdml3L0ZxellIRTB2WHBzNjFRZjRxeFpCV1c1NU9BQU1VbjlVdXZlUnI3YkhQYUUyZmI4NVp2dXRHdWNFRlY3L1NtTGVYa1pPYmxjQUhxQU1qM3I0S3V2aXErUGxGd2NIQitiR0t6bStLT0VSamJ6dG51emNWbTU0UmZhVCtRcFBIT3o1R3ZtZmZ6YWl6SWtndVFPTWNjWTlxaFM3a1VzVXVpTW5KSUl5YzE4RFA4UzdoMHg5aFpSNjd5YW9yNDl1d0ZLeEJzOVFTYUZYd2kvNFlUaGpwTmFhZCtZL1JOZFhrVUtQdFo0NEpMQWsrd3FtZFJYeldMWEl3RG43M1VWK2VWeDQrMVB6UmkzUWNkeWMxbnllT05iQ2toSXhrOSthUHJHRVQrSDhEYjJlTHNydjhUOUYyMW0yZGR6WGlxdmNCc2MrdkZMTHJsdXFiVGUvTDJ3M2F2elFieDc0aGtmWVBMQTRIQzFKTjQzOFY1UkpKb3dBTWZLZzRGUzhYaGx0Qi9jUjlXeFR2NzZ2OHo5SmwxalN3bVB0UUl4MjdWQlA0azB1TldBbFlGcyt0Zm1vbmlyeEVXeDlxd00vZEMxZFRYOWZrY1p1U2Nqb1JVckYwZXNHS1dIci9BTXlUUHZwdkVPbkIxRzlqa2ZMeGlxOHV1V2JTYkdqZGsrOERqdUsrRnB0VDE2UlUvd0JJY1lHQlZGOVMxbFlnaG1jdHU1ZmR5UjlLbDQ2bXRvTVN3bFcyczBmZXJlSmJCcFkwOHB0eEdja2NVWGZpRzJFY1NDTmljNUhQVWU5Zm5rMXhxU3V1THFUUFBBWWo4YXFOZWFrelBtNWw0SEJEZnlvV1BqcGFuK0pYMUdwWjNxTFh5UDB1c2ZFTm00MkZGVWorSm5BejdWaVhQaU8zT1RzR0FjSERERmZuWjV0NXgvcEVtUjF5eHEzSEhjT0JtYVRuMVkveXFmcnJUdW9maWFMQk5yV3BwNkgzNHZpNjJpdzJJMUxIR053cXgvd20xcmxDVENNZFR2SEZmbjdIQmNrdGt1Y2RBQ1RpdEtIVDVISi9keWRlU0FlYW42NUovWVZ5L3Fyam9xanNmZUwrTmRPeXFtNWlVRTlRL1RQMHBaL0gybFJzQUwyMmZibjFINTE4TXJvODdIYjVUa2tjWkJyTU9qM0RIQmdkaU92eWs0cFBHeS9sUTNobWw4YmQvSSs2SCtKT2tvRHVudGlEM3lhWS93QVNkSVRZd3ZZUVQyR2VCWHc5SjRmMUVSNUZ2TGdqbjVDY0NsajBYVnBKZ3EyRXpmS01FeG5tbDljcVgyUmF3VGErSi9jZmI1K0tHa0VsVGZScUQzMi8wcW5KOFU5SlZRbjlvb3pjYlNZeVI5SytSZjhBaEY5YnkyTk5uNlpQN28xTC93QUliNGs2L3dCbVhIUCt4VCt1VDZSUXZxVWs5NUgxZVBpZG9jOHNwbTFSSUFJMlpRSWlRV0hSUjZaOWF3MytLZWxyTWdGMndRbjVtVkNjRHZpdm5zK0NmRTdLdU5LdWVuSkVaeFRrOEhlSjVNYmRNbnl2WDVlbjFwUEdWR3JhRlR3ZE5ieWxmdWZSNStMV2tCMlZMcVR1RllwMS9Db3BQaXhwU0hhdDNJU092eVY0RzNnTHhXV1hPbHp0ODJmbEdTS3VuNGNlTDJZTU5KbWJuSHpBREZQNnpVMDFSS3dsOXVjOWtuK0xtbHRzSG56bmFPb1hGUXY4V2RQMkFocm9uakkyNS9LdkxrK0dYalZVY2pUU2M5TThZcUEvREx4bGxZellPcmJkMkMyQWZ4cC9XNm5kR24xR1hWUzlUMktQNHRXalJFQ0s2M0Rub1AweFdTL3hadHd4R0xsc25nQmVuNTF5VUh3dThabEFGdE5wOTJGUW40VitOVEp0K3dIQUorYmQwSXFsaWFpdnFpSllMUk8wNzlEc3g4WExJTW43dTRDajd3NkZxWTN4YmhDeUtZcmduSTJ0bkJBOURYSnQ4Sy9HT3dsYkVQazhEZUJuNjVxMy93QUtpOGFpTldOa21UMHc0Si9HcFdJcTMzUk1jSEo3eGw5NTBjbnhjdC9zb1FXMTQwbTc3N0ViY0dzeGZpcDVqRUNHWlFveGduTzRqcmlxOFh3ajhZT2puN0lQbGJEQU9Qd05UTjhHL0Y0YkJnakdjSEc0RTFmMXFxdEUwVjlTdTlZdjd5ak44V1dWZzBkdE1RTTlUeHg3VXkxK0sySk56MjA1SkJKVXNSblBOWFgrRFBpWjRCOHNmbUF0eVd4eFZxMStEUGloNHZNRWNPQUFQdlo2OFVuaUt0dmkvQWYxSmMzdytlNUFQaXl5Uk1FdEpzdDBPN2dWaW40cFRzbURiM0I1enUzVnZUZkJYeFVWWW9iYzdPeGJ2N1UyRDRRZUl3dUdXSU1PeGIxcFJ4TmRkZndJZURYMmwvNU1QZytLTEtpbGRPWXNRQnZKT09LbHVmaW1YZ2lVV0UwYmhpV0lrem42VmRiNFArTVhSTm90MUE5WDZpbU44SHZGUk9HRnZ1QTdQU1dJcXQvRVg5VFVYcERUMU1vL0ZOMkticldWZ0Z3dnovclZvZkZXVlVYYlpTYnV6QnNqOGF0RDRQOEFpY0lNckRnbmdic0g4YWpqK0VQaXBVWW1HSlJ2eGd2NjkvcFQ5dlV0OFg0QThLM0w0ZnhLY1B4VGNPMjYybUp6eHRZREJySW4rSjBzbDN1VzNteUNOeWx1RFhXcDhHL0VrU3U1ampJemsvUGsxbHY4SmZFa2JodkpRZzlCdXlUU2hpYXFXNys0eWxndEV1VjJYbVY1ZmliUHZVR3hkQUQyYm1yVVB4WW5CRzJLWTlBVnlBU0JWcC9oQjRxWUZrU0xKd1NyTnpVeWZCcnhVc2U3eTR3UjZzQ0I2NDlxdjZ6VWErTDhCUEF1T3FpNy93Q0lZdnhXTEErYll5TVRuWTIvQi9IMXBIK0sxdUd5dGpNckJjSEozRDhNMVdiNFhlS0ltVlRISHRQQzRPY0dxazN3MDhUWkdZWThBODRiT2ZwVSsycTdwL2dXOEtyYmErcHUyUHhWdGt1a2FleW1rakdRMFliYWZ6cDAzeGNqM1lObStPMjNBUDRtdVZuK0gzaUNHTWVaYkxzYmpkdXorZGRaNGUrRFBpSFc3eHJhTnJlSmxRdmgzeG44T3RUVXhOV0VlWnV5WFd4VU1HM0pSU2xkdm96bTdqNHBRVHU1TUU2QWRNWVBUMXExYmZGYU9BTVJESTJCL0dLNTEvaHRyUnVMcUJWaWVTRjNqY2lVWTNJY0VaRmJ1c2ZCM3hKcHZoaTIxZVdTMmEzbmxXSlFyamVIYzRIMUdlMVp5eHRTUEtuTmE3YWJtc2NCR1NsSlJsZU9zbmZZNnlUNGlXazlyWnllV2ZOZEczLzdKendlSzVpKytKMGNFcXlKSElCdHhodm16V2JwL3dBUC9FRUtscExma2RCdXpnZTN0VUV2Z1RYWlUrV3pMREJHU1JnVnNzVFdzbitoakxDMDl0VjUzMU5GUGlkQVdMQkprQkF5TTU1K2xEZkZDRm1KQWRlT09EbXVUZndEckt5S24yWmpucHpuOWFCOE9QRXd3cTJtNHRuZ0VabytzNGkvL0FNRmhLZTNOSi9NN3BmaXBiYmRzalRFZGM0L3BUMitMRmhHenFwbFlBREIyNHhYbmkvRG54V1VJTmhKZ0RHRHhXYS9nWHhOdjIvMmRJQ0NCanJrVlgxcXIvU0tqZzRMbzJleG40dWFheURJY1p4L0RqYlN6ZkZiVGNJRW1kVzVESFpuZDZWNHhkZUJ2RUFHZjdObEJ6eUt6WDhGNnprcjlpbHloenRDOXFsWXV0ZlpmY2FMQ1IxdTVudWtmeFEwSU1HZVpnVDIyOWZjMW9mOExSMEYyWlJjbkE2ZkwwcjUrajhINndDeE9ueUFIakpUb0t5cGZDT3NnTXAwNlk4OWtPYTBlTHJXdlpmY1Y5UWpiNHBXUG9hWDRrYU0zM0xuZHozR09LaFB4STBneE1QdENJK2VBUjJGZk9MK0V0ZUVZSjAyNEtucUFtN0gxckxuOFAzOGJaZXlrQXdNQXhuT0IyRlZISFZyYkk1WjVkVDB0S1NQcUdMNGhhT0U1dkVMSE9WeDYxdldmeEIwd1FNelhVSUE1eDFOZkdoME84TFord3lnbnRzTk1iUTdtTWd0YXVPUDdweVNhVHgxVnZXS0hITDZhV2s1SSsyaDhRdEhrRDdKNFJ3Q010eVQ2Q2xUeC9wakFCbWlHZXVXNUh2WHdlMm1UcXdQMmRnUU1mZE5KY2FiS3ArZUVnZHV2ZXErdXlTK0JFZlVXMy9HbDl4OTRyNDIwaHB5SGxUWmpIRFovd0E1cS84QThKbm9lR0laQmtaQTNBOVBidFg1NXg2Y0F5L3UzR1QrZjBwLzluZk5KeS9COVR6N1ZMeHphMWd2dkwrb1dYOFYzOUQ5R2JYeGxwRWt5Z0JCdTRKWmdLUzQ4WjZRSjhiY3FNOUNEbXZ6MUZyTUR0YVdRQURzVDNyTWtodU9BSjMrcGJGVkRHTC9BSjlyN3lGaEsrcTl0LzVLZm95ZkZla3lZVXh0eU9vSXppcGpyZWhaR1lpRHh6MU5mbWNKYjFUZzNNdWVjblBGU1JYR29xQUJjeWtFa25KNlZwOWRqMXAvaUVjRlZsL3k4VCtSK2xyZUtkRTNqYVd5dWVkdWZ4cXdtdWFMTG5FM0p5Q1FPYS9NejdYcXdCSzNjaWprY0hOYVVHb2E1R3luN1krVDM5YWJ4dEwvQUo5djd4ZlU4UmQvdkkvY2ZwRC9BR3JvMlF2bTg0NTQvblVMWDJtRXFWdUVDZzVQcVIycjg2UjRoOFJMSTJMcHVSeHhuODZlbmlMeEFFeDUyNCt2cFZMSFVlc0pFckI0dHY0cWY0by9SK083MDJTTmdKMDZldFpabXNFbFVpNFhPUFgxcjgrNFBFL2lGUWN5akJQU21mOEFDWTY0akE3bytPbkg4Nm42M1F2OE1pYXVDeFZrazRzL1JmejRwVlUrWUNTZXZIU3BKNDdkMVZXblU3RkpBNHlhL09wZkhtdVJPTVJqdWV2SFBwVnhQaUZyQStab2tMbnI3VjByRjRWNzMrNHdoaGNhazd3Vi93REVqOUJsdGsreng1Y0x4eVFjMVRsczRnRUtzcDQvWDJyNE4vNFdScXlGdjNKK2JqclZpSDRrM2ZSNEppQWVRSDlLWDFuQjMrSi9jTDJHT2NmNGR2OEF0NCsxcHJCbkkrUU4rSFNvanBhQU9IaFU0N1k1NTlLK05qOFVwVk9RczQralpxeVBpdlAvQUFtWVk1eWVhMFdJd2o2L2dZUnBZNkR1NlV2azduMTAraFFPbkVNUk9laFVHc3E0OE4yUmZJczRnUjFLcUJYemd2eGZZS0ExeEp4aitIajlLMDErTHE1Yk0yT2Y3dERlRGJ2enhHbmpMKzlTcUpkejFxNDhHYWM3T1RwOFp4azlPYTV0L2g3b0VoRG14WEpCNDlLNWYvaGJkdXpFR1ZGN25ka1ZvcjhWYlJnQ3oyKzdya0hyVkpZUi9hZzBaeXE0NVAzVlYrNGhmNGM2Q3lFaTBJYjF6V2IvQU1LejBqZ0NPUnVQV3VqVDRtMkxIcEVmWDVxMFlmaUxwMGdPQXY0TUJUbGhzSTl1VTJoaXNYR3psejM4MGVmeWZEVFRVenRNcW5qbkg2Vno4L3d3amtkOHl5SUNNQTR5Ulh2cWVQTkphTlFVYkk3aGdhMUl2RmVrekpsd1FQZkZjN3dsRHN2dk91T1kxN2Vmb2ZLRGZDYVlQbEx3Y2VxOG1zU2I0YzNxa2szQU9lMjAxOWhmOEpINGM4d2d1UlU3NnA0ZGNFaWRRVDJ4MHAvMmZSOC92TVhtOVpQZE0rR0x2NGY2dm5FYkwwNE5ZRS9nRFcxSE1RUEhHRG12dldPNzBSbUlNaVkvaEhlcDl1a3lmZG1qUG9jMG5sbFBwSmtTenV0SzN1eDh6ODZENEc4UXFFSDJOaUQ2Vno4M2hUVlJJUWJSOGoycjlOMnRyUmd1SFhnbm9SVFcwYXpjNUlRbjhLeVdWdC9hT3VHY05MNEVmaTJrOTNMa1pZL25YUlE2RHFWenRJamJtdmVOSzBTd3NiTXkzaFVFQWMxM0Z0clBoKzJpVmx3eDdlb3J6cU9DcDZPclZVZkpzK2h4R1lWSTZVcVVwLzNrdER4ZlN2aDNleW9IZHNEMDcxNnJZL0Q2MWkyN3p1QTdtdVc4UmZFVzR0b2tObEgvQUJnTmdaeUt6N3Z4N2VORnlRQ1Z6ak9CWFFxbVdVcHRXY3JkZTV3emhtdGFtcFJhamZ2MFBXWjdUd3BwQWkrMXp4Umwyd2c0NXJyMjFMdzlhUmdoazI0N2Q2L1Avd0FTYW11clMyN3RLUTBMYmh0NS9DdDYzMUhWYmtLcXd5TW9BR1c0NlZpczB0S2FoUmlsZjNlL3pOWGswcDBxVXFtSW01ZmIxMCtSN3g0eCtKa3VsMmtiYWZicStaTU16RE9CV2pEOFE3aWEyaUo0WW9EN2M4MTRySG9tc1htVThwVkI5dDM1MTB0ajRBMUNiL1hYRWhBT01mZEdLeGppc3dsT1Rqeldsc2t0RjZIVExBNVhHbENNb3d2Rzk1TjZ1L2NrMXp4WkpxRmxjVzhrdTNlcEFKTmVkNkpySnNiQmJYelhrWVp5VVU0UFBCcjZGMDM0YjJxeUJtVmMrcDVyMGF6OEEyVVVnY0lwL0N0Rmdjd3JTNW5kUGE3N0hKUEhaWFFwT0NhYWJ2WmFxNThxZmE5UnVuQlMwa2IwTGNjMVlqOE82OUxjcGNKYlFwSmdqY1ZMSEZmY1Z2NGFza0pKUlF2c0s2RDdEcDFzZ3k2RGpnSEdjVjJSeWlwTDQ2aDV2OXYwWU44bUgwdDNzZkd0cjRJMW1VWmtuYmtad1BscnViUDRhd0YxTXhManFjNVA4NitncE5TMGVINzBxOUt4TGp4cm9GdUh6SXBJSFFjbXVoWlpncWZ4MWZ2Wnl5enZIMVgrNm8vY3JuSDJIdzYwdTNPVmlISjQ0cjBlSHd2WXVnVTJ5RVk5Szg2dWZpbHB5bkVjTHNjZGhXRE44VGI5b3lZWU52cmsxcGJLcWEwcy9sY3dWVE82azd5VFYvUkhwVnI0Qk5ycjdYeVhMTEVZOWpRa0RIMXpXelkrSHRKMC9WN205VzRjdE9RWkYzWlViZTRGZUIzWGpuWFo0d3lFRGprZGE1R1h4UHE3V2NvbGNZZGxCUGNITmVkUEVaZEIrN1JiZDczZmM5ZU5ETjZxMXJwYWN0dXJYeVBzYVhWdEpUY1duQjUrZ3JNZnhWb2x1eERNdUIvdEN2aitXMXZuS3R2ZHZXcFUwbTlkU0ZoWm02NHhYVEhNR2w3dE5mTTVKNVdwNnlyU3Y1SDA5ZGZFZlE0Z0ZSd1Rub0JtdU91UGlxQU1KR3g5TURGZVBwNGExYVJUdHR0djRZcmJ0L0JPcVNENTlxSDg2aDQ3R1MyVnZSQ1dWNWZEV2MyL1dYK1IwTS94TTFKOXBTRTRKNUpOYzFjZU9QRU03a2JsWEZkSmJlQUpuUnc4eHoxR0I2Zld1dmcrSDBHMEZqSXh3TzFKTE1adjRwTDUyS2pIS1lPN2hHVFhkWC9NOFBmV3Rha09IdVhHNGRxb3l5WDhpS1ROSytUM05mVlZwNEZzVkkvMFE4ZDJPYTdPeThLMjBReDltaXdNOVJucFRlQ3hjdFpUKzl0bXp6SEw0TzBZUlhra2tmRk1kcGRNRklTUTVQUEJOYk1XZ2FqTWNpMWZnOVNNVjl3UmFCQkdjZ0l1ZmFwVnRiWlRocGxQSHFLcU9WVkh2SkdQOXQ0ZU1rb3diUGxXdzhJNmxKQTZOQVY0NEo3R3IxcjRDMUJ6dFowWHYxOUsrdFlocE1LYm5rVDhUMnA3NnA0ZGlPZHk4OEJsR2VhM2psMU5hT1R1WjFjMG0vZWpCSHp0Yi9ENjRDamZNdU05cTZLeStIVUFaZzg4aktjOEFZeFhyOG5pclFvd3grYkk3WXhWQWVQOUpoeVJHdUQzTGVsYUxCWVpKdDJmek1ZNWxpSk5kUGtjZkY4UGROQnk2eVBqSFd0Mkh3SG82RWtXaW51TW1xOTM4VE5QalVZTVFIcHU1RmN2SjhWWWlPSGpHU1J3cHB1bGdrbHJEN3grM3g3dnBKcjBQUVkvQ2RpbTRMYUp6alBHYTZGUEQxc3ZBaFJSbis3WGl0NThUL0tqQUc4dVJuaE1WeGNueEt2WkRsUk1TT2ZhbDdYQVE3ZmRjaU5QTUp0dmtsOTlqNnBPa3d4bmQ4b3F3YmExeVEwZ0g0aXZqS1h4OXFqbHNRbmpCK1o4VmtTZU5OWllnaEkxeGp1VFduMTNCeFdrYi9JS21EeDhvNzIvN2VQdWhGMHJPUFBYUG9UVWswK2tKS3ErY3U3c0svUDZieFhyWmJjSGpVa243cTFqdjRnMXlSd1RlTU1uc0t3bG1lSFdzYWJmM0dkUEtNYlV1blZqSHJ1MmZvazJwV0M4QU1SN0NxU2VJZE5qUFB6ZnBYNTd5YXhyRDUzWDh4VVpPM2R3S3lCY1hiTGxwNVQvQU1DTll2T2JMU2t2dk9sWkJKeVRsWC9BL1NSL0cybHhRZ0FMOVM0ckliNGhhV0hHK1NKQnpnNzhqUDRWK2VUUU8rVCs4eDNHU2F1SlpYTDhyYnV3NmZkUE5ja3MzbTlxYSs4OWFHU1FzcjFwZkpXUHZHYjRvNlhFYy9hWVBUQTVxb2ZpeG9waGN0ZWhaT05xaENSK2RmRmtXaWFrNXdsbEp6MU9NVm93K0Z0ZWxBTWRtN0FIazQ2WXJuZVpWMzBTK1JwTEthS2Z4eVBxSWZHQ3lIRytWODkxV3NPWDRyZjZ3TEhPMmNsVDdHdkZvZkNPdU95anl3U1R4enlLNmRmaDk0aFBKQ0xqMWJqbW9lWVlwN1A3a1VzcHdpM3UvV1JxeWZFelVKQzJZNVB4YXN4dmlOcUtSa0MySno2dlZxSDRhYXF6YlhsVUVIbkFQZXRzZkMyNGRnWkxsVXlNanZWUEZZMlMwY3Z1TFdBeStIMlkvTm5uTC9FSFZpNXhGRUQ5UzFWNWZIWGlKK1drUVpIWVpPSzlMaitGc0prL2VYYjR4enRVQ3RxMytGRnF4VUM2bFAxNlZrdnJyL25OZlk0SFgrR2VDdjR4OFFBSEYzajNDNHBQK0VuOFJTdVhrdnBTZU9lbGZVTUh3ZjBnWWFTUnBPdkFPUHpyZmorRk9paHR6UVBqNjljVnZHbmpYL045NWkxZ1k3K3orNCtVWU5UMWQzK2E4bUJQY3R6U3lDL2JBTjFKejErWTk2KzM3VDRjYUFnQSt5NTQ1SlBKOXE2NVBCK2d4a1kwK000OXMxZjFYRXZkL2lackVZU0xka2w4ajg4MHN5MFozTkszMVkwOUxCM0krUmlQZk9NVitpSytGdExWdDMyS01ZOXE2R0RSckdKVC9vMFE0T2ZrR2EyK3FWR3QwWXZGMFgzKzQvTkQreW1JSkZ1NVBiZ21yVWZoN1VKQ1dXemNqSFhZVFg2ZFIyTnZoUUlvangxMmdWcUxaeGdMOHNZQXpqZ0NsOVRsL01pb1ltbW5zMmZsOHZoVFdwR1l4MkVod1IvQmo4SzJrOENlSlpNYmRMbi9BTytjZEsvU1l3UkVFTkpFQVd6emdZcVR6SVVJSDJsTVk3a0NpT0RsL04rQTVZeW1uOFA0bjV6Ui9EbnhWOHJEVFpjSHZ3TVZxcDhMZkdVaURkWWJRT2VYQU9hKy93Qkxtejh6SnV4bjB5TVZaYTlzQUQvcFFPZnlwL1VuZldYNENXTmh2eS9pZkI4SHdnOFlTbGMyNlJqSDNpK1JWdy9CcnhLQ1FXdHdSMjNHdnVGOVRzNDF4OW9PRGc0R2FwUzZycCswTXhaaUQ2SDg2RmdkZmlZU3hzV3JLUDRueVREOEVkZGFNT2J1Qk1rZkxrOGZqV2lud1AxVlQrOTFHQkQwMjRKelgxRzJ0YVRJU3JGemdkTnBOVnJiVWRPVDdnbExkbllmNDAvcVM2dGtyR1J1a2xGK2QyZUVMOEQyWUQvaVpvRDdqajh6VnRmZ1paR1U3dFlDZ0RyamcxNzdiNnRhU3UrOE1CbjVja0FmL3JxdU5ac280d3hqTzBNY2t1T2FTd2NiN3NVc1lycjNWK0o0M0Y4RWZEb1pTK295SEI1S0NybytESGhEYTNtMzF4a0hLZ0hyWHBTK0o5T0VrckpDdU9wL2VBVlN1UEYrbkxqS0owemtTZEtyNmxDL1g3eFBIdUsyajl4eFZ2OEFDVHdLQXdlZTRiQjZjNUkrb3JXaitHM2c2QndFU1VxUjN5VCtOWFQ0dnNtY3VnaVZnT2YzblhOUm54akF6SEUwQUM4bm5OT1dGb3JyK0pqSEdUa25wSDVJWTNnWHdxamxXaUpVbkNxQ1FSbXI0OEgrQ0lFSmwwL2V4SFRieldQSDRyczNsSiswUU5rWnozckR1L0ZscEFVMzZuYnNXNUlUcVBaczk2WDFmQ3Q3cjd5bGpLa2RvM2I4anE3YndwNFFZaGpwcXNnY2pCSFA2VjA1OE4rQ1V4alJJeU05TnZOZU9RZVB0TGpuT2IrTkFUenh4K1ZYTHY0aWFLQXFqVVFjWnpoY1ZYc2NOZmRmZVFzWmlsZmY3ajJlUFRmQ0NrLzhTRkdCSjJuYU1qOEtsVFRQRE1ic1UwZU1FanB0RmZPbytJMmxSU0szOW9sc0RwanIvd0RYcFA4QWhadWlCeXpYY3AzZm5SS2poSTlWOTRMRTR4N3AvY2ZROXhaNkxMR3dYUm9WWnNEY29BNTk2dFJ4VzhUeG1QVDdaVlVBRUVkZnBYekZMOFM5RkFUTnpPM1BJVTRJSHNLdUQ0bTZHRkFFdDBlaE9Xd0I3VXVYREpib2Z0Y1Ura3ZrajZvRjFDN2NhWkFQY0wwSXF3OXlCdUlzTGNiKyt6L0QxcjVRbCtLbWtxdUl6T094M0grVllqL0ZpeEhXR1Z5TTlHcEpZUlBvYU90ald2dGZjZlpCbW5KQUZyQU53eHd2VDZWZGh1cnNNQVlZUVU0WDVBSytJbitMdWwrV0NzTXFrbnBrNHFvbnhiaFlqRnBJM1hBREg5YXB2Q2YzZnVFcW1OVDE1OWZNKzYzMVMrWmlmM2FFRGJ3S3JOcWQxTmpMb05vSE8zSDQxOE9wOFdZZzUzYWM0QUlPN2R6K1ZWWmZpMnJQbGJFajBCSkk1b1VzSXRrdnVKblBHdnJQN3o3cmE4MUE0MjNLb3FnZ0FkR0RldFFKTGRDRjA4Mk1LL0RBWUdhK0dqOFdydllGR25LTTlTRGltUDhBRnU4RWJSLzJjakZqOTg5UlZLcGhWMFgzRTN4VGZ3eTIvbVB1OUx1OXlQMzY0QTI0NDZmNDFhanY3L0RBWEtjSG9jZnpyOCtoOFd0UlhoYkpSanJ1cWRmaXhxK0Nmc2tYL2ZOUktwaDEyKzR1UDFyKzkvNEVmZjhBSmZYWGxsdnRTcVQvQUE1SEdLcXZkM0xLby90RUQyT0srQVcrTEdzazVGbEdRUHk1cXQvd3RiWFpOZ1MzZ0cwbkh5OWFJMU1QNWZjVkw2dytqLzhBQWo5QXZ0KzFjRzdVOWVjOGlxeTNUTTI5TDhjRGpEZFI2VjhDSDRtZUlYYjVyZUlaSGFwditGbStJbzR4R2lRc25ZRlJ3ZlNxOXRRN2ZnWnRWM3ByOS84QXdUNzZXOVZTQTEyTUhwZ2p2VVJ1MUQ1RjV0VW41anY2WTlxL1B5UDRuZUpVT1BLajRQcDBxS1g0a2VKSkpHZk1ZYlBUSEZXcTFCZjhNUmJFMitIL0FNbVAwTFNkWGZmOXZ5Y2RRZHZXb1piNUhCVTNmSFRPN3NLL1BwZmlMNGtMbjVvMUdPZzcxbVNmRVh4UUhPM3k4TDZEbW02OUR0K0FyWWpsK0g4VDlFWHVJTUxtOGNEK0VnOWZ5cEk1N05XQlc3SUhzVFg1NlNmRW54TVR5MFp5QU9oR0Q2aXBvL2lINGtWZUNtVC9BQkhQRlI5Wm8rZjNGd3BZcDd4U1hxZm91THFOOGxiazU3bkZaczJvd0kyQmViWDc5eWEvUHdlUC9GcUFnWEtqbkpJRlEzSGo3eFpLWTkwMFpJR01nZHZlajI5SHMvdU5IQ3U0MnNrKzl6OUNqZTI3SERYSlk0SFdtZmFvWE8xSjhaR2Njak5mbnFuajN4U0FRV2hJYmdaWDVoajBwbzhjZUtsSXhPZ3dPT09uMG9XSXBkbVI3S3RmZGZlZm9ZTGlFT3dNNUpYcjFPRFJGZHdZYi9TMkpCd1FlZ0Zmbjcvd24zaWcvSUpJMXlNRWdISnhTeGVQZkZFYXNGbGlPZURuazFYdDZmWi9jRHBWdExKVzlUOUJVa1NUYy8yeHl2VEdjamp2Vk9SU1VEQzVjZ25BSVk5Ulh3SEY0KzhUcnYyemhDNElZRG9SUTNqM3hPeUlQUDJCUndPZnpxWGlhU2VxZjNEVk9yYldLKzgrOUZsU01GL3RUZ0VrQWxpT2FsYVRJMi9iSkdYR1RnbkdLK0VKUEgzaTJTR09KcmtNRjZBMG8rSW5pdU9JZzNZQUl4Z2R4NlVMRTBleis0ejloVzZiZXA5N1dnTXBUWk01STZaelRtbGlmY0JlZzViNXNHdmd5MStJdmpHS1FPbHp0WkNDcEhxS2pmeC80cWVWNVRJb1l0dU9CZ1pQdFNWYW01UGY3alYwcTNJckpYNjZuM05JSW1USzNKT3dZd1QwcnpYeFQ0UnROYlczbGU5dVlwSXZ1VFFUUEM0ejJ5aEJ4WHpUYy9FbnhaSkdJM01mQjRPMFo0NTVOTGNmRlB4YktTWGVJNXdYVlZ4bkg4cWNxMUNVWEdVYnJyZEdUcDFyUFRvdXFQcW5RdkRzR2xhY3RyYlNZUlFUZ2tzeEo1SkpQSko3bXZPVjhEYWVtb21kOVJ1NUZTY3pSMnNsMHhnamtQVjFROEExNFIvd3MzeFNXT05pY2JjanVQZW1YWHhTOFVTTHNNY0xIYUFUdEFQQXdNMWw3VENOeHZCUGxlbW14VWFXS1VHa3JYVnQwZmVHcVNHTzIwMWxjamNyRDVlYzFoUXJjT1R0a2ZhQVNRRDZkL3BYeHdQaWJxdDlhV2Rra0pqbHROM21PRzViZWNqSG9LdVNmRVh4TGFzNGhJVGNtelBjRHZXc2ErSHRwdmZzYWV5cjgvdlIwc3V2a2ZZQ2xWNDgvdmtMbW5CNVF3S1RnRWREdTVCcjRtUHhGMThxcDhpUEs5MTRKUHJUMitKWGlIekZmeUZ5aTQ3VnA5WW9kWCtCemV4eERiOXo1M1B1MzdkZU1nTWwzeWh3aDNpbzJtdTJZRTNLWTl5TTVyNFFYNGw2MHo3bnRrT0dCQTRBUDVVaWZFclhWa2NpM1ViamtESU9QenBxdmh2NlJEcFlwdEt6Zi9ieDk2U0xNT1ZsR2UzT2VLZ2FCbUlac1pBd0QzcjRYSHhSMS95dHYyZFFDUmtEMnE1QjhWOVpRQU5acTdEdVR6K1ZTcTlEditCMGNtSTZ3ZjNuM0F5WExrbG1VOU9lL0ZUc3R5eWpNdWNjRHQwOWErSmJYNHVhbEhJMy9FdURCdDJRZmYwclZ1UGpES1lsQTBsdk1DNVo5M0J4N1ZYdDZIZjhESDJlSTF2Q1gzbjJXTHpVa2gycTZvQ0NNNEg1MWtFWDB3RzlrSlFjY0RnSDYxOFl6ZkYrNG1BQXNOcFBjRTRJb2I0cmxXakw2Y1R0KzhOeEdRZnBTVlREZDE5d245YjB0R2JYcWZZM24zYkhhOGNaSzhCOWdCSS9DcHpKSk1nVXd4RUwwK1VjVjhhRDRxd3EyWTdPUlFmNFNTY1ZjdHZpNVlJb0VsbktTRC9DeEZOMU1LM3BKZmNYRjRxTU5ZVDErWjljL1oxS3NQc3NSemtFN1I4dWZTc3A5TXRHVUs5dEczQU9Dby9Xdmx2L0FJVzdhcVNmS2xDbnRrMW9RZkdEVHdHM0NVZW1lY2UxYWMrRzZ6aVpLV0xlaWhOSDBndGpwclI4NlhiZ2pnZktNOFZtTm91bWhtWVdNV0R6OTBWNEovd3Rxd3o4MDhpZ1p4a1ZVSHhXdE03dnRiRUgxRk8rRmw5dUpQdGNVa2w3T3A5eDc0bWhhVXpOdXNrWTlpRkhGVTVQREdoNUptMDJOanpqQ0FmNU5lTzIvd0FWckl1dTJjcUIvZTV6V3V2eFMwaGpLcHZNcWZWZTlTbzRhNzk2UDNtM3RjVW9hUnFYOUdlZ3krRVBDN3g3djdOVGIwM1l3Y2ZoV01mQkhoaDNCL3M0QWR5TTlQYXNPUDRsNkNGSy9ibFBIY0RGSTN4SDByelkxUzdpd2VTd09NRWMxYWhobmUzSVl5eEdJamJtNXpXZjRmOEFoVW5QMkpoanBna2NWaXQ4UHZEcFpHK3pTZE9QbTlhM0lmaVBvN2lUTjFDTWRoM3FhUHh6cGJBZnZvRGtqK0xGSlVNTnUrWDd5cFl1c3JLeis0NWdmQzN3OUlKSFh6UWNIQURWa0w4TXRLVmdubVNZeDF5TTE2MVllTnRKRTRIN2txYzVPN0pxQzQ4V2FYRk14ekVlZVBuNjFLd3RHVjlGNVdZU3g4NHhYdldzOWREekUvQzdSeGdDNGtISGZyWE96ZkNXd011RXZDTzI0alA1MTdZZkZPbXZqNVZEWkpCM2lxNytJTEk0YkE2LzNoUytwMHI2cjhUTjVsTnE2a3JlaDROYy9CcG1WY1g0QTljWjZkcTU2VDRPYWdzaTdMdVBIZlBGZlZ3MXJUQW8zWjNIb09LbkdzNkt3TFljN2UyTzlDd1ZMb245NXRITXAyV3NVZkgxMThLZFh3V1NXRnVlbWNmbFdDM3d6MTZNc0I1WkhBQnovT3Z1QWF0cEVnNXlvSk9EaW9oZjZVVjJyY2JtSjV5cEFwUExvUDhBbUNXYXVOa2xGL00rQkpmaHg0akRuRUNzZlk5Nng1dmg5NHFqWS82RzNUSEhOZm91TG5UR0l4ZEllZWMveXByQ3lLdVZ1a0FQWXRTL3M2RCsxSUZtay81WXY1bjVyeWVEZGZqSHphZklDZWdISXJNZnd6cmdZZzZmTHpqQngvT3YwMkVWaklxWWxUSzk5d3hWVjlNanlNc2g1NDVCNjFEeTVmei9BSUZyTlkydTZWL1JuNWhYR2dYU09VYTJmZHdUOHBKckZsMHE0VXNCYnVoSFhLbXYxVWZTWW5VbnlZeWNZN2NackxmUXJYamZDcEo3N2Mxbi9ac250UDhBQTZQN1dwS0MvZHYwdWZsVzFySXE1OHM5ZlE4MUc4VXFxZVdVOXVvcjlRSmZEbGt4d0xhUEdlQVZIRlo3ZUV0T2JkNWxyR2VSakNpcGVYVkY5dEV4emFpM3JDU1IrYk1LVDdjTEk1NzlUMHFacHJ1RlZIMm1YSnovQUJaQUZmb2t2Z3pSeklkdGxHQ1R6OHZOWXQzOFB0RmJhWHRjRUhuNWF4K3BZaFNWbXZ2TlZtZUZrbW5HWDNINTlqVWRUQnd0eko3WnJRaDEzV2xCeGR2MXhpdnMrNitIbWk4RVdwQlBHYyt0WXpmQzNUeU1sVHdjK2hxM2hNVXV2NGhIRzVmZlZYLzdkUGtxVHhMcndja1RBbnNUVXllTWRiVWM0YkE3VjlJM0h3cjAvd0F6aVdUbi9QRlkwdndxaUtOdHVHOXM5YWgwc2F2NXZ2TkZWeXlUMTVGOHJIa0VmajNXVlJCcyt1RGlvSCtJV3FiemxKT1A5cXZUcHZoVGNyeXR5VDdZcm5UOEs5VExzUlAxUHBSelkrTzNNUGx5dWVudU0rV3J6WFZ2ck40NUxoc01OdUY1Tlo5azk4eVJRdzIwakJSZ081Nis5ZlJPamZENkdKRlV4QWQ4NHIxeXo4TWFiYklwZlprRHFhNTRaYmlaNnpkdk05YVdhNE9sRzBFNWVSOGkyM2gvVzdqZ3VFQjZoVnJyclA0YXpTdURNV2MvN1J6WDFFTG53N1pjdEtneFdQZStPOUR0UVJFeU1jSEdCbXZSaGwyRHAyOXJWL0U4U2ViNDZwZjJGRHIyT1AwLzRiMnlZQlFkUFN2UkxQd2JZUURKQ2dESFhpdko3ejRteXNHRUVKeU9NOUs0UzU4YWF4YzVVUHRyb1ZiTGFUOTJITS9RNUtsTE9NUkgzcWloSHFybjFwRmI2UmJGdDBrWXgyRlVyanhCb2x1T0pVR1BjVjhWUGY2bmNPZDAwakh0VTBXblhzN2Y2dDJKNmQ2bDVxOW9VVXV3b1pJN0wybFp2MFBxQzU4ZTZWYmhpcERlbU9hNCtUNG1TTzZpT0ZpRDNQRmVad2VHZFFQM2tDWVBUSHJYVTJuZ3E2ZCtkMkFldUtsWXJNS3Z3NmVpTjVZRExhVFNsRzkrN0pMdngzcmNnUGxueTFybUx2WE5YdUNTOTI1RzN0WHJ0dDRCSXhsV09SME5keGErQXJUYW9kRkI3OTgxbThObUZSTzdsODNZcjYzbFZHU1NoRzY3UjJQbFJUZHVSa3U1SUJIUFd0cUxTTDZZL3dDb1BQY2l2cmVMd3BZUTlXUk9QcGl0bGJQU0lGdzhpSEE5YTJobEZadjNwcEdkVFBzS2w3a0pTOUVmS1ZwNFgxQ1pjZVdxNFBCUEJyc0lmQlZ5Y0JwRjV4eUJtdmRXMWJRYmZQektUVlc0OGMrSDRCaFZCT2Z5clY1ZmhxZngxMGNIOXFZdXJma3cwbDIwUEZkQjAySzRPcFdVOXRPSjRIeEhMczJ4c3BIcjZnOUsxdkJQaFMrMU5MaTExaXdLb2tqR050d0RFRGtIaXVrdWZpTFl4LzZ1TkNENlZnM0hqaVpyTlo0bFpXWnlnd2V3NTZWNTd3dVh3ZDVZaHpzM29sbzc5RDBxT0x6YWNyUnd2SW1sN3pldDExUGM0dEF0MVVLSTFDampwMHJaaDBPeWpiTHlvZ0E3a1Y4alQrTmRaeHdYT2V1VFhQeWVJOVprY3NYeGsrcHJyampNSkQ0YWJmeVBQcVpmajV2M3FxWHpQdHFmK3dvaDgxd2h3T1Jtc3g5ZDBDMng4M0dPTVY4UHkzZXB5RDU3a2pKUFFWVzIzRHB0TXNqZjhDclpacEZYNWFLTVZra25aeXJ0L0krMTI4YytING13RStwSkdLd2IzNGw2ZkhnUmxCak9PK2ErU2t0R09DSXkyZXVjbXRDTFRMcGdOdHN4R2VEdDYxelBNOFJKNlJYNW5vUnlmRHBYYzV2NTJQZmJyNHBPSXNveFBQWmF4RDhTcjRveEhtZW5IclhuNitHOVZrVGF0dTNYdlhTV2ZnN1VXU1JYQ0x3RHljNHJPV0l4MHUveVJVY0ZnSTIwVGZkdTQxL0h1cXpnbmJJUHEzNjFneStKZFlkdUNvSVBybXU0aDhBM1VqSEUyQjdMeFhTUWZEeGd5bGpJeEhYdG1wNWN3ZTdscjVtai9zdUsycDZlUjVJMnI2ekxHcCswNEhzdFUvdG1wRmVicHVEMk5mVEZsOFBvbFhCakpJL3ZOMnJvTFh3QmFxUnV0azdlK2FmMUxGeTFjbjk0bGo4QkZXVWYvSlQ1UGJ6cE1GcG5iZDFHVHhtbTIybk80Y0JYYm5wZ212dWkxOEcyaVlBdDBHTUQ3dGRUQjRYZ2o1K1VkZUFCMHAvVWFuV1NRU3pDbmRjdE9UWGMvUDJMUTdwMUFXMmM4OWtOYTl2NFcxWnlHK3h1dVFSeUsrODAwbXlqY0JuakFQcVJVTXFhU2pOKy9YanJnNXJlT1dkNS9jYzlYTjRxTGFwM2E3cytObjhNZUlMbFl6TEh5aTdBU2VjRHBtcmx2NEcxTTlXUVpISHRYMWtzMmtnRE1nL0FFMGk2dG9rUlBCYm5Bd0FPbjFyWlpiUy9tWndyT3BwZkRCZk0rWTErSGw2Mkc4OVJrWVB5NXJVaStHVGtFUE94UFlrVjlHRHhOcGlrZ0l2WGdaRlFTZUw5TlJ3R01ZSjc3dWxhZlVNUEZhdjhTbG11Sm5wSGxmcEU4UmorR05zdytjdVJTcDhNTEFQankyUFlaSnIxaVg0ZzZWRTNNc1E2anJYSHovRkhUbGt4NThlQnp3S3plR3dLM2Nmdkg5Y3pGTmNxazM1UkhRZkRpd2lRZjZQbkk1SjVyWWg4QjZmSHVLMnNZL0N1VWwrTFduN1NCTVFlY2NkYTVXNCtMTnVWK1VURnM4Z2RNVnl0Wll1cU85VmMwbDlpZC9TeDdpUENlbm9DZnNzWVBBR0Ivbk5hL3dEWWx1QVFZa0FDNHdCaXZsdWI0cHh1RGczQkpQQXB4K0tMcWlCclNWL1g1c0UxenV2bDhWc3Z1TnZxMlp6ZDJwTDVuMWRCcEZtaUtvZEFNZ25KclZqMCt6VmlvbHdldU9nSTljOTYrSUp2aVBxVDRhT3oyQlRrRFA4QW5tdXRsK05YaVNUU0xPeSt5Mm9TMkx0Ryt6NTh1ZWR4SFVWazhkZ1Z0SDhEb1dBekRlVXZSWFByVnpwMFRJQ3lFcjA0N1ZZKzBXSGxFZVlDQVJrWVBldmd5ZjRsK0o1Y3FUR0J1M2dLdUFQYkpySGZ4dDRtbFVneWJRL29PbjBOVC9hTkpQU0RLV1hZdVRkMmw4ejlENDlRMGRwaXFtUU1lbUY0T1BXcjNuMmt4RzJDUmdlTTdjZnpyODE1ZkV1dmhDR3Y1T0czWkhVSDJOWmt1djhBaUdZS0gxSzVLYzRCY2djK3dwLzJuRHBUWnJMTGFxU1RuRm42TjNHcFdrSllTUStXMmVGWWpKcTdINGowMUlpNWFGZHBBT1hCNXI4dHByL1ZYd0h2cmh3RGtBdWVQeHFaTGE1a0lKYVZpZVNRU2Z6cGYybTI5S2Y0bWJ5cisrZnBNM3hBMGxTeEUxdmdlaHpVY1B4QzBGb1pSTmZBTXEvdWxVY1p6MGIycjg5RjBxOEFPSUpPZSswMTBsdjRkdlhDNHRwU1Q2S2Z5cmVPWVQva1J6enk1SnIzMjdlUjl4RDRqYU1BcCszeDV4eU52SDBxaFA4QUZEVE5wSDJ0dmI1UUsrVWJmd3BxdUNCWXlaN2ZMVzFINEwxOThFYWM1UFBVWXEzakt6czFGR01jSFRkMDVTWjdQY2ZGS3lYT0xpWnVleDRwbytLbGdBQ0ZtWStnTmVacjRDMThvUzFxcTU2Wkk2MWFYNGErSlpEaFk0d2Y5OFZyOVp4RFdrVjl4aXNCaDFQNHBlbk1kay94WHM5eHhiVEhuMU9NMW5TL0ZhUERCYkZ6L3ZNZUtxUS9DSHhNeEFMUWpqSnkzZjFyWVg0TmE0UVdhN3QxeWVUeWE1bmlNVmYvQUlCM1BEWWUyMzRuTFQvRkc1T01XQkcwZENjZ2lvbitLbXFHTmR0akdwQnlCMnJ1SWZnM2VBL1BmeDk4SGFUV21ud1lMbkxha01qakd6aXBkYkZQWnkrNGF3dUVTOTZNZnZQTGYrRm8rSWNFcmJ3alArelZWdmlQNG9sQndZMTQ2RGpOZTh4L0JXeitYZnFiTUQxQVVDdFJ2Z3BvY2FtVCswSlRnNEtnRG9hejU4Vytzam9WSEJwWFNqNlh1Zk12L0NmK0o1Rk9adHJZNDRyTWJ4ZjRzZmszaFhQNDE5WHcvQ0x3L0d5ZzNNc2d6amc0L0t0dFBoUDRZM2MrZGcvN2ZQRk54eFQrMUw3eUZIQmMzd1FmeVBqSnZFL2lkK1Jlc01kZUtwanhEcjI3ZDl1aytsZmRjZndxOElxUnVTVi9UY3hyWmgrRzNnbFNTTGNrNDZaUE5Rb1lsYnQvZWFXd3ZOOWhlVmo4L3BkWTF0bE83VUpRUnhnVkQ5djFjcVFiMlVER0NBeEZmb3JEOE8vQnFTQnZzQlpUL0RrODFiUGcvd0FKeEVoTkxRS0QvRXVUUjdLcysvM2lkWERyYTMzSDVtZWJlQm1CdTVUejAzWXFIZGNTYzc1UWVlQXh6K0ZmcUMzaGZ3d3NrWlRSNGVEZzVUcjlLbmw4TmFGOHJEVFlWK2JnYkFLRmhxcjZoR3ZoMDIyL3VSK1hhVzkwV3dYbGZucms1cll0ck83TzRCSkNQWUhPVFg2aDJlbTZaYm5qVG9XSFBWUnhWdkVFYXQvb01SR09NSU1nMUx3dFJNaVdJb2RHN2VoK1hvMFRVcEFjd1RrQWNEYVJXbGQrSFo1SWJOb3JXNDgxVlpabDhvNDY4SFBmTmZwT3NnREVyYnJrOThkQjlLWjl0bFFrSkVuSXg4dy9YNjFTd2RSOVVROFZTVm5yWS9NTmZDdXNQbnk5T200UDl3MWEvd0NFVTF6ZHpwdHd2cjhocjlORFBjRVlKUWdlaWpQNTFlZTZuS3JpUkNxOGpvZXZyV24xS1dtcUhIRTAzZDZwbjVsRHdWNGtJSkdsVGxmWFlSK1ZhQThBK0tXVXNkSW1Jd09kdU1malg2U3JQZkdQNWJoQXZwZ2Q2amt1cng0Z3IzQ2tjampqaXErcHk3bzArdVF0cW1mbnpIOE0vRmhqM0xwekFkY1pGYWIvQUEyOFZHSUVXYkhvVHlCaXZ1RVhCMmxmUFVjakdEMHJWUzRVZ2dYU2pIZnRtaDRSeDZrUEZRZXkvRStFditGV2VNUExJRmdkeDVBTER2VnBQZzU0MmRWYjdKR1BVYittYSs2WkxtVmx6L2FDL0wwQXgrbFIvd0JvRHkxQjFMSTZrYnNmblUvVTVQN1ZodkdVVnB5Ti9OSHhZdndWOFl1R0hrUlpIKzJDYXJ3L0JyeGhsZ3l3cU4zOTcwK2xmYjZYNmtZYS9KR2VnWVovU3BtMUNOSEcyOUczNjFYMU9XM04rQlR4bEZyNEg5NThZeC9CWHhVR3kwMXNPT2hhcGwrQi9pVm1CRnhiZ1l6d1NSWDJWSGVXMG1SOXJCSnp4bm1xMXhmMlVXSCsyTURqQTV3TWlpT0RkL2ovQUFENjNTV3JncmViUGs5L2dqcjBlQ2IyMkE2RE9SL09wVitCK3ZOODMyKzNBSFBQZXZwOXJ5eGtRczEwNTZjRWsxVlRWTktlVWdYVEZoZ1k1clg2bTdmSHR2b1p2RzB1YitIRzNUM2o1dFg0STZveXNXdm9sVWRSak9LZXZ3TzFEcWwvR1FTT05ocjZxZ3U3S1J0aG1Za2RSanRUSmRTMDRBS3NyRHJuazFMd3V2eE5qV0xqYitIRmZObnpRbndIdkVpSmZVNHdQUXFjMHovaFE4MFpHN1U0OEVaeUZ6WDB0SHFObVhJVjVId3VUMTRINDFUWFV0TkQ1RHZnK3hweHdkdnRoOWJwMjBwcC9Obno5L3dwSndpc2RUQkxBOGJlQlZyL0FJVVpIaHBEcmliVjdiT3A5cTk4WFZkUDgwOHNlT1J6VFA3YTB4VGdMSURucmlqNnFrL2pNUHJkUFc5TmZlendOUGdkYUFiNU5hSUI1d0VISDUxTWZnbHBVaWNhNDZuMEVZSkdlK0s5NVRWOU5mS2xXSXdTQWZhcWk2dnBSSkFFaUFqazRBNitsYkxDcC9hWnA5YWhweXdpL3ZQRTRmZ3JveXI4K3RURW5IL0xNRDhjMVFmNE42U1ptWCsxWjNVTjJRY2l2ZFA3WDB4ZWhkcWRIckZpcjVDTjkzbmpqODZIZzRxL3ZNaDRwNmZ1NG5pa1h3WDB0MjV2NWNkaGdBNEZhMy9DbTlDUlBsMUdVdG5uQUg1VjYvOEEycGFiQktFM0hCNEJ3Umo2MVFnMTJ3Yk8yQ1FrblA0MWw5VWplL016Vll2YjNJcTU1SVBoQm9lOXM2aFArbmVrZjRTZUhneXI5cm1PZW9HQitOZTNYR29yREl5eTJzaWtBWkhIZXNOOWQwNk56dXRuQkE3NFBCcTQ0YUQ2dC9NeGxpWktUOXhiOWp6QmZnNzRjTGNhbk9pa0huYUR6U1hId2g4Tkt5bE5WbHdCZzRUayt2WHBYcVMrSXRQS2piQTU2ZWxLZGZzTnVURVJudGtaK2xQNnJHKzdGOWJhdmFNZld4NWEzd2U4UEhCL3RhWkNEa3FWSEkvQ3EwM3dpMExCQzM4NjQ2azRJWWVsZXNEVzlQSnliZHhrRVlKQk5USnJWbUFRMExZd0R0OU0wL3E2N3NheGNudW8vY2VVVzN3aThPbEdEYWxNeHh4aFJtbjNQd244T3dyaE5UazM1SFVBajZWNnUrcldnTzVGSkREZ2pINjFoSFU3TUZTMFB5NTVJWUUvbFMrcVJidnpNS21Mc3JLRWIraHd5ZkNmUUhVS2RTa1ZpT3E0eCtOUXQ4STlEOHRzNm5MdXdkdVVCR2ZRMTZJZFVzNDVGS29TcmVuV3B6cmVubVRidGNZOXV0UDZwSG8yUjljNk9NVHkrUDRUNlVGYi9USkFRTWtFaW9oOEt0TUxiVGVTS09DRDFOZXhDK3RKRWR1VjZlNStocDczMXFJVmRkeEgxeFFzTkcrN1JQMXQ5RWp4UC9oVk9pNE9kU2xIellCSzVCeDdWYTB6NGZmRGFMV0Z0dGQ4UkxZUnl4TTBNc3JDSlhZZndoanhudnpYcDArcFdzY1c3eW13U2NFZDZ3dFJoOFA2cEVndTdSWmxBQnc2QmdEK09lYWl0ZzVTcHRSblp2cUVNWmFlc1kvTk4vaGRIaDQ4RmVITDBYRW1uYWs4OW9KcFVpbUM4U0toeHVYUFk5cXlMblFQaGEyazJJdFBFbm5hdFBlZlozc1FQM2lBZFhJN0FlcHI2Uyt5YVpiMjhjY08wS09pcVJnRHArQXJtYkhTUEQ0dlh1SWJLTVRrRW1YeXh1WUw3OWF3bGdaTlU3VkVyUDN2TTFwNDNsYzFLSE5kYVdXMzRubWRqOEY1Tkt2WkwyNTFaWGl2OXJSS0V3eUJPUG05NnV5L0RleGxWbi90SERCemhkdkp6M3I2TjFXK2FmU3RKVXhGVlFNRVk0NXlhNHk0dWJTRGI1aEdkM1FmenJhR0RqYnp1K3BOWEhTNXZoVnJSNmVSNDlIOEs3ZVZEdDFOVUJIY2M4ZHFZdndpa2NydTFlTEo2QUxYdU1OeHAwc2VTd3lEZ2pHRHpTVGFwb3lNcGFVanFDY1ZwOVRUN2t4eGRvM2FUK1o0WS93ZGxBK1hWWUNldWNZclBYNFFYQkRFNnBGK1dCWDBaSmM2WGdBczJTUGw0NjFXbHVkTkRLTnh5TS9wVFdEaTkyeVpZeDMwakZmTStlSmZoRmRvbVYxSzNKYmpBeVQrTlpyZkNQVlVCSXZvSElJNzQ2MTlPMjh1bHNXQzNLakg4UFN0SGRZRXFQT0I5am5OSDFTSzZzcFl4dEwzWW55d1BoSHJDYkNieTNKUG9lbFJTL0IveEJzSlc0dDh0Zzh0WDF0dXRWVVltQUEvSEZPY1JGbC9mQW5qbjB6V2F3c2I3bW4xclQ0Rjk1OFp0OEhQRXFzNnM4QXdCMGFzaVg0VGVLY0VyR2pESVhnOFY5cnROQXBZZmFEbGVEM0ZWbXVZM0l4ZTQ2OGM0UHZWZlU3OVNQcmEyNWJmUC9NK0xXK0VuaXZkankxQkE1RzhkL1dxRW53cDhWQWNSUjQvM3dhKzRrbVF2cyswamNRTTg5UlUrWVVITXlqNXFuNmluMVkzakhiU0tzZm45L3dySHhXaWt0YUJobkhCcXRMOE9QRmNYQzJySHVlbkFyOURsbWprMnI5cVRhcE9Ca0NvM0NGaXd1RVliY2RRYUZndThnK3VSNlIvRS9PZi9oQWZFN1ovMEIySTZkS3BUZUNQRUNrQTZmS1NUd2NWK2ppUWhwTm9rQk9Na0E5S3J2YnNyN2hJcEI0NjlCUytvNi9FeHZIWFdrUHhQenJQZy9Xb2dOMWhJVDZZeldkSjRYMWhVYk5sSnVBNEczSnI5SVk3T05teUNwSlBjMWROcUVYZ0FlMVI5VGQvaU5vNHg4dnc2SDVYZjJGcUpVajdGSUc3Z29mMXFxK2hYY2JFRzJrSnh4bFNLL1VkN1RkSUNWUnVPM2VxNjJHWEt0RXJESEdWeWFyNmkvNWpPR01wODN3UGZ1ZmxvZE5uVXRtMmNBZjdKNjFaajA5c1pFYmpua25QNlYrbjF4cFFjSm1GQUJ4eW9HUlZhVFJVZFFUYnhFOUNkb3hXZjFLYiswamY2M1R2cEdSK1p5d1RwTXVHa1gzR2F5STRMMTNEbVZ6ODU2RS8xcjlQVjhQMm0vSnRJam5qN2dyQm04TFdUejUreXBrOEFiUUtQcVZUK1lKWTJrdnN0bjU1djlyQjIrWTRiY2NIZGtnQ3E3M0dxUnYvQU1mTWhIKzlYNkVQNFAwdHNCckdKdjhBZ1BOVlovQ0hoOG9tZFBRTUJ5Y2RxajZuWHZ2Y2xZbWcwK2FLUzgxYy9QcHRVMW9kTHlYcnh6MHFMKzI5Zlg3dDgrT3dyN3kvNFFUdzg0SlhUanR6MTVySHVQaHo0ZVk4V1pVZXhOVjlXeEtlai9FeVdJd2QvZ1gvQUlDZkZ5K0pQRWlNbysyTVQyQjcxSW5pN3hTRHhkWjU5Syt1NVBobG9HUXl4T0NQVTVySGsrRitoaDl3a2x6OWFwVWNZdG0vdktjc0E5MURYKzZmTWJlTmZFUUIvZUx3Y0RqclZ0UGlCNGxDaFNWSXpYdTgzd3EweHp4Y1RLYzlzRVZudjhJNE1raTliMDVGUGx4L2VYM2o1Y3M2eGhmMFBINC9pTHJpTU1vcDk2dmo0bmFrcTUremc4OWlhNzJiNFVUWStXNlVmZ2F3cm40WDMwWkcyNVZzL3dDeWFkOHhYV1JnNkdWU2QzQ0srOUdPUGlwZG93SXRqbkdmdkVWcXI4WUxsNHp2Z1laNEFVa1lyS3UvaGRyQlFNc2lIaXVjbCtHM2lGZnVxakE5d2FmMWpIcitiN2dXQnk2ZTFsLzI5WTdxUDR0SXB5R2xCQTljMXN4ZkZ5UEJCbW14M3p6WGljdmdEWG95UDNBK3VmMXBHOEVhMGlrbTFZKzROTDY3amx2Ry9yRXRaWmx6KzAvbEkrZ0lQaTNiU01wZTZiNVR4a0FWMDBueFpzSlk4ZmJWT1J4dVFaelh5VWZCK3NLYy9ZWDVQWEZZZHo0ZTFOWk1tMGZyMENrNW8rdllodE54VjE1RS93Qmw0Uk5xTlNTVDdTUjlteC9FelRSa21lRWs5aUsyRStJOWhJUnpDVHh4dXI0Q2JSYmxIK2Eza0EvM1RWV1N3azNzY011T25XdFA3U3JkWVJabC9aRkZmRFZtdlhVL1FYL2hPZE5ra0pLUjlmNzliQjhXNlUyRHNYOEdHQlg1cnl4WEtEQkwrM0p6VEExNnUwck81R1BVMVN6T1MzcHI3dy9zYi9wODIvTkg2V3grSmRISTUzZk4wSUlOYUM2OW8yMFlMSDZqbXZ6RisyYWdpZ0xPNDQ5YWtHdTZ5aEsvYVhJR0syV2FSUzFwZmljN3lhdmU2clIrNDZHNytJdC9JV0VDYlIycmpMdnhIck55bnpYREFIME5kVnAvZ2k3a01ZS05rKzJCWHFsbjhQU1ZHK05WNTV6elhucW5tRmJkeS9JOTZWWExNT3RPWDgyZk5NWXU1MjZTUDY1TmROQm9WL0pqRWVNblBOZldsdDRQMFMxVU5MTXYweU8xYVVsNTRic2hsUXBJL0hpdXlubHZXcFZVZm1jRlhObzJTcFUyN256WlkrQ2J1Umd4Skdld0ZlZzJudzdJWUV4Z2dkU3hyc2JueDdwVnVQM2FwbnNLNHErK0prbTF2TGpMWjZZNHhXM3Nzc3BPOHFqbDZIRkxFNXZXVnFkRlE4M2M5RXRQQWNLN1MyeFFPdnJpdW1Ha2FMYUQ1blU0ejFPSytWYnZ4N3E4N2pZV0M5T3RZTnpybXJYQ0VHWS9oVkxIWUtDOXlqZjFSajlTelNvdmZ4Q1Q4bWZZajZwb1Z2bkpVL2hXUko0NDBTRnZsMjR6M05mR3JtN2xJTFN5Tm50elZxMzBxNWtLNGhaaDdqbXMvd0MxYXorR25GZkkxcDVMVDNxVnB5WjlIM2Z4VGlTUWlGTTg5YTVPNCtKV3B5RUJGSzU2bnBYQVcrZ2FpNmtDQWdrK2xkREg0SjFlWS9keGo4OFZnOFhqNTNzNWZKSFpITDh1cDZ1M3prVkp2Rm11U3QvckRnOXlldFpjdW82bzZBdGNuazhnVjZQYmZEdlVEdExIcjYvMHJ2N1Q0Y3dwR2ZNYkpQUE5SOVd4OVJhODN6Wkx4T1dVWldYSjhsYythaEpLN2ZQS3pmalVzZGhJU1NVWTQ2OS94cjYrdFBBK25SSERLT08vRmRETDRhMGtRbE55QUVZem5GYWYyWGlHdFdreVpaM2hJV3NwTmVTUGpzYU5jcHA4ZC81QmEyZmR0a3dNSFljTmo2VjExbDRXbm5TM21nZFBMa1JaQWM1NGI2VjY5YStGUERXbTJGeGJmYVpKSVpYY3NqdVdBM2RRUFFWMG1rWFBodlFkTWEyZ3RZeEc0SGx5YnNrQUhvUFNzSTVaVlRpNms0cFBlejFSMXJPcUVuVVZLTW0xYTExdWp6RStESFpQOWFmd0ZiVm44UHhJM080a0R2eFhXdDQzMGhjNFZCZzlEVktYNG42ZkN1RVpSL3VyblB0WHBMRFlDQzFtbjh6eHBZck1wdHBVbmJ1a1c0dmh6Q3BHWS9ybm11Z3QvQWRpbldKUmoycnk2NStLKzlXQ05KK0F4MHJsTGo0ajZqSXVWaGtPZjRpYXVOVExZSjZKL0s0bkhOSnBKS1M3NnBIMDdINFYwMk5lcURBempnVWo2YnBjSTRtanpubm12a2gvSGV1TUR0Q2o2OWF3N254SnJzeDVuQXoweFRXUHdrZHFkL2tZMU11ektkcjFyTHF1Wi9vZmJpUzZKR0R1bFhJOUFUVHY3YTBTRW5MQTU3SEhGZkJRMUxWblAvSDB4UGNBMVNsZTljZk5NNTU1NXhXTHpXRjlLVCs4My9zYW80Znhmd1AwQi80U25SMEFLYkR3ZjRoV2JKNCsweUVrbDR1TythK0RJNExwMHdRNUdlUnpXeW1uWFRGUjluY2o2VmpMTTZyZWxOTDhUV25rOElyM3FzdnVzZll6L0ZIVEk0emgxNkhvbitOY3UzeFdRbkNTdU1uMHJ3KzE4T2FqY1JOaTNiZzhaclFYd1hyRGRJUXZzVFVMR1l2cEZmY2REeTdDTGVUK2JQUjMrS1Z5ek1GODRqSFVIRlZwZmlKcUR4Z3JBNUlHQ1MxWmx0NEh2QzRMTWdIY1lKcm9yYndEY2xHRFRua0RHRjZWRHJaaExvL3VRNDRmSzQzdlp2emsyY2RONDExbWJCRWFwOVRtczV2RSt2dHVHNVFQYitkZXRSZkRtSmdBN3lOejFIRmIwZnc2MDVTY3JLMlBVMVZzZTFyS1gza3FXVXhmd1F2M3RjK2VtMXZYU1QvcGhYNkRpcWYydlZKRklhOWNnZCtsZlYxdjRCMG9ZLzBaajM1T2E2Q0R3WllMa0MwVDhSVS9Wc1UvdFA3ek40akF4ZWtZL0tKOFdwRmR1eEJubWJJSFJqVUxXY3pPQmlWdWVoelgzbkY0VGhRNVdDTVk2L0tLMGs4TlFySXA4cFBVY1Z1c0JWa3RYcVp2TXFhZGxCL2tmbnpKb040ZitYV1JoOU0xTkY0WDFGZ0Q5amZrOEFpdjBOYlFyYmtsa1U5Y1pBSDFxb05Fc2xZTXpEQVBYdFVTeTJYOHgxUXpWYUpRYlBoaGZDV3FmS0RhZ0VqZ25qTldvZkJXck56NWFMOVRtdnUrVFNiUlJFcFhKYjd1VlBQMHJhWHdycVh5N2RKdXoyQkVEZGZUcFhKTEw0TGVva2VoSEhWbkxTaTM2SzU4RlcvZ0RVM2tDNzQxSjZaL3hyc1l2aGplN1Y4MjRSY3RnYlJ1NjE5cVcvZ2Z4Sk1QTWkwVzZLQS9lS2JlbjFycVkvaDU0cGVMY21reUhhMkNwWUEvVVo3Vnh5d3VGVjFMRVFYL0FHOGowb1Y4YkxWWVdvLyszR2ZGRWZ3bkpUWTkyd2N2eGxNWUZkUGFmQ3Z3MmtmbHozYy9tQWtmS2dLL25YMnhiL0M3eGVmT1piU0JHVURhSkplRCtJeldIcDN3eCtKZjIrVmI2UFNSQ1dKVjRKSEpYMHprYzE1MDZlWFFjYjRoTlBiVzUzMDNtazFML1pXckxaci9BRFBuSFRmaE40TFFCN3U0dUZ5cDZIZ25zUHhxQmZocjRkTWk3WW5aVGtsU1NPUHFLOXorSmtkcjRMdWZEY0dwVEt5NnJNeVJ5UnFRSW1RWnc1UFkrdFo5OXFtbVJvcGcxQzFsMzUrVlpGeWhIcjdWM1F3bUZsR01sUG1YcWViVXgyTHB6bEdVVkJyZlJIQzZkOFB2Q2R1OGhleFVrakFCTzhmaUt1TjRLOEt1Q0hzQWh4OGpJb3dEN2owcnFCcldod3hRSCswVk1qSXhsSXhnRWVtZlN1UlBqUFJsbEpmVll3QWZ2RUE4L1Qwcm9XR3d5ZXlPR3BqTVZLU3MzOGlrbmhUUm9DQ2xqRzdCd2N0R0s2RmZENlRJbyt6UW9BeElDUmdZelhsR28vRW13anVwNGt2aEpsZ0k5bzR4NzFGRDhTb0ZWZzAwdkF6OTAvMHIwWVF3YTdIbjFLK05iMDVqM3ROQWpBT2RvMmpqaXRGZEpqQ0xoRjZkYzE4enlmRkMwNStlZHY4QWdKRlVEOFNvM1g1WUorUjA1cnBqVXdrZWtmdU9SckZQcFA3N0gxdWxoQ0FNdWc0cS93Q1JicVA5YW52eUsrSm0rSWN3eml3bFk1L3ZWVWsrSTErMjRMcC9CNE9XNXEvYjRkN1A4Q1ZUeFMreTM4ejdhWmJBNEJtVTQ5eFVxeWFkR1A4QVhwMTlSWHdzZkh1c2xncVdpQUFjSE5WSDhiYTZ1RDVVUXlQWDNwUEU0ZExkdjVCN0RFeTE1VXZtZmZ3djlJNTNYR0Q2ZXROT3BhT0VPWkh6ajN4WDU5UDQ1OFRFSGI1UUdldUtweWVOZkZEWjIzU0Q4UDhBR3ViNjNRN002VmhLOWxacjVuNkZmMnRwbUZBWWs5T2xWcE5mMDVXd0ZjbjZWK2RjbmlmeEd4R2I3R2U2amlzOXRkMThrSCswbmJuOUtuNjdUL2taazhMaU9aZTlFL1NQL2hKZFBCSDdpVFA1VlVrOFgyYThDMFkraDNBVitkWDlyYXU0TEhVWjhkeDYrOVVKTDdVSkFjWGM1OTg4R2tzYlRiMHB2N3pxK28xZitmcVh5UDBnUGpDMnhuN0lCem5HOENxcy9qYTNqSUhsUnFjWjVjY1YrY1grbHNvQm5uUEdjNzZoTVV4NnRLMzFZOFZNc1lsdFQvRVgxV1NYOFRYdlkvUlp2SGNLODVnNUdRQzlScjQ3aEl5SjRBUmtZM0N2endXemY3eGpsYkk0eVR6K1ZYWXROdUdPQmF5a25Cemh2eXJGNDYrMEVhUXdjcjNkUnY1ZjhFKys1ZmlIR3FjM05zTWZqV2RQOFJyUkZqLzRtTnVTZWVPMWZFTGFGcUw1L3dCQ25JN1lRNUZXazhKNnNmbUdtVDl2K1daTlpyR1N2cENKVWNHMjlaU1o5ZlQvQUJNdEJMa2FwRTIwOVFLcTNIeFUwMEgvQUpDWVlIQndBT3RmS1VmZzd4QThvWmRLdU9oNEVaRmFhK0EvRVo2YVBPQ0QwMkNtOGJVdDhNZnVObGwwZTg5VDZIUHhQdGNsaHFMNEl3QUJWYWI0bTJPMS93RFRaZHhHQmoxcnhhMytIdmk1eVF1a3lnZXBGZERGOE9QRlJCRGFjUVNPK0tYMXl1L3NyN2laWmRCS3pjanVCOFROTFdJYjdtY3YzSVBXcytmNGs2Y1RFY1RNQ2M1T2VjZTljNnZ3dThVTkdEOWtYbk9Nc0tZZmhSNHlJQkZzdU1nakwxRHhlSWIyL0Eyamw5QkxkL2VqVXVQaVZhR1ZTR3VGN1lCNHA3L0ZEVDMyaFlwbXdNSEJ4VlVmQ0x4YytNUnduMkRjbXBiTDRPZUtaaktCSEVwWHFTYXA0bkVXV3Y0R1N3ZERtYnR1KzQ1ZmlYWjRDaTF1RGduQXpVYzN4TFFvQXRuSURqMTVyWUh3WThTTEkyNldGVHR3UG03MXBRZkJEeEU0M05kVzRCSGRxbVdJeFBmOERkWVdrOU4vbWNtUGlNeFFBV09lZTdkYWIvd3NlN1ViUlpqYUQwQjcxMzhQd1MxTmhocjZFRUhvS3NMOEZyd1p6cVVJSWJCeUtqMjJJdmU3SmxoYVN0cHA2bm5LZkVuVTQyWXBacmpCSEo0NXFuSDhUdFpoYjViS0hrSEpKejFyMklmQkJsWlk1TllpRzQ1eUJuSHNjVmJId0t0Um5PdHhrRDBYbWxLdGlMYU4vY1RIRFVsSzFsODJlSk44VE5iS0JWZ2g5Y2dZSXpVWStJM2lKRWJaNVdHNFBldmQ0L2dicGpFci93QUpBTjRIM1FuK05SajRJYVZ0TzdXWERCc1kyZGFJMU1RK3NqcGRERHBmWis4OERYNGcrSXdRUUlUeDI0TlVwUEhmaVoyNGVQSjY1NUEvQ3ZwTC9oU09qeGtBNjA1emprSUFEN1ZNM3dZMEJGSkdxekZ1NENnMWZQWDd5SWRDamF6NUhienVmTnkrT2ZFd3R0bm54QmNra1k1ejYvU3M4ZU5QRVN1V0Z4R0dQUFR2WDFFUGc3NFhLWmJWSldiR1NNQUVWWUh3YjhKallUcWtwejB4ZzBKNGhQN1NSQ3crRy82ZCtSOHUyM3hCOFcyMG5tcmNvV3dRZHk3aHo5YXBTK09mRXJrTWIwWjVIM2VsZlhnK0VYZ2tGeWIyNFBIcUFCaWtYNFIrQ2hJRDlvbks5K2MvU3JmdDMwa0hzOE12dFErOCtQMzhZK0o5by80bUhYb1RTRHhoNHIya0RVc0gwQXI3SWsrRWZnVGZ1bGVkZ09oRGQvb0tRZkNud1VyWUlrZFQvRnY3MGtzUS93Q1l5OWpoNHkwY0Q0N1R4VDRrQzdqcWVHM1k0RlZsOFMrSkhsR2RTWWs5anpYMjRQaGY0Q0FIeVRISFg1alFudzA4RHE2c2x2TGdkZHpFMGN0ZnRJMGRPaC9OVFBoMlhYZkVBWnYrSm14NmRzVkYvYnV1c20zKzFHSFBjYzE5eEg0YitBdk56OWtuYnJ3V09LWWZodDRJM1oreHlmUXNlQld0c1FsOXI3ekdOUENxVi9jKzQrSVJyT3Vjaiswbk9mMXFOdGIxcy84QU1Ra0hxZXRmY2NmZ0R3T3NpaHRLYm9jZk1UVmsrQmZBYVlIOWt1U3cvdkhnMVBKWDdTZnpOYllWN3loOXg4SFNhM3JyS3FuVlppQURnWnA2NnByaWphTlNsRmZlSytCZkJSNmFRRG5qa21ycWVCdkJnWWc2Vm5IR2VhWExYdmYzdnZDU3dyMmNmdVBnZWJYZGZkZGpheFB0QXdQbXlLcGYyanEyVGpVNVNmYzVyOUJwUEF2Z2dxMk5KSlBHU2Y2QVUxZkIzZ1ZWeC9ZcFk4WlBJRlZ5VjMwZjNndnEwZnRSKzQrQmY3VDFraFMyb3k4ZE9hcmYybHEyVy8wK1E1NlpOZm9JUEJmZ2dIblJpU08rU0IrTklmQTNnaHZtL3NqR09nM0h0NlV1U3QyZjNrdDRWNlhqOXgrZnNlcDZzRHpmekRIZlBUNlZLZFIxa25JMUdZNTZuZG5OZmZROEUrRGp1eHBHM0hiY1NNaW8xOEUrRERrLzJQdEdmVTgwdVN0NS9lSExRdHZIN2o0SC90UFdWWEIxQ1k4OC9XcGZ0K3NPd0gyK1RBL0N2MENYd1o0RzNFLzJVdzQrWVpJQitsVTI4RytDV1pkbW1xT1NDR1k1bzVLM1ovZVFsaDA5SnhmeVBndDd6Vk51UHQwaC9IcDlLcmYybnJJUC9JUWx4bjFyOUFsOEZlRE52emFiODNiQk9Lb3llQnZCL203aFlZeDFHVDBwS05icy92TjVPaW9wdmwrNCtHMTFUV1YzQVg4dkk1R2VLQnFldUt3MjZoS00va0srNTVmQkhndzhwWXV1UWNET2VhcmY4SVY0WDhyYTlpeEo5eUtVWVZ1eis4YmxobjI5Ykh3My9iSGlBNUg5cFM0UDlLcHRydXZLdURmdmdlbmV2dUdYd0w0UitYL1FaQUIvZGM4MWlSM0hnVHdycmNiNm40VHU3K3dualpTOXRINXp4U2RpVUpCSVB0MHJPdkt0VHBPWExLVnVpM0ZTaGg2bFJSYmlrK3RybnhZK3Y2L3QrWFVINTRJOWFpaDEvd0FScWpoTlFjTjNPYSt0Tkc4TTZCZjJrdDNQbzdRR1NXUjQ0UzVES2hQeUI4ZDhkYWZyR3FmRDNVOU1zZEowL3dBRzMxdnE2WEtyUEkwZUlFaVU4djVnNGJJNkRyWEhWclZvK3l0R2I1MmxwME9xalFvU1ZSODBGeUs5cmJuekxZK0ovRkVxU1JOcURzSUdBVUgrRXR5Y1ZldU5VMXlVTHV1eTNQQk5mUldtK0FkRnRMclVYZTBrQ3l5aG84c1NNWXhXNGZCZmg1b3Y5VktDVHh6MnJwcHhydGJ2ZnVZMVZoNHkrR095Nkh5UStzZUlFQjIzZWVhYko0ajhRb21Gdk1ubnFNOEhyWDF6SDhQL0FBeTdqZkhKbnFUbXBtK0czaEozWGNzcStvM1ZweVlwUGQvZWN6K3JTVzBFdlErUTI4UmVJbTJocjRzRkhIYW8vd0RoSmRmUmlSY2pwem5yelgxMUw4TWZDR0RocDhFLzN1UldlUGhiNFh5Q1paOEU0Skp6Z1pyWC9hTzh2dkNNY0lub29mY2ZKNitKL0VDU0VyY0x6N2NWY1BqcnhaakF1MHdPZ0FyNm11UGhYNFQ4MWxqbW1LOUEyZXRaMG53ajhObk9MdVkvVEhBL3JRbzRqdS92QkxEYTM1ZEQ1c2o4Y2VMR0RCcm9FSGsrNXFVL0VUeFlzZUJLckRwZzllSytsRitFdWdqWWZ0c2d6eDBwcmZDRHcrY2JkU2xVWndmbEZWeTRqdXlIREQ5VkUrYWwrSS9pWEJVbVBCSElxekI4U1BFa01UeGZ1MmpQSkdQNVY3OU44SU5HUHlwcU1neHlHS0Rtc3h2aEhwZTNBMVdUSjRIN3ZQNFVXeFZ1b1JwNGE5L2QrODhadC9pRnJMUHpDZzQ5Yy9oVm1iNGphMnNYRnNoSUlPRFhyUitEOW83N2wxUlI3RlBUcFZlZjRQS3BVRFdGY0hKd0UvbWFhbGlsMWtXNldGYTJqOTU0NUg4VE5ZWGdXaVp5VDA3bnJqMnBFK0plb2p6QWJRRU4xSHFhOVBrK0RlQWNhbWg1eDA2Vm5QOEFCMjdWc0RVWVFRT3BCR2ZwVk9waWx0Zjdnamg4TGF6Uys4ODdUNGxYNnZrMmJESTRLbkZhYS9GQ2RNNXRuSllZeG5vYTNadmhCcktxcWZib1cyOGpyMzlLb0o4SnRaTzRDNmlJSHFlRFQ5cmk5N3Y3akpZYkJMcWw4eWhGOFMyMzVlM2xIcmc0cTFGOFVSR1QrN21HNzF5ZWxTLzhLdDFyWWNUUTllM1dzcTQrR2ZpRkJ0VXhzZTN6ZXRTOFJpL1A3aWxoTUxyMC93QzNqWmorS3RzcER0SEtSMXhrOWFlL3hWdDVKRVBteXB6a2pucFhKeS9EVHhRdVAzS25CeVFHRlpSK0hQaWd5c2ZzZkdNOVJWL1dzVWxxdndNZnFHRWQ3U2wvNEVldVJmRnF3US9OY1M5Ty9PYXVyOFdMRnMvNmF5akk1cnd4L0FQaU9MNzFneE9leEhOUkh3UDRnV01rYWVSMnhpcy9yZUlYVDhEUllDaHA3OGw4ejNxUDRwMnF2L3g5WlhJSXpqcFdvL3hSc0hmQzNhL2pqaXZsdC9DdXRBTVRwemc5aGlvRThMYXI1U2x0T2NIM1hGTjQ2djFpbDhqUllDaGF5bS92UHJxSDRsMlFJSnZZeU00SXg4MzRVKzgrSXRxN2p5cFltR09yOGMvU3ZqWi9EMm9uNzFqSU1ISk9LZ3V0SHVzZ216Y1lHU2NIbXFqbUZSZllpekY1ZEdTc3E4bDl4OXVXUHhBaGJDdk5iZGVmbXhuTlc1UGlIWmxtQ3JDY0hydjY0cjg4ell5bklOdTRPTThBMVNObk1wSEVnL0U4VnIvYUVyNjAwWVN5eHEzTFdsODFjL1NFZU9MSnlQM1VURS8zWHFLUHhqcGpsaVlSeDZNSy9PR2Exa1J2OWJJRGprQmlEVmRmdFl6aTRrK200MXNzeGR0YWY0aS9zNmQwL2EvZ2ZwcEg0dTBVa2JvV3huSnhnMU9mRTJpa2s3V0FQb0JYNW1OY2FnQXVMeVZCei9GVFcxUFZJOEFYc3VQcjFxVm1LdjhBdy94SmVXVnJPOVZmY2ZwaS9pSFEyM2ZNd0gwcDBlcytIblhMVE1GSTlPYzErWnphMXJLNEgyMStldWF2ZjhKQnJjWlhGME1CYXIrMG9QVGtmM25Pc3N4TjIxVWhienVmcFQvYW5oMlFBcmQ3ZnFPbE5lYlEyeUZ1azR4MngvT3Z6WWJ4VnIwYmNUS1Q5T3RQL3dDRTAxOEVrc3B6VnJNYVA4c2lsbDJMczd1SHl1Zm9za2VsUHd0eEV4T2VjMVorejZZY2dUUmsvVVYrY2llUE5aVE9Ja0ordFhrK0lGK28rYTJVbnBrRTFvOHdvUGRNeFdYWTdXeWo5NStoY3VtV1pKS3RIakhPQ0t4STlEV1RDZ29lT09hK0lVK0lsMXQrYTJiMDYxZlB4R21VL0xFNm51QXhweHgrRDdmZ1pWTXZ6RnRPMjNSU1BzVnZEVWVUdVZjNTY5ZWxWNWZDZHRuSmpUSTZFcjFyNVBUNG9uYURJWndSd01FOFZxTDhXdmxVRzRtd1BXcStzWU4vYVgzRHA0Ykh3ZnZVNVA1M1BmNS9DZG95dVBJVHB3Tm9OWVQrQ2RLMkF2WnB4MzIxNVdQaW5iNTNmYW55VDNIV3RXUDRySzVBKzBnQWRpb3hWcWVYeVd2SU9VTXpqSzZVN2VSMDB2dzcwdVZpVXNWeURrNHJtNXZocnBUUGsybjVFaXRXSDRueGpJRThXVy9DcngrSjBCNnlRakh2U1VNRTl1VUhWeHNVcnVxdlUrZUx6NG5Xc0F4YndyOVNNbXZQNzM0ajZ6Y3NkbVU5czRGZWNXbWhYMHJqRUovS3ZSTER3SnFFekRLRWYwcnhmYjQrcTdSNXRlaVI5SDlVeTZqSDNrdE4zSm5NUytJdFZ1Q044djVHcVVrOTFLZm1lUnUySytoTEQ0YXRrYnlvSXgxcjBPRHdqbzl0eEtRMlBvTTF0REw4Wk8vTnA2c3hubVdYd1ZvTk8zU0tQanlMVDd1WmdFZ0o5OFYxZHY0VTFPWUQ1U00xOWFMRjRldGNmSW9xQ1h4Vm9GbU9DZy9FY1YxZjJiUmlyenJwSG5mMnZYYnRERHQ5andTejhBYWkyM2VtQjM1eFhwZGw4UHJkVkc4NHdPbUtsdlBpWnBTREVXRDZFRE5jVGUvRXVlUlNxSzU5TzFheGhsdE9ObStabk82bWMxWDdzVkJIcmNIaEhUWXNBNHdEK2Ric2VtYUhiZ0hLOEN2a2lmeHZyY2dPQnQ1N21zeHRmMXFUY1RjRUVqdDZVTEg0U20xeVVkalo1WmphaWJxMTkrelBzdGRUME8yemtwL2hXWEo0dzBlRXMyNVQrdGZGVHlYTXJjenV4Njlhc0N5dVd4dGdjODhWblBONmowalNpZ2hrTkd5YzYwbmI1SDFUYy9FeXlHVlVyZ2VnNXJpcmo0blhUS3dSR0l6d1FNR3ZINE5GMUZwT0lBUHJYV3crRjlRa2pPU0IwNkROYzMxM0hUK0ZOZWlPeFpYZ1kvRXIrck5GL0htc3k1Mng0UDFySm04VWE5SUNQTUM1cmZ0ZkJWMjdESmJKUFlWdjN2Z2k2aXNwbWlpWnBBaDJqT09hbHh6Q2FiYm5vamFNY3FwV1NWSk4ralBIbnY4QVdMaHNOTzV5RGp0eVBTcmtkdmV5SURKTzdZT052cFhzVGVIOVQxRHd2YmJOTkZ0ZkpFRkpMZjZ4d2Z2SEhUTmV3K0gvQUE0SjdCbnZXaVM2UUlyS2dHM09PZWE0bGhzVE5xOFpwUHF6c1dKd3NWTlJjTHAyc3JIeVNkS3VqOHdqZHNuaml0S0R3N3FjaHg5bS9FakhXdnN0ZEhzVjZ5SUFENmlyYVcraFJBbVc1UTRQQXp6WHFReXA2WG5aSGoxTTJTZkw3TStPUjRVMWduTzFWOU85ZEhCNE12M1B6U2dBalBBenpYMDQrb2VISXh3KzdIb0tCNG44UHhES3c5T3BKRmQzOW1ZZU1kWnY3eno1WnZXVHRHbXZ4UEFMZndDNVVicEpHNTlNVjBzSHc5dGpqNUdZanVUWG9jL2pyUjRoeEdnR2M4dDEvS3VjdXZpaFpJMkl6Q3A3OTZuNnRnSTd6WDNtYXgyWjFkRlRhODdXSkxmd0JhSzNOcXZKNzVycVlmQnR1cUUvWjFHVC9kRmVjemZGU0xPUk55UFFWejh2eFB1Q3d3OHJLZmJGSE5sMEgwWlNobXM0Njh5K2RqMzJMd3RBcmZLaWp1Y2dDdGROQXRsWUVzZzV5ZVJYeWxjL0VXOWt3QkMrTWMvTmlzZVR4dHF6Y0lneGp1YXI2NWdvN1IvQWlPQ3pKdjNxbW4rSSszMXRkSWdRaHBJaGs5TTFkU1R3OUdNdmNKOUFNbXZnNCtKTmJtVVo4dFNCVUw2NXJCeHV1UU9NY0NzM21GQmJRbCtCMFBLc1hQWDJzWDVPNTk3bld2RGNZUHpzY2VpME40ajBhT01GVXlQVTRGZm40TDdVMlU1dkhOSjVseTQ1dTVXT09PYXgvdEtDMnB2N3lxZVV0UDNxaStTUHZaL0cyblJnRVJKOVN3ckxsOGZXZzNmNmxlTzdWOEtMQTh1M0xUTWZjbXI2YVRPK01Xa3pISFhCNUZTOHdtMXBCR3p5cW1wWGRWcjVIMkMzeE1nUVo4MkVlL3BXUEo4VTRBZmx1MHgvc3IzcjU0ZzhOMzdaSzJaL0wvR3RtMjhMYXNRZjlEQXgyUHZXYXhtSmIwaCtCY3NEaEV0YWo5ZVk5WWI0b3ErUXM4amZSZlNzMlQ0a3pNeEFTNGY2Y1lyblkvQitxTnVIbG9PTTV6M3JRajhHNnNyS1RJaWpQSTYxdDlaeGoremI1R0t3ZVhyVnliOVpINk4vQVdDeThSK0VMeTd2dE9qazIzN29ubXJ1STJxTzU3ZTFmWVZ2cGVrMjlxMXZIWXdMR3h5VkVZeFhnSDdPdWtTMlB3K21qZGxaanFNN0VqM0FyNmVsaXdlbGZsR1pZckVMRzExS2N2amVsOUQ5eHl2RFliNmpodVNFVis3anJiVjNSUlAyY2hRWWsrWDd2eWpqNlZmRjJ4R0N4T0twR09rRVo3VjQ2eFd1KzU3bjFaV05OTG5EVm9MY3Iwcm45akNnSEJ6MCt0YlJ4Q2ZReWxobGJjNlZya0JXNDdWNGY0MStJSDlnbkVTd2xZWUh1THVTVTRXS0pSeC93SmowcjFiSVpINUhiUE5maEgrMEI4UmJlNzhSZjhJbmYyOTlwVXI2bVA3V3ZTeXVqd25pSjQxSFdNQTV4WGJERVUxTmMxblpYUzdzOWpKY3JwWW5GdU5SKzZrK2wrbTcyLzRjdGZHRDQyNk44VHZodDRhbmcydzZ0WVgxNTlzdFZ5VEVOcEVicVQxVmgrdGZuejltdXJuV0k5a2txL3VFSlpXSU80am5wVWVuNkpxbmdmeC9kYWZxa1JtaGl1bWdta1Vaam1qZmxKVVBjRUVNSyswWXZCMWxhWGNrMGJGbGtBMmtqdDJGZlY0QiswdzNMRjdQWDU5VDg3NGp5MzZsanZheXB5aFRycHlnbjBhc25HL2tmTjZYZmpPd2pLMjk3S3lmODg1azh3Zm1hN3p3dHE5eHE5d3F2WUFPR0t2dEhHNGR4WHRjdWt4aFdCSi9IbXEzd2o4UDIwbDdQS3pZeGN5YzU5Nitrd2VDbE9iNW5va2ZtMk96Q25DS1VWZHU1MFVmaEhVSjVWWVdvQlBRWUZkQi93QUlqcW9LQklvMjR3QVdyNjlUVDlMQ2dsMEFHT1MxUU5GcENzTVNvTWM1QjlLOUpZT2t1NTVUeGxXSyt5MHo0NFBnYlZtQkdFems1T2F2d2ZEdlZHSE0wUVAxTmZWQmswaEdKTTQ1enpVd3ZkR1ZBZC9IMHpWUEJVK3pNSTQybzVhdEh6S3Z3MnZ5TUc2UmZvTTFZaStGajVPNi9IVHN0ZlRhNm5vZ3hnOWZRR21QcmVqcTVBVTR4NlZLd3Nkck02WlkxcGRENS9qK0YxdUFBYjF5ZlhiVnhQaFJwN2tlWmR5SHJuQUF4WHRwOFNhV295RWNqNkNvRzhhMks1eGJ1ZnFSU2VGcHJUOVJ4eDExL3dBQThvVDRTYUZuNXBwejlLMm92aFg0Y1grQ1lrREhKcjBCdkhObWk1RnNmeFlWR1BIOWtVeVk0bEdlOG96V0t3bE5QWmZlZFVNWFB2OEFnY24vQU1LdThLZ3FvdFpUL3dBRFBPSzBvdmh0NFVqWC9qeHlRUnlXT2FqbStKRUVmSSt6YmM4ZnZCMHJNZjRxV29reHZ0Y2VwTlZMRDBWdnkvZVp5eGRXK2lkbi9kT3BIZ1B3dUdHTk1UOGNtcm4vQUFoUGgzSUEweUxiNlk0cnp5WDRuMitGQ3oyNUpQWHZXZEo4V1lSa0M5aEI5a3Bld3d5KzFIN3pQNjFYNlJsOGtlN0o0VDBDTkZLYVBiTHpqbFJ6VmxORTB1UDVVMDJBRGJ5UWcvd3I1NFg0dzJpZ3ExNkg5QnR4V1MzeGZ0eUhQMjE4NDRBWHBXYnBZYS94USs4djYxaUdsYU5UN3JIMVhEcDl0SHQyV2NBd0QvQ0JqNmNWWSt6RUt1TGVJRUhPUXY2VjhaSDRyd2tqTjlPU2V3SDhxUS9GV01zcEUxeDlSM290aEY5cUlvenhiMWNKL2VmY2lReUtXSWpqQkk2NDZmaFVobHVSR2Z1QUhBYklITmZDVC9GT0RxVGROMTVKclBmNG9LM1NDNVBHZnZjVkNsaHI5UHVPbHl4VDZTKzgrNlRKTUdZTE1vSDBGTmRMaG1HYm5CK2d4aXZnVS9FZG1jRVdrL0dmNGpURDhTcDk2U0xwODJCMlo4Zy9XdEhXdzJsbXZ1TWVUR0pYczM4ejlEQkpOa1p1UVQzNkRnVmszTnlwYkQzbkE2WlljVjhETDhSNzlwQ2Y3UEF6MjNrY1ZZbThiMzBycWZzU2o1ZWhZOFZEclliditCcENHSmx2cDh6N3JNMXR0WE42ZzUvdkRGWkwzZHVqRURVQitEMThMZjhBQ2JhdUNjV2tmVHVhcnY0MTFrdU0yOEk0eFVyRTRkZC91TkpVYTdYVDd6NzBGN3AvWDdhTStwWThWSkhmMldIL0FOTjRQZmNjbXZnbytNTloyY0pFTStvelZOZkYrdmduRWtRd080cFJ4TkM5ck13ZUh4TGFhVWRENzdGOXBlN2FMdmVWNE9DY2lvMzFEU0k4TTAvR09PcHI0Ry80U3Z4RGovajRRRTlmbHFWdkZldmJWemNKMDQrV3RaWW1pdG9zbjJHSTB2eUgzdkxxbWl4b0dNN0JXT2VBZXBvVFhkREdRWlhKUGZhVFh3VWZFL2lGNGdwdkNWd1NCakFGUW54RDRoV01GYndaeHpnVmg5Wm8zMVRPcjZ0aVhxbkJLeCtnWDlzNkdneVJKbnJrS2FzRFdOQ2NoVDVuVEk0L25YNTVMcjJ2Yk9iOXdENlZTazEzWHQvL0FDRVpPS0hpNmQ5SXNpT0ZxMjFsRS9TSCszZEdWQXdTUXJuR2RvR2FqbThSNkt1UVlaZTM4STcxK2JLNjFybU1IVXBlL0ZSalZkV0tuT3FUREk1Qk5QNnpEK1ZqZUdxdjdVVWZwSi93bEdrUjRBaWNqSFRpbmY4QUNVYVlWejltZGM4a2NWK1pMYWhmNUIvdE9VK2czWTVxR2EvdnVBZFNtUFRqZFV2RXc2US9FZjFlczFwVVMrUittYStMZEtLbk51U1FlT21UVEg4WmFXZzNmWkhCUDAvU3Z6SCsxemJnZjdSbkhQOEFmcXdidHlDR3ZwVC9BTFcva1VuaW9yN0g0a3JEVlc5YW40SDZSUWVMdE9KWnhiQW5ydExESnJSSGl6VG5KLzBWSXhuQkJmZ1YrWk1kenREWnZwQUNlRHUvblVJdWgydkpDRC90bWhZeFA3SDRoOVdtdE9aZmNmcHRjZUw5UFZtUllFM0RrZlB3ZmNWQkQ0dHRBQ3pXMFlIL0FGMEZmbXFaNC80cnFUa2ROeC9Lb0RjUURLL2FYQXovQUhqVCt0SmZZL0UyK3JTbHJ6MitSK2xUZU43Y09vK3p3NEo2aDZZZkc5c2NqeW92Ky9ncjgyUk5iZzU4K1ErMjgweVNTekVoeEl3OWZtTlY5YjdRWDNtSDFlci9BTS92d1Awc1BqS3hWRC9xRDArVVNjaW9wUEd0bUNtMk9FNUhQN3dDdnpXKzBXNHdCSy9KOVRnMUt6MnVlV2M0Ni9NYVR4anV2ZFgzbHJET3o5LzhEOUdwUEdOcW0xdHR2dTdLWDVxdC93QUpyYmtzeWkzQUFIQmZQSnI4OEZhekROeXpFbnJrbkZLWHNnTUhkeDlhSGpaVytGR2YxU1QvQU9Yalh5UDBTSGphMTZzMEF3ZnU3dXRXZitFNnRpemZ2TFlBREl5K00vOEExNi9PbEpySWtBSzUrdWFRTmFOMURIaytvcGZXMi9zb3Y2czBsKzhmM0g2SHovRUMxWGFGYURPZWN1S29KOFNMUm1iYzF1dU9uemRhK0FDTE5qblllT3ZYcDZVcXJZQTQyTU9tZXRQNjNaZkF2dkc4TlBwVWErUitoMFBqdTFmbG50OGR5RzVINFV4dkhGcHUyckxiWXllUytLL1A1djdQVUg5Mi9YM3FwbTF5U1ZQVThjbXBXS3Y5aEVmVnBwcTgyL2tmb0ZGNDhzMmwybVMzeHp5RzZmNDFKL3dudGtGWUdXM0p6L2V4WDU4eHJaNUoyc080SE5UUkphRUg1U2NkeURTZUtmOEFLZ1ZDYmY4QUVkdlErOTVQSE1KNVNTQTg4NWFsZzhaV3J1MkRiYkZQSjNZSTk4VjhHU20zRGJ0aC9BRTFCaTJaaG1NK21NR2w5YmwvS2pSNGJzMmZvT2ZHZHBpUmx1TFpsWEdCdXdUbjYxa3llT29IWGtXNTlmbnI0T2VHMExncWpFZytocU1SMitXd3I1UFRyVkxGUCtSQkxEVGxIK0kxNVdQdk9IeDFBQWMvWitPTnUrdHhQR05oSXNaRnhDRnh5QzNUMnI4OHZLdHk0d0d6MzY4VkcwZHY2TVB6cHZGUHBCSWNjTEpSK052NUg2S254WGJPNEVid0hKd0NYQUg0bXM2NjhSMkRBS1pyZmZuN3Bib2EvUGNyYm5PTjRQMU5JbG8wck5zam1mQTUyZ2tqM3FIalpSK3lpNFlUbTNrL3VQMEhieERaQ0laZTNCSEJVT004Vm1KNG4wdEpqbEl3TURuZHo5YS9QeVNBaFRqZnlPbVRWOGFaY0MzUm5pdWtXUURZemJnRytoUGFxK3V0TDRWOTVQMUs3dXAyUzhybjZUNjk0cXNuOFA2TzhSZ3lCS1pBSEc3SmJnR3VSaThVNmVJc2tSOFk0TGNtdmhLeEVRYTRqYVVuQkhCWTVBcldtZ3QvbElaaGtEK0tzYWVMWEw4QzNmWHpMcllXZlA4QXhPaVczWldQdVUrS2JFQldYWU1xRGdOVitMeFJwdzNNOHFkZUJ1R1RYNTl5d1FrS3dra3owUHpFQ3FVZ2hCLzF6bkhUNXpWckZ0Lzh1MTk1bExCdUt2N1YvY2ZvZWZGdW5TRmNvcCtqRE5FM2lteENrRk1ZYkgzaHhYNTJadDlwSnVuRFo2YmpUR2VMN3h1Wk9uWmp4VzMxcEw3SDRtY2FFbW0rYS95UDBUUGliVFZ1UExaY1lHZHdZRVlxWC9oSmRPZVRZcWJpY2ZNR0JHVDB4WDV0T3hQL0FDOXlnQWYzK2xOeVIwdnBoZ0RvL05OWXVQOEFKK0pQMWFvNzJxSmZJL1NXWHhEWnE2aDQyd3ZwZzFyUTYzWVRncWtUT1FjRUFEdjZWK2FDM2R3TVoxR1lZSDkrb2x2N3NINWRUbTlmbGJCelZQRlIvay9FMFdGcnUvN3lOdlEvU3A5WDA0Y0VZNEdPYzFBMnJhY3FNU0RoZVNmL0FOVmZtbzJwNm9CZ2FuUDZqTFZZL3RIVnRpZzZuSmo2OU0wL3JrZjVXWS9WYWwvaVIraWgxM1IyQkpTVUFEazQ2MWVYVk5LMlJoaS9Jd0R0d0RtdnpYVFY5YVVrRFZKTWQrYzFjT3RhNGZsL3RRNDZqUGFoWXlEK3l4L1ZheSsxRzUram4yN1JjYmlIQ3NTTnhVNHFFMzJpcVZDdjA3WU9Qclg1MGY4QUNSZUpFNFhVTURPUFVab1BpUHhRTm9Hb3FmWWlyK3UwdjVXSjRXdlplOUUvU0padEtkZHdKSUE2a0dxQzNHak5rQ2RjOXdjMStla2ZpL3hkRHVRWDRLa2NnRGlyS2VMUEZJNTgrTTQ0UEZLV0xvL3l5SytwVjlHbkh6UHZ4NWRMQjNlY0Y1d0RuaXBndWtsTjMya0E5L21yNEUvNFM3eEZzNThvODVvZnhsNGhaVytXUEFPVGppbkhGMGY1V1E4TGlIZjNsOTU5OFl0TjJSY0RrZjNxbThtQWsvNlVwNDZCcStCQjhRUEVwR0dqaHdBQngxSXFBK085ZDJqRUE0UFpxYXhWRHFtdmtaZlZjU3ZQNW42QS9ZNEdQRTQ0NmNpbWpUZXVKeHg3aXZnNWZpSnJLRTV0T281QmFyRWZ4QzFSSDNmWk1IamdOVmZXc04zZjNBcUdLL2wvRSs1anBXV09KUVNSMk5PT2xPV3h1em4yNjRyNGtiNG5hZzVjaXlkVGpraHMwRDRuWHV4UjVVNHhrOEgxcW5pTU4vTitCZnNzVnkvdzNmMVI5dlBveExBNFVaOWF4MzBnRCs1K1FyNUVqK0tVelJrRVhJSTQ0TldYK0tvVkFDTGdZNzlhaFZjUGY0MTl4U2hpb3Azb3lUZm1qNnhHaHh5bkhsUm5IK3dLekpQRE52eWZzY09jL3dCd1Y4eHgvRjBLNXhjWEFIQXhpdEwvQUlYRW5hNmtHT29aYTJVOEsvdHhKa3NUeS9ETTkybDhJNmE3SGRZd2s5ZDIwWnJHZndacEcvblQ0ajJKQUZlVHgvRjJISS8wNDUvM1JpcmlmRnVMZU4xN0RnazhsS3UyRS9tZ3pqdmlWOWlvdmtkdGQrQXRGbEkvNGwwZUJXT2ZoMW9aSHpXWjQ5RFdkSDhWclpzLzZUQ1QyT01WZVg0cFFaNWEyZnZuZGlyVkxDTmJ3KzlHZjFqR0xyVlh5WmxTZkREUldMWXMrQjE1TlVIK0dPaGpHVWtHT09EWFpyOFM3TjhmTENEM3c5T1B4QjA5dXNhRWVvY1ZDdzJFdjluN3pXT054S2p2TitxWjVaZGZDYlN6TVNKWnNISEhXdWV1ZmhOYWc1UzRrNjQ1cjM1ZkhPbnl0bnljRGIvejBIV3B4NDEwazREUU1CNjdnZWFid09HYjBYNGllWllwWDZmOXVuekhKOEo0KzE0MzRyeldkUDhBQ3VjcW9qdXNlNVd2clpmRTJnRmR6UnVPZW1CVVk4VWVIYzRJYi92bnBTZUF3N2VuM1hOSTVwWFc3WHpSOGpqNFdhZ3E0RjNIajNCN1ZrUy9EYldYa0xMTkdjRSsxZmFEYTk0Y2JINzM4QXBxekJjK0htVTV1bEdUME5adkxLVnIzc2JyT1pON1IrOCtEcmo0Y2VJU3Z5N0R6NjRyR3VmQUd2eDRCaFZnUHZZTmZvZVcwSThmYTQ4L1dtdGI2WXhCVzZpUEhyV1R5dFh1cHNyKzJIZjRVZm0zYytDOWNSVkxXVG5uc001ckgvNFJuV1ZSeWJGL1Q3dk5mcGsybDJMa0R6NHllL3pDbVNhRmJOa0xJdjNjOWF6ZVdMK2Mwam05Ui84QUx0ZmVmbDVjYUZmbzRWcktRSEhKd2NWUmZTcjBZL2NTZFBRaXYxQmZ3N0F5amdHc1dmdzhyTnpHb3huR1Jtby9zcXAwa2J2T2FQMm9QNUh6dmNhejRiMDhrS1EyQjdWemQzOFM5T2hJRUtEcDZWOHBMQmR6ay9mWTl5YTJMZlFiNlRvdTJwbG1lS2F0Q0NpdkpGUXlqQ3BmdktrcCtyUFlibjRtM1VoYnkwYkhidFhIM1BqSFY1Mi8xbTNOU1dYZzYra0k0SkJQcFhwZG40QWVRQU9nejZrMUhMbUZmVzhtdnVMdGxlRzA5eFA3MmVKdnFlb3puNXJoMlAxcUw3UFBOODNsczNibk5mVTluNERzNGo4KzNBL0N1MWk4UDZOQWdMbU04OUNhNkk1WmlYckpwZXJPYWViNFNOMUdMazEyUjhjMitnM3I0SWkrbGRaYWVEdFFsL2hZWjlCWDFNYnJ3N2FEbFZPUFFBVm5TK0x0SWg0U01ESHFhNlZsOUNQeDFsZnlPVjVwWGwvRHc4dks1NGxCNEN1MkkzcVQ2OWhYYVdIZ05FYmxGem52elU5MThSTGFNall5RDlhNUM1K0pFaEJLdTdIdGhhdFJ5dUQxbHpNeWRUT0ttbkp5cjBQVzRQQlZtQ1NRb3gxNlZycm9XanhmZmRRUjcxOHZYSGp6VlpIUDd0OFk0eTFZVW5pVFZuUDMxQTc1T2FsNDdBUmZ1MGIvQUNNM2wrWnphNXNScDZuMkdaUER0djhBZWtUQTlLWk40bzhPd2dCRnlCMXlNVjhVUHFGOUtmbXVqazlscEhqbFlBbDVIejE1cFN6VzN3MG9vMVdUTnYzOFJKbjErM3hEMGxIT3lFSEE0NXJFdVBpaEF5L0lxQWZTdm1LMTArWnBNTGJ1YysxYkZ4cGs5cmF2UExBVWpRY2tEcG11S2VhWWxyUkpmSTdLZVQ0T0ZvdHVWK2paNjFjZkUyY2dxTWpIOTBkcXdyang4OXl3TnZBOFFBRzVRVHl3Nms1OWF3TG53OGxoRERkWEZ6Q0xTUXhocGtjTUVFblE4ZGZldGkzOEhrNnRJa0YwazF1VjNMS25SdmNmV3ZNZU54VldhU3FOMzdIc1U4dHdOS0RhcHBXdjE3R2MvaWZWeUJqdjFKYjFxcExybXNzbk53Zy9DdlpsOEJ3UEV2ek96WittYTJyZjRmMnBHUEpaZ1BVMTN3b1l5VDYvZWNFOFRsOFA1YitoODBOZDZpMzM3eGg2Z2RLUkZMZ2JwWm0vRTE5WVJlQnJlTUQvQUVaYTYrMThFUUFaTVNEajBycGVYNHBxNy9NNHY3VndmTTFGYStsajRqK3dsODRnbGYwUEpGWFl0R3UzWWJiSThkY2l2dWxQREZuR0Q4eXFQcUJVbzBuU294aDdpUDhBRmhXc01ybjFtam1xWjFTdWxHbTJ6NHVqOE42bzViYmJCYzk2MUQ0SzFncUF4UUFZeHpYMkN3OE93NERUSitCb09wK0hvUVNHeUNmVE5iZjJiVFQxbVpyT0ttM0lyOUQ1Ymo4QVhqcmw1c2UyT3RkSGJmRGh5QXpTU0Vad2NERmZSZHQ0ajhPcklyRU1RcDV6akZYZFUrSU9nUUlFaWlSbUE1TzRBVTVZTERKcjNyK2R5L3J1SWxGdmxzK2lTdWVOV3Z3N3RRbnpDVS9VNHpXNUg4UGJIWUQ5a0pJSndTVFdoSjhUYkpFd0k0VnllcGJQV29HK0tscXFZYWFJZWdBelRkTEJSM2xINzduTXNWbU1ucENkdS9LMGI5cDRCdEd4aXhUb2VUM3JwTGJ3SWlaeGJ4S2NaNUZlVXY4QUZjSFBsejhkOXExbHlmRks2SUpEenQrbkh0UzU4REhaeCs0YmxtTWw4TXY2OVQ2QWo4SkViaHNqSFRvSzBsOE5JQ04waWdLUHAwcjVUbStJdXBNU0VobVBHZVd4V2UzanJXbnhpSEJ6M2ZPYTFXSndhMlg0SE04SGo1YXQvd0RreDlqUjZMWWcvTk92dmtpcjBPbTZPTTc3bU1aQjZ0WHc2ZkZPdXZsdGlESjljNHAzOXQrSUpBRHZpQnowd2FTeGxEb245eDBMQVlpeXUxOTU5Mnh4NkNqRUNkVzQ1SU9SU3ZkNkZER3pNd1BweG12aHRkUzE5VU82OENIUFlWQWJ6VTNaaEpxTGpqa2NBVS9yc09rR1l2QTFMcTgwdnZQM0grQ2M5dGNlRHBYaFB5ZmJaaDB4MkZlL1N4QW12a0w5bDFuYjRhc1dsTWgvdEc0K1kvaFgyYzY4aXZ4dk5FcXVNeEVyV3ZVWis4NWF2WllQRFJ2ZTFHR3Z5UmdHR2p5UjZWcmxBYVlVd0s4RDJOajNGV2ZjK1FmMmhwdFVzZmhONGkxQ3d2SnJhNnNZUlBESkUyMDVVOUQ2aXZnTHdmNEsrSTNpSDRkYVJyRjk4Ui9FVWVvYXBvMXpxa0JodEZiVG9FZ0JJam5sN00yT0JYNkdmdElBcjhFZkdaLzZjam44eFh3MThOclA0R3Q4RE5GczdqeExESGRTNkJjejNOa2RXa1JKWjJVZ2hvZzJBNnQvQ0s5M0s2VVhDcmVGL2VYUy9RK1Z6ZW8xN1dmTkJOUWpibWRyN3ZUYzl0L1kzMW5WdGIrRTl6ZmFoZVNYZHpKcVU2R2FRNTNCT0JqMkZlYmZ0aWZDY2F2NGJoOFUyY0didlRGOHU3Q2psN1pqdzMvQUQrbGVzL3NSMlNRL0F5MC9jdEh1MUM2T0RubjVzWjVyOUFiMnl0cDdlYU9XSlpJNUZLdWpEY3JLZW9JUFVHdUhHVVY3ZVVrMHJPNlB2TXF4OHNIVm9TZ3I4c1kzWFJwclZIOGpHa2EvcWQ1YVIyOXkvbTI5aTRmZVRsbkMvZFRKN0R0WDJkWmVQTkMxblRMVzlGbi9BR1BDUDNEQ1dZem1TUmVycUFBVlgycTkrMXY0SjByUmZGRmhKcEdpSnA5dGN4UXZjZVV2bHd6dXJZQlFEcGdjTlh5OTRzTTl4cDkxbU1ScEdVMklpN1F2YkZmZDVUVXRoVksxM0pkZkxRK080enp6RVpyaktNWmN5cDRkT0VJdDN0ZlYvZWVuNnQ0c0MrYXNURnd1UUd6d3c5Um11VitHL3dBUUxxR3p1WTQ0QVc4OStTZmV1S3Q5UHVwOU9qS2trK1VPU09lbGVjZkR6UzlRbDFDOFJOLytzWWNEME5lbFF4R0lqVzBiMXZzZm5tSnd1R2xoM3pXVFZtcm42T1czeEQxU1NBWmdRWkhVbXE2ZUtkY2tNaFZvc0gwelhuR25lQ3RTWlkyYVdYbnQwNitsZW4ydmdHL0NqTFM0NUhVVjYxOFU3WFVsK0I0Q2hna21seTMrOHBTYTNycFgvajRRRDI1NHFzK3FhMFZCRjdnRHJ4ejlLN2VQNGZPdytiZWZmZldyRjhPNHlCbmNmUWJqVzNMaW4zKzhsTENSVjN5L2NlVnZmYXZ0eTJwU0tNOFl4Vk5iaStiZzZnN1o2NVlWNzVEOE5iUmxBYU4rVDZtdWhnK0dXbC84KzJlUms4MURwVnZQN3pTRlREdlM2ZnlQa3lkSkd4dnY1QmduT0pLcUZMYkJ4ZlNaUFA4QXJDYSswVStHK2xna2ZZbEl6Z0hiV3hIOE90T1ZsSXNWUEg5MFZsTEQxSlBkRzhLMUZhWGZ5UjhMQzN0Vk83N1M3Y2Q1Q2VmcFgxbnEzd2s4RVJlQjROWmk4VE8rKzNEaVFKNWtUU2taOHB0cHlqWjQ1cjBKZkFVR1J0c0l3ZjhBZEZkVEI0WGxpZ2VKYlNOVWJrakE1STc0ckdXRXFhV25GSFFzUlMxdlNrK3pkOUQ4ekk3YTBhSUV3dVNld1U4VllGbkFTY1draEJ4akNIaXYwamo4S0E1eERHQ0Qxd0JXa2ZDb3hnSkdNam5GVjlUbi9ORWxZbUtXMHo4MjFzbkFKVFRwaU04RUlhblN3dW1LN2RMa0pQYloxTmZvNG5oaDhjN0FENm5GVER3ekFwd1pJbElPUnpUK290ZmJSSDF1bTdlN0kvT1JORTFwbU8zUjVmeXA3ZUhmRVdjalIyL1N2MG9YUWJNWll6dzhEdlViNk5Zcjh4dklRUHFLbjZvNy9GK0JVc1FyWFVkUE5vL04yTHdqNHJmQlhUQ09ja2tqaXRaUEJ2aWxWNXRGNTU2MStnTFdtbm9RUHRxZGVvSUFvYURUQVFQN1JUQjY0SXExZ3RkWkVyRksyeSs4K0RQK0VKOFVPVCs2ai9GcXN4ZkQzeFl4SS9jRDhhKzUxR2d4WURYNjd2VElxVnJudy9Ibi9pWUxuMUI5YVBxYS9tWmYxMlA4cSs4K0pSOE5mRnJISG0yLzVIaW5wOEwvQUJNMjNOM0R3Y1l3Y1Y5dXgzMmc3VG04eVFlbWF6djdSOE5GdHYyaDJQWEFCcExCTHV3ZU9nN0xsajZYUGt1RDRWYTJ5ZlBlUkxrOVF1YzFwSDRYNmlqS1RmalBUQUdhK294cTNoMFpBa2ZJNmpCTlFQcStoakEyeU1PMkJUZUVoM1pIMXF5dXVVK1pCOE5Ma3NOMm84ZWdUb2FiTDhMbWMvTHFiOEhuS2l2cEgrM05CUjhOQkt3N1lYcFNqeEQ0Zkc1bHRwTWZTazhIVDgvdkpXT20ra2Z1UG55SDRVS0V3K3FQN2NDcEcrRkVBZjhBNUNMNHgxR00xOUJyNGwwbGdRdG8vd0NJQnB6ZUlkTFRPYlBMWjlSVFdFZ0N4ZFI3UDhEd1lmQ1BTaXVUcUV4UDRDcGo4S05KVWJXdlp2eFA2Vjd3UEZlbnJqL1FqanZ5S2lsOFUyREhKdE1BSGpKRkN3OUsrci9FMGVKZldTKzQ4VmkrR1dob2gvMHVkdmJkeldxdnd5OE5OdEcrVTRIUHpldmF2VXo0cHRTaFlXZ0F6akpZVk12aXkzallnd1JLY0RxUlZQRFVlMzRnOFpOZmIwOUR6TWZEUHd5VUM3Smg3bHpWdi9oVi9oRFlBWXBXYnVkNXJ2SlBHYXFRUkJBMy9BOFVMNDVUQkppdHVPb0w4MVgxV2tsZlQ3eUZqSjkvd1BPditGWStFMXovQUtKSTJCeGxqL1NuRDRhK0ZpQ0RZdDdjc2E5QWc4ZDI3T3haYmRWR0RrTm1rdVBpQkNyRVJ2YkVBOEhkaWg0ZWt1aSs4bjYxVWFiNXZ3T0gvd0NGYmVGbUNnNmJuQVBQelZPdnc4OEtnS3JhVURqdnptdWkvd0NGaUZTQ3h0RDE2dFZPVDRrUjk1clFIMHpUV0hwZGtZZlc2aTZ5KzRveCtBZkRvWEg5bUx3ZUFFSnE0ZkFuaHN0enBpSDB4SHpUUjhTRVBTNXRkMlBYTkNmRVNJUmt2ZDIyVDNCcE9qaDc2cEc4Y1RWdHUvdUxVWGdidzl1LzVCS1lIWDVPS3RMNE0wSUZ4L1pNZU9nd2c0cksvd0NGalJCUW92clhCOWFEOFNMY0J0Mm8yd0k1SEdhbFVxQ2VpaWFQRVZ0TFhORC9BSVF2U0FRZjdMUW5ISDdzZnlxMHZnelNDQ1RwU2tIMGpGY3EzeE1RWnpxVnVRT2hBcWRQaWpiK1h0L3RLTVB1NkJNakhybWgwOFAvQUhia0tyV1d2djhBeU9tSGc3UlMzT2xvUmovbm1LZkw0VjByZ0pwa1kvN1ppdUxiNG54czdLTlVqYmc5RnhqRlUvOEFoYUZ1MlA4QWlZampxUW5XcVVNT245a24yOWUvMi9tZHduaEhUeW9IOWxJZWM1MkN0RStGckJzNDAySmNmN0F6WG52L0FBczJ6LzZDK01uT05uU3FFM3hSdGNIR3BIUCs3VFVLRGU4VURyMWwvUDhBY2VucjRWdEFjaXdpSUhxZ3FSZkN0c3lrSFQ0disrQlhrUStLZHVEZ2FpUi93Q3JYL0MxYmZhQ05SUFBZTDBvY01QM2o5NW9xOWUzMnZ1UFhJdkRWcXFrRFQ0OEgvWUZUdjRadHRpLzhTK0lqL2RGZUtTL0UrTWdsTlViSHVnNlZaWDRxMmE3UTk4UjdoYUZHZ3VzZnZCMWNTOStZOVcvNFJPMndmOUFqSFBIeWlwRjhMMnl1cGJUb21BSFFxSzhTZjRyUithd1cvZkJQR0Y3VW8rS3NBTEEzOGhKNlpYR0tubG9YZXNUS25pS3pmL0x4MlBjUCtFZHRpVG13aXdSL2RVNXFNK0dMZGwrWFRJc2ovWUZlR3A4VWx3d2JVRzU2WVNyYmZGUXFneGZPTzJjVW5ERHJyRTBWYXEyOUpuc1QrRzRkdi9JT2ovNzVGU1IrSG9TQTM5bXdqais2SzhqdWZpVFlHMXR6QnJVMGtqS1RNaGpDaEd6MEhxTVZTaCtKMENxUkpmeTU0eDhneDc1b3RRYTNpRG5XNXJ1RTdXUGFqb2tLSVI5Z2ovNzVGVXhvc2ZtRWpUWWprY0hZT1BwWGovOEF3c3kxZGlUcURmOEFmTk5IeExnRW5GOUlRUndjWUEvRHVLcTJIdHZFcDFLN3R5eHFIdEkwZGRtRFlJRC9BTHEwajZEQklpQTZiRUN2ZmFNbXZLSCtKY0hsNFcvYkp4ajVjMVV1UGlZVEdQc3pYRHVQdkVnQUUvalhGVXI0S252T0NQUXcyRHpXdTN5VUtzdE43V1gzdlE5WWJ3M0F5TW9zWS9wdEZFUGhtQlloaXhqK3UwWnJ4bVR4MzRsYlkwY3FKbkJHVnpuUHI5S3o1L0Uvak5tWS93QnVOR3ZYS0lBTWV3OWE4K1daWUJPeVRmb2o2aWh3em5NdFpPRUYvZW5mOGt6MnFYd3ZiaDJaYkNQQlBaUnhYS1IzWGpud3RySDJ6UmRDc2IrT1dGb3BiVzYrUlFUeXNpc0FlUjNIY1Y0NUg0bjhWdklGYldia0UveGNkUFhHSzZpSHhYNGhFTFoxaVQ1VlBMQU5rajhLeXJZekExcVRoS0U3UHRZN0k4TjV0VG1wUnIwbTF0ckpma2piMEh3enJhV2pUNnBieE5kU3l2SzRTTUJBWGJkdFFmM1IwRmFPdTYxOFFkZWEyMG1idzlwdHRZMjkya3B2SXdmT2FOZWtXMDhBZXBya1YrSWZpSUtVWXBLQmp0dC9IaXRhSHg5ZktTOGpTeGtqcUZEQS93Q0ZiWHl1cjdPOG1uRGEraDVkZks4OXcwWjh0RDJrWko4emcrWi9kZE5ucjE5NEowdTFzYkM0R214ZVpkQnl6N1JrN1RqQitsYy8vd0FJNVpzeEgyR01ub1BsRmMxZS9FTmJxSzFTUFVRL2xnNVVqRzB0eWVLeDdiNGd3cExLSnIzQjIvSjh2USs5ZWpTamgzSFNVTjMxOHo1ZkZ5eGFxKzlUcXhzbGROTmROVHVKZkRkaGdidE9ROG5CMmppbS93RENLNlU0VUhUWWpudHNGY3dQaVpiS3VEY0x1QjVQWWl0U1A0bWFiNW00M3NZQTZBam5IdFhTb1VGL0tjZnRLdHZ0OU9oYVBnN1NPbjlsSU9mN3ZTcys0OEY2SGh2K0phb1BUY0Y1cDZmRWZTL05iTjdHd3oxeDFGVFA4UTlMZFdIMnUzVEI0Qnp5RDZWcjdQRDMreUh0S3FpL2krWm5MNEswRlVHTk5ISFVsZjUxRzNnblFYM0U2VkdlMmRwRlc0UGlMWkZXQm50OW9ZRC9BR3NWYWI0aFdmbnVFdW9USGtiU3dBeitIYXBkUERwNjhwbDdXdG8vZStTT2VIZ0xRc2pHbUxqdUNwcEpQaDU0WjJFdnBxRDBPQ01EOEs2Ri9pSkFybjk1QjhvemtIak5JbnhEaGx3V250OGdjRDE5cXIyTkgrNzk1VHIxMXM1ZmNjcS93NThJN055MlpWZ2VlVGptc21YNGVlR3VjMjdZeDJZOXE5RWo4Y1d6TVFYdHhrOEVrYzFibDhYMjZ5WUxXaEEvdXVQeW9WQ2p0cDk0dnJXSXQxdjZIbE1YdzM4S2w4TkRJb1BRNU5OdVBoajRiTHQrN2JnLzNqejcxNnUvaXBXWmp0dGNBWkh6ak5XWlBHVmpIR3JlVkV6RWNya2NHbjlYb2RrRHhOZHV6dnB2b2VGeS9DclFwTnVHa1FIL0FHKzlSZjhBQ3B0QVliVGNUcmp2dXIzZUx4blpTSVdOdEVBQjBEQTFzZjhBQ1M2YjVJazhxRWc0Nk9PRDZFVW5oYWQ5Zyt1eXZaU1YxNUh5eS93aTBtTi9sdlpzK3g0TlJ0OExOUGpLRmIyVWgvNGM5UHJYMG9QRk9sU3pCUHNLYmlUajV1S2xiV2RNa1Q1TGZINGpnaW04SlMwdWlGajZydmFhZnlQbCtUNFdJWkdBdm5HM3B4d0toUHdxdVdYSzZpY0hnZ3JYMUZMcjJoSktkMXZ5Qms3Y0hCcTFIci9oNWxIN2hqeDBOUjlVaFphTTIrdHl2cktOMTVIeUJMOEpOUVZ6c3ZnMzRZeFZPWDRYYXVvSUY2QWVoeXRmWkIxalFKRlloQ3JBOXgvS3FyYXQ0ZndSdkpKNmNWWDFLbStqSm5qNVdWbEUrS0crSE9zcjF1a1AxOXFkL3dBSUZyMjB1Skl4amdDdnRaYnJ3MDI0czVHUFk0cTFITjRhZENGbUg2OFZQMUNuZjdRNFk2Ky9MZjFQZ2hmQTNpRlMvS0hQSGZ2VXc4Q2VKQnlVajVHTVpyN3JWdkR6TVFMbGNnOVFUZ1Zia2cwVmt6OXI1ejNOUzhGQnZkbXl4L3UzdEg3ejgrMzhIZUpWSkhrSWVjazU0cWpQNFQ4UWdERnFEeDY5YzEraEp0ZEhBM0M5QTU2RmhTblRkUGRONHVrd09SeURTZUFncmU4eWxqK2JvcnJ6UHpWZnd6NGhYSSt3SG9jSHRWQnZEMnVzK0RwN0U0NkFacjlOcE5Ec21PUHRTWnhuQnhTRFFZVkFLVFJuMVBIYWg0Q0xXazJSTEd0T3ppdnZQeTN1ZEYxbEpTRHBzd0dQN3ZwV2ErbWFnZ0c3VDVCL3dHdjFKYncxSExNRHVpT0NlRGptcytUd21Ha1pmTGp3UGZpcCtvUy9uTC90RkpKZXliK1orWEVsbk9xNGF5a0I5ZHRaeHR6akJ0WHpqKzZhL1VFK0UxQk9JbHgrZFZwdkNPN0JGdXZiaFFLbDVkTnZTU0dzeWdsZmtrZm1DSW9rKzlESU1leDYwN1pGdDQ4d2RPNXI5SkovQlVESTJiVmM1NTRGWmJlQ0xiQUJ0ZlRHVkZSTExhdjh5S2htVkYvWlorZE14Q09QMzBnQUEvaU5SbWVRRUJidVRqSis5WDZCM1hnS3haaHVzVkp6L2NGWk0vdzQwMWxQK2dxRGpuNWV0VDlReEMycy9tS1dQd2plcmQvOEo4TUxmYWd2eWpVSlIzQXpWdUxVOVRKSSszTngzUFd2cnFUNGE2V0NmOUZBd09lRFZKL2hocG44TU9QenAvVThXdFYrWWxqTURMcDk4VDVqaTFiV2tZWXV5ZWF1bnhINGdFaHhjcWZ3cjZHLzRWaFlnazVZWjdaTlpzbnduaTNrcEt3NC92ZnpGWnVoalYxbDk1U3JaZEw3RUwvNFR3aytLZGRVRTc0eWZVaW5KNHkxN2FOeXhFOWp6WHJFM3dwTFoyM0RyK09haGI0WVRxaW43US95KzJjMVhzOGFscHpmZU5MTHBXdW9mY2VicjR6MVVjTkNoK2hxOUY4UWRUWGp5Ry9CcTJwL2hwcVlZN0pzaytvckJQZ0xXb3lRV1U0RlJ6NDlQN1picFpYZXpWTXZKOFNMOVdCOHFiOEdyUy80V25jcXh6NXk1cmtwZkJ1dXFGd3FFWTVOWlZ4NFI4UUt3MndvMmVlZWF0WW5ITCtiN2hQTDh1bHRHUHlaN01uaDdRN01BU3lvTWRpZWF2cnFuaGkwenRLc1IyNjE4WVhHdDZuUDk2WS96Tlp5bTdsUDNwRzU3VjB2TWFjVjdsR0s4MlpSeXV2TjNxWW1UOGtmWkZ6NCswbVBjSTQwWEhyWEZYSHhITzRpTW5qKzZLOER0dEt2bkp4QWVmV3VtaDhNNmt4VUJlRDI2MUR4K05tclIwWGtpbGxXQWc3eTFmVnRuVlMrT2I2VnVBZlRrNHJscm54SHE3dmszQVh0NjExVnA0RXZuUHpLNUI1OUs3eTArSHhJRzZJZmljMW43TE1LblNUTmZhNWJSWHhRWDRuZzBsMWVUNExYTXJIdUJTeDJseTdmNnVSdnFTYSt0N1B3TmJ4cUN4QzQ1NkN1b0dnYU5iS0RKS240bm10NDVaaUcvZWtsNm5QVXpmQ1IyVW4yc2o0MmowVytQU0lMK0ZkREY0VjFHVEFKeHgyRmZVZm4rR2JkVDg2c2M5QU0xWGJ4Vm9NUStWY2ZYQXJwamx0R1B4MWtqam5uRlYvdzhPMzVzOEFoOEVYRGhkMjlqN0N1cXR2aDBaSEI4ckl4em5yWGJUZkVYVDRuYmFrWTI4QTlhdzV2aXB0VEVZSDRMVGRITEtlOVhtWmg5WXplYjBvOHFOV3orSGNZSzVqVVo5cTdlTHdUYklOcmJSenllbUs4R3VQaVhxOHh5bThZNmNZNHJuYm54anIwckE3bUFQVExVTEU1ZEg3RGZ5RkxENXJOSzAxRjk3bjFoQjRjMHFKc3RPZ3dQVVZSMVhUUERVOW5KQlBORzZ1TnJybnRYeCtkYTFxUnptY0tmclZJM21wUG5kY0U4YzRyS2VZWWZsYVdIVnZNdW5sT05jbEtlTGQxczEwUHFjeCtDTEhUSTdMeWxlM2pIQ2ZlQi9Pcmx0NHE4T1c4WU1Oc0Y0eGc0cjQ2OHE2bHlQT2tac2dnWjVOWHJHRmxaMGxETXdQR2M5SzRmcnlVMXlVb1I5RWV3c3VrNFBucnptM3E3dmZ6UHJ4L2lYYVc3WVdLSURxTW5OWkZ6OFY1anlGajRQRzFlYStmNUxDVGFycGJNUjFCeFU2NmZxSkFJdCtoN25GYmZYOFQwdDl4elBMTUlsN3prL1dWajFHNStKdW9TL2Q4M0k2Zkxpc1dmeDNyY2h4dWxQYkJiRmNyL1pXcnVWL2RBRDlhdXgrR2RWa0FIUFhqQzBmV3NkTldVcGZjUDZobHNkWENOL09RcitKOWVjL053RDZ0bXNtWFd0WmRpZk1VZnJYWnA0SXZaUW9MeUg5S3NMOFA3d0U1RGtqdVRVOG1PbnZ6L2VQbnkybGYrR3ZrZWZEVWRTSXlibkdmUVZuUGNYZTdtOWZucnpYdnR0OE9HTzBtQWtrZTliTUh3NFBtZjhldVR4bmpwUytwWXlUNi9OaSt2NWZGWDA5VkUrWWxrNSthNmtQMEo1cE5zUmZwSTVJNkhKcjdNdHZoME01OGdEOEs2YTM4QVJCbHlpcVI2bkZkQ3krdjFhTW5tdUV0ZEtYM0h4WkZhRjRnVnRISTU2aXJxMmQ0RGhiQTQ5eFgzTXZncXhSU1htaVg2a1ZvUitHdENUNW11SWhqdm5OVkhMSmRhaStSakxOcWJzb3dmelBpYUhTdFZlUDViUUw2RTFxUjZCclRLUjVhTGtkdVJYM0xEcHZocEl6L0FLVEdjZWxTbHZDQ0RQbk0yTzRGYUxBUnY4Yis0bVdOWEw4TVUvTm54Q25ocldwRisrRk9NSGdtdENMd2RyTGtGNXp4L2RYRmZaSjFYd2JDUHVPNTloVXYvQ1QrSEZIeTJ2U3V0WUNrbDlyOGp6NDVuTnpjYndYcHFmSzhYZ1c5a2JCbGw3SEE0NXJiZytIY3hVaDVabTU5ZWYwcjZJSGpQUjFRdDVLNUJIQlljNXBCOFF0T1hrVzhRUHVhRmhLQ2YvQk5aNHJFTGFkLyszVHhtMStHNmtEL0FGaEhvU2ExRDhOSU1oL3M1T09uSnIwOXZpWlk0SkRRajZWemsveFF0UkdRWll3U2VEanZXdnNzTEgrWDd6bWRmRlMwOTcxVWJINkovczc2YWxoNENNS3JnQytuT1B5cjZ4WmErVnYyZWRUR28rQVJPR0pEWGs0QjZad2ErclRYNUhqMUQ2NWlPWGIya3JmZWZ0K0JjL3FXRjVyMzlqVHZmZjRVVmR0UnN2RldzVkV3cnhuSFE5VlBVK1Z2MmhOV3ZkSitFSGlTOXRmSjg2Rkl5Z21qRXNiSGNCaGxQWFBwWDQ3NkI0cU9vL0NEVmRlazhSV0ZucnNjN0pGYng2UEVvaklQeXFxcWhMRmgzN1YremZ4MXZyZXcrRzk5ZHp4dThWdmQyVWtpb205bVZaUVNBdmMxK2RwK1BIaGFTM2E4dDdTTmpFWkdoMDlFYjdVd0J3SE94Y2MvM1QwcjBzQTNGVkZjODZ2TDk1SzkrbnlQc0w5bFR4RnEydS9DZUs1MUY1bXUwdkpZNXZOaUVUYmx3ZUVBWEM0UEhGZlo4b1BsbXZsYjluTHhYWitLL0JXcGF2Ylcwc0NYR3FTZ3hTL2VWa1VLYy9qWDFqS3AyTjlEWG1ZcTduSitwN1VKSzhmU1A1SS9IWDlzM1VNMjNnYXl5RDV0OG55bnZ1a0FQNlY4RmZFS0ZZTFhXRkFVQVhqS01mN0p4WDJsKzJaQWo2NzhLWTQwL2YzbC93Q1Z1emdZV1pTTWo4YStGUGlOZGtSNnZibHR6aS9uQkk5UkpqK2xmYVpQVmpMTDQzM1NhL0ZuNXZtbEtYMTZxNDNhZGVhZnlzYkdnUzJpV01ZbE9CNVBIMXhXL3dEQ3Q5SmplNW1aQVNaWE9jZDgxNFhmdGRwcGFGSkNwRVE5dTFlTitFZGN1b3JobDg5d0M1emc0NzE3dUh4S3B6WHVKNk04L0dZVDJ0RDQ3SldmNG43T1duaURTUStCYmc0NjVJcnQvd0RoS05PVlA5VVB1NTZpdnpaMDZlVXNoYTdjRTlSdXIxSzNjTkgvQUs1amtlcHJ1V092TDRQeFBuWlpiSmJWdi9KVDdQWHhiYUJNN0VIdG1tRHh0Q2hKQ1JZSFU1cjR3ZEl6Z051T2UyVFVpUUlSd2pjZld1aFkxMmRvTDd6Q1dBZWlkVnY1SDJ3dnhCZ1dQSW10eHRPY1pxcWZpVGJoaVJOQUsrUUJicHorNkpPT3kwcTJjNy9kdG5iL0FJQ1JVTEdTZjJJblZIQlIwdEpuMW9QaWRhb2ZtdkVIUFFDczJmNHIydytWYmpvZW9IV3ZtUmRMMUFxVDlray83NXhVcTZMck9DVXNKU1NPRHQ2MUx4VTkrU1AzR3l3U3Y4Yy92UGZ2K0Z0eEFrcmVQako2Q2t1UGkwR2p3czBwOThWNEdQRFhpT2JnV0xMN0JhMkU4QytKSFJTTFJnQjIvd0RyMUgxdXJwN3NmdUc4SEc3WFBPM3FkL0o4VkpNSDk1TzMrRlpMZkUxMkRNZnRCN1p6Z1Z5eS9EL3hReFVMWW5uZ2tuaXJRK0dmakRmZ1dpZ2Y3MVI5YXhIOUlYMU9sMmYzbTAzeEltYkdJSjI5eTlWbitJTndlUmJQeWU3VXYvQ3JQRjVJSWlpSHI4MksxWS9oSjR0bFVzVEFQK0JjMUx4V0lhMGY0R2l3VkphdVA0bk5QNDh1bUFIMlU5ejk2czF2RzkvdXg5alU1N0ZxOUNpK0QvaUY4bDdpRUg2R3J2OEF3cFhXOHF6WGtXZW1jZXRaZldNVi9NL3VObGhNTzE4TWZ2UEx2K0UzMUhiajdMRjM3OFVzZmpuV000RVVTZ0VFZld2VzRmZ25ldC9yTlNqQUhQQzVxNHZ3WWRTUTJvS1EzVWhhemRURlgzWnNzTGhWRDRZL2VlTHY0MjFwdCtWaDVQWGJXZC93bDJ0OC93Q3E1SEhIK0ZmUmtQd1Z0encycFBqcGpBclNiNEoyQ0J2K0pnNUk5Q3RUN1RFOTVEK3I0UmE4c1VmTGorTHRkSnlaMHozTzJtSjRwMTB6QS9hRkJ4MkhTdnFKdmd6cFdCblVKVG4zRlRSL0I3UkVjRnJ5UmdSaklJeUtyL2FuczVmZVFxZUZUdTFBK1dXOFQ2OHpmOGZmNlVqYS9yVEVrM1RjRDhLK3RvdmhKNFdWaHV1WkR6L2VxNS93clh3bWpLTnNqY2YzcU9XdjF2OEFlVmZEWCt6OXg4ZE5ybXNOMXVuNlZudHEycTV3YnR5TTlLKzRWK0hmaEVuSDJhVEdSZzdqU1A4QUR6d2twQlcxWTRQVWsxSHM4UmZyOTVYK3kyYjl6N2o0ZS90UFVobi9BRXlUSGZtb1B0MSszVzZmbmpPYSs2MThCZUZOdVdzY25QVG45S1UrQVBDcElLNmJrOWU0clgyVmUzWDd6R004TmZkZmNmQ3pYMTRBUDlLaytoYW1QZVhSR1B0TW4wM0d2MEdqOERlRURHdWRLQVAweU9LMWo0UjhJQ1BIOWxLQ080U3NuUXJYNy9NNjFVd3pXLzRINXhyZDNPd2p6WFBjY2sxR2JtY2dicFh6MzVOZm93bmhUdzBySEdtUi93RGZQK05ha2ZoYnczOG8vc2lNZXBLQ2s4UFZNSFVvdDZma2Ztd1hsWkI4NzgrNXJQZG4ya0V1ZlRyWDZvdytIL0Q0T1JwTWJqM2pBeFVvMGp3OW5BMFZDUFVBY1UxUnJXdFpmZVhLZEZKZTliNUg1Vk5rQUVGZ2NBanFhYUJJMlJodnh6elg2dlM2WG9qcUF1alJManBnRHRURTBqU0FuemFWSG5QWGFPQjlNVUxEVnV5KzhhcjBGOXEveVB5bldPUUgvVnY5Y0dtdkEyY0dKengvZFBOZnJRbGhwZmxqT21Sa0RvUUFCK1ZOZTAwNGpCMCtQT09QbEZDdzFhK3lMZGVnL3RQN2o4bjF0RGxTTForUDlrMWJTeXV5cEF0SlNCL3NIbXYxT2kwNjJiZ2FiSDljRE5hMGRsYm9oSnNJK1BjREZXOFBVOGpPTldsZmQyOUQ4a1dzTHJ2YVM4SG41RFQxMHUvYmFSWlM0NHo4aHI5WlJib09SYXhlMmNjMUptTUtTdGpCMnlNMG5oNnIydDk1dDdlaDNsOXgrVUIwbTl5Vk5qS1IxKzRhVmRNdnpuL1FwUngyUTVyOVdoSWlzV05uQjEvRVVwRVdjbTNnNTk4VmF3MVZMcDk1ajlZb043djdqOHBmN00xQXNBTENicGppTTA4YVRxaE9EWXpBWTdvYS9WSFpGa2Z1b2lmNVV3bUluYVlZYzV4azRvV0ZxWDNRdnJOSGJVL0xGdEYxa1lJc1pzOXZrTk5HamF5VC93QWc2ZjhBNzltdjFPTVViQVlqaEF6MUI1cVVnYmRvOGtZNzVHVFZmVnFuZEdVcTlGdlc1K1czOWhhNXRQOEF4TFordWNlV2FWZEExODlkTXVBVHlNb2EvVUlsaHVHNkljOGREVUtzVktuekl4OVNLZjFhcjNSYnhGS0swVFB6T0hoN3hBK1FOTm00SDl5bS93RENNZUl3b3pwbHhqdDhsZnBrWmxaK1hnejlSVXpUdHNHSGdCSFQwcExDMUw3b1RyMFhHK3ArWVA4QXdqdXVvMmY3Tm5CeG5sRHpTLzJCcjdjZjJiT2YrQUhpdjB4ZG1JLzEwUFh0ZzFaaW1iSi9ld0hIVHBWUERWRjFSRUsxQmRKZmVmbWNmRFd2akIvczJjQWpqNURVWThPK0lpUVA3Tm45dmx6WDZldGNLRlVtU0RrOXlLWjlvUWdrTmJESEh5OENwK3IxTGJoN1dnbjFmelB6TVR3N3J3SjNhZE1EbnFVTlBYd3pyeDNmOFM2WTUvMk9LL1N3enNZenpFUVQxUHRWSFYvRTJuNlZwc3QzZXkyMGNVUzVQVEo5Z0IxSnFKWWFhMXVqb2hXcHl0RktWM2F5V3JiUHpmYncxcnNhbDMweVpVQUpaaU1BRDNxamIyanlaYmI4bzQzSHBuMEZkWjRtK0l1dmVMNzBxcS9aZEtqNVNHUDc4cEhReUgrbFVMVGExcXdUY1IzQjdEM3I1VEVZNzMrU0RYbXo5VXl2SUl3aXFsWk83MmgyOVN0Ym9va1lmWjl4WGtQbm44S3MyVUYzTk9XYmdIUHk0Nm4vQUJxMVpMbVE1d281cnZiYzZZR1F4R1FzT3BJQTU3MTVWU04zZTU5NUZSakZKS3hneElEQmhlU2hPVG11aHQyZ2Rkdk9NZEQxSjdpczYrdlpaSlpDa0tLQzNPMFk5dUt3WW5ranVBd2ZjTTU0NmdqMUZSR20zcU9NanBZZE5rODB0OHlqSitjNTQ5TTRxdzFvOGRyS1l5RGpsbi9UR0RXeW1xQ0xMeE9Ubmo3djlEV1VOUlJtTWNpZ0srU0dJNmUxZEtURTVkamtZeVltWGhnd1lncVI4dU8zNDEyOGR2RzhhdHM0SUdhcG1hMmprRWlLcFlNcEF4dUJ4N1ZNTlRTVWJRQUNwUDYxMHFLU1pMakptSmQ2RmJUekdSSDhweU9wSEFQcnhYbmQvcE56Qkt4a1FNQWVXVVpHUFd2YVVKa1VrUGhobi9Jckd1Ym1WRkk4cERnZHgvVHVLNXZiVktVcnhmVTQ4UmdLR0pwdU5TTjlMZWFQRzQ5UG1sWGRIQXpxZjRsR1JWZDlNdVEyUHNqa1o3SWVLOUkwYlZMelI5U2FXMTI3SFA3eUJ4KzdiOE8zdFgxLzRmMXpTTld0bWUzaWlFZ0dKWVdIeklmcDNIb2EraXdkZU9JZkxvcExwM1B5UE5zcXE0Qzg5WlVtN0tTNmVUUHp5ZlRya3FDbHJMeVR5RU5aeHM3ckFQMmVRNHp1eXZTdjFLV0dJUTdQSWlLbHNqNVJrZjhBMXFvbXd0U2NmWkkyWG5QUVY3ZjFlcGZvZkkvV2FYbWZsd2JHWlZKK3p5ZzQvdUg5S0d0WmR2TUwvWEIvV3YxSlNDME1ZUTJFUUNuZ2pHVG4xb2swL1RpRnhwMFlIcndUV2NzTFV1dGpXT0xwMjYvY2ZsbXRrdy81WlA4QVRCcW5MQUViSGxTSDN3YS9WSmRNMG5jcGZUbzNVSDVseGpQNDFIL1kyam1GZzJseDg1d0FBY1VmVnArUlRyMHBhSS9LcnlpUHZCeDdITkkwUHlEYXpFWjdacjlPem9XakdSYzZmR1JnOGJSVXc4TytHbVhMYVdoeDZLQlNlRXFMcWlJNGlnbHEzOXgrWGtnK1pTVElCMjVQV251emtFYjV2eEpyOU1tOE1lRjJjNTAwYlNPbTBFODFVZndsNFhZQURUK25jcU9hcjZyVnR1Q3hWRnV4K1pzclNIQVNTUTRIWEpCRktzbDBrWkJuY1pKeDgzTmZvN040RjhOU3VDTElZNzFRaytIdmhkM0kreWdBZXE0cHJEVmwxQjE4UDEvSS9PbGJ5K1VaVzZrd0J5TjNTcEJlNmtHR0x5Ym5vZDFmZk1udzU4THFRQlpENkR2VmIvaFhuaGtGdjlDT0Q2bk9LU29ZaittUzZtRzh2dVBob1grckRHTHlYSjZrbXJIOXFhdXZQMnlRZ0gxNHI3VlB3NDhQYkZDbzJjOXowRlF0OEwvRHpET0d5VDY0b2RERVhUdS92QlZjTnI3cSs0K05CcjJ2aHNyZXZ4MHBxK0lQRUNrLzZaejE2WjYxOWlINFUrSGxPUXpidlFOV1ZOOEtkRjZySkl2UFNuN0xGZDM5NCtiQ3BhcVAzSHliL3dBSlI0aDM4WGJIK1ZhWC9DVCtJVmovQU9Qcm9PbU9sZlNYL0NvdE1QSXVTQ2VvenpWV1Q0UDJ6WnhPK2M0REFpaHd4U1c4dnZJU3dibGZsaC80Q2ZQVWZpN3hFU0YrMEx0K21LZko0dDhRako4MEhuR0Qyelh1VTN3ZFpUOHQyY2R2Zi82OVFTZkNHNHg4dDBmWDhhYWpqTzh2dkxheS9yQ0wrUjRrUEdtdGxDR1NNKy9jMVpIamZWa1FqeTA3ZDY5UWI0UTNJWEF1dS9RMURMOEpkUkF5dHl2eTllLzRVbjljWDh4S2pnRTc4c1VlWmY4QUN3ZFhESE1JNDQ0UE5NLzRXTmZnak1MZXBHOGpOZHJKOEpkWDNIRGh2U3NpZjRTYStwQjRJSDQxY2EyTlc3bDl4TlREWlhOWHREN3pOSHhJdVVDNHQ1RlBYaDg1cTZ2eFF1ZG01b3BpU09QbjZWU2wrR1BpRFBFVzdJL1NzeTQrSFBpQUovcU00UDZVblh4cWYydnVNMWdzdVZySmYrQk02bFBpazRUa1hBejZOUy84TFljRGFKN2hCajFyZ0pQQVBpQmVmSXlNZDhpc2VUd1ZyMlFmczVIT0NPdkZQNjNqVjMrNDFlQXdVb3ZiL3dBQ1BaaDhXRytYTjVOOU50WEkvaTh4eGk5WURIOTJ2bmU0OEw2OUc0eFp2NlpxbzNocldzWk5rK1BwVnJHNHJyK1JoSExzSloyYlhtcEgxTC93dHR0cWszNEp4MUsxZEh4YVhBSDIyRS9WYStQcmpSZFJpd0d0SDZEK0dzMXRNdkZHVGF0alBIeTFYOW9WL3dDV1AzRUxLc1ByKzhuL0FPQkgyOG54VWpmaHBvQ2ZXdENQNG4yNnNDRGJNZmZwWHdBMWxOMSt6dmpQUEdLdGZaV0ErNjNQUFNxZVpWZjVZaVdVUTZWNm40SDZCajRqMmtuSmdnSjltNjFkWHg5cDVZNXRVNmM0WVYrY3JRc1A3NDZEdlNTR1ZTY000eDZFMWF4OC93Q1JEV1V4dGIyMHZ1UitraStOZEdMWWEyWEIvd0Jxbm54ZDRkd0dNRERKemc5c1YrYlN6WEFPUk5JVDlUVHpjWG9VZjZUSitkTlprMDlhZjRtVHltZTBhMXZWWFAwZUhpWHd3N25kdlgwNHFzMnBlR1hKUG10ZzlDUlg1emYyaHFDdWY5SllqdlV3MWpXQU9Ma2tEcGsxYXpTRjlhYk9kNUhXM1ZaWDgwZm91SnZEVEFmNlNNZzlQYXB2SzhQa0EvYTQxK3RmbmF2aURXa0l4T0I5ZWFrbDhVNnp1d1h6eDJyVlpuUWU4SkMvc25GNyswajhybmI2ZjhPWEp5eXF2MTVOZDNGNE5zYmNEekpsR1BvSzhKdS9pRHJFbVJHekFleHhYR3llSTlZbFkrWk5qL2dSUDUxeHZFNWZENGFibDZucXZEWnJVc25WakR2WSt3MXR2QzFvb0xUS3hBK3RaMC9pblFMYk8xRng5UUsrTzIxTzRrKzlPMkQxeFdjNWRtLzFjai9YSnExbWxvMmhTaWpCNU01VFRxVnBTK1o5YXpmRWF4alA3dFl6N2ptdVR1UGlWTStmTEQ1T2Vnd0srZjQ3YThkaHN0enhYUXdhRnFzbXpDdDE1QVhOYzBzZmpadlNUWG9qcmhsZVh3V3NFL1ZuWlhQamZXWlNSdUk3Y3RXRmNlSXRYbFVocHdCOWEzTGZ3TnFjcEJaWHdlL1N1dmcrSEV6a2JnTTQrdUtsVXNmVTZUWVNxWlpSU1hOVFg0bmliYWpjTWZtdTJJenpnNHBtVmY4QTU2Tno3bXZwaTIrSEVhNExiUitHSzdHRHdOcGtJRytRY2RpMytGYUxMc1hMVnEzcXpLV1o0Q21seXl2L0FJVWZIcXd5bjd0dTM1VnFRMkYrL3dCeUhxUFN2c29hTDRYdC93Q05NanQxcWRMand2YklTUU1EKzdqOWEzV1Z0L0ZXaWppcVoxQk8wYUU1SHlSYWFIckx0L3FnUCtBazEwa2ZoSFVwUW1TLzVZcjZPazhVK0hvQU1JRDdDc2k0K0l1bVJFK1hiSmpIQUpyb1dBd1VkSjEvdU9WNW5tRWt2WllUZnVlVDJ2Z0M4WXFXVStoeWExZFErSDJyUTJnZXloak02c3JJSEoyNUJ5UWZVR3VsZjRwNFg1VlJUbnNNMWd6L0FCUnVuQnhuampnY1ZqT2psbkxibmI4MDlUcXA0ak9aU1Q5bkZXZXpXaDAxOTRZOFNYRnphNmhhMjlucDkzSE1reFJVM1JLUjFWUWUzc2E5R2wrSGNGdTl0YzNWekcxMWNSbVNSUUFvWGNjOER0WHpXL3hGMU41TjREbkI2ZlNtVCtOdFp2WldsZG1KWTU1YnA3VnlRZVhVNXJsaktWdSt1eDZkVCswNnRLVjVSaTIvczZXdWZYS2FEcENnSzl4R0FvOVJWdjdONFdoSHozS25IcHowcjRvZlh0VUpCMzQ5NnB5YWpla2d0Y24zSUZlZ3N3b3gycEhsVHk3RXlncjFsK0o5dm0vOEl4OUM1UHZnQ28yOFUrR1lGSldFTVIxQndLK0VKTG1SaWQxeEtSVFJJQ3BJTWhQYmsxRHpPKzFOTDVpV1R1eXZWZC9RKzNIOGY2UEVjcmJwK0pySWY0b1dLdWRrY0lHTUhQTmZIcW96QTRpYy9VR3JZc3JrNUsyakUvN3ZGUkxNNnp0YU1UU09VUVc5V2IrNUgxRGNmRmFVS1JHNktjOWxybnBQaWRmczJSTzRIc3VLOFBoMHJWSFhLMnA1UGNWcncrR2RiZHNlVUI3Vm45ZXhiMlMrVVRxL3NyQlc5NmNuYm81bnBaK0pGNi9JYWR2eHhXZWZIK29zN2Z1cENEMCtldVhoOEhhMFg2Z1k3WXJaZzhCYXl6akIvSEJxZmE0NTlaZmNaT2hsdE9WclFWdTdDWHhkcThqWVdFRFBxM0pxSC9oSjlaMllCalUvblhZMi93QVBOVjNqTW8vS3RsZmhwZEhJTWh4N01LWExqNWI4NDV5eTlhcmtaNXAvYjJ0c3ZGeXEvUWMxSTJyNnE4R1B0alk5T085ZTBXL3d4akNaWXUyZTJhMW9QaHJicW9KdDNJNTVKTldzUGpYMWYzaStzNWZGZlpidC9LZk5jbDNkTnc5Ni9JN0hBTlRwT3JxRk16OERuNXpYMWpiL0FBeXNHMjdyWVpBd2ZwWFNRZkQzVG9sNHNsOWppcStwWW5xMTk1a3NYaHRiUmYzSHhNSGl5bzNNZTNXdGlPT1BBL2RPM0I3RW12dFZQQmxtR0dZSXhqMkdLNmkxOE1XSzQzSkVNZE9nclNPQnFwWGNrWUxNcU43S0x1ZkNNY2U0Z2kwZnIwMkhGWGx0YjNJQXNwU0FjL2M0cjd6T2s2YkV3SU1QSUhHYzFuM01XbnFqZlBDUHlyb2psOHBOZnZGOXhIOW9VOVY3Ti9lajY3L1psaGxpK0drSWVNeGszbHdTcDl5Syt5VFh6UjhEQ2g4Rmphd0krMXo5UHJYMHVhL0xNWERreFdJamU5cWtsZjVuN0poWnFlRncwcld2UnB1My9icUdVMWhVbUtRaXZQYTBPMVBVK2JQamhlUVdQdzExVzhtdTJ0WTdXV0NacGhGNTIwSTR6OG44UVBURmZtM2FlRDlPR2hwNHJzTkE4UTNXbk5ZU3U4ME50RkVaSUc1WmdqTnZaZmZIU3Z2bjlwbUVTZkJUeFNESXlMNUM3c2R3V0hGZkpXamF6NG1zdjJZYkx4TTBHbEc2dGZEZHpZMnN4U1l5TGJFN05yS0cyN2ovQUhzVjBZSzE2bnF2eVBPeFU1UmpVa28zNWVXMW5iYyttLzJXVDRUYjRXK2Q0ZlM2VFQ3alVMaVNOYm5IbUt4T0dISGJQU3ZzdVVmSTMwTmZsOSt5WDR6MHJTUGhEYWFkTERjTk5CNTExS1ZRQkVqZHNnbG1JeWEvU1hSdGMwM1c5R2d2N0tZU3dUSnVSaDNybXJyV1h6c2V6OXBXMlNpdndzZmovd0R0Wkl6L0FCQytDS1lCQjFZNEgvYlZhL09QNGlXN2p4VHI2SHZxTnp4ai9wb2EvUmI5c0JwSS9IWHdUYVBPOGFtU29IcjVxMStmSHhKaW10dkcrdHd5YmxrT29TazU2NGQ4MTcrU3EyQmluNW53MllTYnhWYTMvUVJVL1EyNTlFamZUVkRkNHVuMUZlSStBL0E2M2Q1S1MyQXNqZHM4QTE5QmF6cWtOcmFxalNBWWo0ejlPSzg3K0hQaUsxaDh4bnVWUWwycjZ2RHFnNmtYSnJSbmhZbWVJOW5KUlRhYWR6N1gwRDRlNllFaXpIazdSa2tkYTlyc2ZCV21JT0xaVDljVjgvNmY0NXRsSy82Y01iZU1WNkZiK1BiSUFFM2VUamtja2ZTdlhsRENYYmp5L2VlQ3F1S2pvNHp2M3Nld2Y4STFwcThDQk0rNEZhRWZoN1R4dEpnUUgxcnhNK085Tk0yUkxJYzg0Q21xRTNqaTNMa2I1dnlPQlZ4ZUhlbDRvNTV5eE85cHMrbkUwU3lHTVJSRDhCV3BEcDJuS1FDc1dTZWVSWHlZUEhVQmJKaXVHUHQzcXVmSE1PUmkwbno3MDcwRjFYM0ZjK0p0OExiN05uMkpKYjJFY2pERUdBYzU0T0tmNW1tN0FBOFBYdGpOZkdGeDQvYkNlVll2Z0RuRGRUV1RMNCt1d1FVc1dKOUMrS1BhWWUzeGZnTC9BR3h5ZnVhUHpQdWo3WHB4Ym1hSVlIb0ttYlV0TFZUbTVUazRyNENIanJVeTUyMmE4anU5UnplT2RYZHNpMWlYUDhPVDJySjFzUDNmM0hRNDR4eHVvcS9xZmZEYXhwOFl5TG44bHF1M2lEVHkyLzdXeGJIOTN0WHdDZkhtdFlJRnZDT2VlcHBuL0NaYTcxSGxLd0dlbmFrc1JoK3pORlF4TW82eVNaOTlueExZTDk2ZVJzOWdLay80U1BUZG55bVE0OUsvUDl2SEhpSW4vV1JENkxWQi9HSGlKc1l1VTl6dDRwUEVVUDVXUzZPSVdsMTh6OURQN2VzNUN4UzN1V0tydWI1ZWc5ZnBXTEo0cnNBMkRETWNFWXI0WGc4YitMNFBORU9yR01TSVVjQmZ2S2VxbjJyRy93Q0VpOFJFNE45Z1k3REZadkUwbDlsbHh3MklkclNTN24zOHZpZXpZRWkxa3dTZXB4UTNpTzJaZ3d0R09NOVRYNS9IWGRkSi93Q1FnM1h0UTJ1YTBRZDJvU2tuMHJONHVuZjRHZFN3dGZyTkgzdS9pcUFFZ1dKL0Zxcm54U2R2eTZjTUgvYnI0TS90YlZDUm0vbFA0MVhiVXRRWWtDOWxQdHVwTEcwLytmYis4d2VFcTNzNXI3ajc2UGk2WUVnV0tmaTFXcFBFOXlqSVRad3JrWkIzZGEvT3NYdDV1d0x5ZmtucTlUdGN6OWZ0RXhCOVdOVThXcmZBVThOT09udEQ5Qlc4VjNERElodDZ6SnZGVnlwS3I1QXhqQnpuUHRYd3JGSk9WNHVKUGZMVWpSeWxXWXM1SVA4QWVQU3NGaTFmNEN2cTNUbVo5ekR4WmQ3TStaYmZUMHJOdHZGMTNOY0pITHFGcEVwSnk3RElHUFhGZkU1aGxIVXlFSEhjMGl3dm5oRzl1VFZTeGx2c0lmMVhWWGsveFB1SC9oTFo5cEF2SUJ6MHdDUHJtcXorTFpJMUFPb1JidTQrWDlLK0ltZ2ZHUEtZSDF3YWJIQVEyZkpZNTc0TkpZdDlJb2lHQ3Uvalo5eGp4bGtET3FRcmpweU9LcnorTWxES0JyRUxkeVZOZkdwczdqai9BRWQvKytTYUhzTHpIRm5JZitBR2o2MjlQZFJvOEhKU2Z2TSt2bThhSUcvNUNjZjF6VS8vQUFtOXFZeHUxZ0E5OEd2a1pOTXZHandMU1ZmVEtHcGY3RTFKdHBXeWxQQXg4aHFIaXB2b2pkWVNDVjd0M1Bxb2VON0pEbGRad2ZVR29ENDh0RWNidFpKK3YvMXErWkRvR3Fra2YyZk43ZnV6elNud3Q0ZytVZjJYTmh2OWlqNjNOZGpKNFNOOW5idFkra2YrRmdhVXJrLzJ1MlNmNFNhYkw4UTlKWGEzOXFTTU8vSnI1MC80UlB4SnoveEtKeVBYWlR2K0VPOFN0L3pDcCtuZGV0Q3hrKzZFc0pHVHR5dEgwVko4UmRETWE0MUJ4Sm5rYzg1OUtvdjhRZEVBei9hRW93UFExNFAvQU1JWjRrQzUvc3Viai9aNXFRZUNmRmJGZHVsVFp6L2RvK3QxUEljc0ZGUFJTKzQ5L0h4RzBYeXNtK21IdUFldFpzM3hIMFNSUXB1YmhqbjNGZVBwNEc4Wk1weHBVdzVPZUtrYndCNHhZWk9sU25HTzFaL1dhbmtONFRtMDVaZmNlclMvRVRRbWJDejNBRzNIZnJXZi93QUxDME5TUUh1TWp2ZzE1azNnSHhjb3ovWnN2MHhtcFI0QjhZRU4vd0FTdHprZW9xbmpLbGxxaUZnVmZhVjBlakw4UXRDK1lxMXprOWZUNjA4ZkVUUi9MWU1zL3dBMk1Ibkl4WG1pK0FQR0pKLzRsa242VktQQVBpM2NCL1p6YnZyeFZQRTFMYU02UHFkS3kzUFNXK0lmaDdjdi9IMlNBUWVNRDhLcFA4UTlHYVZUNWM1SEhPT3RjVWZoeDR4TzRuVDNPTWM1Rk1IdzI4YWtralRYeGoxRlRIRTFlNGZVcWIwc3owVzYrSXVoc2lGWWJuZGs1RzNBL0NzNXZpSm9KenR0TGs4NStZL3pJcmlwUGh2NHpZRC9BRUE5UnhtckMvREx4bUVQL0V1Ym4zRkgxcW9sdVovVTFlelRYM0hScjhROU1SWFUyMDNQVDJwbi9Dd05NSVArano5UFN1Yy80VnY0eEgvTG53UGZOQStHL2pJL2RzaVJqMUZYOVpxTmJvRmdZM3NvdG0rdmovVGtiL2owbU9lL1FpcDIrSWRoei9vMHg1L0t1Y2krR25qRmp6WWdaenh1cXcvd3Y4WGdETnVGYjAzQTFrOFRVN292NmxUV2xyWDh6Vi80V0RZYmR3czVUenpuMG8vNFdCcDJjcmFUZ2VucFhQeWZEYnhvbUFiSGQ3N2hTZjhBQ3VmR0FkQjloNVArMXhUV0lxdFhUL0FoNFdQTjhMc2RHZkhlbXNvSnRaZ1JWY2VQTlBCS2kxbi9BQnFGZmhsNHZkUCtQUWNjSDVnTTAwL0RIeG1BMmRQR0FmNzRwZldxcTNmNEd2MU9IOHJPbWwrS0ZsRnB6UlNRU2lLTmpLUjJVNHh4WHpmZmE5ZGVKTlNhNW5meTdWQi9vOEFPYzU2czN2Vzk0LzhBQ0d1Nkw0VXZycTVoRWFEYUMyZW1TQlhBV0Fna1dCZksyRkkxR1Y1RG5HYzVGZk9acmk2M3N1WG0wZXJQMGJobkw2SFBLczQzbkY4c2I5RjVIYVd3dDRZU3FLQjZrVk5hNmxjd1NsTWdvL1VkRFVua3h4SUNWQjNjOWF2SnByVEdGM3h0SFQxL0d2aW9OdWVtNSt0T0tVZlE2TzJrZ2VRRmxJeU9SbXVqU0hZcWxDR1U5Q0JYTmVYYUlxNWNaSDRzZnBTMityUW9WU09PYVU4allJV1A1R3ZYanpiTTVadFdPcnRrODJabEM1SnpnREpQNEFWUktSUlB1S0ZVd2VUME5SMk9vWHE2Z2t5NlpPR0dRRzNLZ1VIMXlhZmZXZDdLckdSclNORGtsWHVWM0hQKzdtdXFPek9lTGJsYm9XcDcvVFlGalNXZEFaV3duUE9mU3FNMXh2RENNTDFJNUhZMTg3M2ZnN1dwWTVVT3EySitiNVg4d3N5NVBIWWMxNno0VnRaTkx0SGl2THlPNGtPZjNoZm5JNEhCN1Zoeno1dGpxcFFjbm9teldFRXBYYXU4ODV4M3JadEM2WEtLd0tuT1NHSGNldGFjZHpBd0IrM2ZLcEpDTXd4azlSd09LeVpKYnI3UnZpZ1pzQW5naHV0ZDBHcmFtMDZjNDdwbzlHbmNwRWtyb3VHWWduR0FUNllGVUo3bzNFU3B3Nkl4S2c0QkI5alhJM056ZUpwYXozTVRRd2h2bWtJd3VmclZUVGRTczVBNEZ6RzRJL2hjSEFQdlhEVmV2a2MxMHJMUzVQTlpOTkxsVitjdDA5RFJtNHRMcU82Z2NSVFJkY2RHSGRXSG9hNlMydWJVQjVBZ2RWWGtOa0w3RFBITmNIcTl5MHNKT1BMT0RnbnArZGNpbktEVW95YWFlalFWWTBxbE9jSnhVb3lWbW5zejAzL2hZV21zekNTU1dOK2hWZVFEVkllT3RGVXNXdTdqT2VuT0srVWZCMm42MXE5L3JqdzI3eTdKMHp0NUM1SDlhOVNmd2Y0akpJR252bjBJcjlCdytOcnpwUWsycnRIODc1amxsQ2xqYWtJUWZMRi9kZlU5eFQ0aDZERVNCY1B0Ym94QjRweWZFalExZHMzVXB6ME9DQitWZUR0NFA4U29NdHBzb0gweldkSjRYMTVTTVdFdlhyaXVwWXFxOXppZUZoWkphSHU3ZkVEVGpLU3QzSUFmVmlUOUt1dy9FVFNVejVtb3lrRWpnSERDdm5xVHcxcmdPMDZmSVQyTzJzYWZ3OXJLZGRQbXllRDhoNHFuaktyc3JJeGpnYWFsemM4ci9JK2o1ZmlEWTcvM2Vydi9BTUNITlcwK0lFUUlEYXBuSXhnbXZsUjlEMWhSbjdHL0greGcwaDBmVlFvell5YzU2clJMRzFGOWxCOVNwdC9FejYvYng1cEdGMmFrNkVyaHVjamQ2ajJxeVBHMXJIQ1ArSnZHMmVucitOZkdENlBxWXhtd2t4L3VrWnBQN091aEoveDV2OHYreWFGaloyMlFubDhQNW44ajdNYngrbzVYVVk4RThqSTZWWmw4ZVJzRkM2bkNSK0dhK0ZaZE9uVldZMnJBSC9aTlZ2c2piTWZaM3lPKzA0TldzYk8zd3hLV0FTdDc3UHZWL0hDYmRxMzBXTUhPUU9meXFHUHh3V0NiWm9tSUpCR0srRDB0MnlUNWJkUFE4Vkw5bWJnN1pBRDA2Z1ZDeDB2NUVPZVgzZC9hdjBzZmZaOFd0czNlZEVlT1JUMThYRkNCdWlJNmpucFh3VzBiTEhIL0FLekovd0JvMVRJbDNFN256a2pnbXRWais4RVpmMmM5L2F2N2o5RGo0cFVFa1BHK09UeFRHOFd4U01vVVE5T2hPT1Qycjg5RU1xc2RzMG85QnVORHkzUWJpNWtIc0RWL1g0LzgrL3hKbmwxU3lmdHRQUS9SZFBGZHVZOEdGQ3k4WUJwNDhVeEVMdHRseVR6ODFmblJIYzNxNDIzY29KNzdxc2krMUlFa1hzbzUvdlV2cnl2OEg0aVdBcTlLMzRINkdQNG1oVkZMVzR3ZW1HcEU4VzZheTgyN1o0eHp6WDUycmY2dHZVcnFFbU05RHpVMDJxNnNya0M4Ymp2MHF2cjhQNUdLV0JycGFUajh6OUR2K0Vsc0g0RUQ5YVNUeEZwcTdpWTVPMmZXdnp4WFd0YVVLUmVOMXpWdC9FT3VvR0gyb252MHEvcjlIK1JrUnk3RU5hemo4ajlBNHZFZW1FdWRrZ0FISngwRlQvOEFDUmFReU44Ny9YSGV2enNUeFA0Z0F6OXBCUHVLYWZGZXY3Z0RLbzlPSzBXUHczOHNrYzhzdXhhK0dVUG1mb3NtdmFQbkl1R0dSMEsxSU5XME9RRE4wZXZPVnI4NVArRXYxOUNmbVE0N1lxMFBIT3ZnQW1OQUQrVlA2N2grMGkxZ3NZbHJ5ZkkvUTZhKzBnOEM3UUFuaklxaDV1amJzL2FvZWUxZkFjbmp2V1N3RFc2NHdUbnVhZ1BqMis0RFdpK3ZXdDQ0dkMyK0ovY2Nzc0ZqTlh5TDd6OUNpbWtNVGk1aFlkamtWRDVPblkvMWtQNUFWOEZuNGd6cXFqN0VUdUhVR2gvaUk3R1BOb3dJWDF5VFMrczRWL2EvQVBxZU5TVm9hK3A5NmZZTk5rd1FJRDc4VlZtMExTNUV3MEVKNDl1OWZEY1h4SFdQZG0za0lJeGduMTcvQUlVNlA0aXg0Ykt5cUI2R21xK0UvbVgzQjdISHAyNUcvbWZZOG5oalM4SC9BRVNQOE1WbE40UzBzbi9qMFh1Y2NHdmxlUDRsUkJTQThxK3BOWFI4UnJmSC9IeklPT296V250Y0UxOFVmdU9hZERNTC9EUDVNK2k1ZkJXblNZQnNsR1Bhc3VYd0JveHovb29HRHp4bXZHNGZpVEZ0d0wyUWZqVjhmRWxWYy84QUV3WlFSenpVS2VDdjhVVHJweng4WVdjWjM5RDBKdmh6b1BMTmFublArZUt4NVBobHBEOUl2ekJyRWkrSkJQSTFFSG5nRWppdEEvRWRpeHplUmtZOUJpazQ0RjlZaWxXektLMnFmZGN6NWZoZHBUREdDdnVLeDIrRTFuaGlKaHo3VjJCK0l6b3Yrc2dQNENwWS9Ibm1rZ21FZ2ZoVGpoOEc5ZmRNNVk3TUZaTDJsLzhBQ2VibjRUd3F3QW42bnRWVS9CL2Z5Ymc0N1Y3R25qdURIelJ3c2UyR3hWaGZIRVJBekFvLzRGV1VzRmhHOUg5ek5ZWmxqb3EwNC9nZm5UYStFZFZ1Q1BsYkgwcnU3VDRjM01pZ3NweGpuSnJ0NXZpUFpRSnRodDA0OVRYS1hQeE52V0IyREFQUUFWeUtqbGxQNHFqa3oxbGlNMnJKU2hSVVBVN0t5K0c4S2dHUWdEMTRGZFhENFUwUzJHWkpFNDlUMXhYenhQNDMxbWJQek4rTFZ6cyt2YWpMMWx4K3RYOWF5K0NYTGg3K3BsTEM1clVkNTRoUjhsL3dENjlRZUZiVU5nb1NQWVZHL2lqUUlDZGtTNUgwRmZGVGFoY3MzTTdIUHBRQkt6QTdXYk5KNW5MN05LSytRb1pURnlUcVZaeStaOWQzUHhFMDZJWVZFWDlhNUs1K0pPNURzWitlZ0M0cndOTEc3Y3J0dDI5dUszSVBEK3RTWkFpd0QwNHpXUDEvR3plamZ5UnYvWldYeDk2VVU3ZFd6dTVQSG1vU0xoUS8xSnhXQk40cjFWK0FSM0dUelVrSGduVzN4a0hCNjEyVnY4UGI1bHpJMk05Qm1qa3pHbzcybitRM1BLcVhXbWp5MlhYZFFadVo4Y2RCVlVhbE1TUTA3bklyM3EyK0dnSitZWjQrdGRiYS9EaTBVZ24wNzR4VGVBeHN0MWIxWVJ6TEFMYVNmb2o1VFZoSWNrTzM0MWNOdStRVmhicDB4bXZzSzM4R2FWRmt1MFhIcVJYUURTZkRzS2pmTENNZmpXc2NxcmZhbkZITFBPc1B6T01ZU2R2SStMYmJUNzZVa0xia1o2Y1ZabnNEWnkybjJ4MWhpbm1XTXlPY0ttNDQzTjdDdnRCYnZ3dGFSc2NxZmNML0FDcmxkUzFId2hleGhKclR6a0JCMnNveGtVVHl6M1hhdXIraG5ETm1xa2I0ZVRqZlcyNTg0MzJsV21tYXZid1hrdzhpZVF4cFBFQ3dKSFJoanFEWFlhVjROV1NTVUF0aFh3ZlRQdFhxZC80aTBGTGRBbG1oRVFHek9EajB4VW1tZU1iR0oxUkk0azZISlBjMXp3d2RDTlQzcXFmb2RuMS9GVHBQa3cwbHJhN2Y2R1FQaHlKQ0NUSWExMStHc0JRWkJPZTU5cTZEVVBpQUlaQWduaVhqUHJYR3ovRXR5U0JlZE91QlhmeTRHTzltY0ZTZVl6ZnVYWHlPclQ0YzJDcUYyZFI2ZEs2TzM4QzZmR3lqeTA0OVNLOFhsK0lJWUwrOG1QMHlLeUg4Y1hEQmlJNW1IYkxWMHFybDBWOEMrNDQ0VWM1Y201Vm45NTlPUitHTktqUEpoSE9NRWlwSTlLMEtOeURORDc4MThrUDR4dlhZaGJibkk1WnF5VzhUYW1YNGpRSDF6eFMrdVlLTzFOZkpHY3NCbU1wM2RUNzJmYkRmOEl6RWNlY2h3ZXkxT05SOE5xb0lkaVR4d3RmRHg4UTZzNHp2akgwRlZtMXZWR1htN3hucmdWbi9BR2xTNlFaMWYyUlhhdktjZGZtZmMvOEFiMmhCc0pBNUk2NUFGRWZpYlRWT0Z0L29NNHI0VUdwWDdISnZYSkk3Y1V6N1hPekEvYXBHT01uTGRLbDVrbjlnbU9UMitLcGQrU1B2RnZHVm9vR0xSQWZVdDBxb2ZIeUtEaU9BY2REWHhTTnpTYldlUnNqMU5SdGJqR1ZoZHZYcWFqKzBHMThDKzgyL3N1TWQ2ajlMSDJkTDhTV0NLdm5Rb2Z3cWpKOFNYOHM1dm9oOU1jZmxYeWNsbE02Z3JZczJQWTFzUmFiZU5HeFhUam5ISEZaL1g2dDlJUis0UHFGSjd5bDk1OUNENGxIZC93QWhBdDlLclMvRVNKaVFMdVpnQnp0QnJ4Tk5LMWR5cEZndy9ERmFzSGg3VzMrN2FiZlVFNDRxbmk4VEo2USs1RnJBNFJMM3BOTC9BQkhweStQb2lPQmNISHFDS2FQRzRkbEMyMXczMU9NVnhrSGhMeEEyQUl3TThjNXJwb2ZBL2lCaHUycDZkNkZXeGZaL2NPV0d3QytGcC9NMkc4Y3lBN0YwOWllbVdjVlJmeFRmeThyWlJubkhMZE1WYVB3LzE2VE82WkY0SFJhVlBoM3FTTVMxMzZmdzVxK2ZHUHBMN2ptK3I0TmF0eFh6UDFiL0FHYmJxUzQrSFVVam9xazNkeHdPbld2ci9ubXZrMzluZXdleStIMEVMTnVLM1Z4ejlUWDFrYS9LOFU1ZldhL052N1NWL3ZQMmloeS9WOFB5NnIyTk8zL2dLRkZJYUJTMXpkRG9Qa0g5cHAxVDRKZUtTeHdEQ2cvOGVGZm1IcVdtZkQ2VDlsRHc3THJldDNFbDYwTjUvWmRvYjExUmJqZHlpSWdJUEg4TDhWKzR2aWZSZE4xaXdpc2I2M1NlM2xuVHpJbkdWYmJ6Z2p1S3dZZmhkOFBJTWVYNFowNWNkUDNDOGZTbGg1eWpPcWxHKzJ0N2RET3RRaEtuZVU3T1VvdGU3elc1WDZyWHNmQlB3TjhMNkY0OC9aK2d0OVRobmlqVVBhYm9KV2dsTUVaKzR4VEdSbjFyOUN2RGZoM1N2RHZoNjEwM1Q0Zkt0cmFBUnhKbk9GQTQ1TlMyMmtXR25XdW93Mmx0SERFV1ZnaURhTW5yd0s2YVJmM0Ivd0J6K2xlZFVrNTFKUzFYdXZTK2kxYVBhbkpjcVNlamxHK2xtN0piL2VmaUwrM0pkM2VtNmo4TDlUZ1RMV01zc3dKR1JsV0JBUDFyNTgxbTYwZnhmYWY4SkF0c3lTVDNMTVZjYldCeG5IdU05Syt5djIwTFVUNkxvUit6ck1JTEtXVW9SazREZ2ZLUFd2ekEwajRjK05URmJhcnBVUTBpem5qVE5wY1hEVGlROTN4L0Ruc08xZlk1UzVyQzA0OHZNbkhzZm5lT2hUZGJFVGMxRnh4RXJOdnVaSGlXRjdoNXVDU0Y0NHJ4VHdWRk5KTzRXTW5Ea1kvR3YwR3U5RnQ0TEVyS3NabEVSM0hqQk9QZXZOUGhSNFpzeWtremhjR1ppUHpyMzZHRW5PcmE2UjQ5ZkgwWVVaYU4yV25uWXM2WHBXb1NCU0xWaWNkY1Y2WGI2THE4Z0NwWnZudmdjbXZxdlM3RFNvMUJESmhlU2E3YUNUUm95Y1NwdUhOZW5IQ3VMdHpYK1I0VXNZcDY4dGo0Nmo4T2E0eFZ2c2paejY0clZYd2w0bWxKSXRCMHdmbUFyNjRXL3dCTXh1RXFnWjlLdnBxdWx0d0pjajJXdWhZWjkyWmZXb1cxWDRueVBGNEg4VXYwdDBIUFo2MHo4T3ZGc2lNVmpRQURrN3ErcjExalRWZFFDeHovQUxKelQzMTJ5VlRqek1mU3Irck52Y3hlS3BwWFVmeFBsZXgrR0hpTzRkRUx3cXpFQUFrODVyMVRWdjJkdkdOaFl2ZFRYVm9pTGpQekVuQjdqMXIwMlRXckpJZ1FINmNDb1A4QWhNSlpZUkJKYzNid3FjaU9SOHFQcG5tb2VFYmxIbHFKYTZwcmYwT3FHT3BxRDVxRGJlMGs3SmVwODV4L0NqVis5N0Q2OEExcEo4STd0MUcvVWxHZWVFcjN0ZkUybnhxUjlta0o2Y0VZcUVlS3JWd01Xekw3RTFUd2tlN0llTlNhU1NmM25pc1h3Y2gzWmZVMkFKNXdCelhxdXBmczUyZGxvVnRmdHE3TVpzZklRRk9HNlk5YTAyOFJ4ZVhJd3QrbWNET2MxSEQ0eXVab29SS2hLcU1JanVTRkhzRDBybmxoYWZORzFXMW5xdTUyUnhrMVRrNVVMM1h1dGREelJmZzNwSkdmdGN2QTZBNDZWYlQ0TzZFQWN6ekVIQis5WG9Fbml0NHdTYmVQbi9ielVBOFpTS00rVENBZTViRmRQMVNIZjhUbFdNbS9zWCtSemEvQ0h3MkI4elRNZjk3RlRqNFMrRlF5a3JLUjZieml0ZC9HODRjS3FRL1FucFZEL2hPcnNFNSt6Z2ozcWZxZFB2ZjVoOWVxZnkyLzdkUmNYNFUrRUJqTU1oSTdialY5UGhyNE1RLzhlVEhQcm1zWC9oT0xzL01zMEdNZTFSRHh4YzVPNjh0MUE3bkZaZlY2UGRmZWRDeHRUczdlaU9sLzRWejRTejh1bjRCOVRVdi9BQXIvQU1IaGhuVGxQcHhYSmY4QUNjVEhPYiszQUo0NEhTbVcvajJPQzREVDNjVXlBSEtCd3VlT0RuMm9qUm9lUmxMRlZYTldkcitoM01mZ2p3c0FjYVZHY24wNjFjSGd6d3dIQi9zaU1BZGlPOWVWbng5RTVmR3FvQmtZNkNxVS9qd0dRbGRYK1hISHpDbjdLaC9ORWYxakV0WDVaUDVIdFk4SitHd2VOTGlBNDQyMWQvc1BRMTRUVFl4N2JRUWErZFU4ZUlYVUhWbVByZzQvT3BsOFpXRWx4KzkxbVdLSnMvT3ZKQng2VkRwNGZ1amVOZkVPM3V2OGo2TVRSdE5HN09ud0VlbTBjVkErbGFjckFDd2lIWWZLSytZRzhiV2dqeC9ha3JNUFVtbzVQSGRneTRXN24rVWM3bUxaTlh5WVpQZUptNjJKbHZHWDNuMUhGWWFlcmY4QUhsRnlDT1ZGWGphV0JHMzdGQmtBRVlBNlY4ZWp4cmE0NHU1anh4MXFXTHh4WW9TUFBtYkk0eVNhYmpocmJvU3hHSXZaUlo5a2JMUU1BdHBCa2oycTIwOXVYSkZyQ3BHT0IwL0t2aW8rTjlQM2JoTE5odU9NMFIrTnRNeXhmN1EzcHdhbmx3M2RHbnRjVWwxMVB0R1JvcEJuWkVQVVk2VWdNWkkvMVFJNmRLK0lqNDIwMkptS3BNNFlZQndjajM2MGplTjdCeU14UysxRFdHUytKZmNacWVKZXFUZnpQdkZMb3FBZDhYSHJpcjMyOEU4dkJrREhhdmdWdkhlbm9nSDJhVTg5UVA4QTY5UXY0OHRBUnR0Wk1ZNlkvd0RyMW5mQytYM0d2UGkwdG45NTk5ZmF3cURNa1A2R3F5M1VBWUV5d2pCOXErQ1Q0N3NNWSt4ejd1NXlCVlovSE1BYml6bTRPZVNCVnhsaHY2UnorMHhYTnJHM3pQdjgzMEpVL3dDa3c4SGdjVWgxQ0FEQnVvdnd4WHdHZkhjREJNMmNtTWRjaXBWOGYyb1VIN0RLVzlOd0ZXM2h1LzRGeHFZaHMrOVRxTUNZeGRSRG5HQ1JTUHJCREhiZXhIQTR4aml2Z2svRUtFcWYrSmErUWV1OFlQdFVsdjhBRVdHTjgvWUdIWCtJZDZqMmxEdGY1RjN4RjdhcGVwOXluVVlKQ1FiMkVnYzlRQ1B4cU02bFpzNEMzc2VSM0JGZkN5ZVBvVlNRbXdjaGdlZDRCNis0cXFmSDhZeHRzV3h5Um1RY2ZrS2FxVU94RGVKUHU4YXBaZzdUZm9UNkFpb3pxbGtRVk4vSHp3ZWV0ZkJnOGU5L3NSeG5QTDRxWWVQbkJiRmt1TUgrTHBWT3BoMTEvQVVZNHFUUHU2VFY5T2pJQnZVem4xcG4vQ1EyQnovcDYrbGZDUDhBd25rcENuN0NCanBsOGltZjhKOWNLL05pZ3g2UFUrMXd5NkZPR0p2dWZkOG10YWFRQWI5TSttY0dxMzl2MlBYKzBBVDlhK0ZXK0lsenppeFE1OVgvQVByVlVsK0lOeVFEOWdpR09PR09hUGJVT3crVEVQclkrOWY3ZjA1Z1FkUVhIYW8wMTdTaVRqVUVKeFh3TzNqMjdKR0xTTWVuem1xeStPcjBISXRZK21mdkdxOXJRc0owOFNtbW1uL1hxZmZoOFE2Y2paKzNEUDhBT3BKUEVPbGtydXZWem44cS9Qc2VPTlFKSk50R2ZxVDBxYVh4N3FMQmY5SGpJQXdPYXpkYWoyS2xTeE5ybjMyL2lIU0dJemZESTZDbURYTk81LzB6Z2RpSy9Qb2VOOVJKR0lVR0QxQnErbmpYVWkzTVVZOWVldE5WcUhXNk5ZVThiTmFSUjk0TjRsMG9NU0wzbjZITk0vNFNUVHVwdnljOSthK090R3Z2RTJzWEt4V2VtbVk5Q1Z6Z2ZVMTdoYy9EenhaL1o4Z3Z4TGJTdjVaamFBcVVWVys4V3prbkh0WFBWeHVFcDdwdjBQZHdlUTVyaUhGeWxDbW05SEoydjVwSGdIN1NWN2Q2eDRIT21hVWs5N2RYVnhHSTRJVkx1Y0hPY0RuRmZOWGdqNExhM2FXc0Vtdnd2WllYbEpybGtiNmxRYzU5cS9WRFh2RHR6b1BocTN0dEUxWXZMUDVTQ1czaVZKWExkZk9ibHlmZk9LODYxUDRTYTVNYmkxKzB4VFhVVEtaSlhsTzBzeTUyNFBVLzFyNUhHMVZpSkp1Tmt0ck0vVnNseTZHQ3BYalZVbTIzZVN0dFpYczlqNUxid0Q0QjM3UHREU0VLU1FKWkZISHV6YzFMdDBTeUNpMXRpcWdEL1dTRS93QTY2TFd2aHI0eXRabGpaQXBiY0kxUWo1eU91SzQrNitGSGpxSllKMzBlYVpkNFJvcGdZd0dZWkJiY1FOdGNNYWNOUDFQcHBxdkpwdnJ0dHFkUVBGMFVmbGhKYmRkbkdJMUdmcldWZWVJbmxsM0Y1Q3pIZ0FoZXRlbGZENzRXNmRlYXRxK21haGRXOFYxWVcvbU5hV002VHpYUkl5TUU1VlZYdVFlSzRIOW9LMStIZmgvUXZEMWpvLzJnYW9DejNqR1R6b3lqRGhmTlg1R0lQOTJpVkpTbG8wajFjdHdpeE9McDBYelhscmRLNlN0ZTc4anlXNThaV215N1Y1V2praVVsVVpqKzhJT0NvMjlEWGowdmlTZTlrZmJiQVlIT1pEMit0ZVF2Zjd5UVZBSlBYTmRicG9sY09ZNGl3VmR6WUdRbzkvcldzTkVmWnl5S2xCNlhldjNIYzJjMDhqQXFnVWdnamsxM0ptdnJpWU5KdFozWTVZbjczMU5hWGl2d0RxUGhiVHZER29haHIybkxZYXd3SG4yekdieWVNa04wR1FQVHZYbStxZUovRDFqZTI4V242bzEvQ3crWjVZaEU2dG5HT0NRUjZHcmV0ckh6djlwNWRoOFRHbHozYjZwWFMxdHF6MFpMMW80M0d4V0hJSTdacVNIWE5RREt3Wmw4bFFGQ0hIQU9meHIweSt2UEQ5djhLNDlSdTlOdFgxRFVwdkwwKzV0cmhSNUtRY09zOEk1REgxeHpYekwvQUcyRGtzZ0xZNUk0elM2SDBGNFY0WDVkSXlhMXM3MjdIZnorTUwrUU9za3piSEJ5cmNqNllyRjAzVHZDOGtjajdIV1p6dUI4eGxDSHVWQXJqWHZZR1ZpYy9OMjYxUlMrZ1dKU3NoM2M1QkhRMXlWWXVWbGRyMENHQXcwbnJUaS9WSDBWcGMraXk2YUxPNXRaTHFQY3dCRE1YK3ZIV3NpLytIM2hMVTRFVzF2cnVBOG5hOHpIYXg3Y25wWEJlSGRXdUxHOGl1TFNRUnpSeUIwYk9jRWYwUFFpdmF0VDhTV3VyM3h1YisxK3lueXlEOWpVQlMzcnRicDcwb3hiZXUxdDcvb2VmaThpaFp5cHAyNnJjOWIrRWcwTHdScHR4WXkyMXdYbW04eVc1VWVZSHh3dVZQSS9DdnJhejhVZUhiMEZyZlViY3NlcUg1V0EramNpdnpYdnZFbGhaUEdMVzhtdVlpaWtsNC9MWldQVmNaSU9QV3RhMThWYVRlaFk1SFVCRU96Z0syVDJKcjNzUGphbEtLVGdwUlh5WitPWnJ3bkNyVW5VaktwU25KNnUzTXZ1MFAweGE0dFdIeTNLSHZqSTRGUkxOWmtGVFBIK1lyOC9yZld0UmdVaUM1V1NNNCtWdVNjZWg2MXNIeFhkd3gvdkxGbE9lVDk1Yy9XdmZwNDdCelc3aSt6UHpIRjVGbXRDVGFoR3JIdkYvb3o3ckx3ZHA0aitJb0tSNVhMeG5rK2xmREVYaktGRHpiU25qcUNCVTB2eEJoei9BTWU4ZzRBcnJWU2gzUG5wVThXdEhUdDh6N2xsYUFuaU9BZkx6akJyTmtpalowWWlIajZWOFFmOEo1WjdTcGhsNTZja1kvS3E0OGEyd0traVU0R09wcTR6dy9Wb3luREV5VnVSbjNKT3NHQUdpaU9lK09ocVQ3Rlp1cWo3UEVmb0JYeGFQSDJtK1ZqeXB0K2VDU2VLb2p4M2FLNS9lVEgyeXdwODJHZjJraXVYRkphWGZ6UHR6K3lyRmcyTE9Mb2VvSEZaNThQNmR0WS9ZNHM0SDhOZkhTZkVOVTJrVHlqbmprMWZUNGpSN2lXdVpCeHh5UnpWM3czODhURnp4TzNzcCt0ejZ1LzRSdlRNbmRZd2tFZjNSbXE0OE42U2MvNkRHTWR0b3hYekszeEtzMUJJdnBRM3N4cEI4UklIWWs2aXlnK3B6U2J3M1J4RjdURlA3RS9tZlJ3OEphTzduTm5HTStncHYvQ0g2R3J0dXNZejZaSFN2Qng4UTdjb215OVlFWno4M0JxM0I4U0lXTGJ0U0E0NHp5U2ZTbHk0ZHJWeEQyK0srRnhtZXdEd1Q0Yzh6STAxT2FWdmgvNFhmNWpwNmowR09LOHFYNGpRYjFKMUZjRHJqQXpUMitJVEdSZHVwSVJ1eWNrZEtTcDRlVCt5V3NSaVkvWm1kblA4TS9EYkhJdEIvaFZKL2hqNGZLbkZ1ZjFxZzNqMU1sZnQ4VGRNRmNFVk8veEMya2dYTVoyL1QrbFY3S2c5UGRJZFd2RnZXUlRQd3gwQlhKV0VqRlU1ZmhWb2JuSURDclIrSXJsc0NTSWpISXdLbC80V0hKMUJpNllGVTZHSDhpUHJkZnZQN2pEYjRTNkx3VmR4anNlOVZKL2hQcGNnMmlSaDY0UEZieWZFT2Jwc2cvRTFkSGp1UlFwTUVKSFRocVN3MUZ0YUlTeHRaYnlrY0Mzd1pzaU9MdHdPMk9hcU44R3JZYy9hbTZjRDZWNjh2ajFHQS9jeCt3empGV0I0N2hjb0Rhb2NuKy9XandWSHN2dk5YajZrZExTMTdwbno5UDhBQlp0MlV1dXZXcUV2d2N1MlBGeGpnVjlMbng3WUJpR2dYOEc2Vkd2anpUR2NrMnh4Mnd3N1ZuOVNwOXZ4TTVaaFVYMm0vd0R0MW55OC93QUh0UitiYlBuM05ZVC9BQWMxb0t6ZWVDT2c0cjdLSGpYUjJMZnVHNmRpRGlveDQxMEluR3lRK25TaDRHSHA4elNPWk4rZnlQaW1mNFVlSUZBR1FjZGVLeUcrRjNpUGV1VXlCM0E2MTk4ZjhKWG9NbkdIQkk5S28vOEFDVWVIVllndTQ1end1YWF3RWZNaVdhOHM3TngrZWgrZjExOE9QRVNuaUhGWmNudys4UktQK1BjNVBzYS9STC9oSS9EYnRrWEpBSno5MmxmV1BEekVrWFNqSTkrYXIrelZiUnNUelZKdTZqOG1mbTAvZ254SUVPNjBiOHVLemg0VDE1UWMyYjRBOU1WK21KdjlGa0dGdTBJL0tvZytpdHdibVBrZHlLait6WGI0Mzl4cEhONDN0eXgrOC9Nc2VHdFZKYk5tL1huajBxakxvdW9aY3RadUIzT0svVUR5TkhZWTgySTgrbzZWRStsYVd5WUR3bko5UldmOW1TdjhmNERsbWlqdEJQNW41WkxwZDNubTFrNjlRdEovWms0WS91WC9BQ3I5UUU4UDZXV3p0aFB0a2MxTGMrRmROVnRqUXg5TThFVW5sa2s3ZTBYM0Z4emVMV3RKL2VmbFc5bElyUDhBSklPZUR6VVBseXFtN0xEanJtdjFCbjhGYVcyTXdKbjhLeUg4QmFNekRObXZUc0t5L3MrcmZTYU5QN1NwdS83cVYva2ZtbEQ1d0hEdU1FODVxVXozUTZUU2ZtYS9SYVQ0ZWFNWHdiWlFQVEZjOWMvREhTVElkc0pBSG9LWDFDdGZkR245cFVJeDFoSy9vZm1mSHBsNUkrQkVlZmF1amc4TTZuSWNCU09QU3ZxSVgvaE8weGdieUJ4OHZXcUV2alhTWWhpT0JSanBuRmFSeS9EeGZ2MTE4aFN6VEV1UDd2RHUvbWVTMlBnSFVKU3BiY3ZxU0s3eTErR2E0L2VOMU5QbitJOFNnN0hqSDA1cm1KL2lEZFNnaFhjOWVuRmJjdVdRdHE1SEc2bWMxUHN4Z2VrVzN3NjB1RjhPdzQ5Y1YwY2Zoenc3QmpjMGZIdm12bXlmeGhmU0g3cmZpMVk3NjlxRWhPQ0IvZ2FwWTNBdytHaWlYbCtZMVd1ZkV0ZVNQcnhIOFBRbjVDckhwd0tjL2lIUjRNQllzNDllSytOanFtb054OW9LL1RpcVR6enlFNWtrYkI5YUhtbjh0TkkwV1UyMGxXbEwxZHo3QWw4YVdhakt4eGc0NHllS3hKZkgwWVRLeW9NZW5OZkxpeE16Y1JNZU9DU1RXaXRqZXNBVmc1SjlPdFl2Tk1WTGF5OURWNVJnK3F1L005cm0rSWtnSi9mdnovZEZZc3ZqdWVSU0Y4d25Qcml1Qmg4UDZ2SjB0bUdmYXRtMzhHNnkzOEJINFZpOFRqcGRaZmNhZlU4dnBxN1VWYnU3RitUeFBmdVFCSCtiZDZ5cDljMUpzaktqOWE3eTA4QTZrL0JPYTZGUGh0TWNaQnpUalN4OVQ3TXZ5SWVJeTZtL2poOHRUeGYrMHI1MHkwM1BmQXFzcjZoTklRc3prOVFCeHhYMHJhZkRlTlI4Nm4yRlhXOElheHArb2FiZTZUOWtTNXRwdy83K1B6RlpUd1ZaVHdRZlNwbmdjY29OOGtuNUo2bFF6TEwzTkwya1Y1dGFIekNMRzluY2hTN2tBa2dIT0I2NDlLV3p0Ym9zaE1Ma2pnOEgxNjE5VjN2aGJVbDFtMDFDQzlpdEhRU0NkRVFBU0NUN3lnZGdhNnl6MHpTb28xRWpSRGFTVHlLd3BaZGluTjh5VWJkVzl6ZXBtbUVsUlRoTG1hZXFTMlBsS1RTYjk4c0xabUk0SEZNazBUVkNGQzI1WEk5SysySTI4TzdzUFBIeDZWRExmZUdsd2QrUm5zSzlTT1dxK3RXeDVkWE5uR1B1MEhMNW54eW5ocldwT1JDUms0NU5iVnY0SzFxVGhnRkJQYjByNmxieEY0Zmk2SVdIYk5QUGpqUmtJeGJkdTFkTHkyaXQ2dHprbzV2aVpiNGZsKzgrZW9maDdxQitZc2ZmaXRjZkRXWnlwWmlhOW1iNGpXb0RDTzFVWjZFbXNwdmlQR0ZKTU1lYzljMGZVOEdsNzB2eE4vcnVObHRUZi9nSnhVSHd4QVAzVzVJcmZqK0dOdXYvQUN5Sko5ODFaLzRXWS9IelFqSFNxa3Z4TmsyODNLSG4rRVVLbmw4ZXNmdk1wVnN5a3JXa3ZsWTZTMitHdGtvR1lFSTdaRmI4WHc3c3h3TGVQSVBZVjVXL3hKWjI0dW1BOXF5NVBpSmRlWWY5SW1JOXFhbGwvd0RkKzQ1bi9hVW8ydkw3N0gwZEY0RXNsd1NxY0FaNEFyVmo4SzZYRzN6QkZHTytLK1VQK0U2dUhMRE53Y0RQSnFvM2pLNFk4eFM1OXpSN2ZCSjIwOWJFUncyWVc1clhmWnlQdElhRm82UjRhYUllMlJWbGJEUVVYNWJpTGozRmZFZzhVMy9CQ0hCSEdXcXUzaVhVM0hLcmpQWFBwVXZGWWJwK1IxUEM0dHE3c3ZLNTl6dE40ZFZPYnFNa0RvQlVaMUh3N0VueWtFbjBXdmhUKzN0VTZGb3htckxhOWZsVkMzQzhqc0tGanFLV3pNdjdQeE11c1ZvZmNNV3VhS3VXQWJBSUJPT01tclNlSjlJVUFoU1FmZjByNE9HcmFtVng5c08wbkpHT01pcmtkOWRFQUM4a3lmUWdDbjllcDMrQmtSd0ZhTzg0L2NmY00zaWV5RFpXSEk2NHpXUkw0bWdlTnlJVUg0ODE4WlBmWExBN3J1VDZidUtpVzRKZGYzem5wL0VmMXFuams5b2ZpTllHZDIzTy9sWS9jLzREM1F1ZkEwVWdHQWJtZkgwQnI2ZVlWOGJmc3o1LzRWalpjay82VGM4azlmbXI3SU5ma09LbTVZckVOOWFzdnpQM0xEUVVNTGhvcnBScC93RHBLRkZPelRLSzViNkc1blhZekxhKzBnL2xXNmF3N2ovV3dmNzliWm93NzkrdDZyOGlxdndVL1IvbWMvTG5ONFA5MnBKbVBsbi9BSGFqYkJrdXVldUtkY0VlV2ZUYlhseTJtNzkveloyTGVDOVB5UitWUDdXRi9GYmFqNFZFaE94dFB1Tnd4a0VCd2VhK043cjRnNmJjd0xCQ1pQM1NLTStnL0N2cUQ5c2VKM3UvQ3pLMk50aE9DUDhBZWNWK1lQaG13dUxpYTRqU01rNVhpdnVNdXFOWUNsWjYyZjVuNTVpcUtuamNTMy96OWwrWjZMNGk4VHEwTW9WV0kybk9SN1Z6SHcxOFY3ZEsyaURKRFBuQjkrOWJXcytGOVVNVW1JR0h5bnI2NHJ5WDRWZUh0VXUybVNNSGFKV0IvQTg1cjFxRmV2ejZOL2NjbGJEMEhTZDBycnpQc2UyOFZYU3pJMFVPM2FCa00rUWUvd0NWZENuaW0vM3M1ampCUFVkcVhUUGg1cXhYbGdTMkJqRmRwRDhOdFE1MzNHMDlQdTE2a1o0bSt0enhuVHczSmV5T1BieGJxUUl3a0l3ZmMxV0hpM1ZVSUlNYXNUa0VBakZlaGY4QUNzTGduTFhaNUhJeFdrdndxWmdHYTlJNDdmMHJwNXEvVzV4K3pvZVI1U2ZGK3ZGdHd1a0RIK0lLYy9qVVRlSjlaa3dSY3FEanNPdGUyUmZDV3pLamZmU0hQcDcxb0o4SXRJVk9idVU0NmNnVmQ2dm1KVTZkL2VTc2VIVCtLdFllTmMzUDNSZ0VLS3hGMXpWWFB6WHpuOEsrb1l2aFRvWVE1a2tKSS92VmJqK0Z2aHRRdnp5SGorOGF5dFdmZjd6b1VLQ1c4ZnVQbDZQVkw1eG43VklmZmlvSjlTdmlPYjZRNU9DZDNldnNLTDRhK0Z3bVBMYmp2dU5XaDhPL0NTb0FZRDdjbkZFbFdlbXYza3FORk83bEg3ajRUZlZiMWNnM2svNFBpclVlcE85cys2NGtKNElKYzE5eUo0QzhJQ1FrMktzT001eldpZkEvZzRaMjJTY2pIM2FqMlZhK3h0elViWFVrZm40OTM1aEI4K1hCN2J6VUJtVmxKTHVTQWNndWNWK2hzWGd6d2lyTG15aTl2a3p6VjMvaEZmREJrQ3JZUmtaNitXS2wwYXd2YjBHbHFmbTR6UmsvS1dPUm5xYVJBT0cyay9uMHI5UEkvRFBoMUFBTk5pL0dNWnFNNkhvYXRsZE5pR2V2eUR2NlZDbzFHeStha2xlNStZN0FaSDdvNDlzMWFpaWtPQUlXd2Y4QVpKSXI5TGswelRJK0ZzSThlcFVDcnlXV25xT0xLUG4vQUdSbjYwL3ExVHlEMnRCNlhmM0g1bmkzdVNvMjJ6OERrN0RVZjJhN0RmOEFIbTVIL1hNaXYxTEVOb0FBTEZCejFJSGFsemFLNUpzNDgvaGlzM2hxcjJOZmFVRXRaUDdqOHZJOU52MlU3YktVbkdjQ004VTg2VnFaY2JiS2JPTWo5MmEvVWVONGN0aTJqQlBUR09LZGNxK1ZZeFI4QVVsaDZtMTBhZTJwcU4wMjBmbUtOQjFyR2Y3T253ZSsydFNMdzdycnhOaXhtQnpubGVlYS9SWnBNTm5hbkhQYitWU0xkQ1E0S3dManR3S3Y2cFVYVW1PSW9MVFc3UHpjWHd4NGt3TTZkTi8zelNmOEl2NGx3Mk5MbUh0dHI5SlB0KzBMaG9lT3ZUdFdmTnFDbjVqTEZrY2djY2UxSllTcGZjemxpS1VWMVB6c1BoUHhXY2Y4U3FZRFA5M3JWMWZCWGk0Z2Y4U21iSTZkQlg2RS93Qm94bGNlYkVEd2VvcVZiK0Zoa3p4Zm1CV24xYXIxZjRHY2NSUmIvd0NDZm42UEF2akRibit6Sk1kdVJVZzhBK05DQnQwOXV2QXlBYSsrMzFSRUFCdUVBSEdDUlVxYXZHbTRpOGpCenp5RFI5VnFkL3dLZUp3K3ExKzlId2czdzM4WmlOUzJublArOEtCOE5mR0tyazJQUWpQelY5NVByS3VBcHZJeitJcHAxdTMybk42cEJHRyticjlhaDRXcTF2OEFnYVJ4RkNLdXZ4WjhPRDRZK01XMm43TW1ENnRUMitFL2pRYy9abCt2bUFWOXlyckZvd3d0OG5Ua2UzdFVSMSsyVnlyNmdtT01iaFRXRW5hMS93QUNuaktIYjhVZkVoK0VmalZsVStUSGpyOS8wcUlmQ1R4by9BaWp4enlYNjE5dnJyOW1HT05TVUFkS2tmWGJWVkIrMmpIWVlwL1ZLcTYvZ1E4VmhtdmhmM253L0g4SHZHTzFneVFxTWQycEUrRC9BSXdremp5RGowYXZ0cytJOU9LSE9vZzVIVEdNVlFIaUhUMVZpMTl5Y1piRlY5VnEyK0w4Q0k0bkRLMW8zK1o4YnhmQjN4ZXpNUDNKeDZQU3I4R3ZHTFpPWXZsSEl6MHI3RVh4TnArY0xmdms0eDhwcEg4UTJPSEg5b01EMzROUDZySmZhSWVNb3QvRCtKOGRuNE4rTDlvRE5DQm5rNXpTUi9CanhYSTVDeVFjL3dDMWl2cjl2RUdtS0JtK2t6ampBcUpkYnNYQjIzYjhaenhUK3F0ZmFzWDlicFdWbzMrWjhucDhFL0ZaYmI1c0c3MHpuTlNmOEtVOFgvTUJKYlpIYkpyNm5sOFE2YUFGYlVaT091QWMvU3FROFQ2V0hPNi9rNTlRYVBxYzNyei9BSUZSeDFHK2tQeFBtSmZnejR1WU1mTWhCSFhHYWQvd3BUeE93ejlwZzQ1NzgxOU1QNHEweFRuN2JMa0gwUE5ReWVLOU1JdzE3SjlNSDlhbjZsTCtjZjF5a3Q0ZmlmTXArQ2Zpbll6ZmFZQU9oNjFFL3dBRi9FbkN0Y3haSFBHYStuVDRuMDRqQzNVdnplZ09EVmYrMzlPQVlpN2tKUFh1YTBqZzMxbVpmWG9iS2tmTlAvQ2xmRW0wL3dDa1JnNXowNkQxcHY4QXdwWHhIdUIrMXdFZXdQZXZwV0R4SnA2cWMzY25ya2cwNS9GT2t1ZUxxUTg0QUFJTlU4Ry81eGZYWWFmdS9rZk9DL0JQWHd3QnUwR2VueThHclIrQ0d1TXBiKzBJUU8rUmpIdlgxbG90bHErcStZMWpiWFVpcHh1YktvRC9BTHhydHAvQk0wVmkwMnJYSDJ0d3BLV3lrcGJxZjl2SHpTZmp4WGtZcVZMRHA4MVc3WFJhcyt3eXpBWWpHdGU0b1FlaWJlNzhrZmw5cTNnOXRQa0VhNmxITVFlU2crVVk5KzlYL0RkaG8wdXFRVzhrYjNNanNBcURnTWM5UGFwL0hyWEM2aE9BUWlCanRWQmdBZWc5aFdCOE12Ri85aCtNN1M3YTBOeWk3b3pHTUFrdDNCUGNWODg4WTZsN1BRL1Q2ZVJ3d2wxQ2lwU1M2OVg4ejl5L0J2aGpSN0hSUkhhMlVjUG1LTjQyaFhVNDVCUE9hK2EvRnZ4UW5iVUhzYkN3a2QzM1FMaU10dlZUZzhkT3ZwWDBINE4xcFU4TG04bm1pODY1a2tsV05YQk9UMFhqdjYxNXg0QzhQeTZQTmUzTWtobGxtbmxrWGZ6NVlrT1NGejA5OFZFcEpibkxoUFkwNTRpZGVQdEpRYVVJdHRKdnI5eE40SWUrc1RLSnJDRmpzSHp5U1lsM01ja2tjOEQwcnA3YXhhMWgxVm5kWkRjVCtZbTVjWkk1emtkdTFkQzl2YmVZN2lOVWQyTE13SExFK3RaMTNjMlZyRVpMbTRqampYbmRJd1VEOFRYTnpOSTU2dGRTcVNsYmw1ck5yMDFPQThTNmJOcm1teDJydjVKanVFbWllSlFESHQ1MkE5eG4xckExN3c3ck91MjhkdmVhdFBLaTVCRFlBWlNNY2dkU0t4OVorT1B3NXNIZUtPOGEvbFgvQUpaV2tSbDUvd0I0Y1Y0dHFIeDUxNjRKWFMvQ2V3SDdzbDNMajhkcTFuS25WM2VpZmZRNmFXUHFVMURsU1hLMjR0cGFONzJ1YW1sL0F1eTB5OSswV041SmJTNWNNeUFjcXd3UWZiMUZlUmVJL3dCbG03MVkyOFk4VVhBdG95V0VVcW1SVUovdURJQUZQdlBIdnhqdjBPMjl0N1JEbkFnaEF4K0xWd2R4RjR3dkEzMi94VmRZNnRtZnk4ZmdNVm5GMmIvZWZxZTFTNG56V2hLOEtrYjJ0ckJQODE1bXBvdjdIbmgrMXZESnJIaWdQQ3BHRWlDeEZ2WGNXSnhYMVpwSHcrK0EzaG1GbzR2N05CY1ljeTNJZG1BUFE4MStmVjVaZUg0M2I3VHJnbFA5MlM0WTUrdlBOY3pmYWg4S3JURFhGN2JodlhrNXBPVVphWG0vKzNUREU4UjV4aXZpeGJpcmZEQzBQdjVUN2wrTm1sZkNqeHA0QWwwZGZFR20yMGxxVExaRkhVS2tuOTNDOW1yODMvaGY4RFBCOTY5ME5jMTJKWFdRQ0ZCS0VCQy94RStudFdwcVBpejRSelFoSTUwenVBRExDekVudGppc25TYm40YXRxTjE1N1BNL21IY3ZrTWpCdmNjWW9UazROTG5TdjIvSThDRlp3clJuSzBwSjZPV3FQYk5kL1p0czVrWTZMcTBKY25LbnpBNEk5T0RYamx6K3p0OFRyY2Z1bGd1QmpqQklOZW94RDRaU0tQS2t2N2IvYWlMaGYwTmJ0dHJOcFl6Um13OGM2amErZ21KWVpIc3dwcUZkTFNyTC9BTGVqYytzaHhKVlNqZFFiWG0xZjdqd20zK0EveFRqaUpPbHhrWndjUzRJOStSV05EOEd2aUxQTk5BbWp2dWp6dU83amowUGYycjd4MDc0bC9FTzBKV0h4TnBXb2orNU1vUmlQcU85ZWcyZnh0OFdXb3pmZURCS0FPWHRwbFlFZW85YVRqaUUvamg5eDJVK0xad2V0Q0w3ZThmQ2ZoWDRBK1A3anpudTlQbXRZMWlabzNFZTh1NCs2bUIwejZucFcxYWZERHhOSnJDMmQ3SStuUnFqR1c1dTRXRU1aVWNaS2c1ejB6WDZNNlQrMGI0S01peDM5cmVhZVNPZk9oTzBIL2VGZlJ1aitNdkEvaUczL0FORDFhMHVBNjRLN3h1d2V4QnJhMVZiMjE3SFovcnJQMzFMQ0pLU3NtcE5PUG5xbmMvbnA4UitIOWQwZXpzYnUraWlXRzczTmJ2Rk1qbDBVNDNGVk9RUHJYQ2ZhWVhUQ3NPZXZZa1YrdzN4Yy9abzBuWG81NzdRR2h0Ynh1ZktQeXhPZllqb1RYNDFlS2ZDZmlUdzdxVTFycU5oTEJKRXhVbGg4cHgvZGJvUjlLNjQya3JYMVc2UDFiTHA1Um1tRTlwaHEvUE5LODZiVnBSOVZycDVuUzJ0NXFVYkFRM0RsZjd2WEFyMnJ3NXJWN0x0U1c1UU1TUnNrNFU1OSsxZko5cHFkeEcrVk9SM0JQWDhhNy9UZFppM2xTQXVlL1g4S2hwbm1Zckk2VGQvWnBYNnBIMTBMWFJMaVJVblpyV1h1VU82TSs0Tk12UEJXcGxBMEU4RW9QUWJzSDJydzZ5dlR2M2hqeU9CbkkvSE5la2FmcnJ3Z0JaekZKMlEvTWgvQTFwQ3ZVaTlKYWRtZkM1bndkaEswWExaOTFvelRIZ0x4Y21HL3M5aXZZajVoK0dLcHY0RzhXazQvczZVRURyWFlhTjhTOWFzTHdxbUVSanpDU1doYjJYdXByNm8wbng3QnFhb3ZuR0NYSE1UNHpqMlBRaXZvTVBPRlo4dk1sTHMvMFA1K3piS3NYbDhwU2NIS212dEpYdDY5ajRmVHdWNG8zSE5sTHgwNG9id2w0bFZzbXdrNmM4VitpQTFPTjB4OXFoT094SXBXMVJKRkNtYURBOUFQMU5lbDlUbmZjK1ArdTAyclcvRS9OYVR3ejRoQndMR1RnOUFLcXY0ZDE4S0FMS1Rucnh6WDZYcmZvejRFa0k1OUFBYWtkMHl4Smk1K25GUDZuSjlSckZxMngrWUVtaWEydUMxZy9vT0tqWFJ0V0pVZlk1QnQ1KzcxcjlPV2VOaU42UW5nK21LZ2p0NGQyUExqempQYXErcFNYMmpOWTZIU0g0bjV1dHBlcERZUHNjZ1BPZmxyTmwwNjlEWSt5T01IUDNhL1RnMnNIQjhxUEhjOFVxMk5zeS84ZThaejZnZm5VdkJ5dDhRTEdRNXRqOHZmc04wc2cvMGR6MjVYMXFwTkJjaVUvd0Nqdjc1WElyOVQwMDZ3d1I5a2lJNS9oR2Fycm85anU1dEkrbWVncVZncGZ6R2p4OExmQ3o4dUlvSlFjK1U0T2ZRaXJXeHlqRVJNQUQ2RVYrb0V1ZzZTeWsvWVk4OEVuYUtwSHd6b3JxQWJGQmp0Z1ZMd2tyL0VPT0t2cnkvaWZtTkVtQ3hDc0NPYzgxSGNNQXNSeTNJT2VwcjlNejRWME1NTTZlaEE3SGlxTS9oRFJEejlnWEdlbU0xWDFTcDNSYnhjWDluWS9NM3pueGdGeCtQV3RHU2VkSXdXa1k1N2hqWDZLcDRKOE9iVHVzWS9iaXM1dkEvaHgzTzZ6US9oVXZEVlNQcmRQVDNUODYydlorQ0o1RndQNzFLbHhka3FUZFNESjZiajJyOUNUOE9QRExaUDJRVXcvREx3MlFUNUhIOHFmMVd0My9FbFlxazNxZm5rOTdlYmMvYUgvUG1yZjIvVVZYaTVjY2ZuWDNlL3d0OE1TQlNVWUgwclBtK0UzaDkzQlhJOXMwZlY4UmZmOFMxWHcyK24zSHcwTlkxSVNObTZZanRRdXU2bUNNWFI2OXdQeXI3U2srRUdoY3R2Yko2WXJuWCtEMmwrWnhjTVBwVit4eFBkL2VONGpCcmUydmtmS0oxM1dpM0Z5bzQ3ajlLZWZFZXJoZ1BPUTlBZU9LK25uK0R0ajgySjJBck1Qd1poRDd2dGpFZWhwZXl4VjlHL3ZNZWJCU2Qyby9jZk9aOFM2c0gycThaL0NwUjRxMVFBQTdPdmJ0WHRFbndnazVJdWNIUEdheFpmaEpxSUpDemdyOWFwVThldHViN3lYTExtOWVUN2p6WC9BSVN6VUZZbnl3ZVBYdFVzWGk2L0xFR0lZSFAzdjhhN1p2aFJxdzNGWmdBTzVxb3Z3dTF3Rmp2WHArRkhObUMvbkpjTXFrdFZUTUJQR2x3dUQ1SE9mNzFLZkhFNjVKaGIzd2ExcGZodHJaQkh5WnJGaytIUGlCUTJJd1FEUzlwajdhOHh2SEQ1ZGJSUXQ2bGxQSFJJL3dCWElLMnJyeDE4c1kvZWs0Qjkvd0JLNUZmQVhpUEsvdWNETkxjZUMvRUljLzZPY2RCVFdKeHNlNitSSDFETFpYMGl1K3AxVWZqL0FNdmt2TCtKTlRmOExHbUtqL1NwQmcrcHJ6Q1h3bjRoUkNUYXRuK2RZYmVITmRRSE5vMmZvYXI2N2pGcnI5eFA5bVlCN1BUeWtlN1FmRWU0RzRtOWs0NkVuTmFRK0o4NC93Q1h4dnhyNXpPamFzSTJCdEpSejNGVUcwcTczRVBBNEk5cVA3UnhYVkw3aFJ5ckIzZXN2L0Fqeko1N2h6eks3ZTFRTmF6eU1Dc2JuUHNhK3dyZndQbzF1QVpabEhmdFd2OEEyZjRYdHNabmpKOWpWTExLK25QT0s5V1U4M3dxWHVRbkwwUjhpMitrNmhJQVBJNjlPSzZLMThLNnZNQVBLSUhyaXZxSk5YOE4yeTRWQTNweCt0VTV2RzJteEg1WVYvRnE2WTVkaG82enhDZm9ja3N6eGMzN21Fa3UzTWVKUWZEL0FGTjJ5d1BQYXV4dFBodEl4K2R2d05kTy93QVFvUVNRSTEvSE5jN2VmRUNjc3dTVDhoMHF2WlpYQmF5Y2pDZFhQSnlYTENFVjEvclU2bUQ0YTJlQVdBeml1bWk4RmFIQXVYWmR3OVdGZUZUZU9iZ2cvTkllM1dzU1h4TmVTQVlVNHoxSm9XSXk2RzFHL3FYOVd6V2Z4VjdlaDlQUmFUNFlnSUpNUjUrdGE0dVBDMEM1QUhIWEMxOGF5YTVmc2Y4QVdLS2diVkx0MFA4QXBCOXhUL3RHaXZnb3BmSXgvc3JFeWtuUEVOL00reXYrRW44UFJxZGtiRStuRlowL2pyVElodGp0aytwTmZGWnUyY25NNzhuUEJvODFUL2ViUDFyS1dhMWVrVWplT1RVcEpxVTVNK3ZKUGlNa1krU0tJSDNOWU56OFRiOG41SlVUanNQU3ZuQ0JKV1ViWVdPT3VCeFdzdG5mNXlMYzRQdDYxbTh5eGJWMC93QUM0WlBnWSs3eS9pZXVQOFJ0VFpUbTVQcHdQV3NXYnh2ZU5nK2ZJM3RYRnBvbXF2d3NCSEZXYlRUN0N6MVN5aDFlZjdKYlhMTW4yZ0lYMlBqaktqa2duaXVLcGpNWW91VGNySG9VOHZ3WE5HTVlRYmZvUjN2aTNVcEltQU1uUFU1NlZMYjY1ZU9jNTRJNHlha2ZUTEcwMTJPeHYzZEV1WW1OdEpIR1d5NCs2RzlBZld2UnJMd0dDaWZ2OXdCUEk5UFN1YW5VeFZhYnR6Tm83SjBzSFFvSnRSaW5yOTV3YTZ2ZWdIOTRGOU1WRzJwWHU3bTR3Q2ZUdFh0Q2ZEMkZ5T1hiUDRWcE44TnJjQmYzVGRCem12VGpoY2JMby92UEgrdTVjbmJtWDNIejFMZXprL1BjdGpzQjBxdjVxYnVaM0ovM3ErcHJiNGFXUndUR1RqOHE2Q0g0Y1dFYmY2Z0UvU3RQcUdMNjIrOGlXUHdmUjM5RWZHKzVDM1ZqK0o1cVZWeUcvZE0yZTJDYSs0SXZBdGxnRHlrQjQ3QVZwanduWVJBcnVpSHJ5UDFwL3dCbTFYdkpMOFNIbW1IUzBqTDdqNFhqaWtPM0ZzNVBIRzNyV2wvWjJvdG5iYXZnKzFmYmFhSnBNWXkwc0trZjdRcTE5bjBOU0NibUFldlBTdFZsVXV0UmZjY1R6cW05RlRmM254TEhvV3JzdWZzckR0NlZwUmVHZGZNaS93Q2pkVGpPYSt6MGw4UG9mK1BpUDhCVS93RGFQaHhYSDcvT1BRVnFzdFMrMlpQTkxwMnBueWJINFAxb3lJQ2dBSXdhdkR3RnJicmt1Rng2OTYrcWw4UWVIa1laTDhlZ3AzL0NXYUJqR3lRNDU1QXEvd0N6Nk45Wi9pS09ZVm5IV0tYeVo4N3dmRDNVMmpYZE9Od1BYYldtZmhyZGxjRzVPTWs4REhXdmVUNHcwWlV5SUNmVVp4bWtIamZUT2d0K25UTkR3ZUdVdmkvRVByMkpjZEY4N1dQRVI4TVdMZ05PNUdLNkczK0Z0cXFBdk0vcDE2L1d2UkpmSGRwSGpFQStnTk1ieDNEc0cxWXgvTVZ0OVd3YVd5Kzh3aGpNWTIvZSs1STV1MytHdW10d3djZ2RlYTZ5MytIR2pnSE1CUGZ2V1VQSCt3WjNSWk9lcEdLUWZFb0lvemNSQTkrbFM2T0dYOHBwS3ZpUDd6Zm9kUDhBOEsrMEVPcE52a2dlbFY1ZkNHalJLZHRvbzJuT2Nacm1KUGlFcnZrM3lBYmVBSzUyNjhjUnVoSDI0RTU3WnJWUndpVjI0bko3WEd1VnVTb2ZxLzhBQWlDR0h3TEFrU2hWRnhQZ2Y4Q3I2ZHpYeVA4QXM3M1l1ZmgzYVNoOXdhZTQ1LzRGWDFyWDR4akpSK3VZbmwyOXJPMzNuOUFZZU1saGNOemIreHAzL3dEQVVPRkdhYUtEWEZmUTZTcE4vcllQOTZ0anRXUktNeVErelZyVldIK0tyNnI4Z3FmREQwZjVtREp3OC9IWEZFMmZKYi9kcnh6eFg4UzlDMEhXTG5UNW9MbVdlTzBXNmtNYWpZa2JFZ1paaUJ1T09sZWs2WnF0cHFtalc5OWF1WGduaURvU01IQkhmM3J6cEpwUzgxTDgyZGNIZmxhNk5MK3Z1UHloL2JEbEF2OEF3MHZmK3pKajlmbkZmRFh3OWEyajFTNExzQndoUHRnMTlqL3RsWEFYWC9EQ0ZlRzB1Ym5QVDk0Sy9Odnc5cWswRnhjRVpCSVVIdlgydVd5NWNEVDA3L21mQTRtTGxpY1NyMnZVbitaOXArS3RYdFJhekJaT1NwSEFyaWZoRGEyZHZvM25nY3lTdVNSMzVyNTQxL1h0Umt0NVJrRDVHd2V1YXovaG40czFNNk05dWx3RkNFN1J0QjcxOU5oc1hTZzNlTDJQbmNYZ0tzNmF0TmVwK3F0cDRnMDJQYUZWc2oxcm9sMTJ6WldPRG50azE4QVd1c2FySS9OMTBHU01EcDYxcnRxdXBBZjhmMG1EMHhpdTc2MUIyYWl6eXZZVm8zakthdXV4OXJ0NGl0bEFIbC9qbWwvNFNhSVlBaUJ4M3pYd3UycDZneWpONUlTRDNPS2pOOWVFNCsxems5c04ycm8rdFJYMkRCWWVyZjR6NytUeGJBRVhkQUFmcmdWYVR4QjVzTnhLR2dYeVZCS3MrR1lFNCtVZHpYNTlOZTNwL3dDWG1ZNDlUbXE3eXpNMjR5emV4M0htaDRtUFNKcXNQTjd6MFB2R2J4anRCQUVlZjFxa25qS1VmTjhnOUsrR25rbGRlUE9PTWRTVCt0VkZpa3lDSXBqejcwMWkxYTNJak9XR2Y4Nys4L1JmVGRmMVhVSlZodElQUGtLbGpIR2dadHE4a2dlMWM5ZCtLcmlOMkhuUm9BZWpEQkgxelh6OThQdkV1cytGdGJoMVN3c1BObVJXVXh5S3hWa1lZSTl2clhXL0ZmeGZjK0xiRFNWdHZEY3RrOXZLOGt4Vk9XTDlnUU1sZnJYTExGMUkxVis3VGkxOXgzZlVxVXNPbnp5NTdyUjlVenVuOGN5OHFieUg4MXJMUGpmYVNQdGlaN2ZPSytSRTBUVkdmUDJDVTg4ZklhMEI0ZjFWei95REpXSGJFWjRQMXJaWXlvbDhLTWZxRVUvaWJQcUJ2SFNzaEgyOUY5dHdGU1IrT1ZWeGpWUmpuZ09LK1hCNGIxMW14L1pjeDc0MlZ0eCtGUEV1M2pTcGV2T1Y1cWZydFJieFF2N05oZTZVdmtmUTBuanVNS2M2c01ucjgvTlk3K1BZV0JYKzFSeC90R3ZHcFBCL2liQVA5bFNmbFVqZUIvRmhJLzRsc25JSFlWbDljcStSVXNCSFM2a2VxcjQ5c3dyYjlWQnoweVRUZitFK3N5dnkzN25Ib1cvU3ZNditFRDhYa0EvMlpKK2xXMCtIZmpKbHlOUGJIdWNWRHhsWTFoZ3FTMmpxZWpueDVDNnFUZlNjSG9OM1NxRW5qeXhPNGZhNWl1ZlJqWE5SL0RMeG8vSDJMYjY1WVU4L0NueHdXSit5THgyTGMxbXNYV3ViUEJRZXZLL1Ezb3ZIZW5LUDlmS2Mvd0N5MVN2NCtzaExJU1p5Q3ZUQi93QWE1cGZoYjR6M2d0YW9BdnExYksvQ1R4aklGL2NvTWp1ZWxYOWJyOXlGZ3FkLzRhS3NmanUwUmxhTnA5NDlRYWpuOGNXNVl0dGszRVl4ZzlhdWY4S2c4V1orN0YwNTU2NHJRVDRTZUpTcFg5MXoxNTZZcUhpc1RlOXpTT0JvVytGZmVqbG04ZXdBOFF5Wks0T0Y0L25WVlBHa1dRMzJlVWtBK2xkZy93QUcvRXpsUUpJK240Y1VrbndaOFNKdEJtaTVHY2cxUDFtdSt2NEZQQjBVM2RmaWN6SDQydHd3YjdQSXd4MDRGQjhieHRuL0FFYVRya2RLNjJQNEwrSkhYSzNVUXgxRlBId2E4UUtjRzRqYjF4VmUzcitmM0RXRW9LUHcvaWN1M2pzdGovUldJSElCSXpURDQ3d1Qvb2JjOC9lRmRsL3dwYlhqZ0c3aUJQUWQ2dFEvQTdYSDVOM0RrOGZTb2RhdDNZNDRhSFNLdjFQT3o0MmJ6VlpiVndjNXp1SGFyRXZqcWJrcmJQbGp6bHgxcnZqOEV0U3lxbS9peUR5Y2NWcWo0SVhSSy84QUV6WHB6eG5OUDIxZSs3RThOUjYyKzg4cFBqNmNCQjlqSklIWGZ6bW8zK0lFMGdHYk01eHg4OWV2dDhEcFhYNU5UQStxNC9DckkrQWN1QXgxWmVmWVpGVDdhdDNhK1Jhd3ROclN6K1o0Wi93bkZ3Ri80OGw1N21Tbm40aDNwUkFiUUVMbkh6bjZWN1dmZ0k1UE9zcVBjcVAxcXdQZ0p3Z09yam4wQS9XcDlyV3ZxMmJMRHhXeVgzbmdqZU9iMFJFL1pJL3A1aHBnK0lGNFZ4OWlpNmdaOHc0cjZDaytBa094YzZ3Q1RuNWVBUi85YW8wK0FGcHR3ZGFVOTg4ZmxWKzJxUGRzU3dzYjZKTFR1ZUFEeDdmQnNDeWlCSHBJYXRONCt2M1JsYTJpQnh3QXg3MTdpUGdOYUE1T3NqUHB4VjVQZ0ZaWTQxbmN3OU1FVm5LcFY4L3VIN0NOOUhIN3o1dmo4YjZpV1gvUklUZy8zalg2UGZDbndIb1BpbndaQnFkK2s2WEUwc2lueTVTRndwd01Ddm1wdmdOYlJsU2RhWEdjNE9PUHdyNnYrSDcrTXZEWGhxejArejArMzFHMFM1a1ZKMWJiSXFzY2xwQWVDQWZTdVRFVnFzS1NhY2xxdFVldmdjSlNkVnBxRDkxdXphZjVseS8rQUZrMDVhMThRWGtJUDhMeEpKZ2V4T0t5UCtHZTRCS0drOFEzVXFqcXZrb21meEJyMCtQNGllSUlQRUthZHFIaHFTT09Sd3FYa0V3ZU1BOEFzcmM4bnNLK2lvVzNMODNXdk9qaXE2V2xTWDNudlN3bUg2MEtlMjZpdjBQaCs0K0NXa0lwUDIrNkgxd2E1Vi9oQnBJZG1OOWRkZXU0Q3Z1N1VvRU1UY1lyeWVSSkF4SWJvY1k5cTY2ZU14SDg1NTlYQlliL0FKOXE1OHRQOEs3VlNjWDAyQjArYm1zNS9ocHA2c1AzOTBlQi93QXRCaXZvdlVKR0RFRTRJcmlOVzFLMXM3TnJtZVFSeG9DU3pIL1A1VjZrSzAycnRuaVN3MVBudEdMdmZSSThVaytIdWhvak1iaTc2bmNONjhWeStqYUQ0S252M2tuMWlXQ3l0bXpLek1DOCtPcXhBZnExZVJlTXZpRmQ2bkswRnFHUzJ5U3FBNGFYM2Y4QW9LM3ZBdncrOFFlS2JtUDdOZzI2S0RjVDhnSVR6NVl6MVAwcmd4R08wY1lTMTdyOUQ5Y3lUZzZsR2k4WGo2bnNvcFhVZE5QVy9VKzU3YjR1YVJQcVdtNlJvdW5NOEhDRWpLWVgxQTl1K2E5SDhReXpMYXNzaVk0T005eDdWUjhJK0NOQzhNMlVaRVNMY1BuZVc2cjdBbXZEL2lyNDIxYlVMaXgwN3c1YitjODdtSmJuT0VEZzlNbnNPNXI1MnBCelQvelBkdGdLK1lVcWVDcE9GT0NmUFZuTGRyWG1aOFEvRW0yRWw0ME1MRHpDeEJBNTY5dUs5aStGM3dlajB2UzExUFdZa2E0dWhpTzNrWElSQ2VvNzViMXJKczlMajBhVzd0TlF0cmJWOWZtbUNSN1hjQzNYcVhVZ1lKelh1RCtJOU44Slc2M092MzZ5WGNpZ1FXVU9aSEhIM1ZYcitOYzhLVGo3cTFiZWg5Rm5HTnBVOE5IMmNrblplLzFta3Q0OWw1cytsZE9zNDhvVERHaXFBSTBWUUFvSFRBSFN1UjhWZkUvd2I0YUppdTc5V3VQNGJhRWViS1Q2WVhwK05mSDJ1ZU9QSDNpWUZMZC83RDA0bkdGTzY1a1gzYm91ZmF2SDViandqNGIzNzJEWEJPNXZtTWt6azl6bm11aU1lOTIreVB5U3BYaTVheTYyUGROWStMdmozV1hLNlRwMGVsd05uOTljZnZKaVBVS09GL0d2R3IvU1d1ZjlKMS9XWnIzK0kvYUp2a0I5bEdCWGdtdmZHSmdqUTI4U1dvSndyTjg4amY3cWl2RnRkMXZXSjFGMXFNOGRqR1FNUzZoSnRZai9BR0lSOHgvS3RGR28yK2k4aUpWa2xxa3ZVK3NadkhYaERURkVkdENKam5HMkZmbFBwazhDdlBOVitOTTBJZFloWjIrQmhjL093L0FjVjhMNmw0NjhMd3NZNHpmYXN3NkFuN0hBVDdLdVhJK3RjQmY2ajRvMVpsOG5UNExDRUg1QkhINVl3ZlZueVRXTW9RVHUwdlY2aVRsS1NTNW11OXJIMXhxZnhWMWk2UWtYbDFKM09DSUVGZWF6K0paNTR6Tk5ydW5Xd1lINVpwbW5jZjhBQVZ6elh6d1BDOTdjU2Y2UnFJZGllVlFtWThmVGl1aXRQQ3VnUU9yWFVXb1RML2RqMnBuOFRuRktNcWQ5WDkyaHBPRlhrYWo3dlcralozbHg0bjBCbzlzdmkyNmJqcGEyT1B3QmNpdlBadFUrSDd5TVo1TmV1dlRjOFVZUDg2NmVHVHdqSElWdGZCWm1ZZDdpN2trUC9mS0FDb0w2KzFLSmsreStBckJWOWZza3MzNWttdTJLbzIwNVB1YlBCcUxGNnZrclcveFFpdjhBeVV5Tk4xZjRmTHFGb0lkQXY1WDg5Tm5tWHdBM1o0eUZYMXJvdkVuaUh3V25pSFV2UDhQWGlYQXVHRXJSYWdkcFlIQndOdlNyK2thMzQ4anZiUUw0VXRJRWVWQnZHbEtOb3p5UVdIR0sxOWUxVDRqM09yM3Jqd3REZFJyTXdXVTZTdjd4YzhFa0RuSTcxdXVSNlgxN0tCd3Qxb3BUa25HSzB1OFJKYS9rY3JaK05QQThJWGJCcmtKd2M3TG1PUWZodUFybzM4WStGTHlORmJ4RHJGdHRJd0piWkpCK0pRMXlzbXJlSlkyUDJ2NGZXRER2blRKSXorYTRyRXVQRXZoWS9KZStBYmVOczhtSzRuZ0kvQTVGVEtFZTZYcW1qcnAxcXphU2hONmJxY1pmbXo2RjAzeEhwa3dTT0R4aHBzM1lmYW9XdHlmeGNWNmJaM3V2RFkxb0JMR3Y4ZG5kQitmWUFuK1ZmRWl6ZkNtN0NoN2JXckZ2V09XTzRRZmd3VTFkaThLZUdKWE1taitPTFpKUDRVdTQ1TE54N2JodVhOWXVncjJUVDlIL0FKbHh4RW94MVVscGYzNmQ3Zk9Ga2ZlMWg4UjlmZ3VrdGJtY3BHY2paZXdBZysyZURYcVZ2cm5oNjcrYTc4TnhCKzF6cHNwUng3bGVEWDU2TEQ4YU5JZ0xScytwMnFnSEtNbW9Sa2ZodVlWWjB6NHYyME1xeGFub1Jna1E0TDJyR05nZmVOK0t3ZUhjWHJwOHVVNklZbU5UV0xpN2I4a3IvZnNmcXhvR3ZhckRKdDhPK1Bab3BmOEFueTFOZDJQOWtGc1Y3SEw4UmIwUnh4ZU9QQThWMUJIOTIrdFl4Y1JnSHFTaDVGZm5Cb2Zqend0cmFySEhxRnRkTXcvMUZ5UEptSCs3dTRKK2hyMzNSTmQxaXhZTFlhdExBby81ZEx6OTVDUjZLVHlQcldVNE8ycXY2LzVvOUNuaVowNXhkT3E0eVMzVGNaTDVvK2w1Zmc5OENmaURDOG1qVFJXOHhRODJ6Q04wYi9hamJxYS9PTDRpL0IzeHA0TWtsU2V6YTR0Rlk3YnFKY29RT2hKN0g2MTlRNmhxWGhpNW5TWFU5SnVOSHY4QUs3ZFJzSDJvVG43MjVlUHdOZThXbmpIeDFvbG50MUtDSHhab2tnMm1aQXBuRVovdkwwZXBpN05XdnJiUjdmSm42UmxYR21ZNFdwR0dJazhUU2VqakorK3JmeXkvelB4bzAzVkw2T1pWUTVEZmVWampOZXZhWGZEVUpnaXg0Zk9DRDYxK3JWdDhPUGdOOFI3ZVNmVHJhT0s0MjdYaWliN1BMRzMrMG5xSytGZkdIN1BIanZ3MTRnUWFYYlM2aGF5U0FSeVJjTUIvZGZQVDY5S3Q4dXQvZGZtZnNHQXp2SU16aktFTVE2TlZLL0pWU2o5enZabmsrb1dXcGFWT25uUUhrQmlOMlJqMUJGZXllR1locTluZFBITkdqd1JoeEU3YlpHQi81NSs0cjdOOEdlQi9CbmlUdzFDTmN0SGkxT3plT0dZeDhnTUR3U3FraGhqN3g3VTc0a2ZzL3FnTng0WGpsS0MzTXp5ZWNHUnNkRmpIYXJpdWJyOHo4MHpENnBMR3lvdWJwelRhdkplNjdkbnMwK2g4YVRhM3FtbmJmTS9mdzV4dkl3Nit6ZW85NjNyRzUxM1VnUlpXZ21EYzRqbmkzZmtXQnJ5KzIxbTRzcnFTMTFCTnhCMjdzNUFZZGMxdjZ0OE5OQTEyRkhrQXM1SkFESGVSTGt4azkyQzQzTDZqclhxVWN5clU3UnFTYnRzejg2elhnMmpPY3BVNmZzMzFzbloraVBWdjdCK0pTWWYvQUlSWFU1QmpJS3hCeGo2cVRWSFVIOFg2TlltNDFMUXRRdHJkaUYzeXhiVnllbVNEeFg1N2E3cUh4SitIMnRtd24xblVMUmlvZUNTRzdmeXBvejkxNHprZ3FmMHJZbitPbnhGMURUVzA2ODhVWFYxYVNiUzhVekJ3U3ZJNUl6WHFMTVp0YjJQZzZtUXhpMUc4Wlc3NmY1bjJOSDQ1WGFCbCtuVGFUaXJZOGR3WUF6SVBmYVFSWHduYitPci9BS0VSUGc5eC9oWFV3ZU9vc0R6YlZjQThsSFA5YXBaalBwSTRKWkJKYlU0djBhL1UreVg4WnhZVEVyajhEelhxbmhuNHE2Slk2VDRndGIxWGFTN3Rnc0VnVWtvNm5qNkN2Z3kyOGE2TTdEZWs4YSt1QTNYNlYwa2VzZUdybmFWMWFKR3owa1ZrL3dBYXA0NmNrdmVUL3dDQWN6eWhRbmYyYzAwbnNyNzZIMFYvd3NDRkd3YmwxR2M4RTgxYWY0andiTm91bVVFaitJNXI0VjFmeHQ1R3FOQlk2YzkyUWR2bUFuWVQvc2pxYW8yL2o2MWVYeTd1d2t0bUJ3Y2NqOFFjRUVlbFgvYVZUbVM1bGNpV1NTNWIreWFYeXVmZXcrSkFBeDlyYkhiNXUzdldnUGlhK0NSYzlqakxacjU3MDNRcjNWTFFYVm41ZHpFdysvR1EyUFlnZEQ5YWZONFcxNUVQK2d1ZmZ0aXQxaks5L2hUK1J4TEFZWmJTYWZxZlJFWHhOZVRCZTk0eDBCSEZURDRtU2JSdHZNZ251Ulh5MmZEdXQ3RG13YzU3QVovS2h2RDJxcEdRTlBsNmNqYjFwUEcxci9DdnVLZUNvMnNwTmZNK3J6OFN5eWpiY0lNZGppbUo4UjV0K2Z0RWZIK3lEWHlCL1l1cGc1TmxJTW4rNmFiTnBlb2JNZlk1Q00vM1RtajY5VnY4Sys0eC9zNmt2K1hrdnZQdEJmaWF3VTVrVGQyR0JnMVpoK0pzZ3p2OHY4dU0xOEh0cDk2Q1A5R2w2OGNHbUMxdkNBcHQ1Y0QvQUdUeFd5eDhyZncwQ3kySC9QeVI5N0g0bUFNUGxqUC9BQUhpclA4QXdzMGtnTEJHUVBhdnoyYTN1QWNlVk1NSHB6UWZ0U3BqTWd6MnlSaXErdnQvOHUwTCt6N1gvZVNQMEZmNGxaQUhrUjQ3NHpUNHZpSEF3SmEyVHAwNUZmbm1acmtIaHBRUU9mbVBOTk4xZTVMZmFaZW5BM0dyV1pXLzVkSTUzbGNwZjh2bWZvbi9BTUxDc01qRUM4OWVlbFJ0OFE3RXQveDdqSHJ1NjErZGFhaGVEUDhBcE1oUFBVK2xQVFZMME1QOUpjRVk3MWY5b3BhK3pSazh1bmF5cXY3ajlGUCtFMTB3a1pnNjg0QkZUUDR5MFRqTWVDZTJSWDV4TnJHcEJpZnRUVkcydWFvU1A5Skp4anNPS3RabkhyVE1wWlRYdmRWbGIwUDBmWHhqb3JEN2pEMVBXclMrS05DZHVHSXlPbUsvTm9hL3FRd1BQQjY5cXRSZUlkU0FHSEhQdFZMTTZYOGpGL1pkZGY4QUwyTCtWajlKWTlmOFBsRy9lc0Q2N2FhTlYwTm84L2FRQWU1SEZmbkUzaVBVRGs1QXdDZlNsUGlYVXZKNnJqdHlhRm1ORytzV0U4dHhUalpPSitqUzMyZ2s1TjZuVDBxNUpkYU5JZzIza1pIdlg1clJlSzlRUWRRY0QxclNIaTYvS2diZXhQV24vYUZCN3FSenJMTVlvNk9CK2hESFJUL3k5UkUrNUZWQkJwN1BrVFJZSCswSy9QNCtMTHpkbGtPZnJRbmplOUFaU3A5UVFSVzBjeHd2YVQrUkg5bTQxMjk2SzlHejcvTmxZeUtSdmpPRDZqbXE3NkZZbkJLdzgraEIvT3ZnMVBHZHo4NUtzTTk4ODFlVHg1Y0tvQnp4K3RQNi9nK3pYeUpubG1QdnVwZjl2TThNdWZFV3BNM0xjKzV6V1RKcWQreEdad00rZ3IxKzArSE4zSmpPZW5ldXBoK0dRQlhlUjcxNGF3dU9rOXBmTm4xcnhtQXB3K0tOdkxVK2VQdE1zaW5NckhIdWY2VWdSblVBUk0yT3ZXdnJpMzhCYWJDcDNGYzQ1T1JXdEhvR2dXNHl6eGo2bXU2T1ZZaVc4b3IxWjU5VE9NSkhaU2w2SStONHJPOGNnQzNkZndycUUwalZab3dSRGduaXZySkQ0V2dQenpSL2dBYWRjZUl2REVXTmlaeDZBVlg5bTA0dTA2OFY2R0R6bHlpdlo0V28zNW55eEY0VDFtUWNqYVRYVzIvdysxTjBBTGdqMXIyWi9HbWpyMHR4L0txOC93QVE3Tkl3RmpYQUI1clQ2cGw4UGlyODNvWnh4dVkxTnNQeStwNS9EOE5KZHczRTQvR3VxaCtHVVdCbit0VUpQaVk0STJPby9ETllrL3hIdldIeVRzTWRjQ3RQK0VxSzJ1UkwrMlp2UnBIcGxyOE9yRkNNcURqT2M5NjMvd0RoRHRKaVVjUmpIclh6akw0NjFObE9acFQ3ZEt4SlBGZDlJQ0dhUTU0KzlpcCt0WmJIYWpjem5nczJtdGNTNCtoOWdXK2g2RENuenl3THU3Wkhhbk8zaFZPR3VZampzQlh4YytzM0RqdWZUbnRXZkxxTjBjNFpSelIvYWRDUHcwVllGazJLa3ZmeE1tK3A5dERXL0NNUUFERWtlZ3pXVGVhOTRUazJGb0ErdzVVT0FjRWR4WHh5dDlkYmMrWjE5QlZsV3ZwOGhKV2NnY2hSazQ5YTVKNXJLOXZaUnQ2SGRUeVpMVjFaMzdwbjFyL3drR2lYc3V4SW9sWmhoWGw0QXg3MVN0L0d0bGJSK1Vsc0R0NkVuZ212bDYyMCsvdWpLc1Fsa2FKTnpnYzdWOVNPd3FTMXRydVJjckU1S25CNjhHdVJabFVjN3FLVHNkanl5azZUVXB5YXZmVm4xVWZpT3lENVlvbHo3WnJIbStKbDB4enZRWU9BQUs4Q2JSZFNiQjhsaitGVE40ZjFqZGtXekVld3JiKzBjVzNwK1J5TEtzRW5kcjcyZXlTZkVxK0tuL1NjRDBGWmovRWUvazZYY25YSEdhODhUd3RyYm4vVTRCSGV0YUh3YnJSeVNBRGltOFhqcGZ6ZmNOWVBMb2RJL05tOS93QUp0ZmtuTXN4OWozckxrOFlYVE1NZWFjZFNUVThYZ1RXSEJ6S28vQ3RlUDRkNmllc3dGTG14N1gyeWVYTE92cy93T1ZmeFBjSE9Jeno2dFVKOFJYWDkwRDMzVjZISDhOcHk1M1hIRmE4WHcwdHlRSG1jK3VCaXRlVE1KTDdUSXZsaWYyRHlFNi9xQXhqWitwcVJkYXZpU0RLZzdqQXIzcVA0WVdJVVlNakgxUEZkQmEvRFBUQ1JtSmlSemsxSDFiR2VmM2plTHdNZE5QTFErYWsxVFVTNUF1U01qajVlOVZ4cVdvY1p1M0FJUFFkNit3WXZoeHBhdW1MWE9CbmsxcEo0QTAvSS93QkVYcnh3S3RZVEZQVy80aVdOd1VkN1B5c2ZIZjJ5NFpFYjdUSmh1Ty9iNmRLcWlTY08zelN0bjNKcjd3aThEV0t4WSt6S0FUeUt0RHdoWUszTUVZNjQ0cHJBMW52SkRlWTBJdjRIOXg4RW1PUno5eVZzNHh5Yzgxb1J3WFJ3QmJTWi93QjAxOTlRK0Y5UEdNTEhsY2ZoVXo2UFlScTNFWklIRmRFY3VtNysvd0RnYzA4emd0ZlovaWZDZzB5K2RnQmFPT2NnRVpyWHQ5RDFhUmhzc21PT01sY1Y5d1crbjJJSU9ZeCtWYmNVVmlvT1hUcjZDaFlCcjdmNEdVOHhqSkp1RnZtZkNyZUhOY0l3TE0vaGlyS2VGdGRIVzBLNTZkT1JYMjlKOWhENTNyakhhc0c3dWRPQ2tHVEdLMytvUnQ4Yk9kNW5KUFNtdnZQc3I5bTIzbXQvaHJZeFNMaDBudUFSL3dBQ3I2L3pYekw4REpJMzhFUUZEeDU4L1A4QXdLdnBVbm12eGZGcmt4ZUpqZTlxMDErSis4WWVUbmhzTkpxemRDbTdmOXVvbkJvTlJBMDdOY25NYldHSC9XSjlhMGllS3gzUDcyUDYxcEU4VnBSbDhmcVROZkQ2SHpyOFJ2aGg0UzhhMkU4ZXFXcnN6QlkyZUtWb21lTld6c1lyMVhQYXZVZEgwalRkRTBPMjAremk4cTN0NGxTTk01d29IVG10MTBEUnlEMWFxZDYySWo5SzhpVjR1VXJ0Kzd0ZlRYYzlXRDVsR0MwOTdYVHRzZmo5KzJYQ1p0YThMbGVDdGpJUHpldnozOEplSGplM2x5cGZBRzM5ZTFmb0wrMkRPcWF4NGV5Zm1OazJCN1pyNFY4Q2Fra056Y2tiVHluNTErZ1lLU2VDb1gwOTM5VDg4cXIvQUdyRXBLOXFzL3pPOTEzd0RiUldrdTV6alkzSDRWNTE4R3ZBbm53dks0TzNlNC9XdmJmRXZpSW0wZFFvKzRldjBycXZoWGNMRDRidG5qVGtqY1RqdVRYMG1GcFVKU2QraVBuY1pYcnhnbzl6MTZ3OEFhV2tlSGdCSEdCM3J0SXZBMmlLbVRicWZxS3pvdGV2R3lNS01IMHhWMWRldmdEKzhISjVQR1AxcjBsU29OTFE4WlZLbm0vTXZSK0RkREM1K3hSbm5uSzk2MEkvQitoNS93Q1BHUGoyeFhOTHJsME9ET281L3ZBVXorMjd3c3pHOGpDanQ1aWl1eFU2WGtaeXJWa2owSmZDMmh4cmsyTVgxeHpXako0ZTBYYUYrd1JjYzhnRVY1YWZFajhCdFNpQi93QjhacGllSkxVNUQ2ckVPT015anJSN09pdGRCKzJxV2ZUNW5yRU9qNlNwQkZsQ0FwNkVjWkZkQkhwMm15QTdiS0Zkb0JQeWp2WHp0TjRtc2xQejZ6QUFmK21sSXZqRFRFUXFOYnR4N0NTbEpVRXJtY0t1SmJzbS92UHBpT09DMlpKUmJSa0Evd0IzSElxL1ByL21ISDJXM1hKNjdhK1ZXOFlhVVkrZFpqWVp6dzVJRlZQK0U1OE9MeWRTVjhkZHVUK2xZLzdMdTdOblZ6WXhXdEpwZGVwOVZ1azBVSWxhelVSTWNxN1JrS2ZvYVZiNVNtMHBGNkhnWXFzL3h4OEVYM2hsTlB1Wm8zajhvTDh1Y2dxT0Q5YStSN254eDRXV1p3MnFTWXovQUFvVCtWWjBhMUtjWmM4VkZwNmE5RHB4TWFsT2NmWnpjMDFxN1dzejdCZS9TUGo5MERuMEJxSWFrQ1RtU0pjOUJnVjhhTjQvOElxZHJhaFBuUFh5alRWK0lQZzhBa1hOejE3eDlhM1U4TmJvY0xlTGxMZHBlalB0TnRWd2dIbngva09hak9xcHVBRnlnWWZRWXI0MWsrSkhnNGxmbXU4OU03TUNvMytLWGhwa1pmOEFTVDJ4c0g4Nnk5cmgreU5lWEUyM2Y0bjJPZFpBWmo5dGpJeDN4eFNwcTRZWVM4VWdkOGl2aDV2aVI0WDNITVU1VVk0VlIrTlRqNGw2QXVRTGVjcmoyRkoxc0wwc1hHbmlHcnVUWDNuMngvYVVZUE40dkgrMVVmOEFhc09lTHY4QURkM3I0cEh4UThOS0RzdGJucm5uR0I5S2pQeFAwTWovQUk4cmtybms1QXBlM285a0RqV1MwdjhBaWZiUzZyWjdqbTZ5ZS9PZWFzdnJObVcyL2JDQW93ZnJYdzRmaWpwRVdTdGxPY2Q5dzV6VVQvRkhTMVlEN0RQODNQRERCcUpWNkFvUnJwNjZIMmcrczZmbm04Yko5elVSMW5UbEl6ZUVrZW1UK2RmRzBueFVzQ1ArUEtkaVJ4bHdhcWo0bldZSE9tVGRPb2tITkNyMHJhRzNzcDN0YyswQnJkazcvSmRzV0hwazVxdi9BR3pZTzdLWlczQVpQVWZ6cjR0aitLZHJHNVpkT2xCQjZlWUFhclMvRW1FN3BQN09Zc2V1WmZXcCt0VWs5aExEVm10MmZhdzE3VHlGWHpXK29xZHRkMHRRTjByWnoyeWErSEkvaVpEdDUweko3ZnZPd3B3K0ppUG4vaVdEL3Y1elZQRlVYWXlkQ3N1dXA5eHllSWRMQ2tsM3gyd0RVcWE1WW9pc1hjWjZjWnI0WmY0bnVvd3Vub0IweHZOVno4VUozd0RwY1dCanE1ejlhWDFpa1VxVlo2Ni9nZmNyK0pOTVZzSGRrbkhURlRRNjNwMGp0dExEdmpGZkNRK0pkd3pOL3dBUzZIUHFTVFZvZkUrN1hHMnhoeDFHU2VLVHhWQmYweFN3MWRwTzJueVB1MU5ic1N1UWtwR2V1emlsL3QzVGd2enF3NTlPYStFRytMT3JBRUMwaEhPTzlLZmk1cWVDRjArMUdPK0NjL25XVHhjTFhzYlU4UExUZGZjZmRqNjlwUXdRa3ZJL3U4R3E3K0lOS1VrRkdIR2VtYStGejhYTmFLQkJhV3BRQTRHMDRGVlQ4VjlaeU1XZHJnRHVocHh4a2VxTnAwSmRHL3VSOTBTZUlkUEtBK1RLM0dBMjM5S2dpMTZ6ZVJWV0Z1VDZZNitwcjRVZjRzNjJUa1cxc3VBT05oeFR6OFgvQUJLUXdFRnF1ZTRpN2UxYi9XNmFXaHp4dzAyN3U5L2tmZGllSXJIbk1MRGFjYzk2cnQ0b3NjSGJDNE9lbUsrRFQ4Vy9FQU9ERmFjZC9McUQvaGJuaU5zNGd0K1IwOHIrdEw2MUI5Q1BxMVM2My9BKzVuOFdXQmRsRURGeWNZNHpYMkg0QXU0NWZDdHF5RGFTOGhLa2NxYzk2L0V2L2haM2lBdU1RMm9PT1Q1WFA1MSt1bndjMWFYVXZBV20zRXNhQ1I0UXpGT01rc2UzYXZQeDFaVHBSU1gyajZITEtNb1ZwTi95Mk90MUh3LzRodWZpRG9XbzIxNUtMQ0dGbHU3YkNtSnlQdXMyZVF3N0VWOUJ4Z2pOWkZoZzdoZzhBVnVKd0srYmU3UHNMM1M5REkxRndJU0s4THZaWXpPRnl4T2VnUEdhOWoxV1RFWjV4WHpGNGs4U2FkbzBFdDFkVEJJMDZOamxqMlZSM0o3VjBVbHFjZFZTazBrcnR1eVNLT3Y2dGFhVFozRjNmVExIR2c1SjZrOWdvN2sxK2VlditOWDhTMzUrMHZMRFp4T3V4SThmS3JIazRQVnNkKzFjTDQ5OGNhdDRrMXRsbExSUkk1MlFFNDhzZTQvdkh2Vkx3OUREYzN0cGJTUk04WG1ES3JrRjhuN3VRTS9qMnFNUldsSmNzYnBkKzUrbThPNUZUb05WNjhWS3Exb3QrVy82K1o5Ri9DL3dmb0hpYnhBOWxFdHpIYVJaa21hU1ZROHFnNFhieDFIZkZmcmhwR2oyT2oyZjJlMWhTR1BPVkMvVHFhODM4Sy9EN3dyb2xuRTl2cHFSU21GUWYzaGNyL0ZqY2ZROTY3Rzl2N2hyWDkyVldiT1BtRzRMNjlLNW94U1I1T2RacThaV2pDbktTb3hzbEdXbXZkMnVlZGF2NGk4TFhlcy9aWnJsSm5LYlo3WjJYeXhHZU4zVVovQ3ZuL1h2REZ2YVhXZEJ2RTBld2lJa251OTJTd1U1MktyOEJSL2U2MWYxNjM4Q2VEWVpkVzFBQ1M0TE41Vy81NUdaamtKRXZibjByNWgxZTgxN3hqSjlwMWZObHBxbmRCcDZ2dDNEczB4SGYycHBUYS91M09HT0xoUS9oVkpPUExacVh3dDk3ZjVtOWMrTGhkU1hGcjRXaUozczMybldiZ2Jpem43eGpCNmsrdlN2UDdoZEE4UExKZVg5eTF6ZHY5K2VRNzVYUG92b1BwWEMrTFBpWHB1azIwdHRZbUZFaFREUzlJNHdPM0hYSHBYeHhxV3I2bHExdStxMzJvSFN0TWNuL2lZWEtscHJqMnRJZUMzMTZWY2FYNWJkZm1lTGlzWE9hdk9iMWFWMzF2MFhmMFBhZkYzeGR1WlhGcGFLMExTSGJIREVwa3VKUFpRTTR6WHo3cmQ0Tk8zU2VJTlRHbU5Jb2I3RGJFWE9vU0QwYzUyeFo5em11QnRmRkd0NnBlUzZUNEQwYTVpTWd4UGZ1UkpmVEwzYVNVL0xFbnNNQVZoM09pZUFmQ2NwazF5Ly93Q0VoMVlOdWV3dEpUOW1qZnJpZWZxNXoxQy9uV3JXbW0zZlpIanVTVlN5alp2b3ZlbS9OOUlvMUxIeFI0bjFpNmExOEcrSEd0ZjRYdThlZmNrZXNrOG55eC9oaXVPMVB3NW9HblhVazNpVHhRYjY5Snk5dFl2OXBrejZQTTN5Zy9UTmJOenF2eEE4VjJXeEJCbytpcjBqaUFzN05GOThjdWZybXZQdDNnWFNFWUtzdXNYUTZFL3ViWlNPK1B2TlhMN1JYZjJyZEVkYXBWV3RYeVgxN3lmcTJleitIN3UxYTF0MzBmUXJTeGlaaVB0VXcrMFhKd2Njcy9BL0FWNm9OQ2l2U0hGdmNhaExrQXRHcFliajduakZabmdxKzB5YncxWlhkN0ZGRkkwN3FsdkhIdEFSVHh0VWV0ZlkraTMvQUlrMUh5YmJRdkN3ajJLTVQzYitVZy8yZ2k4bXZKclRrMjdSNjI3SHUwWVJoRk5kVjFaNUhwbnc4OFJTUmNhYloyQVhwNXJGaWNleVVsNzhOdFRnUnBadFF0a3d1UXhSWTAvRFBKcjZHdWZCSGlWSU02NTR3YTBSMkpNVmlnaVVML3Z2MXJ5L1hiTDRTNmZCc04xL2FkMEFBclMzRHp0K1E0L0N1U01adHAzdi9oamY4V2E4emI3cnNrZUgyMDQwMmZFZXN3d3VBY3RFVjVQb01EcFhGK0xialZMM1JyZ1dXdFhLejVWMlBtc29JSFhjUngrTmUxaTQwTXNnc1BEdDNnbm55N1Bia2VnSkZkQWJEeEhxTm5lVzBIaHFkSXJpRXh1SGtSRGdqR2E2dmFWSXRQVmE5V2tRcWRLVjNLRWJ0V2QxcWZuSllXdXN2ZDI3WFBpNjJWUE1VdWpYenNTTThqQUI2MXF6NlpyTnhxTTZXbmpTelNMekc4dEd2NUl3b3prREREaXNHSFR2Q2VuNjh0ck11cXZjd1hRak1ZV0lEZXJZeHpudlVlcGY4SUMrcVhobmoxbUdRelB2VWVTMjFzOGp0WG90elVycVQyM1J4VG8wdllPUEpINHV1cU85ZzBuNG4yK1d0dkZFY2hHQVBMMVZXSitnSnJvSUp2andwQVFUWHE0enQydzNRUDhBT3ZEVFovRDkvdTZucWNYdTlzai9BUG9MQ3IxdHBHakFrMlBqSkltN0NXT1dEbjZqSXJkWW1yRmExSjJmcWVSTEw2RTNHWHNLRGxIWnVDYlYrMXp1ci94VHJ0dk1ScnZnVFRwY0FnbVN3YTFmMythUGJ6WE9KcVh3cnZ3QmM2SnFXbU9UeTFwY0M0UWY4QW1HZjFydGJPWDRzV0VVWjAveE1sNGg1Q3hYeVRnLzhCa3FwcW5pL1gxVGI0aThFNmZjcU9ETTFtYldRLzhBYldIQUpyZFltbkp0YzhaZVVrci9BSUhPc0hPRDBwdVArQ28vL1NYb1VOTjhNV0RYS3krR1BIVUNUbHNwRmNzK256Y2R0eEpRbjhhNnJXTmIrSStteEFlS2ZEVU9yV3B6Kyt1b0EvSFQ1TG1IL0d2UGxnK0ZPcktkbHhxT2h6NHdGa1VYbHVUL0FMd3c2ajg2N2JUTkUrS0hoNkpybnc3cks2aFpnWmMyRS8yaVBiNlNRdHlQZklxMVdqRmRZOTdPNis1a1BEem5OUDNaeVdpNTQ4c3ZsT1A2STVCZFArR2V1dVBzZC9jYUJjbnBGZDV1TFVuMEVxL01vK29OZGY1L3hUOEdXNlBLbzFEU3Y0WlF3dTdWbFA4QWRrWEpUOGNWaXorTFBCZXJzOFBpVHd3Yk84eVExL3BnOGg4bi9ucEEzeUgzeGcxczZYNGY4VjZVa2wvNE04UXJxdHNWek5id2NUQmVwRTFxK2R3OWNacm85eWVxUzlZYWZmRm1FblVvTzBwdGEyVWEycXUraW10dGU5MmZRUGc3NDArSHJ4WTdhWnpaU0ViVEJjSHpJSHoyRG5wN1pyNlgwclY1ZEtsaG0waThheDgxanZnY21XMlluMUF6Z0gxRmZtTEpxWGdMeEl6UjZwWS84SS9xV2RwdTdaQ2JWMzcrZEIxUStwWDhxMllMejRnZkQ1b1pHS1gya3ovNnVSSDg2MG1YL1ljZmNiMjROY1ZhaTNCdU5tdTYvVmREdnAxN1ZlV1NjWlMreExyL0FJWDFQMWxhNzhQYXBxY0V0MDAzaDdXeC9xYnUzYkVNcDdFTU9HSHNhOTgwejRzYTVvVnpGcDNqTzNFdHU1Q3c2dkFwTWI1NmVhQjB6WDVyZUN2aWI0WThRVy8yVi80dnYyTTdBNFAvQUV6SjYvaHpYMHBZNnRlNmJZbEl3ZFgwZGxJa3NwZm5taFU5ZG1mdkFlbld1VlU1YlBheTYva2QwY1VtNHE3VGp1dG1qN3d1L0FObnFFbHZxM2h6VVZzWnp5Sm9NTkZLcDdPbzRJcmNuOFErUGJDM1dDWFFyaTRUeXZMZU8xZU9PRHA5OVNmbXlUMUZmRmZoYlZ0VzhOcU5WOEozQjFEU1dJYTUwdDJKZVAxOHZQSVlmM2EvUlh3VjQ0OE9lTE5NVzVzcHdTT0pZVzRlTnU2dXZVR25GTkxSM3RvZlVSenF0S05PT0lwUXhFWWZDNXA4eThycXpQeVM4ZGVDZFd1ZkU5eFBhYVJld3hTQlpHU1NNRGF6ZGNZNDI1NlZvTlk2eG9OaEJGY0k0V1JlbU9VSjdlOWZzOCttV2orWm1OVzNqa0VkUjZWOGRmR0x3aVJwWW1pUnZLWE80Si9Cam9RUFQxcmxxcVc5dXAraDBlSktPT29yRGZWbzA1dU5sTG12ZHIxUHp0MW5UZEk4UWFiUFphaFlKY1F1dUVjY1N3c09qd3QxQkhwMFBldnprOGQrQXRlOEcza1BuZjZSWTNRTFdsNGkvdTVRT3FuKzY2L3hLYS9RNUpXdDVXUmo5UDhBSDZWMGtuMkhWZER2ZEoxQzNqdUxHN1E1allrWWtIM1pZei9ESXZZOStocmFEVVUwM3AzN0h5V0xvcXE3cGUrajhmcmJVY0hJZjhLM1UxamhWemozcjAzWFBncHJXbnkvNlBxTUVzYmx2TGFSV2lKeDI3ak5lZVQvQUE1OFpSQWxMYU9iL3JuS3AvUTRyUktUU2EyWjhvOFJDRTNDVFNrdEdpeEZyUWprQS9IajNxNE5hVWtjZEs0SzU4TmVLYk1neTZYY2owSVF0LzZEbXNDU1M2Z2JFc01rWlBabEtuOWF2bW10Q28xYWJkejJsdFhVYlNKWFVyendjRUgyeFgxLzQ4dTlNOFYvQlB3OTRvbWpFV3NXZDZkTXVKbEFIMjFWR1Zra0EvNWFLT0NlOWZtbzE2ekVBWjU3RHZYMFZxSGkyS0w0WjZiNGRqeGtYNzMxeXc3dVYyb3YvQVIxcmh4RldxcDRmbGp2VVYvS05uYzZZZXprcWpkbmFMdDZzajhNZU50WjhONmxIZWFkZHRDNFB6TDFTUWQxZGVoQnI5bWZoLzQzMC94Zm9NTjdDaXh2blpjUW5HWTVBT1FQVlQxQnIrZXhidDNsVUFrODE5WWZCcnhQL1pQaVF4M0V6UjI5MUdWYnJ0RERsVDcxOU5nc1VvMVVwZkM5UFErS3piQnlxWWVWU212M2tOZlZkVDl0amFBVEtSc3hqMEZhdjJHSXFQa2pQNFpyNHZieGxwV0NxNmloT1QyWVZMRjQyc055ZjhURURnOGJqWDFUclVOUGVSOEZDT0pWMzdOdjd6N01UVG9kdy8wZU51dWZscVArejdWU2Y5SGpPVC9kRmZJUThjV1lPMGF1b3owd3hxNU40M2dZeGthcEdDRkFKRG5uSHJVODlCeTNSTCtzU1h3U1hscWZWamFSWXNTVGFSWjc0V3FSMEhUV1lrMmtaem50WHkwbmpxTGNjYXF1ZlhmVjMvaE9jcXUzV0l6Z24rT3RsTEQ5ME51c3QxK0o5SUh3N3BiTW8reFJISHQwcW0vaGZRbUkzYWRFVGs4NHJ3cFBIREZQK1FySHU3L3ZBT3RXRjhiWGEvZDFDTnYrQmc4MVArejMzWDNFeXFZbHF5Yis4OWJsOEllSGpuRmhHTURtc2VUd1Q0ZFlEL2lYTHo5SzQxdkhkeTFzRUVrQmNIUG1id1Q5TVZUVHgzcUlRcVprejZqRmJSamgydWh5ckVWMUt6NWpySlBoL3dDR2c1STA5Y24yckpQdzU4T05LMkxMSDFGWnllTk5SWWs3MFBQR2NFMDQrTnRSRFpDcDA5QmlqMldGZlNKVHhHSTNqejM4ckN5ZkRIdzNJakg3UHRKN2dWZ3kvQ2Z3K3grNFJuMDYxdnI0N3ZRY1BER2NqMHdhaGs4ZlhRWWY2T240QW5wVDlsaGRyUkwrczR2bHUrZjhEbG4rRVdoaHNoR0hvYXl4OEl0SERNZHo5OFY2Ui93bjdqYUdoWHA2RVVvOGVJUUQ1U2dmenBQRFlYdEVpT0x4TGVybDl4NVMzd24wMTBjQnlNbmc5eFdiTDhJTFpoZ1R0d0IwcjJkUEhscU4yYllIMUdjVTcvaFA3VEJ6Ymc5ZU00cGZWTUs5a3Z2S1dOeE45WlMrNDhCaytEMFp3RXVXNjk2Z2I0UlRBNVdkamdjSE5mUWNQaml5YmtRcm5QVE9hMHYrRTEwc3NQM1p4dDVBeDJvbGdzTjB0OTVjY3d4Q2RyZmZFK1Q1L2hOZWtzQmNIUFlWaXQ4Sk5WVEpFNjQ3WnI3TGg4UzZWUE9xS051Yzh1UUI2OWFyU2VKZEh3VG5IYnBta3NCaDMvdzRQTWErenQ5eDhaRDRYYTBCdEVnejlPdFpML0MveEdYSlJrUFBOZmNzZmlIUjJQM3hrZTFTSFhkRHp6S09mYkZTOHRvOUd4TE5heWVrVXo0RG4rSnQwT0UyTDZZRmN4UDhRZFRtSi9mUCtBeFhDeGVHdFNjQWxNWnJvWVBCV3BPRjVJL0N2TGVKeDAzdkw1SHVMQzVmU2piM2JlYkd2NHF2NU9TN3RuUFZxcHlhN2V5TDk0Zm5tdS90UGg5ZUVydURjOURYVjIvdzNVRDV3VFRXR3pDYjJsOTVuOVl5Mm05NDZkbGMrZS83VHU5NXpKMTY0Rk9hNG5seU43ZmdhK3BiYjRjMktFN293VDB4bXVuaDhFYVlnQTJKK2RieHl6RnlXdW5xekNlYlpkR1NTZXZrajR3UkoyZkFTUThkNjBWc0wxazR0U2VmUTRyN1JYdy9va0l5V2pIdGtacSt0djRjaEJCbFFldk9hMldWVCsxVWlqbGVjVW5LMEtjbWZGMFBoL1ZuT1ZnSTdkTVZzRHdyclQ5WXl1ZU00cjY3L3RQdzNDaHc2azlNNHFCL0UyaVJnRllzajJxLzdPb0plOWlFalA4QXRMRXVWNFladGZNK1lvL0JHb3QxSkdhMW92aHplc1NTV3dLOTZQamF4VFBsMmhQcHdNMVRrOGVsUmhMVHI2MGZWTXVqdlZiSm5qOHplMUZSUE83VDRjeUhJWU1jMTFKK0cwSTJsby94OWF2eWZFTytBR3lHSlByZ1ZnemZFTFZpU2Z0VUtEMDRxbkRMSXJxelAyMmN6V25MRi9ML0FJSjE5dDhQN09OVG1FSE9PS29YWGd6WGJMVnJEVU5GdVVzcmlFa00rd051UnVHWEI0NUJyaVpmSGQwZVcxUkY2WndQOEs1dTc4Y1NoZ1RxYjRKNmpKcm1xLzJYT0RpNmVqOHpwb0xPSXlVdmJLNjhyL29lcDNQZzY4aTFhQytoMUZyWUpFNlhNY1lBKzBLM08xdmF1MjBYUjdWTFRkTTBhczdzNTVIZnRYeTJuam00U2JjSlpKZHA0ejB4VmovaEtJajk0VEhKenh4MXJHRlhBd3JjMEtmVFc3T3Q0YkhTdy9MT29tdWxsWSswMXRkRFFEZmNRampwdUZTRnZEU0JkMXluSGJQK0ZmRHg4VFI3amkzYzQ3czlWWDhWU2c4V3E5T01zVFhjc3dvZnlJOGQ1VGlYSy9PMnY2OHo3c2JVZkM2RmdKdzJEeGptcW45ditHVjRESFAwNHI0YWJ4WmRuQkVNSS9PbWp4YnF1L2hJd01ka3pTL3RTS2VrVjl4U3llVHZlVHY2bjNNZkZPaUsySTR5Znc0cWMrTHROR0N0bzJSMTQ2MThLLzhBQ1Q2NWs0bUE5d2dxb2RlOFJPL004dUQwd090WnZOVi9LL3VMaGs3VjF6YSt2L0FQdWcrTVlkeEsyUndhVlBGVEZqdGdISFkxOEhmYi9FTG5Ba3VHL0UwdmwrSkR6aWR1UnpraXFXYVR0cEZtME1qcEozbEw4ejd2YnhoZHEzK3BRWTY1NlZYSGpXL3l6S1lsQlBISXI0bkdrZUk1VnlZWit2UWsxclczaFh4QTY3VnQzSkhQT2NWazh4cS84KzIvNjlDWlpUUVQvaWYxOTU5aE40MXZHUS82VkNwNy9NQVJWRmZHdHlqZk5xTUtqL2ZGZk5kdjRNOFF0S2lOYW5uMTk2MFgrSHZpSGNvK3pkOERGSlkzRlBha3pXT1hZSldicXh1ZlFzM2pnREc3VmtHUFI4MW1IeHZhNEliVjBJOWVUWGxxL0RQeEc1akhsaGNqbk5XaDhMZkUzYU5EaGhrNHhnVWZXTVk5b01tV0h3SC9BRDhYNEhYdDQ1MHhneWpVbWJqb3F0VldUeHRwdUZCdUpTY2RrTlpNZndrMTh5bHZOUUUrOWJhL0IvVkFRSmJsVGtqQUJyWDJ1TzVmZys4bjJXQlMxbXJkeDQ4ZmFYSGppNVlkOEtCVXErUExISkl0N2crMlJXekg4R3lVeWIwQTU5Uit0ZExhL0NLMkREZGQ1QkhOWnFXTWV0aE9PQ2N2aWJSd2pmRUcxVUhOcktjalBMaXM2VHg5YnVCalR6MTd5VjYzSDhJOUlSaXNsNldIVVVyL0FBeDhPUmdBM0VoSVBPTzFiZjdjMXQrUkxqZ0UvaS9NL1IvOW5MVVZ2dmh0WXppTHk5ODF4OHVjNHcyT3RmV2pkYStXL2dEcDF2WWVCTGEyaEpNY2MwKzBuM2JOZlVUSGsxK05Zdm1XSnhITnY3V2Y1bjdoaDNCNGZET096bzA3ZitBb0FhZm5pb2MwSHBYRGZRNmVYVWE1L2V4MXBFOFZqc2YzMGRhVEhpblRsOGZxS2NkSWVoUy9nayt0WTkrKzFDVDB4eldqbjVYK3RZZXFuRUVtVC9EWG00aWRxVGE3SG9ZZVA3Nks4ejhTUDJ6TG00LzRUUFFWUS9KL1pXUVBmeksvUGJRYnE4UjVURVdCSkhRZHhYNkEvdGJiNVBIT2k3VlBPa29GejBPWHh4WHkxNEVzMVRVcm1LV0ZTeXpLcHp6eU8xZm9HWHB6eStoL2gvVStCcldwNHZFci9wOVUvd0RTbWVkNjdOckp0WmppVS9JZlgwckwrSEdvZUlialR4QkVaMjJsaDhySDFyNzAxKzN0eEJPdjJlRUw1VGZYcFVQd1g4SU5hNklreGlqK1lzK2NkY212b2NQaHFrbS9ldFpIaFluRzBveGQ2ZDd1eVBGYlhUUEZUOHZhM1JIcnVhdG9lSHZGaFBGcE9jNEl5V3I5SHpwdDNZdkNreVc2bVdQekUybFdETDZqQnEvRktpYnVZL3hBcjFvWWVWdmlQR2RlTnJPTm1mbW4vd0FJZjR0WmpuVDVqd2VlZndyUmc4R2VNSFVEK3o1c2pzUWEvU2hiK0lLK1pGNmZMdFVkUlUwT3FUc3hIbklBUDlrVnA5Vm0rcG1zVFNXbXArY1ErSFhqRWpKMHhzZXVQMHE4bnd3OFpsUWY3UFVEc1R4L092MFdHcUJBY1hLRGNlY1lQNVU3KzFncTgzT2Mrd05QNnBMdUo0dW0zWnJRL084ZkNYeHJJcS82SWplZzNETmF0djhBQnp4bDBhMFFjODU3ZTFmZlExVjBBYjdWZ0RqcUJUMDFjT3padkhJSS92VVBDdnVpb1l5aXRPVm53djhBOEtZOFZ2OEFKNUtEUFE3cWtpK0EvaXpPQzBZSjY4LzRDdnVjYXBhQmViczVIZmYzcG8xKzFMRUc5YzQ2ODFqOVN2MVpUeGtVMHJhZXA4ZFd2N1BQaXlOTi9ud0RQWWs4MUFmZ1I0b0laR2xpQlU0SFUxOWp0NGlnRytNWFVoeDJMSGlxdi9DUUFaSDJwOEE0d0NUMXE0WUdTVzZKbGpxZlpueVFmMmQvRXpBdUxpUDBQSjZWYWkvWno4UUVmTmZSWlBPT2NWOVV5NjlhSEdaNUdJLzJqVDExMnhWQU4wbWZxZjFxL3FiUytKRXZIVVc5SVA3L0FQZ0h6Qi93enJyRFlXUytqR0Ixd1RRZjJkTHdNTitxcXVPZ0MvOEExNituL3dDMzdScy9mSlh2a25GVlI0aTA3Snd6bkg4NmxZUGZVMldOai9LL21mT2gvWjJtREFmMm1tRDdZTmFhZnM1TDgyN1ZGQUhiQS94cjIzKzNyUGZ3ckhQVHJtckxhN1pvQXBpYjY5UlI5U2ozUmo5ZVYzN3IrODhLWDluaXlWY0hWTWtIcHhqRk9rL1o0MDRFZjhUZjhnSytnSWRYczdpUklva0xPN0JWWHBrbmlsZlVJcmFlYU9TQXJJamJXSHVPdVBXcCtxUS9tK1Jzc1gvMDd1dTU0Vi93ejNwUVRuVlRrQWdZS2l0RC9oUU9pK1RHRHFZVnVUdUxDdllrMWUwWThRTjlkdkg1MW9TNmxBU3NaZ2JLcnVHUmpyVXZEVTl1WXI2NXpMK0VlQ044QWRCQkJiVk00em5sY1lxOUY4RHZESVVGOVJ3U091NFkvU3ZWQnIxcHRJTnJ6Ni80VlRmeEJBUmdXL3NNZjRWYXdzRXQ3R0VzVTlIeWZtZWJQOEMvQ2djWjFYcjNCQng3MWRiNEdlRHhrRFUyWUgwY0EveXJxcFBFcUVsUmJNUU8rS0l2RXFNN2Y2SzNUSEZMNnBCL2FObzQyVGRsQTVOUGdiNE5KVlJxTG5QZmVCVnMvQkR3UkM1VnI5Z1I2UG5tdXZHdGgxRzIyd1BmbkZTblZ3b0phM09leHBMQzBmNWkzaXByL2wzRi9JNDMvaFNYZ1ZobHJ3OGM3ZzJLdko4RnZoOFh5YnRpTWROM0ZkT3V0ZzVQa0hqbkZKSDRnZm4vQUVZN2ZZY2ZqVlBDMC81Z1dMa3YrWFMrNDVwUGc3OFAxM0h6bUpCL3ZuR0tlUGcvOFB0L003QUE4OG5tdDcvaElQUzN4ejBxd2RiV01ybUJOeEdRcFBQTlM4TFMvbUdzWEtVZmdYM0hQcjhJZmh5V1B6c01IMVk4VTcvaFVQdzMydGhqNzVMR3Q5ZkVEL014dEFPY1l6anBTSHhES3pPdmtqQTk2Ynd0SmRXU3NaTGJramYwT2VUNFIvRFVaRytUc1JqY2ZyVmovaFVmd3l4OHZtUDdaYkZkVXZpRnZLUWZabDdrbnVhb0h4QmN2d3Rzb3o2bkdLbjZ2US9tWnE4UlVzdjNjWDh2K0NZaS9DWDRacVNQSms0LzN2NTAyUDRXL0RZc1FMVTR6d1R1NHF3ZkVkOEMyWWwvUE9hQjRodUNRVEdPT2NCdUt0WWFoL01adkYxZitmYVh5SW4rRm53MjM0K3lFZTQzWS9JMHgvaFg4TkZ3b2dZTGpyODJjK2xSbnhSZVlZZVNEejYwczNpUzVDcUZpUUU5Y3RpdFBxdExwSXdlT20yL2NYM2Y4RXpXK0dmd3ppSC9BQjZ5RmU3RU1lZmF2cnI0ZVdXbDJXaExGWW9SRkdCR3ZiZ2NnWTllYStSWi9FdW9iV0JSTy9SZ2ErdmZobEtMandwRlB4bVNSaWZyWG00MmxDRkZOUFhtUjdlV1lpZFN0S0xWbHkzMlBjckJpR2s0eHdLMkZicldKYU1BSk9mU3REZDhoYlBBNzE4Mjl6NjVhSTRUeFRmMjFucHR4Y1R5aU9LTkNXWTl2OFQ2Q3ZsN1R2Q0g5cVhFZmlEeEJhWHBFTEZ0TjB5T0xjVXgwbGxVL2VrUFVMMEZmTi94eStMcDFMVm90TzBxYy9aN1dmS3V2L0xhWkQ5Ny9kVTlLK3lMV0R4UnJmdzIwSmJQVVBOMUh5WXpjWEVqbFpBWCs4ZnJqc2EyYjVZVzZ2YytrbzRHZEtqVHF6YWc2a3VXN2R1Vk5maGM4SzhIL0Nmd2xwMzl2WHV1UVNYMTVkN25FTElaSkkxbFluSEhHL1BVOXE3VDRjK0NyV3d1MHVaMUNTeHlNeVc4dUhtU01FaFI2QWR6WFc2Qm8zaURTTDBXY0J1ajVhYlh1THR4S0dHZXE4NStnTmUzV3RoYjJvYVFnTkkzMzVDUG1iNm11WFdVanV4ZU9uQ0ZXS3JjM3RFcldleVhaZERUdUc4NGZNQ0ZCempPTS9Xdm52NGlmRXJTL0RGbUVBOCs5bnl0dGFvZm1rYjFQb3Z2V0I4WFBpM3BmZzdTeUN3a3ZaaGkzZ1U1Snp4dmJIUlJYeHNMcXkwKzFtMXpVcnhiM1VMdEF6VFozQUJ1a2NRN0N1dUZOdXphNjdIdzlTcmJSM1M2ZWZvWExnM0QzVW11ZUk3dFpid2pNY2YvQUN5dGxQOEFDZ1BmM3I1WThlL0V1YWVhT3h0eE16enR0dDdXRWJwWmovN0t2cWF3L0ZYakhYZkVHc2pUZE1oU1c3S0Z5cnZpQzBqSFdhNGJvTVY4d2FsNGpNVjYyaGVFRE5xZXEzeDhtODFnSVROY0U5WXJZZjhBTE9FZXZVMTJTU2ltM3RzbitpUFBsT2NweVVXblBsdW92YVBaeXQwL00wZGQ4UWFQNGZsV1hWVmcxaldVNWgwMVR1c2JGdXhteC9yWkIvZDZDc0s3OE42bGZlVjRrK0lPclQybHRPTjF0YURIMnU1VWRGaGk2UlIvN1JBSHBWaDR2Qy93MXdaUHMydCtLanp0L3dCYmFhYzU5ZTBzdy9JVnlGM3BVMHM1MS94eHFGeThseis4anROMmJxNUhiZy82dU91T3BVcHhsZHJWdlNPLzNtZEdsV3F3ais4ZXFzNjNMeXQvNEU3OHFOMXZFdmlyeFJhUzZQNFkwdVBSZEVpR1praGJZcFgrL2R6bmxqN2ZwWERtZndSNGMzUjIwSTF6VVFjQ1p3VnRJMi8yRTZ1ZlFuaXRwN254SDR1dFdpZ1czMFh3L2JOeU1tTzJUL2VQV1dUODZ3b05kMHJTWmhaK0c3QTNkNDUyRFVKbzk4ckUvd0RQQ1BrS1BROWE4K1U1eWF1OXVpNmVwNzFMRFU2ZE5KUnNwYnZkdDk3N3RscSswanhGcWNTWDNpUFZWMCsxeG1PS1RoeU93aWdYa0QzTllBMWpSYldWYmZRZEdhZVk4TGMzSytkTXg5VWpIeXJXdGQrR29yU1JyenhYcThpM0QvTjlpamJ6cnQvOThuaU1mWDhxMGJEVnZFV293eTJuaGpSbDA2MFVZbG5qL3dCWnQ5WnJsOFkrZ3hVYitmNEk2WlJVVXIyWGwxLzRCOWQvQ3M2N0Y0ZWxXODBxVzQxTDdTem5kRUdkWXlQbDNOMFFleHI3QzhKNlY4UWRaZ211UnExdG9xRUZmM2FlZE13WGd0end2MXI1aC9aOGc4VXhhZnJPaTZYZGFmcUVrdHdzMTFPMGhlR0U3Y1lKNnUzMHI3TTFUd1BZV2RqSE40bThXelNXNmdqN05Fd3NyWmZVQUtkelZ5V1RxUFJiNmRXYnk1WXExN1BUKzh6bUx2U2ZoTHB0eHUxM1czMUs2VS9NdHhjTk9TZjltT0xqbjByTmJXckprSC9DTitBYnRvSkc0ZjdNc0VaUFFITDQ0cnBkRzhYZkRyVEc4dnduNFhuMU81eHRaclcwK1Q4Wm5yWDFlLzhBakhxRm5tUFJkTDBxQTVJYTRuODZWZnFzZkZkdnNuWlgvd0RKbmI4REdVM0cxNy85dlM1ZndQTjc2OCtLTnkvbE5vK25hZkh4aDViZ3VTUjIrUUdzcE5HK0l0d1NHMTJ4dGxKeVZqdDJQNDVKckltMG54UFAvd0FoTHh6TEJqQmRJWVVpSDBET1RXQytrL0RLTmhKcVBpMjVuYnF5dnFHU1NPdkVlSzVIRFZhTDVSditZUnFSZDBtdmxGdjh6NDMrS2VqYWg0YitJY0tOWjJlb1RYdmxUcmV0RTJXZGpnNVZXd0NDSzhMMURYWjB2N3NYWGhpd2xjeXVHY3dTSVNjOG5JUGV2c2I0cjJ2Z1U2Zm83K0Z0WWRKbHV3THNmYUpBREN3NjdwZU1qMnI1VXVJdmlBTHVVVzJ0R1ZONUVlMi9qWWxjOGRXcnNnbnlLNmVuZFdKcXR4YTEzNzZISC84QUNRK0YyZGZ0SGhHQURHRDVWek5HVDc4azFLYnY0Y1hIRGFmcXRvZldPNFNZZms2ZzEzVUtmRjFNdUlwTGhlTWdpRzRCeDdmTldKZmF4NG9nWnY3VDhLV2IrcGwwL3dBdjlZd3RUS09xdGY3ekZWTkxYaS94TUlhRjRNdUNUYWVLR2diSHlwZDJyUjgrbStNc0s2VzIwMzRoV1NLZE4xVVgwV1B1MjF5SnhqM2pibjlLNG82dDRRdURpNDBDUzNQZHJXNEkvd0RIWk53cVNEU3ZEbHhJRFlhKzlyTG41RXVvakdjLzlkSThpb2xGMjFkL1ZYL0kxaEpPUzkyejhuWTZBNjdBMXdJZGU4TFFzK2Zta2pRMmszNllCUDFGZEhaYVhvTFRMY2FCNGpsMDY3L2dndWlZVytnbFRnL2pYYlJYSHhNMG13QXVCRHJWanR3Zk1WTCtISDE1WmYwcmhkV3ZQQVdxUWhaYlNiUkxscy9ORG1lM0o5MGI1bEgwSnJpdmVWbHQ1YXI3ajZTblRoRERTbTdOK2R2dXVTYXo0bjEwTWtIaTNRMHYxeHRqdXlvam4yK3FUUjhQK09hd0xEdzlGYzNLWGZoYldIRjBoM0pheVA1RjBoSDl4aGdQK0ZNU0R4aG9sazBsdFBIcUdtTnczbGtYTnVSL3RvZVUvRUNzY1JlRjlYS3RiU2YyUmU4RUk3RTJ6dC9zdjk2TS9YaXV5TGErSFR6VzMzSHpVNEs4dnlaNlJKNDEwelZaRzAveHhvMGpYS2ZJTlV0MEVON0VSM2xYQVdVZlhuM3E1SFkrTHZDRmhKcU9pYWhCclhoKzV5cysxZk5nSy8zTHFCc21OdmY4alhJWE91YWhiS05QOFU2WWJ5SXFQSnVjZ1RvQi9GSEtPSEgxcDlqQnJ2aDJRNng0WDFacnExeGlYWVBtVmU2WEVSNEsvb2E3WVY1WFRscExwSkhETEN4ZE9VSXdUai96N2UzeTdmSTNVOE1lSFBGZ0Z6NFdrT242c3Z6dm84c21BNUhPYk9VOWY5eHVmU3U4OEQvRi9WdEV2LzdPMTVaWTNqZlkwektWa1JoeGlWVC9BRDYxeE52cHZoYnhvR20wcDAwYnhBRHZGanUyV3QwdzV6YnZuOTNKNkllUFNwenIrbmE5blJmR2tNbHBxY0I4cURXU2hFMFJIQWp1MS81YVIvN1gzaFhWenB0cE5YYjlJdjhBeU9CMFdydHFVb3hXbDFlcEQwZXZNajlKN0c4RXJwcXVqWEt3WHJBTVZVNWd1MTlIQTR5Zjd3cjB2U2I4MzJvZjJwbzdmMlRyOElIMm0wZmhKd096anVEMmF2eU8wN1dmRi93MDFxT3l2MTgreGt4SkN5TnZpa1E5SnJkK2hIK1RYNkhhUnJlaCtMOUpzN3FDOEVkeXVSYjNhY1BHMzl4OGNrZW9OSjA1Y3p0ZE5icDdyL2dGd3F3YWczTlNVbDdrMDdxU1AxUytHM3hWc2ZFY2IybDFFYlBVN2Y1YmkxYzRJSTdybnFwN0d2ZGRVc0liKzBlTjFWbFpTTUh2WDVLMlZ4TnIwb3RyaHY3TThTMktnd1hDY0xNQjBaVC9BQlJ0M0hhdnNINFdmR0MyMW1WdEkxQjQ0OVR0VDVjeWhoZ3N2WEgxNjFqT0NjWCtKM1U2OG9WRTFwWjZhN2Y4QStXZkhudyt1dEgxUnBJYmZmYmJpV0JYY0ZCN0gycndXTFNaMm0yd1lFVWovSXBidjdkeFg3Y2F6cEZ2cU51dzJnbkhwWHhuNGsrSE54QXUrMGhIbUl6TUhWY0U1L2hOZVZMbmcybXJydWZvVkhGVXNYRlhhalByMHVmRjlucHNEWDc2ZHFkcHVnbnlqT1Rob216anpJejZyNmQ2djMvd1B1OVB1V2hOOGtpNERSeXFmbGRXNVZoOWE5VXNQQnQzcVdxcmIzb2tnbEV1VzM1VWM4bkI0MjE5c1d2Z2FMV1BCWnNDaXgzVnU3dGF5bHNzTy9sc2U0UHJYb1lLdFRWUlJsOExlL1k4VFBNQ25Sak9EWHRFdnZ1Zmw2ZmhQZVJuY0xza0tSbjYxamF0OEliclViV2VDZmJMQ3lFUG5HZnFEMkk3VjY5ZWFzbGpleTJsekhKRE5DNVNWSHprTUQwcXhGcWRoS0R0bmJJSFQxcjdkWmRSZlcvelB4aXBtR0lwVkduSGxjWDJzZm1ENGwvWno4UzZURmQzZHJjUVhNTUNQS1VkdkxrQ3FNbjJKeFh5Q1h2THhsVlV3bzlQNjErNG5qK1MwbjhFYStxeWtNYkNZOFp6a0QwcjhWN0RVN0dIRzVYWWdEb3VSL1N2bWN4d2tLRTRjdXQwOStoOXRsZU9xWXFqSnpTVnBXMFZybm9XaitIWUlvaEpJcFozSEE2OCt2MHJjMHkzdDIxM1N5MTJrU0M1VldaZ1FveWNaTk10ZkdWdXNhZVZwVWpTcDBrZHdvd2E1QjlTVyt1NG9MZlNwekw1bVFrUUxrdG50anJYQlRjTHBjMnA3MVZMMmJXeWFhdWZxQkw4Ry9FZTFXVm8yTGRNZWg3MVdrK0VQaWpvRlRJQUdLK3k5SjFMR20ySWt1MmpaYmVJT3BQS3R0R1FjOXhYYngzdG9BbUw1Y3QzM2Y1eFgyVXNCRldkM3Fma3NjeGxiUkpINXpmOEtmOEFGaXVxdEVneVQwTlJ6ZkNUeFdEZ1FxMmVNVitqOGw5YmJoaS9CS25LL01LclNYa2NlSE55dlhya2NHcVdBVFc3R3N5YTZSUHpQaytGZmk0SmdXWit1Y1ZsdDhNUEZhSExXSndUMXowcjlUMzFDQnNOOXNSejFQVEFweXpSc3VQTlRyMnh6VkxMKzdhSmVQVGVpWDNuNVNOOE4vRmlzUDhBUWpqUEpIVVZSdVBBZmllTEoreFNkZUsvV3hwUnd2bXgvTm5qak5VMkNrRExSRTg4WUJINDFEd0N2OFRMbGoxR1B3cC9NL0pWdkIvaWhRdWJhVFB0VUQrRnZGS0FFMnMyZXVBU2VLL1c4d1JNRlllU2ZYS0RGQzJZamJMUlFjanBpcS9zOVcwbXlWbUhNbDdtbnFmajR1aCtKVVkvdWJrZFQvRitWSWRNOFRxM0VkeUIzNU5mcnRMWndzeEFpZzVQOTNyVk45TXRRNVBrUTU2WXgweFFzdmwvT0pabkZPM3MwL21ma2JMRjRrUWtiYmpyMnlUVlJwZkVjWVU1dVFPM1d2MTJrMGV5Y2x2c2NSejdjVm5Ob1duazRhd2g5dWVLUDdQcWRLaFVzd29mOCsyejhtRHFYaWNIL1dYSjlldlNtcHJQaVJXQTg2WlIyeU1WK3JZMEhTdHpidFBpSjZrOFZVYncxb3pkZE1qNSttYWJ3R0kvNStYK1pNY2Zobi95NnQ4ajh2VzhRK0k0a2MvYUhPZU9SVlkrS2RmWC9sczM0cnhYNmdMNFMwQXJJWHNWQUp5Q0FEVk4vQjNoeDgvOFM0Y2ZRZzB2cWVLU3Q3VDhXTjQzQ1h0N0phK1NQekpUeGJycTV3M09mN3RYRDR2MXNSL050SC9BT3Y0MStpczNnSHd3eEpGanRZZWdGVXJ2NGMrR1pNNHN5QWV2eTFIMVBGZnovaUN4ZUR1djNmNEg1K3llTk5XNHlpRUJjNDI4Zi9ycWgvd205N3Y1aVRKQXlPYSsrcm40YWVHTitCYmNFZW1QNVZ6emZDend4dS8xZlVlbk5Xc0pqYmZHdnZCNHpMK2F6Zy91UGpWZkhOMG9YOXpHZmJKQUZNbDhkejd1YmNIdHd4cjY5SHduOE81eGdqSnoweWF5WmZoQjRkM1o4enI2NW9XRngvZjhSeXgrV3BKV2ErUndMZUtkRGpJVkxja2p2amppb3g0MmdBUGwyb3gwNU5mR2dmV1plMGhHTzNGWEUwdldMaGtHeVUvWE5EelBFdGU3RzNvaVk1SmhJcThwWDlaSDFyTjQ3bUNZRFJKZzlTUlhNM0hqK1ZTTTNpTG5zT2E4V2c4SGF6TW56UkhuaXRpTDRlNnN5L013SFdtc1RtRTFvcEZmVXN0ZzlaUlhsYzdLNStJSVAvTDY3WjdLTVZ6czNqY1NEaHAyNzh0Vm0zK0dkNndHNlVESGZ2WFhXdnd2VElNa3BQOEF1MG1zeG4wWXJaWkNXa2xjOHRieHBLRGdRT2ZxOVJQNHV1blhLd29DZW1TYTk3WDRhYWVHenRaaGowcm9vL2gxcHFMbnlNL1hxS2NjSGo1YjZmTW1XT3kyTHNrMzhqNWNieEZxY2crVlVIL0FjMVViV3RYSTRrYm4wUUN2cysxOEU2ZWcvd0NQZFR4M3JZVHdwcHFOeERDUHdxLzdNeGIzcUw3ek41emdJTFNtL3VSOE5SM3V0eWdxR21KUHBrVTFiTFdaQ1FSS2VmZXYwQVRRdE9RazVoWEMrZ3F4OWswbU5SbTRoNTY0d0twWlRVZnhWVE41NVFXc2FMWjhHd2VHdGFtR1JDNTU3NXJYVHdKcmhjQXdFSHRudFgyMTUraFJjbTlRZmpURzF2d3dDYzNKSkhwV3p5bWlrdWFzdnZSenp6eXMvaG9QNXBueUZIOE90V2xYNWtWZnh4V2JjZUc3VFROUXRMZlUvTVNHNEJWWkkwTGtQamdFRDFOZlliZUt2REVZT056SHJ5S3c1dkdYaHN1cmZaUXhVOU1aL25YTlV5N0RjclVhNlQ3dDNOS0diWXRUaTU0WnlqMVNUUjREWmFEb2RucjM5blg4RjB5M05zVGJ6Ukx4SEw2UC9za1YyV2pmRCtHVzJabm5PQTdCT09jQTRGZW14ZUtiRFVya1c5dGJBeXlaQzdnQmpqMU5RV3ZqSzN0NGxpUzNVQmNqaytsWTA4RmhvVlh6VlZKYm5YTEhZdXJSdENpNHU5dSszVXk0dmhqcHJmTXpzZndyWi80VnBwRzBaUi95NjFNUEhycjhvU0pmVExWQkw4UTVzNU1rQXgxcjBZUXk1YWU2ZVpPcm1kdHBYOGkvRDhOdEdDakZ1NTdlbGJhZUF0SFVyaXdIcHoxcmk1ZmlOa2NYMEsrdzdWbG40aVlBenFRd2M4NHF1ZkxZdTFvL2NURlpvNHArOTk1N092Z3pUVlZjYWZIK05YeDRac1ZLZ1drSS9Ddm5sL2lJcmN0ZnlQNllHS3B5L0VHRGNUOW9tUEhBclJZakxrdEZIN2tZUERabk9kMDUyOVdqNmRHZ1dnUEVVQzQ5cTFFMDYyQS81WURIc0srTjMrSVVZWEJNemVtVDBGUi84SjJoQVlKSVNjZDZYMTNCeGVsdnVENmhtRW5yZjd6N1lqc3JWU012R01kZW1LdkliQUJ2OUpUMkhBcjRXZng2U1JpM1k5c0Y4Vm54ZVA1bzVRd3QxM0t3SUJiSXB2TU1MWjJSWDltNDI2MC9IL2duMzRzK21ySVA5TUF4MTZWWUYvbzRjRnJ2T1BScS9QNGVQdFFtbGNlU2dKeWV0VkI0NDFYekFQTGg1N2tHc0htTkhzelQreXNURzErVS9Sa2F6b0p3ZnRXZG82RW5tcTc2NW9lQmgyeWVvQkpCcjgrbDhYNnR1WmRzWTNESUdNMUQvd0FKbnJMRUtYVWR1RXJOWmhTNlJabzh0cnZyRS9RUCszZEVVZzdUbjA2MHJlSk5LQ1pXSXNSNisxZm5nZkZHdXMrZnREREJ4OTN0VWk2L3J2bUVmYW54OVBXcWxtTUhhMEdRc3NxLzgvRjl4K2hLZUtMSGdHM3lmWWZ5clNYeGJiaFNCYXQwL1N2enFPdGExdlZ2dE14eDZjVlliVXRhWTVGemNuQXpnazhqOEtqNjlGL1lMamdLbFBSMUxuNkR0NGpCR1JDcDlBZVRYTlhIaVNRWkFnVTVQclh4Q3R6cWtnQjgyNUkrcDRxczUxUm1VZ1hCSGNsam10ZjdRUzA5bitJM2xsOTZ2NEg3NC9BeTQ4N3dkRTJNZnZaZVB4cjZTYnFhL0RQNGIvSFB4YjRLMFQrellmQ3AxQldsZVZaWHVEQzN6ZFFRUWE5bGsvYXQ4ZGhtSThBdzV4M3ZXUDhBSksvS3NYZ01iVnhWZVVhVjFLcEtTZDFzM2MvWWFPUHdGS2hoNGUyVjQwYWNXclBlTVVqOVpRS1l6VitPOC83Vi93QVVONUNlQmJKUGN6eXQrbUJYbkd2L0FMWTN4UjA2MG5tYnduWUR5KzJKZm05ODF3enluSHhpMjZhUzlUWCsxc0R6cUtsS1Ric2tsL216OXhHZi9TRXJTbG1RTGtzQlg4Mk0zN2VQeFZrVHprOE5XS0puNzRTUWo4NjRlNy9icitMRS9BdE5PakdmK2VaUDh6WEZEQllwYytzTlgvTnNkODhWUTl6OTNWMFhSUi9WbjlNTFhrS3hPUzQ2K3RjaHErcjIreDEzamxPdWEvbWh1UDIwdmk5TDBudFVCNmdRaXVUdS93QnJMNDAzenFrV3BScVQyVzNVazF4U3lqR1RYSzZsTkxydWVoU3pMQ3drNUtoVmJXMStWZmt6N3gvYWYxR0NmNGgrR0kxYklqc1lVY2VtWk0xOHM2YnF0dGE2MXF6NDYzYjdTT3dCNjE4bitMdmlmOFJQRWQybDVxenBKY1J4cWl6Q0VJd1ZlbjNjQ3ZOazhhK0lGWWt6Z2tuSkpYbk5mZFlXWHNzUFNwM3Z5cEp0SHhkYWpPZUlyVkxXNTV6a2srMG5jL1JMWGZGOXNiYVloM0oySHQ3ZHE5aStIL3hLMDJQdzdaeC92c3BHQmtEak5mazR2aS9YYnNlVHRWeS95OVBXdnRiNGNlRk5WT253Uk1SOHc3OUJtdll3OWVwZVNpMjduaDQzQzAxQk9kbFo2SDJKSjhSTkxhNCs1TDA3REhXcjYvRUxUTURiSE1SNzlUWEpRZkRPK2tSV2VaVlBiQjYxMDYvQ1M4bHhpNlFBZ2M4MTZ0T3JpWTlHZUc2T0djZHlSUGlMWlJ5NzFnbDQ1Nml1dTBUNHYydW5QZXYvQUdYNTMyaTFlRUNSaDh1NytJZTRySFg0TnpCUG12RTJrKzlha1h3VllwZzN5ZHNjSHRXczZtSWttbnFGT2pRaTAwOXZNbzZ4OFc0YjJjU25TMGdLeG9oV0lnS2RneG42bnZXQVBpVENCbGJCaWM5MjZWM24vQ2xJVEdTOS93QUQwRld4OEU3SUFIKzBqanZoYVNuaVZGVy9JemRPZzVPK3Q5WHFlWS84TFBiZGorelZQMWVwNC9pak9vYlpwYUE0SUpNbWVEWHBvK0NHbWh3ZjdSWWtkTUxXZ253WDBqai9BRTUxSTZncWFYTmltRHAwYjZXKzg4YVg0azNRT1cwK0Q4V0pxck44Ujd4UWRscGJrbnZrNXIzMVBndG9MT29ONUpqNlZhaytEWGgzb0xxWS93REFhRkxFOS93SmRLbGJaZmVmTmovRXZVY0FtenR4ejFCTkIrSk90a01GaGd3eEhBQnh4WDA0UGd0NFVQVzVtR08rT0tzTDhIL0NCd0JQY054NmdWTjhUM1phcDBPcVgzbnlyL3dzbld3dTBwYnFkM09GcFQ4UmRkT0RzaFAxU3ZyTWZCL3dYSG5kTE1lTS93RDY2dnA4SS9CNnFoek1jNXljOXFHOFQzWmFvNGJYU0xmYTU4Y1MvRUh4RzdkSWVPd1dxWC9DZitJRkpPNklIL2NyN2dId204RWNFd3luSEIrYmpIclVLZkNmd1FvSk52S1IzRzdOVC90WGRteWpRWFJIdzYveEQ4UTdzK2JFY2RnbVA1MDF2SDNpTnlmOUpUai9BR1J4WDNiL0FNS3E4Qmh3d3MyWUVkQ2VSVm4vQUlWajRHVjl3c20yNDQrYkg1MHY5b2Iza2lQWTRkZnlud1lueEE4U1I0SW5BK3FjMDF2aUQ0bUxEZGRjRGtIWURpdnZvZkRmd095a0RUU2YrMm5BK3REL0FBNThGQ1FEN0JrY1pBSjROUzQ0aHZxVWxRUyt6WStDMitJUGlzSnRXOU8wL3dDeVAxcXUzajN4U3p1V3YzSjI0eWVuNFYrZ01mdzc4RGVjeE9tbllPVkJPVG4zeFV6ZUFQQmJ0ODJsRGFEd1FjWS94cE9uWGZjcTFKOVluNTJmOEpmNGtmcGVOeHowcHllSy9Fakx1KzB2K1ZmbzhQQS9neU5TWTlLUUVrRE9menBVOEgrRDR5NE9rUllQdm5QdlNVTVErcis4ZnM2RVhyeS9jZm11L2pYeEdHQSsxeVpQR0F0VWYrRXE4UmtrL2FwVjV4bXYwMWs4RytDU1F3MHFNQWpuSHJTandsNFZhSEM2UEVvNmM5UHdvVU1SZmRyNWlVS0YzYmwrU1B6UFh4UDRsSkgrbnprRDA3VmNqOFMrSXd1NzdYTTMxcjlIL3dEaEVQQ3ZsTXY5a1FuSElib2VLdFIrRy9DaTdBdW1RNXgyWGlxZEt0M1lyVStyWDNINW12NG04UzViL1RKK25UUFdvUDhBaEpQRVlYQnZiZ0EvN1JyOVNsOE9lRXoxMGUzT09UZ1l6VFc4TytFbXdEbzhRR2V4L25VS25YOC92TlVxRjE3MFg4ajh2RjhSK0k5M0YzUHdPQ1NhZ2sxenhFV3lidVk0NzU1cjlSRThPZUdtYm5Tb1RqR09NREE5YWtidzU0ZGJCR2xRTHljakF3QlZLbldUM2Yza3lWRjdXWHlQeTBYWHZFYkxqN1hjWTZrQnNjVlRsMWZYbkFKbm56L3ZHdjFmZnd4NGNhUWxOTXQxL3dCbmIvbnJWbUhRZEJEay93QmoybTFRZmwyZDZKVTZ6MXYrSWxERHZSMjMzNVQ4bXY3WDhTcXVQdGx6ejIzR3FwMWp4RVRocnU2NDdCalg2Mi8yTDRla0lKMFMwVWtIK0duRFJkQUVuL0lJdFFEamQ4dWZ5cWxTcnBmOEVUaGgxdEpmK0FuNUNEVWRkMmxSZFRybmtqY1RUUnFXdUE4M0Z3MzFZMSt1VTJrZUc0enVHa1c3YzRYNUFNL1NwMTBYdy93LzlrMnc3NDJEQk5EcDEzMC9FdVAxZGZhVC93QzNUOGhSZjY4d09iaWZHZWdKNlZCSmY2eHhtV1p1ZWhZNXI5ZjIwalJESXpEVExiSFliQmpGWjF4cFdoQWZKcGx0dUpHUXFEa2U5SHNhNy80Y0p5dzl0LzhBeVUvSXc2cHEwRUVyR2VaVlZTVHlRSy9iTDRGR1ZmaFpvM21NV2ZhUzVQVWtuTmZubjhjSjlJaGZSdEp0YmVGSnA1R25uS0RCRWNmUWZpYS9STDRQeVorRytrNEdBRk5jK0toS05CWGYya2QyWFNoN2VhaXZzZHZNK2hyYVVmdkNPZUJ6WHhuOGV2aWxIbytrejZOYVRGYmlhUDhBMHFSVHpIRzNSQi90UCtncjN2eGQ0c3RmQy9odTd2cGlwa0Eyd0lUOStROUJqMEhVMStGWGl6eEZjNnRyVnhMZFA1elNTR1Z5V3h1ZHUvOEFRVjQzbWZxV1M1ZThSVjlwSmU1Qi9lejYvd0RnUDhMOUU4WXg2bnFXcFhFLzdpVlkxZ2pHejNHSDUvRVYrbzlqRGE2Wk1sckdYQldISTNQMVVjQVk3MStmZjdOWGlMVGJUVU5UMDZHYVUydDFBTHVKR0dUQ3ljT0pHSGM5cSsvSm9yVFVMeUM4ZTNYTUtFUk95L01BM1dzclhsMXNkZWRWS3NjWE9uT1V2WnFLY0YwVGEvek5SQVJ1a2ZHOXZ2R3ZBL2lYOFFyYnczWUlzYWVmZjNKMldscXArWjJQYytpanZYVitPZkd1bWVHZERudnJwczdSaUtNZmVsYzlFVWVwcjgvNUxtNmprdWZFT3VQblViaFNZNGljaTFpUDNZMUhyNjEyVXFldDdlbm1mQ1ZxcVVXMzkzNkhJYXphdzJzYzJwYXpPTG5VYmdabGR2bUNBOUlveFh5aTk3ZCtJTlIxSFROUHZvclNXMXR3NkZrTHdXa1pPR0xzUCtXaEhUOHEwL0YydWF4cldzcnAxbXkvYkpVYVJwSkQrNnNMZGVYbm1QUVlGZkpsOXFHbzYvZncrRWZCYXp5V2l6R2E1dTg3SkwyVk9XdXAyL2hqWHFvUEFGZFUybzMxdjAwNnZzZVpPRXBOeVVsRjJ2ZC9ER0srMC84QUlzM2R4cW12YWlmQmZnKzFtRnUwaE45ZFMvSlBlT24zNXJsejl5SmV5OUFLZ3Z0WjAvd29zbmh2d2N4dmRWdUFZTC9XWXdTOGhQRFEydjhBZGo5VzZtdTN1OVhsMUt6MVR3eG9XcVFTYW5LaWZiYjZPTHkvN1I4b1lkQkoyUmYvQUI2dkUzdjdUdzVHMmthRXB1OVh1Q0lyaS9RWktrOVlyY2R2ZHE4V1dKa20wbDcreThrZXBEQUtTakp1OUs2bGJyT1Q2eXZ2NkV3R2srQ0h5NGkxSFgrb1VqeklMTmo2L3dCK1QrVlZKOU1odHBIMWp4ZmN6VFhjK0pJTlAzZnZwczhnekgvbG5INkRyVEEybWVEUVdZUlgrdk9NL044OFZremQvUjVmMEZWSTlOczdFblYvRkR5M0Z4T1BNZ3NDK0paaWVROHgvZ2o5dXByaFhOSnZmMTZ2MDdJOVZ4Y1drMzEyN0ZzVy9pRHhlRnU3eWVEUzlGdHZsVnlQTHQ0Vkg4TVNEbDMrbkpxemFhenRtYlNmQm1tekdTUUZaTDkxQnVwVjdrSHBFbjAvRTFUbWkxWHhIQW1wNjFkcnAra1FmSkFpcnRYSC9QTzJqN24xTlUyMXUvMVRHaitHOU9henRXR0pBaC9mVEFkWG5rOVBib0swNWZ1WFRvWEtWdHIzN3ZmNUN5V1hoUFFKREpxVndOYTFIcTF0RElSYnh0LzAxbDZ1ZlVMK2RYSnBQSFBpMjAzeU5IWmFSQ2NET0xXeWlIb0J4dVA1bXNnTDRUOE9FRi9MMW5VQjBVRS9aSVc5KzhoSDVWZXY3VHhMcmNjVi93Q0lOU0ZqWkFmdVJLTm8yLzNZSUZ4K2VNVmNZWGtudSs3L0FFT2FWVGxpNzZhcjVuM04rekpwTnhMYzY5cDNoL3hRc1FLUk5lM1p0Y25ISUFnRGRQZGpYMTNkVzN3ajhQYWhJdXNhZzJ1YWx2d0ZtTFh0d1Qvc1JMbFYvS3Z6NC9aOXRmQ1dwZUpkVnNJcnkvc2JOTEx6TGk0TndJWkxnSWZ1dGpoVjloelg2U2FGNHM4SGFhR3R2QkhnK2ZVN2hjcTd3dytYRUNPOHR6Snl4K2xDamVxMXJwYTdXbjNzM2RUM2JhN0xTTmw5N05DMzhXL0ViVUNJTkI4SlE2ZmJjQ0s0MUpoRXlyNitUSGsxejNpYnc1NGtlSm04UStQcEVqSDNvckZJN1NOZllsOG11MGZ3L3dERmpWOFNhcjRoczlEaGRpVEJweWg1ZHA2N3A1T00vU3ZBZkVtbWZBM1NaV1c4MVI5WjFBTWN0TExKZnlidlFvbnk4MTJjdTl2d1YveFp5eVN2N3R2KzNZODcrOS9vZVR5Vy93QUZMYTdsVzR2SmIrUWM0ZWFTN1lrZGdFNE5lbGFQci9nKzJpeHBYdzZ2YmprSGN1bkxHRGovQUducm45RzhSM01VN1I2UDRGdVdVazdDOFNXaSt4eTNJcjFpd3ZmakhQOEFKSHAyaDJtZWN6enZPMzRoT01pczVMVFg4V1hLVnQ3OXZlbmI4RG4vQUI5UDRtOFIrQ05TczVQaDNjMjFzMFhtbVY1b2N4K1VkMjRLdUNlblN2eHNuMHp3aEpjVEY5Y25nWXVTVk5rV0NuUEl5cmRxL2NuV2RDK0xMYUJxY2t2aWpTQkdMV1JwSW83Snh1R09WRE1lTSt0ZmliclQ2THBlcDNGcnFIaHhaSmdRNWtTNmtRTUhHNEVEQjY1cktQS3RyZmlWcDdMUzIvUnQyKzh6NFBEdmg5blg3TjR3dGxidDVrTTBPUHh3YTJZckR4ZmJPVnNQRWtOd0IwV0Mvd0N2L0FYSXJGUy8rSGtpSHpOSDFHRStzZDJyNC9CbEZVWkxId1RPVDVHcTNsdG5vTGkyRGo4NHlmNVZUc1l0S3kvWFU2UzkxUHhuQ29PcDZSRmRJUDRwN1JYR1A5OUFEK3RabW16ZUViK1J2dE9tVDJqRG5mYlM3MHo3cEp6K3RXTExSZGNpZGY3SDErQzR6MFNHNU1UZmlrbTJ2UlJOckZwQ3NldDZMRE12UXRKRjVUblBkWGp4bjYxaFZtb3hlcDZlQnd6cTFVbEc2WFFkWWFYY3d5ck5vV3VMSTRBT3dNYmVZZTIxdUcvQ3VEMTN4RWJtL2xoMTdSOThxbmI1NnI1RndNZHpnYlcvRVYwMTdCNFd1TFZtdHIyU3dud1FrZDBOMFJQdEt2SS9FVndGeGQrSTlNalNMVUlGdmJRL2Q4Mzk5R2MvM0pGNUIraHJsb1JUVGR2UTlqTktuSW8way9ONmZtVzdEVGI2RnpkK0hOV2FaZ1BtaEI4cTRBN2hrNk9QcG1vcE5TMERXSkdUVkxiK3o3enA5cWdUQ0Z2K21zWGIzSXJLaDAvUzcrUlgweTZhMXVRY3JielB0eWYrbWNuSDVHdENmV0JOSWJUeEJZdTBpRGFMbFJzdUU5MjdPUHIrZGR0dGQvbjFQbkl2VHlmZlkxSlpkZThQMnkyMTNGRHFPa3pIS1pQbVF0N3h2MVJ2eXB0dFlUUmJ0VThOWHNyZVdNeldoLzE4UTdncjBrVDNGUjI3Nng0ZmhhZTFraTFIU2JnZ1NLVjN3dVA3c2lIbEhwMGVrd1huL0V4OE9UeVJYRVB6eVdKYjk5RmprdEVmNDA5dXRZSzBXM29ydmRiUDFOMHI5L1MrcTlDZU9EU1BFN0JyWXg2ZnErYytYblpEY04xeWgvZ2YyNlYwWDlzd2E2VTBqeFV6V3Q3Qis3dDlVZGZuVEhBUzQ3c25vM1VWeXBmVHZFeFZXRVZqcTRPTi93RHE0YmtqMS91U2UvUTFPYjZHKy80bFhpQkhndTRmM2NWNncrZVBIUkpSL0VudlJ6eVRlL3B1MTVydWh5aEdWbmRYdnBMWlB5Zm1lZzZmcmx4NGVqazhMZUxiQnIzUkpXM3d1aEJrdGkzUzVzNVBUMVhvYXkyR3UvRHpXYmUrMCs4Vy93Qkp1enVndUl6KzZ1RUg4TEQrQ1ZlNFBJcUt4MU5kUFJQRGZpcUY1dE1KemEzVWZ6eVdtL3BMQTM4VVo3cDNyMUxTSXJmNGZXZHdOWXZZZFRzYnU3UXdhZUl6SWswYThpNlF0all3N2ZrYTlQRDFJVGFUbFpmWm4vbjNSNE9McFZLYnZUamZmbm9wZkhmckY5SkgxN0I0am44VzZMcGh0UWJlNlJ3OGM4b0tQYmdqSlU0NStiLzY5ZGQ0VzhPV044MGdpZHJEVzdSaXhsREhMRUhJZlA4QUVyZDYvT0RXTlo4VGVGZkZhYTVGZnZxT202bzNtUTNIUko0LytlWkg4RWlkQ08xZmYzaHZXN2J4RllXZW82VmRGYnFOZDhNcFBCSTZ3eUN1aWF2RnhXbHY2djZNNXFibm8zTk9MVm8rcTNUOUQ5U3ZoYjhSWk5ZdFpOUDFKUkJxbHBoTGlMMTlIWDFVOWEranByUkpDR0g0MStWTnBmVGVJTFNEVnRLUDJUWE5OTzE0U2NGdHYzb1gvd0JsdjRUMnI3OStISGp5eThUYUhGS1BrdUl6NWR4QzNEUnlMd1ZJcmpjVzkxcjFQVHB6Y2R0RnQ2ZVIwZDc0YmhsbGxtQUphUS9NUGYxcmIwV09TM2tNUVhsZlU1elczZVhBalJ1UW9BNUo2VjhqWC94eDBIVDcrNXQxaGtsa2pPQnNJSTNBOUQ3Vnp1S1V0RWZWWUhEWmhqNFRoU3B1cHlwWDhybGY5b240YzNOL3BUZUlkS2hWcjIyWC9Tb1FPWm9nUHZESFZsL2xYNUJMNHd2NFc1aVVqcHhYN282SjhhL0MycGFqYjJFMGNsclBMaGRrNEFYY3crN25vUWErSC9pLzhEdEowdlgzdkxaVEhZMzd0SkVxajVZM1BMUi9UdUs5L0NWYWswb0tXcVdubWo1TE84b3IwRkdXSXc3cHl0ZlZmRkh1cmRqNHlzdkhGNnpBTmJ4dUQ2bXZrLzR5eldrK3Y2ZmR4V01FQmx0eUg4cEFvZGxQM2pqR1Q3MStoOWg4TXRHTW0zN1EyTUU3anhpdmtiOW9Id25iYVRENGVtZ2NzSkdtak9UMkdDRFd1TG8xM1JrNXJSVzFQbmNxcTBWaTR3ZzdYVDA3MlI4bVdlcXhKR1E4WURGUnNjZGo3L1d2b0g0T2VKRzB2eExxTXNjWVBtMnJJUjZBRUhJTmZKYkxJcmtIb3ZIL0FPcXZwLzRGNk5CcVhqUmJPV1F4K1piVEhKOWhuRmVIaDAxV2hiZTU5aGoybmc2Nmxzb3QvZHFmWlVueEZrREhGbUFPL05EL0FCRmJ5c0cxWURJTmVrTjhHN1YySmp1dXZjNU5RbjRPcXpiUmRnZ1lHUm12cUU4WkY2WFB6Zmx3VW82bzhyUHhEakQ3aGJNZnh4V2xIOFRvbEFIMkp1T2VUa1YzTGZCRmljaTlYY001SGI5YW92OEFCV1RDL3dDbWNkT1JXaXFZeS9YN2pubFJ3TnROdlU0eGZpWkF4ZHZzMGcvRVlwa2Z4SXQrTXh5am5rNTcxMXArQ2QyQWNYUzU5S3BOOEV0VFVCaGNnblBURldxMk1qMys0eGxoOEhLMTdmZVpvK0pkbnV5VE1NWTV4azFZSHhOMDdJSk0zcHo3ZlNvWnZndHJTb3VIR0NlYXFyOEd0YTVJa1E5ZVQvT243Ykd2WmZnYXJDWUcxemFQeE8wNHIvckpRZm9SaXJwK0p0b0ZCRnhNZlVqTmNPM3dkMThEZ2crNDdWVmsrRTNpSkZBNE9lT25OTjRqSExwK0JFY05nMjdYL0U5Ry93Q0ZtNmRnRVhNaDllRG1wZjhBaFpXbnV5bjdiSWg2a1lQU3ZLMitGZmlZU0FDRVlIcFdjUGhqNG4rMFlFQXdPcG8rdDR2K1g4R0o0TENKNlByNUhzMDN4THM4RURVR09DTWRSVWEvRXkxMmY4aERQUEdhOEh1ZmgxNG1Ec1RiNDV5QVQyckxQdzg4VEx5YlhQb2EwK3VZeEplNytCQ3dlRDVuNyt2cWo2V0h4SnRHUlI5dlhKNjVOS3Z4SEFQR29vT2UvUEZmTVQvRDd4SUJrMnJWUi80UW54QU1uN0szc0tGbUdLVzhQd0NXVzRSNjg3WC9BRzhmWUsvRWcrVVZGL0czcjBwOFh4R0p3ZnRrWEl4aklyNUFid2Y0Z0NrL1pINXdLeXBmREhpQlpDcHRHNDY4VW5qOFIvSXZ1RCt6Y1BaZnZKZmVmYXcrSWNpNUMzRVhQVWtnMXRKOFFwU3VETEUzNDRyNE1IaDdYZ2MvWnBjZXluRkEwaldWeURhVEFET1RnMWY5b1ZWdlRSWDlsNGROV3F2N3o3cy80VHpJQkx4QWdub2V0Ty80VDRsZWtmMXlLK0NHMHZXQUYvMGViQjU2R3NtVzAxUlpOdXlVYytoby90T3Avd0ErMFJMTGFWOUtuNG42R0R4eGc4eFIvblIvd21FRWhKbGdSaU8rYS9QZnl0U0dNK2RrZCthQlBxa2VRWGxINTA0NXROZjh1MFkvMkxDWC9MMW4xQW1sNkpFb3pMSCtsVExQNGZoQXpNaDYvZHhYeFcrdTM1UFVEMk9UV2Urc2FreCtWeUI3REZWL2FkS1B3MFVkUDlsVjVQM3NSSm4zZC9iL0FJZlJPQ2VPMktweStMZElqSHl3aysvU3ZpaEo5VmtYUG1TYzlxVDdQcWN2T0pTZnhxbm0xUzJsTkw1RS93QmowazFlbzM4ejdNUGp1d1hoWVYvRWlzbHZpT2d5dTJKZng2MThtcm91cVNIaUZ6VzNGNFQxZGxCOGs1UHFLeWVaWXQ3UmYzRi8yWGcxSzduK0o5QlA4U1QyblFlMkt6TGo0aXRqSXVUejNBcng2THdWclQvd0ZmWGl0cFBBZXJNZ0Rad1Bhb1dLekNYUi9jYVBDWlpCWGM0L2VqcTV2aUl6NEhuU2NIdFdOSjQ4ZG5JSG1rWjR5MktuZytIRjgyQWQzVHJqcFc3SDhMN25qTzQvUVZGOHlrOXBGUi9zbUQwbEJzNFAvaE1Kc0VpS1FuL2Flc3VUeFZkcy9FWTU3azVyMnEzK0Y3czJINEFPZVRXeXZ3cWdEZFRpcCtyNWhMN0xOUHJlVndmeHcrUjg0LzJ6cVRFc3V6dnhqTlZqckdzazhPQWZwMXI3SXRmaGxhUnB5ZzY5eld3UGh6WUFES0tjZE9hYXkvR3RmOEV4bm1XWFJlNis0K0lwci9WblhjSkdIcnhUWW85WHVXQ0pJKzhna3FPdUJYM3RGNEQwNVVJTWFmWEZjbHEvdzhrbXU3S2F5djhBN0s4RG5McWd5eW5xcHpVU3kvRnFMZS9sY2RQTmNFNXhUVmsvdFcyUGxuUjlFMXE2bG0renJOTkpBbm11cWs1UlIvRWNkcWRiNmJmWE9aRWlmcWNqSk9DRHlLK3M3cjRka2ExYTM4T3F6MnhpVFpJc1JDaVVIc3hIWTE2TmFhVnBsdkFFWlkwWUVsOEVjazk2eGhsMklsVWFiNWZQZTUxVmMwd2tLVVhIM20zdHRZK0dXOFBhcHZ3YmR5RHpubkZUcjRTMWhnU0lHSXoxeFgzMHNlaUtRR2xpQko3c0t0dTJnb0F2bVJnZXh6WHBSeWp2VlBNbm5HbC9aTDd6NENUd1pyTEtUNVBUOFB6clVYd05yVEgvQUZZNDdaeGl2dVJibnc2cmNzdUNPYXBUZUpmQ2tWNUhiQzVScFN1ZG9YSndPOVZQSzZVYmMxWDlEbWhuRldiYWhSdjZhbnhrbncrMWpzbURtdFpQaHBxckRsbFUxOW5EeEJvQ2pPYzU1eUJWVnZFdWo0RERKT2M1eFZSeTdEcmVvSDlxWW0vOEs1OG53ZkNxL2JpU1VZOU1HdGxQaE5ObkJsL0lHdlV0YytMMmhhUGQyME1zTXBhZGdvS2dZR2VNazEza0hqalMyanlJMU9RRGt0VXh3dUJia2xVVGNkOVRhV014MW95OW00eGtuWjh1OWp3YVA0VGdmZWtZbm50WFEyZndndFN6QTdpVGcrZ3Ixei9oTnJSQVNWVWM4RGRYTDYzOFZyZlQ5UG1uU0NOeEdNc1MrTURQV3RwWWJCUmpkdFdYbVl3eFdQbkxsVVhkdlJXTXEzK0VXbkNkV1pKUGZtcm4vQ285TjgwWlZ3TWp2K2xiOWo4Uklwb1k1bzVZWFYxREJvMjNLZHd6VTQrSUJVa0YxeDdqTlI3SEE5SlIrOGw0dkdQUnduby81UmkvQzdSeTZZZ2JLbnJucldvUGhoNGZEdHV0UWNuMXJHbCtJRSswbGRtUUs4MThOL0dHYlVyN1U3WjdqTTlySUFWV1BDN1QzQlBwUko0R01vUmJWNWJGMDNqNnNaemltdVcxNzZmY2U2cjhPZkQ0ZGd0b3ZBOVRtdDJMd0Zva1lHMjJqSngzV3ZNMytJVjBDcE1qQUhqSUFxRmZpQ3hjZ1NTWUhYT0JXNytwTCtXNWhmRTMxNWoxMCtEZElVQUMwaDY1KzdrMXMyL2h2VEZ5UEtpNEFBeW9yNVo4Vi9Fc2FacEwzSmUrWmd5N0ZnQWJkenp1OUJpdWdnK0lzYzBZbWphZFlwTUZGbFlid0NQNHNkNjVZNG5DZTBsRGF5dmUyak5hMkZ4M0pHYTk1UG9ucWo2TVRRZE5SbS9jeEJUNktLcm5TN0pUOHFSNDlOb3I1OGs4ZHduSTNuSi8yLzFxSWVPYmM3UnVBMjg4dHlUWGM4UmdVcjg4ZnVPU09GeHNyTGtkL05uMFZMYVdvWUQ1QVZIb0t4NW9iY1B1RWc0R09lSytXOVUrS0ZpUEVWbGJ3K0YzWVNXMGlUWGIzUk1lOC9ka1VEb1Y5S3VTZU9MY2ZLR1VrZGV1SzRjUG11R2x6WHB5aHl1MnR0ZlBROURFWmJpNHhoNzZtcEsramVuazdudU42OEtnbmVEeDYxNFg0a3RGdmJXNERzb1VLZjVjVmpUK05iWnQyQ25YdURYTlMrSm9iaVF3QlluM3RoQUJ6azBZbk5NTk9qVWhGWHVtdHROVExENVBpSTE2TlZ5MWpOUzg5RDdrdmZER2lXWDdPOXJFTEdMNXJScFdKUWZNeDV6bjFyK2RlNjB6ejlYdVVVOGVhUU1mV3Y2WC9pTzR0ZmdWQkUyQTRza1ZoOWVjVi9PWllYTVVlc3pNMk1iem4xNjErUllIREtsVXhNbzZjMGo5bXhPSWxVcTArYnBUU09wcy9oMlhVWlZzbXQrMjhGWE9uWGNjdHFxbVlIQ2h4dUJKNHI2SzBYWGRNTVVYN3BXQVVaQkl5YTZLR2ZUWjcrME1kMHVmUGpBaUpHVGxoeitGYVJqaUpTdHpiaTlyU2haOWJuei9BT09QRFh4UDBHMVJ0VTBHT0dLZEJ0ZnlnVktucHlLK2JyZndyZjNoSGxLdTlqMEp3Sy9mMzlycVNPMzhGNk5Db0tza2FFbkhCeUIwcjhtN0hVZEh0N2ExbVcraWZma091TU1oSFhJOTY5U05LVUtVZGRYZm9jRHhLbFdxMmhwR1Z0L0pNb2VBUGhoZWpVWTdpOUVheHB5RlU3dWZldnRqV3ZGMmtlQ05GaXV2c3BuWXR0U01IYm42bXZJOUI4YjJNTVBsYnhzemtjWjYxYThRNnZvR3RXZ3Rib3JNakhnRUhnajA0NE5lcmhzVDdLakpMNDJlTGk0UEVWNGN5OXlMMVMwUHFid0o4Wk5DOFJKRXFXczBNd0MrWWpBTUFUMkJINlY5VHg2dmJvcU5qZ2pJd0svTG53RnFIZzN3dGJhckZIWVhEelhLTDVNNjVZUmtIbmNEeitWZXAzM3hROFBtS0ZyZVMvM0tNT2pnc3FzTzZzT3g5RDByMWFHWTNWcWtOdG11cDVtSnl5Q2t2WTFMSzJxZXArZzM5cndrQmRwSnlBTUQxcjBNYVhkd1hONUZPRWpsZ2dqbEtGaGx2TUlDZ2V2WG12eWRUNHBSQW5hSnkzVWNOeFd2ZC9GalU3MjU4NlZybDV3QUM1REE0VVlINVYyU3h0UFMyaU9CWVdVYjNUZnpzZmEzaS80aTZYNGI4YnA0Y3U3ZWY3UklRcXpvUDNKZkc3Wms5d0R6WGFqeERFUUNGUHplaEhTdnlUMXZWLzhBaElQRmtHdDNseGYzTThBM0ZHeVUzQVkzWTlhOUVoOGVYVXFreDI4elk3WUkvQ3NxR1lXakpWSXB0UFJyc0ZiQkp1THA4eVRXcWIyWitrYitJZ3BYZ2ZpZWF0eGVJNGRoM1l3Ui9lNzErYXNuamJVZ29Kc3BoMndlT2Z4cTNENHgxRi9NQXNwaVVJM0E5YTdmN1FvT1B3bkpIQTRoTy9NZlZIeEgrTnVsZURMVzNsbXRKTGd6TVFxUnNBUUIxT1RYb25objRoMkdzNlJaNmhBUDNWekVIVGNjRUE5ajdpdnpMOGJUMlhpS3hGcnFHblhCQVlGSFViV1FqMFA4eFhYNmI0dWV5MHFDMHQ5Sm5TS0pRcS9LQndPSzRZWTlyRVQ1bEgyZGx5cTJwNjBzSFRsaGFTaXBLc20rZDN1bXZJL1N5VHhWdS9nVmYrQkR0UW5pVkdLSDkzK0xDdnpoUGpEVnBkcFcwbEg0Z1UxZkYrdkt4eFpTRUwzeXZXdXg0K2piU1A0SGwvVWEzTTd6UDBVdVBGVUVVVWp0SkdBbkpPNGZXdVJQeEd0LytFaWswNksvMDI5Q3dSekNXMm0zQlEvOExBOUdIZXZoRnZHT3NsR1ZyTmoxeUNWR2ZwV0RvOXdOS211TGl4ME5JWHVEdWxaQ3Z6R3VTZVBuN1NEanN0MDF1ZE5MQkwyYzFMNHZzdE0vVUdUeFN4UUhkRHlPelZDZkZlR0daWWNuakc3RmZuMlBFR3V6TkpoZHBITzFtQUorbEVldTY5dithRWdnNEdXclgrMEwvd0RMdEIvWjFUUisxL0UrL1I0cmpFakV5UWpJNmx1UDBxKy9pclFScGVwM0UvaWJUOVBhMGlFcUxQeVp2OWxSeDlLL091Zld0ZmlZL3dDajVJNXlIL2xXTnFwMURWYmVPTzYwZUs4aXlEaGlEdGJxTThjVmpYeGtwVTdSdkY2YXBHbFBCT003eWtwUnM5Rysvb2ZvcHBmalNLNXRrbSswUkZXQVlNT2hCclRQaWVMWXhXZE1rOGV1Sy9QSzIxcnhQNUt4eDJXMUVHTnF2a0FEaXJnMUR4a0dHTFRqQk9TeE9SVFdPbFplN2Y1Q2VCdjl1eVB2cGZFNnFTM21LQmpPTTU1ck5uOFk3WXlUS2g0em5CcjRYVFV2RlU4akFRRHB3QXhIUDQxSTE5NHZVN1doVldQQlV1VCtOVzh3YVg4UDhERjRIV3lxUDd5ZlFQMmxQRkY3OFNSb2x4Wlc2MnJTeVJnUnhNWkk5blJ5VDYrbGZjRGVLNW5pY2VZbWNBL2RyODU1ZE0xZTIxazZtdHZFYnQxQ2wxVTdpUHk1eFhRLzJ0NHZra0NCTitPcmZNcDVyZ3crUHJ5NXVlSDJ0Tk9ueVBUeE9Ed3pjUFp5ZHVUM3ZlYjErWjkxU2VKNWlnSG1xQ1A5bm1waHJzNXRSSTEyb0pmYnNBTzc2L1N2aU1Ydmlkb3dCdUxEc0MxVERVUEZHQUdVN3V3SVlWMy9BRjJva3ZjWDNIbkxDUnUvZTZkejdNbDhXV2xwYlNTM0YvNU1NZjhBckpOaGJhdWVTQUs1M1JmaVhvZXEzVjZtazZ6SnFGdERNVlNkN2Z5eXd4K3VEWHpwTG92eEhiVGplUHBxdmJNdVE1M1lJK25lc3ZSYkR4bmNqeWROMHBmTWRqc2hoalliaDNQRmNNc1pOMWZhZTB0Rkt6ajBQUWpoSXFtNHVENW0wMDF2WSszajRwaFZUdXUxM0RvTnZlc1NYeGZibmN2Mmtnazg1RmZHK29XM2ppMjh1TzRoU081YVlSK1R0WWxTZTdZckF1TFh4c2pNSkRGbnR0UmpYWjllbFpXam9jbjFHNjFra2o3ZmJ4cnRmUDJqSTlBTzFVbjhmNlJCUEUycStJRzBxeGNQNWwySXR4aklHVkdPZXByNG1pc3ZGMGhiOTVId3BJRzFoazFmZlIvRk54WnQ1eXhzbUR1RWlNVitoRlkxTWJXbEJxSzVXMW8wdFVhVThIVGpLTGJ1azcyYjBaOVVlRlBpWEhxV25OSkhmdE5GNWpyRmNOSHM4MUFjSytPMlJYb2c4YVc1andMc3R4ZzhWK2ZjRnA0dEVleUdBTEd2QTJ4c0ZHUDZWZEduK05kcHo4clp3QnNia2V0YXh4bFZwWGpkcnJZeitveGkzYWRsMnVmY2plTmtWc0M1Y1k3N2V3cG84Y1FuSU55eHpuQjJZTmZEbzAveGt6QURlTStrVEUvVDNxbWxqNDdabVVRTUNEbjVvMkdRUFNxK3ZUMjVMR1N3S2IvaS9LNTdsOFIvaWgvWXlSTi9iOTFZSjlsTHdzc0FsRXR5RHhHYzlGUDUxNkQ0WStJZC9lNkpaM041S3lUeVJCblVMamsrMWZGT3FhYjR3dVFJWnJSSmwzQTdKSVdia2RPdFdtdHZIQlVLa1JETHh0TWJjVmpIRlZvMVpOdHRQcGJSZWgxVHdsT1ZHRnVWT0xkMzNQdkZ2SHNRaitXNWtCN2piMXJtditFM1l1V054SU05RGpOZkY2V1hpenpBc3dZQTlRa1p5S3c3OGVJYkFUU1hMTWlJTWdGQ3BiUEFITmRzTWJVdmJrZXZrY0ZUQkxsdTVyVGF4MW12YXZKcTNpUFU5UmR0NEFFRVJQOEFkVHJqNm12MmUrRGtZUHcxMFlZd05oeWVnSHY5Sy9ENHhmWjlQampQWGJ1WStySGsvclg2ajNmamNlSHZnbG90bkErMjcxRzMySWU2eGdmTy90eHdLeHpMU2pDKzdsZG5xOFAwWlZjVTRSZTZVVS8xUGw3NDRlT0YxcnhMT2xyTTMyV0FlVER6d1FoK1p3UDlvL3BYeTlhV3VzZmJMbTNoeVRQRUlwRlVLNGRINTY4L3B6Vmw3TFZkV3ZsOG0yM2h6a0E1QXdLL1F6NFMvQytWWmxrbnQxalE0Wms2aEQvZEdhK1hxU1ViZGI5RCtrYVVxV0V3Y2JKS0VGcmZ5UFZmZ2Y4QUQ0YUpvRVR6eEw1czJTVHR3MkR6Z251SytyZFYxQzAwK3dtbm1rV09LRkN6c2VBQUJXbWtNZHJBcUlBRlVZQTlLK0NQaW40aWw4UjYvd0Q4STFhVFlzcmZiTHFrcW5nOXhDRDZudld0R20yMWQrYlorVTVoaTVZbXZVcVBSTjM5RWVkWCtyeWVLdFpieERmUmxOUHRDeTZaYnVlR0k0TTdEMzdWOG0rUHZHZDlKY1FDM2lOeGQzY2hoMCsySFdTUnVONUg5MWZXdldQSFhpaXhodHBvQTRqdExPUE1wQndGVlJ3Zzl6WDU3ZUwvQUJmZGFMWXkzNzVUWE5YZzJXa2VPZFBzRzRCSHBMS1B5RmVxL2NpMjlyYjlrZktLb3FrclJidTNhTVhzK3V0dW5jNXZ4UnFWNHN2L0FBaHZoK1I5UTFIVUpsWFY3eVBscnU0em55SXoyaFQ5ZXRKcnQzRDRUMHcrRFBEaCswNnZmYlk5WnZvRHVMdWYrWFdFaitCZjRqM05XTGN0OEx2QzZYQkNueFZyZHRtTFBMNmRhU2Z4ZTAwby9JVng2SWZBbWl4WExsajRrMU9NdEVwNWF6Z2svalAvQUUxZnQ2VjV0V3JLS2VudlNWa3Y1VXpiRDBWV3FSY25MMlZPZDcvOC9acjdUdDlsZEVaR3BML3dqa1NhRHBMbWJWcm5DWDg4SnlRVy93Q1hlTWpzUDRqWHFjNVJJVzAvU2tzMzhVQ3pDM2M2Y0U0Nnh3ZHZPQSs4UjE3VjVHKzd3ZnA1TFlmWHIrUEpKK1pyT0tUL0FOcXYrbE9pQytETEpiaVVCOWV1NHlZbFBKc1kzL2pZZjg5V0hUMHJ3Rkc5dmV1N3V6L21mK1I5cjdUbHVtcmVYU0svekdmWjdMd2FCTmRDTzcxMXh1U0JzUEhabHY0cFA3MHZvTzFRZllMZXhIOXMrSlpIdWJ1NVBtd1dESDk1TG5vOHgvaFQwSFUxNlhGWldFZG5aWGphWkhQNGxlMmFSYk5teW0xZVJPNm5yS2VvWDhhOGtUVHRtN1cvRWpTdVptWm9iVmppVzVjZDJ6eXNZN244cTY0cVQzMDd2L0k0Nm51dFd0YnAvd0FFbGxoMWZ4SzdhdnJGMExYVDR2a1Y5dTFRRjZSVzZkejlQeHB2OW82anJFYmFWb05qOWpzRVhkTGdnTTRIV1M0bFBiMjZDb1NsL3dDSUFkUjFXNkZucHR1TmtZQXdvQTZSVzZkejcvblRGdXRRMXdIVGRLdDFzdE9qK2FUTGJSZ2Y4dEozN24yL0txU3NyYWFmZ1l1VnRYODJMRmY2Rm9PMU5QaVhVZFJ6ajdWSW1ZWW05SVVQM2ovdEdyVnpva2hmKzBmRkdxT2p5Zk1MWU41bDNLUDkzcEd2MS9LbzR0VzA3U0dGcG9NRFhWOCtVYS9aTnpaUFVXNmM3ZjhBZTYweHRIMGpTaWJuWDdtUzV1Mk83N0JDK1h5ZitlOG5PMzNBNXErcmRqR1RzbEc5OUg2bnZYd2I4UWVEcFBHU0pmYVJiV21qd3dTTVJJR21Na2c1VHpXSExFOWw2Vit0MWw0dThiYTFZeDIvaHJRWXRQc0FQbHZkUVR5SXg3d3dMeTN0bXZ5QytGUGl2VnYrRTIwclVKZEl6cE51N3F0cmJ3QXhobUdGQ0EvZmt6MzVyOWRvb1BpcDRuZ09aazhONmN3eXdRQ2UvZFQzSlB5eC93QktwSmUwdjA3dDZmY0RTNUl0MnRGYnlscGYwVzdPYzFqd3Q0WXQyZTU4Y2VOcGI5MUdWdDU1amJRWi93Qm1HUGtqNjFnMlhqTFJZSVJCNE84RTNWNUVNL3Y0YlFXa0I5L01rNUlwa0IrRDNodlV5c05wY2Evck9jRmtKMUc1M2Y3Uk9VVFBwWG83WDN4bjFtRlk3UFJySFFyYVRHMXJ4L1BueDdSSjhvUHRYVjYvanArQWNsNHJtY212N3o1SS9KTGM4aWV6K0wrbzNHU05LMG9OZ2wyTFhUajBCeGdacXhkZUQ5WFFtVFdmaVJjeERIekpiK1RiTGowN210M1Z2aHBONTNtZUsvSGVvU1JrRTRTUkxHRVk3WVhtdk1tZjluK3dmWmJXWDlxVGhzRXJITmVzM3ZucG1wc3JPMTkraUloZWNueTZwZnlRditMMUc2L3Bmd3VpMEhVdC9qVzhudWhiT1lkMnFGOXo0NEcwY0hudFh4VDhRYmE4dFpkQW44TVhJdjBuMHlJM2lGRXVXaXVGNFpXTGpJejJIYXZ2TFUvRWZoOVBDK3FSV2Z3MTFBUk5hU2dUdHAwY1NvTWZleWZtd0srYmZpcGEvd0J0ZkNudzI4ZmhtNzBjV0NSTTJveVJxc01pTXUzT1kvbStZOU0xbTdxMisvZEhhbk4wN1hlcjZ0ZHV4OFpYZXArTkVqUDJ6d3RiU0tTQ1MrbWdkT09xQVZ5RGExb0RQaSs4THhvVDFOdk5KYmtmUU51RmEwT25hOHVQc2ZpcTJrOUVTK1pEK1Q0cmNsZjRtMjhlSnJaN3lGZW9hS082VEI5U3VUV1Vub2VlbDcybHRkTjJqRzB6U2ZCZC9KdmgxQzdzMkI2WE1Ra1FIL2VUbjlLOWFzN1R4YlpXdTZ4djF2YllBL0pFNG5USCsxRytTSzVHMDFmdy9PZ2p2L0QwY0Q0d1pMUmpBMmZVbzJRYTFWMG5UM1V5NlhyYXJNUHV3elpna3oyQWNjR3ZLbkp6bTFyOTUrbFlIQ3hvNFp5a3VsM2RYWDRIQmF6cXZoNi91UEp2N043T1pCek5hajVNbisvRTM5S3c0TFhYTk50M24wNjdTOHRQK1dvaitkUHBMRTNJK3VLdjZycTJxSmNlUjRoMHJ6bUhTUmw4cVlEMVdSZUdIMXpXZmI2VSs4WGVnNmk4am9NbUUvdTdoQjZZNk9QcFhkRmNzVnIvQUpIeE9JcXFyV2xQbzI3THlNOVUwSFZlQVYwNjVPY1pKTnU1L21uOHFzUzNsN2FOSGFhemFQUENCaU1zY09vOVluN2oyNlV5UyswelZIMmFoRUxTNnlRYnFOTUt4LzZhb1A1aXJVa3VwNlRGSGE2aGJyZDJFb3pGODI1Q1A3ME1nNkgycmJZNGRWTFIzOG1KQXVvNlJ1MURTN243Ulp0OHNnSTNEQi9nbmovcjBxK0xHMTFBL3dCb2FFelcxM0NmTWtzUTN6cGprdkFmNGw5dW9yTVczdWRQL3dDSmxwRnlacmJHSlZJeXlBOVVtVHVwOWVsUEZwQnFBKzI2VG0zdTRjeVNXaW5CR09kOEo3ajFYcUt6Y2RiL0FOZk02WXkwdC9TOURjODJ3OFYvTEw1Vm5yQUdGazRTSzdJN1AyV1gzNkdpTzlpMU5QN0kxMy9SN3VEOTNiWHJqRFJrZEk1djd5ZWg3Vm1IN0o0alRJVkxmVmxHVDBXTzZBLzlCbC9RMTZaWVN3bUswajFtRzFmVmpHd3NwSlc1NEdGVzR4eC91ay9qWE5OV1d6MDI3cjA4anNwUG1ldHZOOUpMejh3MDR2NGIreFduaUVReWJadDFxakR6V3QvU1hqckdUL0RWNjA4VU5IcWQ1b3ZqTVBkNmJmU21SYnBPWkxWMys3YzJ4L3VmM2w2RVY1N0ZkU2F1RG9tcy91YnlGbVd6dUhHQ2puL2xqSWY3aFBROXFzNlF2OW9CdkRlcmZ1Ym1GbVd4bWs0TVVuL1BKai9jYnRVMDNLbkxtZG05NUxwYnVpNjhLZGFrbzNhWDJKZmFUWFIrZlk3d1FTZUQ5VXVmRFhpSC9TOUExTGJMSGNSZk11MXY5WGVXeDdFZnhEOERVZWs2aHJQd3k4WWZacDVSUHA5eHRram5qT1k1b1crNVBIL1VmaFVYaGk5ZzFDMW04RmVKSlBzK3lWdjdNdTVPdGxjOU5qRS84c1pPaEhiclZqUzRaN2lPNzhDZUlZeEJkd1RzTk1ua09QczF3ZXNaUGVLWC93Q3ZYMEVVcGNuSzlIOE4rai9sZjZIeTAzS0RxS2NVbXJ1b29wKzlIcE9QbjNSK2xGbHFidjVIaUhTblY1VWpCdUlrUEZ6Q2VjNEg4UUZlMjZmcnlhVGZXbmkzVENYczdvS3VwUXIweDBFb0g5NWY0cS9KYjRUK045VDhLNjdONGYxWlhnTWN6SW9iaG81QWVVei9BSFQycjlLdE12b1BEK3BMT2RyNkxxamJaa0l5c0UwbkdjZjNXcWVWT3o5VmI5QzZTa200eXMzK2E2Zk0vVHJWSlU4UitFTGtXTXlzMXphc0luenhsaHdlSy9MclRMMjAwbldJZEoxdlpGSlpPME52ZkdNYm9XWVpQbUlBUzR6MFk1cjZYK0htdlA0VzhTRHc3Y3NXc2IwTkxwY3BQQTd0QjlWN2UxY1YrMGI0WnMxazAvV1lJQ0hadkxuWlJ3dy9oSjl4WEZPUHZlWFEvWGVDc1hUbmlKNENwZEt0ZVVKeDBha2wrcVBBZFdmZHFOdzA5M0ZkbHBnMGQzRkdFTGJCZ0RDNENxZS9HYzErcjJqd1JlTXZoakRCZWpiTTl2akorOUhJbjNXcjhTN0FHU0Y1a3dXUjhGTUVsaC9lK2dyOU4vMmVQRnQ1ZUxlNlpPNGI3UEdzaU1UbG1VOGZrS0tWU1VhcWEwYVo5L3hubGZ0TWk1a2szaDVKdDdlNjF5dXg4a1RYOGxocWx4WjNVQldXR1FvNEp3Zmw5cStQL3dCcFM2am44TjZHNFRCUzhmQnovZVhwWDZUL0FMVmZoQTJhMm5pcTBpUFZiZSsyci8zeEljZmthL0hmNG9hdTJwZUViZFJHUjVWNHJaSVBjWTcxOWJYeHZ0TUpKTks4b244a1VjdFZETXFOU0YzRnR0ZVYxYXg4aVN1cHdjNUl4elgwdjhDcitPRDRrYVBJL09SS25IdWhyNXB5eFE1VWtCZURYb1hnRzdObDRsMDI2eVFJNWdTUjF3Uml2bGFFK1N0VGwya21mWTQybTZtRXJ3NnlweVgzby9lU0h4RmJ3dXVZMkM0NXdhMDI4VGFZcjUrWWs0Snh3TVYrYjl6NCtqU1Y5cnZ3ZU03cXBKOFFnNi9lZjNQTmZjZjJoaHY1Ykg1UEhBWXRSdHpKOWo5UEY4UWFac1Y4a2dranQrdGNkcm54SjhNNlcxbkZOTEkwazc0Ukk0eTVZZHp4NlY4QXA0N1JjYnJncUNlNUlGY0Q0ajhRUmFqUGJ5VzJyRzNuZ2JLeXI4MkIzQXpXVmJIMDFCOGtieTg5am9vWUdyekpWSmU3cmUyalAxMXN2RWVqM1VTeXh2dVJobmNSajg2MVk5WTB6TEVUS1FnNUFIU3Z5ZTA3eDU5a3RsalcvTGdkU1dPV1ByV2xIOFNtZlA4QXBSNS8yano5YXVPUG90SzhXWlN3T0l2N3NscDNSK3ByNjVwSVRkNW1Cak9jWnJQWFY5RzRCbVVZNyt0Zm1oSDhScFR2L3dCSmJiL3ZaRkIrSWNUTGhyc1p4ejgzRmF4ekRESldzekdXQXhqM2Nma2ZveXZpM3dxMTc5a1RVb2pPQmtwbnRXdUx6U041S3pLU1R4elg1RVduaWpVN1hWYnFSTlV0L3Mxd3daa0NneVpIYmNlZ3IwbVA0a1hDeHF2MnBjRHZ4V2RMTUtVdWJuaTQ2NmEzMEhXeS9GUXNvT01sYmZWSDZibWZTMmtKV1pNY2NrOEdvMmZTbExNSm96eU00TmZta3Z4S3ZjRUM1R2UvU3JRK0lVenR6UEg3OUszK3U0WHZMN2pMNm5qT1hXS1AwTnZiM1JJb3k4czhLS281Wm1DcUI2NU5WMG4wdVpGYUtXRjFiRzBoZ1FSNjErVzN4QThRWCtzNkZMYlc4NnMyUTIwWUc3SGFydmdmeFJmYVJvZHZieXlvU29KMjV6dHoyRllSek9uOVlVSFRmcytXL1BmcjJzZFR5bWJ3YnFlMlh0ZWUzSmJTM2U1K25qUVdKSitkUHpwbjJDeXprT293SytGSCtJdDAwWjJ5cjJxWWZFTzRkRlVzb09lVGs5SzlENjdoWDlyOER4ZjdQeGQ5VXRQTSs1RFpXZUc1WHR6eHpXYzlscHJ5RkNBZlhrVjhYdjQ2dUhWOE9Ca2RpYStWL0RldmVLN2Z4cGQzVTg5eDVUdVNTMGgyT25ZQVZ5VnNmaDZiaGFEa3BTczJ0TGVaN0dHeTJ2V2hWNTZrYWJoRzhiNjh6N2VSK3ZTYVZwenNCZ0hIWDNxeStqNmY1ZTFWWG9mUVY4WHA4UlpDU1djWlBVQW1yQ2ZFYVZXNWJvUDcxZGYxdkNOZkYrQjVmMVBGd2QvWjM5R2ZXNTBhMDhzZklQbDZjQ3N5WFJOTzNFdEVwNDVPMFY4emo0anMrUXJOZ2orOVh5ejhUL2lGNHhTNjAxZE12N2lGTjJTSTI2djJCckdyamNIVGc1VzV2Skk3Y1Bnc1hpS25zN0tEczNlVDAwOUQ5TGw4TWFXNmtxaUhQK3pVUThIYVl3ejluUS9oWHpKb254RnZScDl1TGxzekNNZVlRd3hudlhTTDhScmdaMk14R2V4RmErM3dUU2J0cjVIbit4eHNadEtNdEcxcEk4cmcrRzBPZjNoWGl0cVA0ZTZZcEJKQk5mTkY3NDE4VC8yOGpyZFA5bks0Mjd1QWEzSlBHOSsyUTAyTS93QzFYbnh4V1c2L3Vuby92UFhlWDVzNHh2V1Y1UnU5ZGo2bHQvQzJpeEtCdVE0NFBJclFPbDZEQjh6RkFxakpKT0JpdmhMUnRmdjdDYTlNdDRHVjVDeUhKSjU3WXJZdVBGYlhOckxHMHJrT3BVNEI2VlN6VENLRjFoMHBXMkU4a3h2dE5jWEp4MDExdWZaK2wzdmhPNVIzdDU0WlZVbFNWNTVIYXQrVFVQRDhTczVZQUtNbml2ek8wSytrMHFDYUdPV1VxejdnUU1jZWxkYSt2M1VpbFNKU0NPY21sSE9WeUw5MUZTdHJiWWRYSUplMGtsWG5LRjlHOXo3WnNQRzNobThhUllKQWRoSWJJeHpXM0o0dTBkUGxDcjljK2xmbkpZU2ZZNWJnd3d5WWw1SUxaeFcrbDlxSkdWaXpqcG5OWkxPNnJTdlRqZnl1VytIYUVaZTdWbHkyMmVyUHN5MCtKbW1TNmhOYnBFQVkrRGx1VCtIcFczTjQvdFVMWVJRYStCOW1vbStOMGx1aXlrWUo1NXJmRW5pT1RCUEJQK3ptcGpuR0t0ckZOMzNTTnBaRGc0NnFUUzg1SHZIaTM0djZqcGtsbDltdEkzU1Y5cnN3T0J6WGFENGtUNFFsTVpBT0FLK1ZXczlhdUVDdWR5NXpnb0QwK3RhME9qNjQ2OFNPY2UzUVZ6UnpMSHFjM2VUVHRaVzJOM2xHV3VqVGp5eFVvM3ZKTjNmcWZTRXZ4RzFDU05rUTdUZzdlT2hyenJRL2lWcjl6SGNKTThpelJTc3JNd0FERDFGY0xCb09yU05ndkovSS9oWFFRZUVyMGdzd2t6Nms5YWlXTXpDVWswNWFkRU9PWDVYR0VveVVHM2F6ZTZzZDVKNDcxa2pIMms4anUzV3VJMS94UDRnbnRsYTNtRFNSdXJCVEx0QndlaHJmVHdORklHYVdMK0hJNVBXcVdvL0RTMURLVVpzSEdlU2V2K0ZaVHI0NnBGeGJsK1JjTU5sdEdjWkpRdXV1NTJXbGVNcm1lYUI3bVJZb2lRWlZWaXdqejJ5ZTFaYzJ1WERUU3NMZ09OeEtrTndSWE5XL3c0aUNuRy9QY2M0UDRWMDBIZ3hFQVZZd0I5T2xheCt1dEpjc3RpWnZMdjVvK2xqeXJ4RHFGN0xlV1UxdnFNVVVzVDViYzNES2VvcnNoNGxZZ010MkdPTUhCcnMxOERSdnkwUXdlbUZHYTNyZndWYkp3SWNIdFRXRXh5YmFUVjNxWXJHNVlvcUxjWGJwWkhrNitLRHZBTXIrL1d1TzFHK0VtczJWOUZlWEVUUTUzS3FrYjFQVUUxOVNSK0JvV1ZtMktRT3pDcHBmQlZ2a0V3cmc4WXB2Qlk2Vy93Q0xISE1NdXA2eDZyb2p3Q1h4SHVPWXhNMlIvZFA5YWhiWEw0ci9BTWU4cDR6L0FQcnI2UFh3ZmJlV05zT0dIZXQrMzhLMnBWV01DTHhqSkg4NjEvcy9HZFRLV1pZSldkcm53MXE4QTFOclo1ck9jbUZ3Nk1weHlPM1BhdXVqMVBVc0RGcVJ4Nml2ckYvQnR1MmRxSU1kUUJ5TTk2MW92Q3RrVVEvSWNjRWdkdldwL3NyRXU3NWtqTjV6aEhaY2tuYmI1bnlETHFXc2JVL2NBZ2pxVGlxa2phbmUyc3NNOXBGSkd3d1ZjOXErNkl2Q2RsTnNYY2hJUFFyMEZOZndsYktBUnRPRzIrNHJhT1YxcldkUkE4Mnc5K1pVajRZMDY0MXEyUmJhM3RJMFJPRlVic0FEcDByWlovRXhQelJvUHdiTmZhMXI0WWdTWndvM0ZlcFVWc1RlRm9pdVVqQnh5ZlhtcGVWMUYveThRTE40U1Rmc1hZK0hVdFBGYm9kb1hPT01xY21xVU9pK0psa2VSSWtSMis4M2w0WS9VMTk4L3dEQ1AycUhJbURMdEdCMHF4Qm8xZ3hPNGdEM09NL1N0djdLMFg3d2xadExaVWtmQ0kwTHhVeWpNeFhQYllQMHFZZUhQRk9jTmNTYyt5MTl4SFJyRXVTQnRHTUFuR00wbzBxMjNnckdwQUh6Tm5HRFRXVkwvbjR6bGVjeXYvQ2o5eDhOand0NGpjNCsxeW5BNjRIQi9HdEtId1I0aUorYS9kaWVneVB5NHI3ZVhUYkZJbitWV2JQQXlCVXNGallranpFRUxZSkpIT2Z3cS83SXA5WnNxT2MxWmFLQ1I4VlA0QTF4aUFicDFHT3BlcGs4QjZnUW9aaU1aeVJJZWErM0liYlRqOHBZQUFkVzZrMGlRNmZ2SVU3eG5qQS9ubXJqbEZGN3prUTgzeFZseXFLUGhTZjRhYWk4bTViazQ0NExucjlLMElQaGpkbjc5eU1FZjdSTmZiYjJlbU5KdGNqQXpqQXgrbFdHVzBPMFkyN1J3UnovQURwZjJWaGZQN3cvdFhGTk82anBzZkdEZkRRaEFHa1E0NERaTkZoOFA0N08raWxhNGpieTVGWlFNK3ZTdnNPYjdDYmVNRWNoK1NSL1AxcmdiNktFM0hSQXhrQUJIMXJLZVc0WlJiU2VubWEwOHp4Y25GYWF0ZEQzYjR6M2xzbnd1V01QOHpXNkFENkN2d250dkM5dEkvbmVmaHBQbXhpdjJsK1BnV0R3SWliaC9xVkdmdzZWK1NXanlXMDBrTVI2c0FNMThqaEtFWFRrMzFaOWxpc1RWV0thV21pUjZMNGI4TldQN2wyYzlPZmw2Vjc3cFBoblNrdnJKektQTUZ4RnNHd2MvTjYxdCtGZkNSZXozTWl1Q25jNEErbGRuRG82MitxYWFnSU9idUxBenlQbUZkVkRDUnUzbzliK2hoaU1ZK2FLdlpxeVBhZjJ5REFkSThPUUZqaHdONjk4WUFyOG03ZlFkRFNVTmlRblBvUHdyOVR2MndYM3ZvWTI3VHdEazErZnVrUXcrZkdyb2dKUExBNVBIclhYQ2pDVktuZGEyL1U0S21JcXh4ZUlTazB1ZjlFZE5vUGhXeWVXUHkwY3FPZlFqNjE3elkrRk5NWmNQYnljYzdnZS92Vi93L0JGSENKYmVVTHlBRkpCNXIxT013cUVhUzVRZktUamNCK2xkY01GUjNhUjVzOFhYNTkyZWRKNGV0MUo4dUZnUjBZbnRUSXZCK2xHM0pXMXpJN0hjY212UjdmV2JHSzVtMytWdEs0Q2s5UHBYUjJsNXBUV3BIMnRJeXVTaTVBd2ZldXFuaHFMWHdvemxpYXYyWlcwZmtlUXcvRDJ5QXg5a1lNVzQzRThmL1hyV2I0ZVc1QVlXVWdib1d5VG4xelhyc0d1NlBFMFptdkViQUc0bHNnbjE0clNmeFBvN1phTzhSQ004RnZsL3dEMSs5ZEVhRkJPM0lqa1ZlckpQOTQxOHp4S0h3VnBYbU12MkpHSTZna2ptdHEzOEdhWnNJL3N4QmpyZ2tacnVWOFJhWHVZclBDd0p6a3NPdnNhMTE4UTJwWElraFlEbmhoV3p3K0V2c2hScjRwUnRkdnpQTkU4SDJIbnFHc1kzd0FkckhJcm9qNEdzemdEVEVVNEpZTHgvT3VzVHhuNGUzN3BwNFF5azRJSUp6NzFTYnhib082UmpleGtNZXU3UEg5S2FwWWJhMFNJMWNSZldVbnFjMUo0SzA4SU4ybkE4NEhGV1kvQjlzaktJOU15MmNmTmdnL2dhMUg4YTZPcW93dkZJM1krWThWcy93RENkNkFJRWsvdFJES3pFRkZRWVVEb2QzdlJ5WWRkSW0zdEtxYmZOTFFyandyYm9qQ1RTYlpUa0RBakhPZlVpcDM4T1c4U3hodFB0bEdPQnNCck1mNGc2UXpzdjIwdm41c2REOWF3azhjYUhqTFg2N1RubHY1VnBHbmgrcmo5NWhLdlhkMnVieU5ZK0dZak9TTlB0eW9PV0xJQ09ha244TldpRlN0bEJqSkFYYU0vbFdTUGlCNGJRU2JiMGNnWklQSDVVMkw0aGFFOHlsYnhjNUhQZWh3dzM5d3c5cGllODlXZFBhYUVza29MV01JUkJqSlZhbmUwUzNoejlpdHo4NFVNcUFyejN6VkNUeDlva1pjTGZJQ0gzSEJ5TTFtLzhMUjhPT3NpeXpqY3d3dUZ3QWZXcFN3LzkzN3pyYnhOck9VanJMclMwMmJ2SXR3Q2VkcUQvSXJIdG83WnNvbHRGa2ZmQUg4aDNya0UrSkhoZzVWN3djNXlUM05iRnY4QUVId3ZsbFNaZm1HV0twNmR5YWZOaGt2c21NVmllYTk1SmRUMGFMU2dCR0k0SWxaeVFGS2pQNTFMYzZWZG1JbElvd1Y2N2dCK1dLNENQNGkrSG16SkhkcVFwSTZaYmoycUQvaGFtaW1kczN4d1Y2NDQ0clBtb2Q0blNuWDY4eDNhV1RLRXpFZ2xCeDhxN2dmYzFpeTZiZUM1YmNFQlY4a0VEQUZZVUh4WDhPUlJURmIxdzdkUGs2L2pXVEo4VDlDZmR0dW1MT3BERmxGTlN3OTM4Sk00VmRQZWxmc2R5bWpYelM1aldBbnJ6Mzl4VThkcmV3Q1JDcU1XWDV4dEdSbnVEWEEyZnhEMENBTklKMlVZMms5UjlQYWttK0pIaHAzYVJaSGJhTy9HS3Jub0oydkd3dVdxb1h2SzU2TWJTN1lScnNqeVJrakFCQTljVlF2OUltMmxmUEs4WkJLOEN2UEQ4UjlEZVpIODh4c1Z3TWc4aW54L0ZIdys2SC9TR2JHUWZsTkpUdyttc1NZeHJ1L3hhbllYcy94SXZMYXgwMTllakdtd0F1b1NBQ1p1MjFuL0FMdnBVbG5kZUx0T2tobjBTOUVGM0d4UlpKSXhKR1ZQQkRMM0ZjUEo4VGZEU2J0OGtnRExqSUhINDFVdC9pWjRTdHZtV1dZRDFBK1g4UGV1SlVjQW9WSTJWcHU4bGM2UHJHT2RTRW5LWHU2Sm5jNko0ZThSdnJubjYxcUUxNWR6M0JsTTZ4YlZCNjdWVWNCUlducWVrekpjUzRCTGNuSTZITld2RFh4YjhQU3pYU1JTdW9GbE95c3dQTFlyelNQNGw2WkpGTUdrWU5qZ2daeVQvSTFqQllhTm9KSlJpa2xxZGsvYXlnbnp5azVOdDZiSGRXdGtVakJ4bmtaT09NbnRYVlhjc3l3TXNjZzJzQXJrQUhwWGk5cDhTZEVnamJ6WlhHMDgvTHU2L3dCYXlCOFMvRFVjcDhxUi9MeWNjZHo3VjJ3bGhlNlBNNU1TdGJTMTNQY0lkUDFCclhkSGtSczMzTWNtajdSZXZMNVQ3WkdUZ1lYbkhZY1Y1Sko4VlBEdkFqa2tQdmtnRDhLem9maWpva2R6dUR0bm9UMC9HdGxVdzk3M2lMbHhHeWMwbnVlNW05dllsWkZaWTJRYmxaaDBKclp0TG5VWFViNXh2eDBDNUE3L0FKVjg3eWZGVFFKUStaR2M5T1Z6eFdLL3hVME1NdVRMOHZIQTI4VU9lRjd4SlVNWENXbk8xNnMrZ2J1NnVubmlZWEVjak14QVlEYnoxT2ZhczkxdWJpNms1MnN1Qm4rL24zRmVLTDhXTkJDQk54TVIrYllSbm4xSHBXMUQ4WmZDNkdOaUhSRzR3aURPUHhvOXBoMHRPVXVDcnltdWFVMThtZWhpRzRZZVNWaXlyRTUyNElIdWUvdFh5eDhXTGw1ZFpzdFBkdzNsZ1RTRDJIM1JYbzk3OFd0QWRpcUxPVkpQeXNNWnpYekhkWHMycjZ0cUdveWNMTEp0akJPY1Jwd0JXa1pVcFc1YmZJeG5DcEYzYWRsczM2V01xNGJmSmo3d0lBNHIyYlZOUnZMMnh0dnRTTXYyZTNTR0ZmU05SMkh1ZXRaM2dEd2pkK0pQRVVkbmJmS3lxMHJNUnVVQmVtZnFhMHZGdWg2MXBsNUpCY3I4N3NRZWVuUDZWOHJtdUlpNjBhZDl0V2ZybkN1QWxUdzA4UTFkeTBqNmR6b3ZBVHdhZUxXNjg1WmhNeGpsZ1Zqa0tEd3JmWDJyOWZ2QzluSGJhWkVRdUdkUTUvSHRYNU4vQy93aHFseDR3MCsybmlZUlJrVFB0T1JnZE0xK3c3YklMY0RvRld2Qmg3OVJ2b3RENnpOcXpqaHFNRzJuSzdmcDBQRS9pbjQxWHczNGRubmp3MTNOKzV0SXM4dksvQUErbld2Z0MvMytHL0Rxd2x2TjFDOWtNbHc1UEx6U2NuOEZyMHZYTlpIaWJ4eGY2azUzYWRvUWVHMkhVU1hHTXU0LzNlZ3I0ODhhK0s3aTRXYS9namFTYWR4YmFkRWVDMGpuR2NWN3RHS1MvRm53R0lucEdLZDd0WCtlcVI0MzRvMWl4RWw1TGVNSk5OMGNyTGRBL3dETDNlTnpIQjdqUExlMWZQSGd4WWIyODFuNGdlSmdKcld4bXpiMjdEQXU3eGhtT0ZSL2NUcWZhb1BGcTNmaUx4Tm8vZzNTSE1pd1RiWjVjNUUxMi9NMHprZndyMjlBS3NlSVlZZkUzaTdTdkIyalNiTkcwamRINW8rNjJ6bTR1bitwQndhaWMxZHUya2RsM2wva2poczFLTUU3Y3ljcFMyNUtTMzlISi8xb1ptalRUMzAycitQdkVuNzlWblAyU0orbHpkSDdxcVA3a2ZldVVzYnk0VDdWNHYxa2k0dVpwbUZqRkp5Slp2NzVYL25uSDJyb3RjdkxieGg0bnQ5TXNwVGIrSHRHaVpZaVRnSkJIOStVL3dDMjU2Vno4SXRmRkd2elhkeC9vK2g2VEdQbEhBV0JEOHNhL3dDM0pYenVJbXVhU3Z0OFQ3MzZmTStwd2xPU2lwT0tpM3BDUDhxWCtSVjBsdjdNdDM4VDZzb3VMcTRkenA4TW5QbVM5NTJIOXhPM3FhcldtYkMzUGlQVjJOeGVYVHMxakRKeVpIN3pQbitCZTNyVnhaVThSNnJlYTVxVWZrNlJZYlVTRWNEYXYrcnQwOXozckt0Q3V2YWxkYTFxNTh2VDdYQU1hOEJzZmN0NC93Q3Z0VGpmZHJYcjVlUnRKeHU0dDNUMFRmVy9VYnBvbXRQK0tsMVNWMmxlVXZaeEZpcjNFby9qT09SR3Y2OUs5RlhUTEh4SHA4WGlEVnZ0ajNUR1FHMVhrM3V6bk1YZFZIUTF3VU83eEJmWFdzNnMza2FaYVlWWTA0Qng5eTNpSHYzTlhyQzl2dFgxWTY1ZVR2WTZmcHhVUitUOHV6Yjl5R0VmM2ozclZ0c2NVa3JkREUrejNtdnUxL3FFZ3NkTHR2a1VoY0tpai9sbEN2OEFFL3IrdEpKTmVhOFdzZE10aFphWGIvTStUaFZVZjh0SjM3c2ZUOHE5TGxnaDhjMm92NWIyV3loc3BHRnhEczNSaER5REFGNnlIdVB4cnpWcEwvWFcvc3ZTYmY3TnAxdjg3NU8wWUhXYWR2WDIvS2lOOWpPY0xOUGRkQ09MVm9iRWl4OFBSU3lYTXc4dVM4SzVta3oxV0VEN2krL1dsK3c2Rm9RTW1wNHY5UUozQ3pWOHhSbnIrL2NmZVA4QXNpbmYybEhabit6UER5UExQTjhrdDZGL2V6RTlWaUg4Q2ZxYWlhTFJQRG9EVEdMVWRUNitYbmRiMjUvMmovRzQ5T2xWcmRhMjFPWnhWMzU3bnFYZ2pVdkdFbmpYdy9yTnlnV0tHNlQ3TGJzUmJwSnVHMEpDZ3h3Zld2MlowandSNHA4VG9QOEFoSk5iTU5rUG0vc3JUbk1NZTMwbm0rODN2MnI4SzlLWHhWZjY1cHV1M3JuWWwxQ1lwSmpzV1FoaGlPSWVuYmpnVit6TjdHWHNvYmp4ejRoYXp0WnY5UjRmMHhtODJjbm9ybFBua0o5QnhUU2Z0SXZUWitiK1J0QzZzbFpQVzFsZC9KSHFNL2pid0o0WnpvL2hYU1RxTjZoMm16MHFJTUZJNC9mUzlCOVNhcjNqZkZEVTdPUzYxbldkTjhIV0F5R0VSV2E3SytqU1NZVlQ3aWwwWFR2SHVxV2tWbjRkMGkxOEY2T0JoSGtoRWw5SVA3d2pYaFNmVmptdU0xTFNQZ3g0YjFBTnIyb3llSWRXN3gzTWpYODViL1pnaStWZm9hNzdkRXRmUzdNbFRTbGRLOG0rM1BMN3RsK0o1MmovQUFOaDFBdHQxYnhkZktmOVpzbHZ0emUzUkFLOVFoOFgrSjJoRVdpL0MrNXRreGxmT2xodEY0NkVnYzEwdzhVK1BibTBXUHc1OFBuc3JZZjZ1NDFLVkxKQUIvZGlqRzc4NngvN0QrTU43S1paL0ZtaldHOC9NbHBadE95bi9la1BVVkUxc25iNXUvNUU4eXY3OXY4QXQrcHpmaEhZNUR4THJmeGdmd3pxZ244TGFYRENMT1l5ZjhURXlPcTdUa3FNWXlQU3VFdkxENGw2MzhKSU5NbThQNmY5aXVOTVJWa1M4SmxDQmNxMndqRzdqcFhaZUxQREhpdTM4T2F5MTE4U3JtVmhiVGZ1aGJ3b2t1Rnp0STY0UFNtK0MvRDNpZTU4SDZPOFh4RXVZMWUwanhiK1RDNlJnajdnenp4V0VySjlQdVpWTjAxRk85UFNlbnhINGluUS9EVE95RHhCNU1pa2dyUGF1dUNPTVpYTmRQcFBoVFg0WkJOcFdzV3MzZkZyZGJYL0FCVnR0ZE44UmRPMExRUEcrcjZiZmFVOGp4VGttNGltYU15Qi9tM2hHeUJuUFN1VXNMRHdiY01EYjZsZFdiSGdDNGlEai92cE1ZcmxxeVNqcDFSNmVEcEtlS2l0YkovZjIyTytrMWZ4RmFvc1dxNmF0d2dQL0x6RHljZjdZd2E1M1hmK0VTdmJSSTRKcHRMbmt3VEZLZk9nYkhvNCtaZnhydG9JUEdGcER0c3I5TlF0aU1sWW5FNjQvd0JwRzVyeDNVTlI4T2FqZU9sN1pQWXlxeFV6VzR5dkg5K0p1bjRWNTFPSE5VdmQ2YW4yV2FZaU5MQ3VFYlhsN3VqKys2SW1uOFNhTkFxWE1TWGxnMzNSSisrZ1lIKzZ3KzZmeXFKTk8wZlZIVjlKbmF6dXh5TFNaK0dQL1RHVGpuMk5Xb0xmeERvc01seHA5MGw1WW4vV0dQOEFlUkVla3NaNUg0MHdXdmgzWGViVXBwbDdqUGtPeDhpVnY5aGo5d24wUEZlbTJ0R2o0Qkp2UnZWUFlyU1g5dmNTdGFhN2JTUlRxZG91MVhFcUgvcG92OGEvclVUUHFPaGd3VENPODA2NE9RQWQwVWcvdklmNFhINTFla3Y1STIvc3p4RmFTbnl3QkhQajkvQUQzQi9qVDJQNFZVWVh1aEhCOHUrMDI2emc5WXBRTzQ3cElQekZKYmlrN1B6ODl5SVcwMW1EcWVqVHZKYnFQM3FFWmVMUDhNcTlDcDllbFNpemoxRC9BRTdTQVlicUg5NUxhS2ZtVWorT0gxWDFIVVUxYmU2c051cTZQTTBsc1cyT3ArWm95My9MT1plNm5zZWhydjMwK3cwKzNuMU9Hd2tqMUNPRkpEYWI4TGJGL3dEbHFBT2R2K3oycHR2Ym9YQktTVjlGdS9JbFcyaUtmYko5UGhmV1h0ekl0dHVBVngvejFLRHBKam5iMzYxd1J6NGtnendOVWdUb09QdEtMLzdVWDlhZmZOL2FzSjFlell4M3NHMXJ1SlR6a2RKazl2VWRxcjNoVFVJQnExbG1HOGdJYTdpVGpCSFNaTWRqL0VPMVNsWXB0V3NucCtac3hFZUo5UEVNaEM2dlp4NGlKNE4xRW44Qi93Q21pOXZXb3hLL2lTdzh1VGpWcktQNUd4aHJpSlA0Vy82YUwyck11eTJvMi84QWE5cCs3dTdkbGE3Uk9NSHRNdnNlOWJHcVAvYUZyRjRoMC84QWRYVURyOXVqUVkyU2Z3ekFmM1c3KzlZU2lrMXIxMDhuMjlEcmhKU1R2cnBxdjVsMzlVZFVzSjhiYUk3cWM2N3AwT1dVRDVydUJQNGgvd0JORUhYMXJvRElQSG5oTG5qeEZvY0FJWWNQZTJjZjZtV0w5UlhBTnFWM2EzVmo0cDBadnM4OE15bTRWZWtVM3JqKzQ5ZHRyc3oybDNwWGpqUVFJb3A1OHp3cU9MZTZITHh0L3NQMUh0WFZRcUpKM1h1dlNTL3k5RHpzWFFtNVJzMHBKYzFLV3VyNnArVEsycjdmR1hoSWF4R3hPdWFRcXBxQ2cvTmMyNDRTNEhxeWRHOXVhKzBQZ3Q0OHRQRXZodVRTZFN4SXlwNVV3UEpJN01QZit0ZktHdHkyL2gzWDlFOFphSkFyNlZxdVdsdGp5aVNIaTR0WDl1Y2oycm43bVgvaEIvSEZqcW1teU1kSzFCUmNXekR2QzU1US93QzFHZUs5Q1QwdjFWbEo5KzBqeDlXNHBhSjNsU1d6VFh4UWZwMC80Qit3T20yMTFyT2ozdmh5Nm5LYXRwSldmVGJrOEYxWG1Od2YvSFdyMnlQeFBCNHQrRzE0dDJvUzhpUm9MaUJ4alpNdkRaL0VaQnI1b2UvbHY5RjB2eEZZWWE2MDhlWXdUL2xyQWVYVDM0NUZlcFIzMXRwL2l2VGRZdENyNlo0amlWSjhqS0xPQndUNmJod2Zlc3FzSFo2Ykh0WlBqdllZdkRWdFc0elVyYmFyVnI1bnc1SFBjMmw1SkV4YU1nbFdHZlRqbkZleStDL0dVM2h6eEhZNmxEdVVSTUZtVXR4SWg0WWZURmZTbmlQNEJEWE5Sa3VkT3VEQVdJTG1RZkkyZTR4M0ZhZWkvczNYd2xqUy92NG1oOHdGL0xUNWlCMkJQVE5lZFkvcWl2eE53OVd3azNVeFVPV3BCODFOcDNzMXRZKyt0VXNkTDhXZUVyaTJZTEpiYWhhNEJQekREaklQNFYvUFg4WlBDTnBwbmhIWExkb0pFdXJDNmlSOG5nQU5qOWEvbzAwdlQ3YlM5S3Q3TzNUYkhCR0VqVW5zT2d6WDVXZnRlK0gzZzhPYXBxUzI0QXY3Tlk1UU9kc3NUQWc1OXhYMGVFNUpScXdrcjNnM0h5YVIvSmxhUFBpSUtrM3l4clhqZmZsYjYvSS9uK2I1VTR5T0RrMTZGNE5pUDlzYVVyQWVWTmVScVQzSHpBR3VVZ21FRTBUaEVrd0FkajlEN0d1enNMeFZtdEp0aXdxYjJOMUE1QUlJeUI3VjQxT3ltcjl6MU1RbjdHZHQrVjIrNC9WbTYrSEdtSVNTek14T01sY2ptc3FYNFc2ZDVJZHVCMEhCR2E5N2oxMktQeXlsd1BMOHRRd0pIUEhVVmNPcmFjMEtBblBYWmxnQVB3cjlIV0Z3eXQrN1IrRjA4WmlaUWQ2c2s3ZW1wOHQzdndpMC93QW9PdHl4M0g3cFBRVmxqNFMyc2NaSWZHY2dEMXI2NVRWYkF3aFpHVUVrWlBIR0tiUGVXclcrMUpWMmxsSkxZM0xqdUtsNFBDdC9CK0owZlhNVnl1OVY3SHlHbndvdGxsWERnRThZSkZiRC9DRFRpVnhLekgzQXhtdnF4TlYwamZ2VmdTcCtaY0FrNDdnMWkzV3VXeHZra0cwYmNnWS9yV2tjRGhXdmcvRTVGbUdMajhWZS9aV1BtSlBoYmF3U0VMSUNBU1NHVVlKcW1maFBaVGIwSlBya0t1Syt2cDlVMFpyYzdtaERrN213ZXY0MG45cDZVeXNTcXRrREF5QURqNlV2N1B3ei93Q1hiTjNtbUpTZHFzZnVQaVdmNE8yc2FySUhUWVR4OG96OURTRDRVUWxpTjRCeHdObmF2dGFhL3dCRzNKdHdRUU1ZSFQyclA4NnlhV1NVeGhRdVBsN2dlM3JUV1hZWFc4SDk1elBOY2RkZnZZdjVIeDFiL0M5bzk1QUhJSVVsT0Q3MVRiNFZzNE9HVGMzRzBKZ2ZuWDNGRGM2ZS9FaUJvMVU5OEg4S1M1bDBqTWZsZ2RSbFdIVWUxUi9adUZiK0YvZWEvd0JyWXk2dE9QM0h3VS93aW1kU042OERrWXdLaGwrRWhod0NWZFdIVVpyOUNGbDAxWUpBNnA2QWdWeTA2Mk11U1A0Ujh3ejFIdFVMTE1MMmYzbTFYTmNjcldsSDFzZkNoK0ZVd2pBVWYrUEhqNjFqUy9ESzZoYkc1c1o1SVk0cjlBYllXanlySEdpajZ0amRucFUrcFFhZEdyUnNvRXF2emxzbjZWWDlsWWU2V3B6VHpyR3FEK0YrZGo4NlArRlo2bUpWS093QjlYTlRTZkRuVVJML0FLMlFBWS9pT09mU3YwaXROTzAyZTBjcmxYUTh0MUJGWkZ4Rlp4bkRLZ1ZzSGc4MWc4cXc3Yjk2U08rT2M0cFUwMXlhcTUrZlAvQ3VkVjh3cWp1TWR5L0ZWbjhBNnFFWW1TYlAreTJSeDNyOUE1Tk5zbVptRGpEYzVMWUkrdFN3V2xpc1dUTXB6NmNZK3RVOG9vVytLUkVNN3hsN1NqQS9POGVDOWQ4djVKcHNnWUhOWU54NE04UUZsRHl5RXJ6eUEzNUd2MDRsMHF4Q014WldCNkZXckZPazJSWmlpWkdlRG50V0R5aWs3ZSt6dGhuRmFPOEZ0MFB6Y1h3aDRoS3MvbXlnWi91Z1ovQ25mOElwNGxYbzB4enoycjlJL3dDeDRRd0F3ZW5YR0FLbXVOR2dsS2xkZ3dNSHZXbjlrMDlQM2tqR09kVmJ5L2RMYy9OaytDNC9LQytXMmNqbWlQd05OL3p6UDVWN0pMNHcwMUd3QXBBN2Q2enYrRTlzRUdBd1VWeHh3bUFTMXFubzFNZm1MZnVVZnhPR3QvQWN6dXBhTTlPdkZkSEg4UFZWY3NWT2UzZXJVdnhFc3NEQkhZSGlzbC9pUmJybmFDZXdIMHJSVWNxaXRadG5EUEVaNUxhbWtiMXY4UEZrUDhQZmo2VnNwNERzMUJ5cUU0NDRyenh2aVkyRktvL3R4VkIvaVJkZFZqUC9BT3FyVThyaXRJM0tpczNtdmVmNkh0Y1BnU3lBRzVWWEhYaXRiL2hFTktWUmo2WTZWODZOOFJ0U0tnN0NNOGRheVc4YzZ2SnVHNCsyVDBxbGlzQWxwVHY4ak40VE9IVS9qV2o2bjFiRDRkMGhHWGhRY1lKSnJUL3NUUkF6QU5HZStRYStNZjhBaE10YTUrYys5VUI0cTF4MllDVHFlVDBxUHIrRVZyVWZ3S2xsZVBuSzd4THQ2cyszRnRORGpqVU5HaW5ua0hOU0ovWk1aQjNKdEhVaXZoWTYzcXpuL1huajNxWWF0cXpnNXVTUjZjMGYybFN2cFNEK3g4UjF4QjkwZmFOR0xBaGt5QmdkcTEwMURTOWlxRlVIMXoxcjRCT3A2bVdCYVZqMnJyN09hK2VOQzgwcHoweHhTZVlycFRLL3NscmVzL3VQczV0UzArRmYzckx0UDQ5UFNzKzQ4U2FNckJ0d09QMXI1YlpiOW9UbVZ6anBYSzNOcnFJTzdmSTFZZjJqSk82Z1Vzc2piV3EvdVBzRnZGbWxxbVZaZS9UZzFtZjhKaHBhNEc1Y0U5ZTlmSmlhZGR2SHlrdlBKem5OWjUwblVHNnh5ZStUV2l6S3YwZ2pYK3k4TGJXYis4K3dIOGE2UUNxaGh4eU9jNHErM2o3UzFRaFpGSHlqQnI0NlRRTlNaTXJBeDU5RFdxUERHcVBIbjdPdzdHbC9hZUsyVVY5eG4vWStCdTVLY2w4ejZuZjRpMkVZUWVldUtkSDhTOVBDa1JzckFad1NPUlh5ZXZoZlZwQ01RRmdNMTBGcDRTdml3WHlEMDU3WnpTL3RERmZ5cjdpdjdNd1NzbE4vZWU2emZFZXpQeTcrUWMvV29qOFQ0WXl2WVo2ZjU2MTVMSDRNMVFnL3VsRzNnZE9oclVmd0ZyTThZL2RMOG80Yk5ONDNIUyt6L3dDU2tmVU11anZQNzVIbzgveFV0OEVra2c4Zkx3ZnhxcEQ4VTFlTnRxNE9CblBCNHJ6VlBoL3FnYkcxYzU1cmF0dmgzcWlxMjd5c2tjZzg4ZjQwbGljZSsvM0VMQ1pZM2U2LzhDT3pQeFRZTVdhTmdjZGptcVorS1VqS3Z5TmpQUW5yV04vd3IzVS9rWm5UNkQwclJUNGVYQXp1ZEJrWjZkVFRWZk1MOWZ1SytyNWJiZFA1czZpMStLTTVobUlnWXQwR0QvT3FEL0VxOUxaYUZ1VHo4eEJwTFQ0ZTNIbm45OWhDY2tpdE1mRGo1MkluYkdlbU9EUnpZOTY2MzlDbi9aYVZycTN6TTFmaU5kSkt3RVJiSG9jaXAzK0l1cHVpaEVVbkI2YzR4VzB2dzdnTzA3bTZjNEdNMUpEOFA3ZFpHSUxnRWNnMC93RGhRZlZtTGxsaVQrSDhUZ1YrSTJybC9tZ0FIWWc4QTFHZmlKcTh1VTJnWko0ejNIcFhwMGZ3OHM5MldMY0RnSGtDcS84QXdyalRoY2NCK1FDUUQzRlBreDc2eSs4eDVzdDBmS3Z1UE9oNDcxWWNZWGdkKzFPYng1NGhaL0xPMWNjY0d2V1lmaHZZc3dZeFM5K2h6V2tQaDFwWmxVK1RLeHg2OWg3VlBzc2QvTS92T3VNOHV0OE1mdVBGNC9HbXVEY3JZd2ZZNXpWWWVOdGNYY29uQUk1NEhTdmZwUGgvcGtaRGVSSXVlT1NlYWZEOE85R2NEZGFuazljMC9ZNDcrZC9lWU92bC9TRnZrZk9rdmk3eEs3RW1jRURxeEdEVldUeGI0a1VKL3BKNEhVZGhYMDhmaDNwS2c3TFZnQ09TVC9LbnA0QjBjTnRlMkw0SHJqODZGaGNhL3RmaVdzVmdZN3cvQStXcC9GT3VOR3hlOFlnRVpIUW42ZTFkQjROMW5VYjN4ZnBrRWx3N3hHVldJUEk5cStoN253WG8wYTdSWUFmV2pRdEUwMjExMno4bTE4dVR6ME9jZTlZU3d1SmpGeWs5RXU3T3VsamNKVXFRaEZhM1hSSFgvdE5YRHhlR0lvd01LVi9QQXI4UnRHdTVvTGpKZCtEMjYxK3pIN1R0MHJXMXBIbklQcitWZkJWanBPbXRNdjhBb2lCampqSFUxNUZERHpxVWs0dEt4N0ZYRTA2V0xyS2FiNXBLM3lSMFhoenhIcTR0RjJYYko4bUFEMXg5SzlZOEszT3JTZU10QVNXNlo0MnZJczkrcmRLMWRGMGlDR0pDYk9QR1FlVnIydlNtc3Y3YTBaVTA5RUp1NFI1aUQwYnJYYlR3dFZXYmxvZWJQRzBmYXRLTjd2UmxyOXN4M2E2MCtLT1hQeUQ2aXZ5cDA1TlJoaysrNFA4QUR6azgrdGZxMysxTGVXNThYYVFURXJZQ0JsUE82dmxleU52Y3VDTk5oR1Q5OVRuOHgySXJlT0hsS2xTYWR2ZFJoVnhzYWRiRUtVT2E5Ui9ob2NGcFY5cUVVQVZuZDl4NUNrbkJyczdJMzg1dzhreXRuNWM1eGcrdnBYdW1rNmZFUVdXM2pYQSs3akg0NHIyS3pqaWFDRUMzaDRHQ3BIZjNxNTRPZjg1eXd4MEpiUXQ2bnlMTnB0NENRenljOThuOUtXQ3puZE1TaWNEWmpjUXhCT2ErdW10WTVKQWZLWEo2QURqNlYxRnBac3FBQ0pTTWM3L1UwNFlPZHZpTjNpNDlZbndpOXBkUEZLckNWWEIrVTgwc2ZoelVIY01XbmZBR1R6Zy9TdnY2UFJwWkJKKzZpWGtZejFxK21tR053R1pFVURyZ0hyWFZIQnRienVjN3hzWmZac3o4NnBiRFZCa0pETTJHNFlBL3JXbXVqYTJwZDN0N2xwR09RUnVBT2ZZVitoazJuRGFPWXlEeUd3QUt0TFlTaFFSSW1RT01LRFMrcHY4QW4vQWlHTXMyblQvRS9OMyt3TlhrbEJhem5QOEF1cWUzdlZ2K3dOV0xNMzJHNEJKeGdJUmtlcHI5SHB0UExCVDVvSngxMjdhcHcyQkN0OHdKSGVpT0E2ODVwTEdiV2grSitlc3VqZUlIVkloWXljZFNZeVRWMlB3eHF6THZuMDlsSUFCMklWUEhxQjYxK2lrbHU1MjdwVk9BTzNRZW1hZ2x0Qkx0L2VESUdPQmc0OWMwMWduL0FERFdMV3Z1bjU1TjRmMXlLVVBiMmR3V1VjWVVnZm1hYmQrRXZFVXNRWTJFbVc2cXFuR2UxZm9sYjJxRGNES1ZCNzlRYWlld21pUlREZDhodHlucFYvVVc5T2ZjWDE1YVBsMjY5VDg4by9BbXVlVklKTk9tMzRHQXE1L01WcFErQmZGVUd4djdKa0dPV2JibkkrbGZvWXNXNjRsbk1wemdmTjdkODRxMnp0NWtma3U1SlE1eHlhaDRDMWx6RlBHeHY4TDhqODlZdkMvaW5henBwVHlnRS9LUmpHZjYwcmVGdkVxeHB1MFZpeW5sVGpCSDFyOUJMWklua3o5cU9jSGQ3R21TckNEZ3puSnpnZ1p6K2ZhcVdDczlKZmdZenhxc3ZkMTlUOCtGOENlSWJrczQwMG9qZnc0RmJVUGdYeFI1UUEweGtVbkM5dW5yWDNESmFsSXMrZXZHQ2NmS2Nld3E5RmNUU1c0VDdRU2l0d1BVK3RONE5QN1hVdjY1WldsSHBwcWZEcStBZkVkdW9hTFQ5MGpBa2dZSFdybHY0RDhUTkNaVjA0azhoa09NajFQTmZhOTBOa0RNdHdjaEFPby9IbitsVVkvSkNnL2FYWTQ0QS9rZmFwK3BhWDVpdnIydG5EYnpQajVQQS9paFZqZGJEYXdISzVHQ0toaStHZmkyU1J4OWlqSTZnQmdEbXZ0VVNNOE9YbXcyTWMveEQ2VkdHRUJiWmNOamFDRG5vYUhnOUxjMnBFc1hHOStUVDFQaldUNGNlSTA0K3loV0Iydmxobkg0ZFJVLy9Ddk5kanR5ZnNtOVc1R0NDVng3Vjlod3V6N1dMam5ybHVhVzRaMXhpZHYrQW5nKythbU9DU2Z4R2l4VU9YUmFIeEhMOE90Zm1oeDVDQmM4cUNLcFhId3c4UlFJSEZwR1V4MUVsZmJyRzFWbUhuRmllbFlydWpxeUxNd0JJT1MyVCtGYUxBSjlXTDY3Wi9EcWZLRno4SXZFdGxwTmxxVnhMRkFsME44Q0YxM1NLRGc0SGY2VnQrR2ZncjRvOFVhb2JhTjQ0U0kyZkpBT0ZIR1FCWG9jUGdEUTR0Y2oxTDdSY3lTSVdNYVBPenhJVzZsRUp3UHdydHRTMHhwNGtFZW9YZHJNb08yYTJsTVRqUFVibDdIdlhteXdPTDluTFdLbmYzWDBzZGtjWmh2YXhsS01uQ3l1cjYzUEx0RCtHMTVZZU1JclEzRU02eHJMSEkwVEFoaDVaendPakE5UlhsVTNnelZ3OGdXTUU3dnU3dHY2MTlsZUE5RTBidzVITE5DR2RrdDVuYmVTNWFSeGpKWTl6bnJXRXBXUW83ZEdHY1ZwREF6YnRON0phcnYxRlBHMFZHUEt0M0oyNjIwc2ZKbi9BQWhXdlNFeHJaa093N2tmenFoL3dyanhCRWNTd0tQUWhoM3I3ZHNyZWFhNUt4bG5ib2tRNVkvU3ExekN4bGRKTXE2L0t5SHFyZWg5RFhVc0NyMjVqaWxqbkZhUTE2TStPRDRCOFF2RnZqdEVVS0FjRWpKQTdpb20rSG10elNzWTdLSTVVZmViQkgwcjdodDBSWTFScDB3QndDZWMxSkZIYTczRFM3bkE0T2VPYTArcEsyNDFqTHRYUjhSUS9EUHhNQzRlQ0ZNOEtkNDcxSVBoajRtaEpEV2NMSFBVeUtRZng3Vjl1eXd4T3E1dUFweGtoVG4rZFpjOXJHQ1ZOd1NDTTljZm5TV0JYY0pZNnkrRStJMitHL2lobUpObENEMTRjRVk5S2lYNFdlS1pTcE5uRU1IaytZbytsZmFrS1d5S1ZOeUFDZm1HZXY0MW15V3R1N1NPbHd3VWdEQ3Q2ZldxK285T2RtZjlvMml2M2QvbWZDV3MrRU5aMHEyRTE1Q0kxOHpZdjd3RXN4NmNEclRoQWtOdXNZeGdBWUZkNTQrdTNuOFFXMW1zNWtpdFU4MXM5bmZnQTF3NFJwYm1LTURKWXFNZjd4eGl0b1U0MGViVzl1cHZTbkxGVHBRU3R6TldXKytoK20zN052Z0Mvc3RQdU5ldW9sVkw5ZHNBSitZSW44UkhveHIzWHhqOFBOTjFtNFY1RVVTQTUzWTVyMnJ3eUlJUERXbFJJaW9zZHBFZ1FjQWJWeGl0RmxWbkpOZkIxM0d0Vm5OcjRuYy9ZS1ZlcmhXb1UzeXFtdVJMdWwzOVR4L3dkNEwwL3dBUDJyTEV1WlhZdEpJZXJIL0N1RytNUGl5VFEvQ2R6OW41dkxzaTJ0VkhVeVM4Wi9EclgwWk0yeFRYNTIrTnRRL3Q3NG9KRVczV3Vnd2IyWHFEY3k5TS93QzZLNmNQVFNhU1dpUEt4T0lsVXFPZFNWK3JYa3VoNHpyOGY5ZytGN0RSYlovMzAveU93Kzh6TnpJNU5mQW5qdnhTbW1HKzFDRmhzMDVUWmFkL3RYY2d4SktQK3VhMTlUK052RUpFdXE2b3VYTnNwdGJOZjc4MHB4d1BYSnI4NFBGOWhjNi80NTBMd2xZdnVOdTZRU1BuZzNFcDN6eUg2ZjBydnFTNUlPeXUzdDZzOGFLVTUzbExUVnl1dExidi9JVHd2Skw0UStIMnBlSkpHSTFMVy9Nc3ROSis4c1gvQUMzbUdmWG9EVlYySGczNGErWDAxanhLdVc0K2VDeFU4RFBZeW45SzlIdkxMVGZHZnhidGRIaWsyK0h2RDBCaloxKzZ0dFpqTWovVjJGZVhTNmhGNHI4YzZ4cjl3TWFmcC83Mk9JOEFSeC9MREVQVE9LOHF1NHhndGRJNkx6ZlZtK0VwenExVmUvTlVhcVR2cGFMMGhINWJ2ek9VMVNDVFI5QnM5Q2dUZHFHb21PYTh4MUFiL1ZRLzFOYVd0V2NpdnBuZy9TMkR5Q1ZXdnBCMGt1V0hPVC9jakZKb04xTkJIcS9pNitHNmJ6V2lzZ3c0YTRrL2lIc2dyT3NKSDBQd3ZjNnRLeE9vNnNYaXRXUDNraVArc2wrcmRCWGpwUDFkL3ZrLzBSOVM3cGEyVjE5eVgrWkxyS3JxbXAySGh2U0hCc3JIY0dsNkxKSU9aWjI5aDI5cW8zcGkxN1ZMSFI5TXhEcDFtcEFrUEdRT1pMaVQzUGFxVXhHZytHMGhYSTFEVTBEU2tkWXJjL2RUNnYxUHRTWGdiUnRGajB5RmQxOXFBUjdvcU1zaUg3a0k5ejFOZE1ZcEtPcjAvcTV5T2JiZDExTmVkRjhRYWhEcHRqKzQwblRVSmFVOUZRSDU1bjlXYnRVVXhQaVhVSXRPMDlmc3VrMkNNd0o0Q29QdlRTZXJ0Vkcva05qcDhHZ1dVYk5kVE9wdm5VOHZJZnV4REhaZS92VzFxcU5ad1czaG5TZzAwOHpxYjUwSE1zeDZSZ2orQktwczBqSlBxV0xlL3ZkWTFqVDdEU0pQc1ZocHBNaVM1d0VDOHRQSWU3SC9BT3RYZTZvOGZpKzN2TFhRN21HMWlpbkwzTWJMNVFuWHZjT3c5LzRhODYxU09XM1NId3hwSVdXV1NRZmJaby8rVzB2OXpQOEFjU3BMcTlrMHhyYlF0QlBtM0htb2JxNFFBbWFZSDdxLzdDMW55clR5Tll6V3FmWXdMeSt0Tk9EYVZvU3ZOTkxoSjd3S2ZNbVBkSWgxVmYxTlY0clBTTkJ3YjJJWHVwWkd5MEJ6RkVUMDgwajd6ZjdJcjIzVVBMZDc5TkRpdGY3YThsZnRyeEhuSkdIRnRualA5N0g0VjQ1TUxmd3dRcWxialdIR1dmNzYycGJzUDcwbnYycW9TWHpPZXBGcVNhZW5rWGI4WE1VOXRmYTdmU2ZhOXl0YjJVWncwUXprRmgwakE3TDFyOXZQQ2VyZUNQQ1FzNTRiSzQxM3hOZjI2T2l4L3dDazNiQjFCNVk4UXgvbFg0U0d5ZzA4ZmE5VUp1TDJYNTB0U1NTTS93QWN4L2tPdGZ1RDhOL0UraDZGbzJsNmY0VjBKTlMxMi9zNFpaMWpQeW9XWDc5ek1mdW9PeTlhM2p2YnlNclBrNnZYVkxSVzgzMlBacnZRL0dtdldVOTM0dThRSFE5TkFMdnBlblNlV1F2L0FFOFhSNVB1RnJ6ZlF2R1hnM1N5TEx3SDRSZlZKd3hEejI4WWloSjlaTG1YbHZjaXZRZGY4SmFWRGFEWGZpUjRoaXUyakdZckxKaHNJajJTT0ljeXQ3bXZQaDR4OFU2OUVpK0ZmRDBHazZjbUF1cGFnbmxSN2Y4QXBsQXZYOGE3Vzd4OUg2SXhjclJkMm5EcmIzWUw5V2Q5ZWFOOGFkYmpNMTc0aDB6UW9zRDl4WXhHNWtIKzlMTHhrZTFlRmF6NFcrRjlnczB2aUh4OWZYZHdDUzhjbXBiQWM5Y0pEM3JodkY5MTRlakxIeEo0eTFIWEp4OTVQUDhBc1ZvbU95eHhrWkZlYmFOcjJpbWNMb0hnSDdWdk9BOE5pODJUNmlTUVlva203TzlsNWFFVTNKcjNZdHJ2Q1BLdnZlcHMrSVpQMmUvN0IxRVdjdSs0K3pTZVN4ZTRjaVRIeW5jZVB6cWJ3eGYvQUxQcWVITkxXK2hWTGtXeWVkSVZ1RnpKams3bDROZEJyRi84V0c4TTZtRDREZUczVzFsOHg1QkRHd1RISjJnODRGVi9EZXEvRkMzOE5hUUI0Q211YlpMYU1SeUpMRVM2RVpCMm4xck9TMTM2ZHlsS29vZkhPNmwveitWOXUvNkh5RDhaVDRldHRTc2Jqd3JjUWFsYVR4RVR4TXB1akc2bmpKa0c0QWl2bUE2OW9iblpkYUF0dTRQelNXc2pSTi8zdytWcjlEL2k1THEydTZDdHYvd2lHb2FMcUVFeXl4M0gyYkNFZDFhU0lFZ1YrZkY3ZitKN1FtTytnaXZJd2VUTEdKUi8zMFBtRmNjb1hXcS9FNm95cWNxbXVaTmFOMzEwODBiZGxCWlhCSjBqV1ZTZkh5UjNCK3p5QS83TGo1U2F6YjdWZFNna1czOFE2U0xrSGdTc05rMlBWSlYrOStPYXdVUGhUVUFRd2wwNlluZ2pNc0dUMk9mbUZiclA0bDBXeUFtU08vMHh6Z1pQblFIUDkxdXFOK1JyR01ZeHV1NXJWeEZXcHk4MHIyV2d0dHBjMFVqMzNoelVubTJETFFINWJoRjlHVG80K2xRK1pvV3ZFcE9xYWJxSk9CS0J0dDVXOUhYK0JqNmppaUxTdE8xQUpjNkhjU3dYaUhKc25mRDhjNWhmamNQWTgxT2JxdzF4amI2bXEyV29yOHEzZTNZc2pEamJPdlkvN1ZHM21SVFRkOUZyM0dTMzF4YkFhVDRodDNhT01ZaW00TXNBN0ZHL2lUMjZWU1ZiM1EyUlhWYjdUTHc4QWN4ekFmM2Y3c2cvT3RCcmlhMmwvc1hYNDNNU2pFRXcrWjROM1Jvei9FaDlLNnF6MmVEN2FJM2R5Ym43VEx1anQwR1l3aThlZGxoOS93QkFQeHE3cXl0MUZKSnlWL3hHbTB0dkNsdkpxTnUxeE0wN2lPT0p4c0VRKzhWbkhkc2RQenJoTlJtbnRyNkxXN0NkNUlwM0pZdWR6STUrOUZKNmc5dlVWcDNONWNhYnFjclhVelgybTZtTjd1VC9BSzFDZnZEMGtRL2xXUThaMExVRERJMzJuVHJ0QTJSMGxpUFJoNk92NkdxVzI5eVpON0phS3d5Y2kyZUxXZExCU0l0aVdMcjVMbnFqZXFOMnA4N0MwbWcxblRWeEJJNVdXSHFJM1Azb20vMlc3VkF3YlFkVFpEaTRzcm1NZjdzMExkQ1A5b2ZvYW5qQzZOcUpobUptMDY5akdTUDQ0bTZPUDlwYVRRSmZnTE1UcE41YTZwWWpkYVhPNEJEeUIvZmhmK250V21KNHRDMWVDK3RSNXVtM3FFR005REczRHhON3Iyckx0MUZqZDNPbFhUN3JTNndVZnNDZjlYS3Y5YWJwaXNKTHJSTHc3Ukk1OG9ucEhNUHVrZXpkS2h4dmUvOEFTTmFjbW1yUFhwNm0yVWcwSFdkcGZ6dEsxR0w3dzZORS9RLzd5R3UxOEczc0dpNjVxSGgzVTVGZlN0WFFReVAxQ2x1WXJoZlFnMTU1cGtiNmhwbDFvcytWdWJkbmxzdzNIekw5K0w4ZW85NmtpczU5VjBFQ1JTbHhZSENzd3dXaDlEN3FheVVsR1YyOXQvUHpPeWRKMXFmS2s3UFdOdnN2cXZ2MVI3TjRVMCthMjFiWFBBT3J5Qkk3eVJoYk9mdXgzaUQ5MUlwL3V2MFBzYXd0QjA2NDFiUTlaOEpYa2JMcU5nOHR6cDRicUpJdUpZUi92QVpBOWExZkVTUHJuZ3JTdGVoY25VdElaTFc5Y2ZlWkY1aGxQMDZacVh4aGZTeUR3MTQ0c0hJbmxaVXZRUDRMdURybjJrWG12VXB5aTQzYmJVYmFkNFBmN2o1K3JoNm5PdWFLVXB5K1VhMEZvL1NVZnc5VDZNL1pxOGRzRWZSN3B1WWNoUXgvZ1BiOE9sZmE5bFpCWXRaOE04cWpMOXUwcHU2ODd0bzkxTmZrcHJGNUI0ZThmNlhyMm5aU3cxVlV1WStOb1h6RGlSUCtBdFg2d2FqZlRYZmh2VFBFTnFkMCtteUxJU09TMFRjU0tmNTF1azdPTDFhZHZWZEdjem5CVklPR2lxM2t2N3N1cSs4Ky92aFI0blRXdkRGcEl4QW1RR09aZjdycHdhK2dNWTcxK2RQd3kxUmRLOGZYdHFqL0FPaDZ2Q3Q5YWdkQTUrK3Y5Y1YraXlrdWdZSGdpdWVVYk4rcDBVNXFTSnd4STYxODJmR3J3Y2ZGUHc0MTNUR1VTU3RidThMZENIUVpHUHIwcjZMVlFvd0tvM0VZa2laV0dRUmcrNE5hVTV1TW95Nm8yaE4wNXhrdGVXU2ErUi9HS3lUMjkySTNqd3lPd1pUNnJ3UWFTNG41T0ZWVTgwTUFEMFByWDFSKzBqNEdrOEkvRkRWN2RGS3dYYmZhcmM5dHN2T0I5RFh5SVFmbU9jOUt3cXdVS3NrdHVubzlUNkhFUmo3UnFQd3V6ai9oYXV2d1B1T080MVVwR1Z1WkN2bG9RUWZVVkkycmFzSUNvdUgzWndDVGl2c2JRTkowOS9EdWpTZlpvbVdTeWg1QUJPU3ZPYTJYOEc2ZE1BcTJVWU9SbjVlYSt1aGhLN2hGcVQxUzZuNHI5YXBLY3VhQzBkckh3WEhxR3J4c3JOcUVtNDlzOWFzeWF0ckxySVJmU0U5eDdWOXhId1Rack1jMk1RQUhBMjhtcXIrRHRPSHovWTQ4RWRoVi9VY1QvTmI1a1N4K0dqdlQvQkh4Q2RhMW9iQ0xtUkNCMHljbXFyYTNyM0lXNWJCOVR6WDNYRjRIMHRveG13aWJ2a2p0VlovQUdpRWY4ZWFJVHdjQ2tzSGkwL2l2OHkvcjJCdHN2VGxQaUQvaElOZTQvd0JKT1I2ZEJWdUx4VDRpWEttNllEdnhnMTllL3dEQ3R0R0RmTmJBRCtEdG1tdDhQZEtWQm0yeXA1SHZWUERZeGZhbDk1bDlieS9mMmErY1VmSmNmaUh4Q3lNWXJweitPYWtUeFA0alhlR3VueWVtZWYwRmZXSStISGh4UU0yem94N0tTUWZ6cFA4QWhYR2hNckVSTUNTZWQzODZhd3VOc3RYOTVNc1psN2QzRmY4QWdKOGp5K0xmRUtyL0FNZm56ZWg0cVZQR1BpUmdtYnJkemdFZXRmVGpmRFRSM1liNFNCMHljbkgwcVkvRERTVTNiSStuSTV4Vnl3dVBTK04vK0JNVWNabDBucEJQL3QwK2Fyanh2NG1qMmo3VWM5OFZRZnh4NGthTU45b0hMWTZFZm5YMHdud3lzWkdZdkU0N0E1endLVzYrRk9sektRcGtYYjJ6eCtOWS9Wc2VucEovZWRDeEdBbHZCZjhBZ0o4MGY4SnQ0a0tZRXE5c2s4VXNmai94S2NJSlFjSE9UN2U5ZTl5L0M3U3NBQlhESU9vZk9jVlZId3l0WldPQVZVZEFEVmV4ekJkWmZlWnlyNVdwTk5SKzQ0aVA0ajYvNUdVMktjSGVBYXdmK0ZoNjR6NUVLY0hBNUo1cjJVZkRTeFNNNDgzRzNxRDNyTC80VmxiQnNGNUczZEQweFE2ZVlXM2w5NUVaWlVuZHhqOXpQTWJuNG02d3UwU1FJeHgvQ2NmblZXTDRtYXd3S3RHZ0I1QXhYcFgvQUFyZTF4dGVVblBYNWF6RStHaWVmdTh4bEFHT21jMGNtWXBMV1d2bWJLcmxGU1RkbzNYZE14aytLT3BlWHQ4Z0FZempQZW9sK0tHc09kbmxiVjlRVCt0ZG4vd3JLQm96L3BEQTQ0TzBkYXlwZmh3c1krVzZaaWUyM0FGRFdZYlhkL1VJL3dCbjMyalk1eVA0c2FxdTVUR1dCeVBTcEI4VXJ3cU1Sa2V1VFVZK0c5eDVoek5rZW1LdUo4Tm1iSk01VStnWGdWUy90RzJ2TUpyS2V2TGYxUERMN1Fia05sSTJPUjNybS84QWhIdFJadUkrL2V2dFFYSGg1bEFaMHpqbjNwNjNuaHlOczRqeGowcVk1ZkJxN3FwSFJMTXFrVzdVWlA1SHh2RDRWMVpnY3hBTHlNMWZUd2JxakVkc0Qwelgxb2RZME5Rd0FYbnBpaGZFdWt4OEtpNS9BMW9zdnd2WEVJNW5tMkxlMkZmelBtQ1B3UmVNZnZuMzRyU2k4QlhaUWZNM1gwcjZHbDhYNk9wKzRwcUQvaFBOS1JOdUV6K3RVc0hnRXRheGwvYUdaUGJEbmppL0RxNUpVc0dBUGJ2VjJMNGJ0amxXK2xla3Y4UUxNQmRwUWM5alZHYjRqVzBiRDVWSjdWWHNNc1MvaU16ZUp6bVQvZzJPYWcrR2hLbktuT09hdi84QUN0WUVLcVlpR1BPTTFhLzRXZW9KQks5UFRBL0dzNjUrS0RCdVFNRG9RT2xSeTVXbnZjMVU4NmF0eXBlaHRXM3cxaHp5dkhwMTVyZWcrSGRxRkpFWTRQUEhTdk8wK0pzZ0RZSnoyT0RWZi9oWmVwWk94MkdldkZYejVVdGtIczg1YStMOFVlMHA0SHMxQkpoWGp1Ulc3RjRidDRvaUJFdUNjL1N2QmwrSW1vc20xbllBZHNjVmZIalc1WlFRV1ByUjlZeS9wRDhEbityWm81V2xMOFQzRTZYYkNNalluNGlyY0dqNmRrWVdNZy9lNDRyNTh1ZkZ0d3lnaFd5T2F3MzhZNmx1eDh5Z0RIWE5ZL1djSW5vdndPMk9HeGlWbkpQNW4xWStqNmNBRnlnSHQyRlJmMlRwdTRBT3BHZXZGZko1OFdha1FDU1QrUEZVRjhXYWtyWTZaUHIycmRZL0NKSmV5T1dybDJObnFxcVI5bXgyR21yOTJWY1orbFhEWWFUaFFiaE1zZnlIdlh4ZTNpZlZDQ1MrQXRSLzhKSHF3emgxYmQvRnp4VFdQdzE5S1RNRmxlTmh2V1QrYlB0RTZmbzBMbi9TVUlJNE9PS3ZwRG9vWUh6QXd4eHROZkVIL0NRYXF4YkxLUm4xeitsU1I2NXF5S3VKQnQ5QlZ2TXFDV2xJMHA1VmlYSjNyclUrM1BOOFB4T1N4SjU1QnJXWFVQRHd3QWNLT2VhK0U3aldkVmR1SmM4REZENjFxakxnekFFOVFCaW9lYVUzdFNITEphOTlhc2Z1UHQyUFU5Qzh6dGducmpJNXFSdFEwZEhZc2ZVRUFjVjhHTnErcTRiWk9SZ1o2ODFKQnFHc1NSbG51SHdPT2VlYWorMVkvd0RQb0k1SFVhczZ5K1NQdmVIVzlEakFDOG4zNTYxWWsxalNnZ0cwWjcvU3ZnRVgrcHFoSm5ZRWprVmV0cisrZGNOY09mVERVUE5GMHBqaGxEaTdlMXVyZGo3cmoxL1RWNXgrT08xRVhpUFRYY2JRRGpJNVBXdmlPR2U4a0xvMDdZNUdOM05PaDg4aVFyTVJqL2FQQnFmN1ZmOEF6Ni9FMVdTeC93Q2ZydDZIM0cvaUxUMTJuYmdESEl4ay9XbngrTHRPQ3NER2hHVGpkak9Qd3I0Ujh6VVdYQm1reDNPU2F0SWsyemVKMkl4aGxKNUdPNHAvMm4vMDcvRW4reDQ5S3JYeVB1U1B4UmFzV0tCTU1NRVp6bXF4OFc2Y1hQQ0t3QTVCSDUxOE1wOXJMQmZOa0dPVndUeGlxd2psTXJsdzdFaklZazlheGVZelQrQkZ4eXFsdHp2MVB1MS9HRnFBQjVpZ1l6MXhpaFBHZGtyRlZsai9BQVlBbk5mRWJHZDNRT0dKWEhQSjQ3MU90b2dseVZJd2V1RGo2MGYybFA4QWtSY3NxaGIrSXo3ZC93Q0Uyc3BQbGthSXNmN3hweWVNOVBSaWQ4WnlTb3h5TSs5ZkZ5cXF6OHdzU1A3b1A2VmJrVGVHOHUzdUVYKzZSeG4xRlFzeXFPL3VSSldXd1MrT1I5Yk40OTA5SkN2bnhFNXlRVFQyOGNhVzB5c3MwZWV2QXhYeGhIWTNBd0RiUHoyWlRubjNweDBuVUZ5V3RaU3ZWVGcxcC9hRmIrUkVmMlpTYTFxeVBzTzU4ZDZlWk5qWENIQTVHT2xNOFBlSUxmVWZFMWhESElyN0pWYkE5SytRRHBHcTRWa3Q1YzU2S3BKSS93RHJWN2Y4R3RPdTRmR2NZdTRTQnh5UVFUV2RURzFwVTVSNWJKeFp2aGN0dzhLOEpjemsxSlcxTlA4QWFpdmxXU1BIQVJRY2Voelh3eDRWOFVKTGVLV2NaNFBOZlhIN1QwalRhazBFUjNiZ3FxQjFyODhOSzBlL2h1MXhidmtjOUs4V2xVcXdqRlIyNm52VG80ZXRPcktiWE56T3grbUdrNjlvWGtneVhSa2tHQnMyNUF6NzEzdWw2cnAxejRrMFMxZ2RnZnRTRUtlbU0xOFphSnArcE1GWVFzcElIVWNrK2xmUmZnVFNOUlR4am9zcnhNbyswTGtrY25tdStOZXE1VzVkRHlIaGFTYWZOcmRHeisxSGR4UWVLOVBZakN4S3BQZm5IYXZsRFEvRmxuNTVMU01CMUFIODY5NS9hV0Z6cW54R2lnaU81VENOcTlNRmV0Zkt1bitFcnhwZ0h0bkJEZFFlSzFsVXFxTUZGT3lpcitvTEQwWnlyU20xclVrMXIwdWZZK2krTGRIeGtTRTVBUFR2WHNjSGpid3IvWU9wUXpRU05mTzBmMmFaZnV4Z2ZlejdtdmpmUzlBMU5TeXJiTVFyRFBIUCtUWHNVZmhmVUNHMldKampJQVVrMUx4RmRxMXZ3Q09Fd3kxVDZOYnJxZGJhK000SXBDckIzSkdCaXVvVHgzYmhWQldaUXZHUFUvU3ZNby9DV3E0WDl3Zms2a2NuNjFhajhIK0lwVUxDQXZqN3BiQUlQcFdzSytKUzIvQTU1VWNQejI1dnhQU0UrSnR0R3JvRlloeU54QUFQSHBtckVmeEZzaTRDUXlNd3pna2pINjE1ZEw0RzhUaU5TbGw4K2NnY0hKOWNWV1h3WjRpeWl5MmE3dXYzc1l4VnF0aUc5dndJZEtndkw1bm9zbnhLanlSOW5mSHIyR2ZTcFcrSkVKVmY5R2xZQ3ZPNWZBbmlLWExKYnFGeDBEWnp6VnFENGUrTFRJeDhsZGpMZ2pmZ2ozclQyMkpYL0REalN3M1czM25mRDRrN0pDeHRKQU1kelNENG5XcTdpYlNZbk9lRHhYQVJlQXZFcjNKQzJZK1ZjTVMrY0d0ZVh3RjRpa1RpQ01oY0E3bkFGU3EySTgvdU5lWEQ5R3Z2T3NYNGppUitMUndNRWs1N0QxcVAvaFpYbHlFL1pwRGpweng5RFhEdDhPL0U1WXRHSUFNL01wYXJxL0RUeEo1Y2gyUk1TdVRsOGswS3RpVyt2M0hOT2poOUxQZnpPbGw4ZnpUL0FQTG8rN0pPMEhIRkE4ZDNoancxbzRYT2Z2WXhYUGY4SzE4UU1xNzBpKzd5U3h5UGVwNC9oM3JoUE1zYjVIVGQwL090UGJZcTNYN2l2WVVGMVgzblF5ZkVhWkFJeFpNT3pNV3lEK1ZWditGb2VVZjNVRGxzNHprcVJuclRGK0crdXRFV0gyZmxSbGQrT1Iwck5Id2o4UnU2ekM1dHVYUERNVGoyck4xTVY1L2NXcWVFZmE2OHk4bnhHdlZKQ1dpNTR4ei9BQ3F3L3dBUWJvcWpOYkVPRys3blBXckNmRERWUTdMSFBBWFVBNTlQVWZTbUg0ZDZsREMzNytJTUNOeEdXemozTlQ3WEZ2OEFtKzRJVU1HOTB0UE1yUy9FaThaMUF0R0w3VGhTTWRPd3FHeitKbDI1Q3lXZ1hjRHR5ZTlXNWZBRjRGamxGMUVHSkJDc1NHSDByVVQ0YVhrN2dMY3crWWZtemc5cWZQaTF2elc5RFJ4dzdsWk5ObUkzeEcxRGZoTEl1UG9Rb0k5VFdnUGlYcUxsUTlqRURqR0R4dHgzeUtZM3dwMVQ3U3UyOVIwYk9WNUF6OUt2ajRXYW5FdTVMdUxPN0dHeU1EMm85cGlYL045eGNhV0dTdnA5NWx0OFNyekNEN0NNOC9OazRQMHFDNitJbXBTSWdlMGpBR2VNOC9uV3hOOE50U2VKeDlxaUFJQUdNOFZEYmZEWFVFZmE5N0d6Yk9HWWRxT2JGZWYzQzluaGJiTDd6RmZ4dnFHeU1KYmtaSHpBdDIvd3EwM3hDMUV4b2hzWThqT0c1NXp4MXJYdlBoM3FIN3Q0NTRISUJCNHhVY0h3eXZHMkNXZEZPZWd5UWZiRlM1WXJ6KzRoMHNNbHBiN3pGYjRoWDVoYi9Ra0xEaklQR0t6bDhkM3pFYmJiT0NPUlhhWEh3NTFEaFlyaTIyNSs2dVJ5S296L0FBcjFHRzNMUHFNUUJiSlZSa2p2eGlxNThXbHV5NHh3N1hRd0g4Zlg2YnY5R1FmVTFHdnhKdlNBdjJOQ1IzQnhYYytKZkNudzlzWXRNc3JEeEZEZmFyZG9IMnhQNW9BSERDVUQ3aEhiMXI1SitMUnYvQk5wWXpMSEhkZmFaR0cvbEZYYjFCOXpYbXh4OVNWRjFlYVhLblozVmoxUDdQajdhRkpSVG5MWmMxMTNQbzdUdmlyNWJYMW5QYk1CY1E0UXFNOGc1d1QyckZsOGVYQmY1YllCVkFHQWNuSHVCM3JOK0ZmaG1YeExwa2VxYlJHajIwcnRHdzNZMmpBUDByYW0rSHQ0WEFXZFZhUWdLd0hVR3VtRlhFU3M0dDY2bkpWdytHV2xTS3VtMTZXOUQySDRlZkdBYWY0ajBxVzZzVlczaGFRaDJ3R0c5Y0hudjdWNTU0aStLMHQ5NGcxRzdqdGxSYmk0Wit1Y2M4RDYxaFhYdzUxaE5vVzVpWXJ3Umc1L0NtRDRjMzRqWmk0QkhZampuM0ZWZkVjL01rNzJzMytJcFJvU3BLTGZ1cHRyWHlzU1A4UWJwM0JGcXA5U0tkSjQrdmxsS2kxUXNCa0tmU3BOTitHK3J5eU15ekl1Rko3bklyb1Q4TGRWTUhucGN4UDN3UVIrSXJaVk1VdS8zSFA3REN5UzBUK1p4QitJdDhIeUxINisxV0pQaVZxTGhkdG1tQ0RnWnhtdW1UNFdhMllSSUx5M0s1NUJ5RDlLenBmaFpxVWk3a2x0eXFrZ25KQXFIVnhLZlg3alZVY01scnkyOVRsditGa2FpdWMyRWVRUjNvaytKT295cnRGbkZIdS9pL0R2V3NQaFZxOHNXOUpZaUJ5VHU0NHJ6cnhKNFIxRFJMZEhta2pCdVg4dEFoeWZjL1NyVThUZnFUVXA0UkxUbE1PR2FhNmxudXBXeTg3bHo5QndQd3IwVHdGcDhkLzR0c0JJTXh4eUNWeDB5RTVBL091QUd5T0FZNHdNWUh0WHEzZ2E2K3hSWGQyaHhNU0VROWNEcit0WlpwVmxUd1VyUDNwSzN6Wjd2Q1dEalh6aW0ybHkwM3pmK0E3SDdNZUh0WnRaN1Y5dTVWVWdmTml1dWp2b1hsWlZjRWozcjg0N1h4UHFkbnBOdGNDNlJBNnNUaDhsV3owWWRqV3o4S2J2VzdqeHhjTExlVE9qUUdWbGtKNDNkTVY4amg0ejltbSt4K3ZZekxhY2xpS2thbGxGTnBkN0gzRDRpMU9IVDlLdTd1UnNMREV6ayt5ak5mbDlhWHJXSGhEVU5XbTR1ZFJtbHVXejFPODRRZmhYMkI4ZDcrV1B3cEZwOFJQbTZsY3gyeWdIQnd4eXgvS3ZqangyUjlyMGpTNDFCalFicEIvMHpnSDZjMTcySGg3dCs3L0kvTk1WS0tnMTNldmV5UGo3eFZxZzA2NGdXYkJpMGF5azFLNHovSGN2eENwL0U1cjQ5K0hjOG1uYUw0djhaWEpKbmlqYTFzM1BlNnZNN21IdXExMVh4VjhRK2I0ZnVaZ3g4M1c5VGQvcGJXbnlJUG9UelhQK01yQ1d4OExlQlBDVUgvSHhkaGI2NlZlOHQyUUVCOWNMVXphVlJ5WDJZM3QvZWxvamhjZWFuVHAyL2lWRkdUL3V3OTZWL0p2UWhzWlp2QzN3ZHU3dklGNzRvdUdnUnY0MXRJT1hPZlIycmlOUWdsMDd3bG8randyL0FLWHEwaVhNNEhYYVR0aVUvd0E2OUQrSWtkdnEzeEYwbnc3YXk1c2RIdDRiTlQyQWlYZE0zNG5OY2xaWDhHb2VNTmIxMWwvMGJUSVhraFU5TW9QTGlVZmp6WHoyS2w3MFk3cUN2Yno2ZmlmUVplbTRTbTlKVnBPVDhrOUYrQ05UWHJJWHV2Nkg0VHRKQUxld0NwY04vRDVoK2FaejdDb3BsMDd4TDR4bWt3WTlLMG1FbkErNklMZmhSanNYTmNWb2w3Tlk2RHIyc1NOL3BONHh0WVdQVW1UNXBHSDRVMmFadEg4RTIwRWJZdU5YZnpaUjNFTVp3by9FMXp4ZzRwV2Q3ZnJ1ejZMMnNKL0V0SDA3TG9hMm1LZFIxdlUvRVYvR0pMVzBKa0NEa05KMGlpQTlCV0hwYzAwTU9vZUk3ejVwV2RvN1FNUHZUdjFZWjdJSzZIWElMbTBzZEY4T1d5LzZSTHNudWR2VnBadnVxY2YzUlYvV3JhUFUvRUduNkJBZk1nc3NSTklQVWN5eWNWU2sydGZRbDRXTTIrVjI3ZjhBRG5CNlBPMmthZk5yTW8zM2M1ZU96M2NrTWZ2ekhQcG5BOTYxOUp1MjhQNkxKcU1nRGFqcUtNbHFXT1dpalBEUy93QzhlaTFvM0ZqWWEvNG44cUJ6RnB0aEh0QWJ0REYxT2ZWeldIQ0cxUFhMclZMMkhGalo0WW9QdTdFNGppWDYxcmVMdWNFcU5hbkp2bGR1clJzcEkvaGJReElBRHFtcVFuYWVyVzhEOXg2TTlFdTN3dHBhUklDZFl2b3daRzZtMmlmb2cvMjI3MVUwcTdhNG4xRHhIcUlEQ0Z3TGVNOUdtUDNWVWVpVS9TODI5dmMrSTlSSWxsYVVpMFIrZk1tUFZ6L3NyV2ZYVXQzZXE5ZHlSSjR2Q3VuL0FDamZyTjRuSjYvWlkyNkFmN2JmcFhhU1dDeHhSM2NXbnhmMjZiWVNQQVhCRVkvNTZoRC9BTXRDT2NkcTg1MDAvWWtrMTYvL0FIMTFOSXh0STI1M3Vlc3JEKzZ2YXRHek1tbHdOcnVvczBsN2NNeHRVWThrbnJJM3NPd3BwV1k3M1RUV2h6N1c4ZWx4dGQ2a1ROZXpaYUtCam5CUDhjbjlCWDY4L0JyeDVOSDRPMGZUUEN1aFJYT3MzVnVIdW5JMlc4TGs0TWx3NDVKOUZGZmxwcEdpUitKYi9UWlpFOGllYVpZNVpKVCs1K2M0RXJuK0VlM2V2MmswbTd0ZkJ0bmJlRS9DRmpEZWEyMFFhZWRnUEp0Z1J6UE95OVQvQUhWcmVFWk5yMXVjOVZwSksxN3U2V3lzdXN2STFQRUZqNGI4SXp3YXg0cjFRK0lQRUU0L2NST3UvYXgvZ3RiY1pDcVBYRmN2UDRWK0p2eENlT1Mvbi80UnpTVkc1YmFQRFhMTDZ1VDhxVnRRYVA0YThENm5EZjZuY1hlditKdFFCRVVTanpMbWQyN1JxZUlvaDY5aFhkYWg0UDEzVjlOZlVQSG11eGFacFNmTU5KdEovSmdRZWx6TndaRzlRT0s3OVZMOG4xK1NNSGFTVW03N1drMWY1UWllT1cybmZBM3dyZUxhMmVuUHIrckQ1V1cyUTZqY0Z2OEFhWTVSRFh2Tm5ybnhWdVkxR2wrRWRMMEszMkVJMnFYWmFUQS82WlFEajZWaTZKNGsvd0JGTnI4Ty9BNGUyVTdQN1NuWDdEWWpIZFNSdmwvQVZOclhnajRnM3RxMXg0aitJQzJFUjVNR21RSmJ4cUQxSG16RXNmcldiZTE3WDg5V0wyYXY3OXJ0L3dETHlUY3YvQVk3Zk1nOFcrSHZqTGNlQzlhdTd2eFpvaVFpd25aNDdiVFd4SXUwNVhlN1pHZld2RExDSDR1YWI0ZDhQTEQ0MnRGV2JUb0pJSTIwMEZGVWo3aGNIbmI2MWE4YzZIOEVOUDhBQ2Q5RC93QUo3ZlhsMzlqazhwSDFsMzNTYmNxUExUNWV2YXZEdERzUGhNbW5hT0kvSDkxQzdXMEptZy90Q1NNSkl3K1lEUHlqSHBRM0xTeWYvZ0tOdVNQTDhOMWQvd0RMbGRqNkx0dGIrT0htbmRaNkxyUVVxamlDUjdXVDV1bU40eHpYQ2F2NGs4SFhOMUpaK05QQjgyaDNERW9KcG9NeEhQcE5GMC9HdW84S2FONGluMUdJZUhmaU5kczdPVEVidFliK0Z0bzZFcmhxbXU5YzhhV1dxVC84SkpvY091V1FtSm51dExQbVlVSERicmVUay9oVWMxOUcwL3dablNqRG1kbEZOYSs2M0dYNDZIeko0dS9adDBEVTdOcjd3OWV4elJ2OHliWFZnZm82OGZuWHdMcXZoM3hwNEt2cFZhS1ZFLzVhUnV1VWRmOEFiUTVERDNyOWFMWFJmQ21zYXBmNnI0RTFnNkxOdk8yMGkrWkNSMSswMnovZDNIc09sUzZocXVtNm5kcDRlOFo2WGIyV29PTVFUbzI2MnVjL3hReWZ3Ti9zbWxLTVc5aTUxWnFUVWx6VzMwdE5lcTZuNDRMYWFackpTVFRGK3gzNmpKdGQrRWtZZDRXUFEvN0ovQ3REN2RiYTRQc21xRVcrb3ArN2l1M0cwT1J3RW5IcjJEZm5Ydm54WStCMnNlSHJpUy8wK05wYlRma09nd1ZQVUJnT2plL1ExNVBwOXpGS1lIdjQ3WnRXTVRmWm1rUDNqakMrY09tLys3bjhhNTVKcTJocXJXVGpLOFhyZFBSbXRZWFg5alFXTnJyVThEWFNzeHRDNithMW5rWVYyWWRVSjZEdDFyZ1pMMjZTZTQwblhITFJ5U21SSno4eGlrZnBLaDdvM2NWWGl1SDFwRHAyb01JNzJFc0xXWnh0eTJlWVpQWS93bnRVVmluOXB3TnBOM21POGczQ3pkK09SMWhiUFk5dlExblpMVzNZY3BYc2tXYlNQN0pQTm9XcW5FRWpib0poeUlwRys3S3A3bzNlaXpoa2J6L0QybzRqZEpHTnJJeDRqbDlNL3dCeDZwMnAvdFhURzA2ZkszdG1HTnFXNnNnKzlDZmNkVnFPNXVFMWJSSTVHYkYvWUFJeDZOTEFPaC8zay9sVnJjelNiUzBHNmNHdTRKdEd1dmtsUm1OcVcvZ2xIV00remZ6cXRwci9BRzJ4bTB1YmlWQ3oycGIrRng5NlAvZ1g4NnYzY00rc1FXZDliSTMyc0VSM0dPTnpMOTJRZlVkZmV1NkhobVcrMUNLY1d0MjE0VlZuaGdqWTVkZXJqak9EU2xLTVZkblJSb1RxTzBWOStoNW5DMDJwNld0b1VMWE5ua3crclJrL01uNGRSWFF2bzA5N2FRVFhCTUUxdUFzaDZzeS93dDlSMHIxYUx3eDRuazFKb0xQUUxwcmtnUEpBdHVRNEo3c091RFdoWWZEbjRoWC9BTnNtdFBEdDNMRmJNOGR5VlgvVmxSbGxZSG5JOUs1WE9UMjBQWnA0T2pEV3BKUFRhNXljN1dhTERxVWNhdGNxVlZuSStZdXZmOFJVR3E2cEJaYWhiYWd2K3B1MTNGZXZYaDF4N1Ywc2Z3MStJSjBPZlVuMHdycHNzSllYQ3lLY0FIQWJhRGtZUFgwcS9mZkF6NGhXV2oyTWVwSmFReDNkd24yYVY3Z01xdElPakZjNERkalhPcWNlYThwZVc1MHp4a0lSbEduQlgxWHpSeFBodlhScDNpUzgwdVpzYWZxc0p0cGNjZ3JMekcvNEdyWGd5Q2FSL0VuaEc1STNYS3UxdnVQUzV0K1Z4L3ZDdXMxTDRLK0pJTlNzdE12TlNzYmU3anQyZEpON01qb3B5QUNCOTRWZHZmQjE4bmlLMjFWTlZoanViZnlYY3FwUG12SDFaZnJqbXZTbzFJSzJ2cjZNK1F4Rk9wVW5VbnphelNhZlJTanN6eld3YVhWL2g1cU9sdW4razZMY0c3aHo5N3luK1dWUHdQTmZvdjhBczMrSjExYnd3ZFBuZFcrVXhNaDV6Z1lQNWl2a1c0MGJUOUYrSWNWNEp6OWwxUkQ1a1FYQzdMb1lZWjc0Tk8rRE9vUytHZmlIZWFkSVNvaXVDQUQzQ25INml2VGk3VGluL2hiL0FDWjQ5U0VaMHB1Q2ExVldLN042U1g2cy9TQ3ptdU5LczdhUmc1dWZET3FCRDZtMW1PQjlSZzErdUdpWHd1OU9pbFFnaGtCSDQxK1pXdTJFYmVMUXVSNU91NmJKYlBrOGVkRU55SDhhK3Z2Z2ZyTWwvd0NEckZKV3pMQXJRUyt1K0k3YUtxZHJtMUtTYmkrajEvOEFBdjhBZzNQcEVzUjI1cnovQUZieExhMkVoU1Z3TTg5Y1lGZFJxOTE5a3QzbEk0UUVrZTFmbFQ0MjhaVDNXc1hSRWpFTTJJdzNYRmVYV3FPTWRIcWZZNWJnS1ZibWxVZG9MOFdlRC90b3hhUHExcG9XdTJSTWtxeXlXbHd3T1FBT1Z5TzFmazFkeDJpTEQ1YnV6c3VYQjRBUG9QV3YxQStJMFYxcVBnSFZyU01Jd2JiTnlPZDBmUEhwWDVQeU94d2VPRFdkR3RLcEZjejFXaDZPWjBZVXBVVkMvTDdOSk4rVFAxMThEK010T3RmQ1dnN3BsQlcwUUVNT2hYZzE2aE44UjlJZHZrdWxHUjJiay9XdnoyOE1DV2Z3NVpFUUZnSXlNZ0U5RDFyYi9zNmZQN3Uza0p3U2NLVG12dTZPWVZWVGg3cTBpdFQ4Q3E1YlNXSXJlOUxXY3RPMnA5MkQ0bFdLNFUzVWJZSFU4a1ZkSHhEc2xqaUN6Uk1DVG5kakZmbjgrbnp0bmRFNEk1NUIvS3F5V2x3TUFsczU2YzF0L2FOYS93QU1UTlpaVGNyODh6OURGOGU2ZGtPYmlKVzVJd3d4K1ZCK0kyajdnVExDZWVvNjErZmYyRjNRblkrN0dlaHdmcFVjbHJLcVI0allGaDF3ZWFGbVZTL3dSSmxrOUsrdFNSK2drZnhIMHhwMkpFUndEdHljRG5qbXRTUHg5cEFXTWVaR3AyODU1NTlLL09XYXpsallZREU0QlljNHg2VkMwYzVPY3VBQ09oUFNyZWF6di9EWDNtVHllbnQ3V1Z2a2ZwTW5qcXdkVllTSXBCd0NjZHFoZnh2cEFrM09FWWs1NFlESjlhL04vRWlqaDNJSjY1NUZUeVNnSnc4aE9jQVpJeFYvMm5PL3dJei9BTEdqcS9hdjdqOUczOFk2ZVFaTjBXMDg0SnByZU45S2R3eEtCY1l4dXI4M2tTN0todk1idU1icVNKN21US2gzQTZEcnlhcDVySi84dTE5NWNNblcvdFd2a2ZwbEg0NzBsSWdOc1djOU04MUt2amF6ZG0yeFJxU3B5UTNOZm1TMHQwb3g1ai9nYXNDNHVWa3o1ODJBT2hOU3N6YS81ZEw3elZaVS93RG44L3VSK2kwL2lqVGM1SGw1eHp6K2xXWVBGZW1JRkVoVlNEa0VucFg1cHRkM1lsTzJWL2I1cWlpbjFCamw1Mjl6bXRIbXJhMWdjcnlWSjNqVmFmcGMvVGwvRStqdkczejVQUEFiQU9hb0o0bDAwT20wcGdldkpyODYvUHV6OTJWaVFCenVPS3BDZlV6SUFKejF4ak9PYVg5cU8zOFA4UnJLbTk2MzRXUDBoazEvU1dsQndoWUhOTGNhNW9teGNTZ1pIYnJuMHI4N0xmVk5VU1pRMXcyVnlPVFZPWFVkUTg0cUxnNXptcWpteXY4QXcveE1Ya2N0WDdWZmNmbzlEck9tTkgyR1A1SDFyUVdiVFhzMnVCSkNGVmd1Ti96a24yOUsvT2UxMURVZkxiL1NIR092TlU1TlYxQldRbThrSUpQUTlxZjlxeHYvQUF2eE5GazBuR3pyZE94K2gzOXFhVU9XVkFvSTZIa2lvWnJ5dzM1UUFxUjY5Sy9QdzZ2ZVB0MjNKOXlUem4ycTR1dFg2cUFMaHZ6clQrMklYL2hQN3lJNUZKSzN0dndPRnVKYjFHYjk2ZldzdzN0eVRneXVjNXI2eWJ3bFlObG14anAycHllRU5LRFkzSlhsUnk3Rnk2cjd6M2FtY1lHbkswbTcrVVQ1TUR6SEh6dCtacXlyU2s1K2MrL09LK3dJL0NlaUl2enNoL0VmcFY0YUhvVWVQdWdjYzhWc3NxcjlaeFh6T1NXZFlWUDRKdjBSOGFwRkt4d1kzT1RuT01pcGx0WmlHQWdmT2VEdHhYMm5IcGZoNVRodGdBNzFiYXo4T0tUaGtLNDY0NXFsbFVsL3k5aVE4N3BXVnFNMmZFTWRqZWh2K1BkL3lxNDJtWHpCZjlHWU5uMHI3V1JQRHhiSVpmeEhlcHBibnc4aWo1bDNEZzhVdjdNWFdzalgrMXBOWFZGK2pQaWVQUTlUazYyeHdjL2pWcWJ3OXFXNzVyWnZjanZYMTZkVDhQRGNBQU9lNHhVVW12YUJHcFJ4aytvcHZLNlgvUVFqSjV2WFQvM2FUKzgrUzQvREdwazdpZ3o3MXNMNFUxQjFBSzdmcFgwMUQ0bzBKSHlJZHhIR1NCVjF2RjJpQnh0dDFCN1lJNW9qbCtHVzlkRWYybmpXcnh3NzlHbWZPa0hnblVTQVJ5QlhWMjNnM1VBQmtET09jZEs5blR4ZnBZajRqVlFXNTU1cTMvd2x0aXFBcUV6Mzk2SllMQngvNWUzS2hqOGJMNHFWdmtlVmp3WmRQRXdkc1lHYzRyTm04Q3pzNEN6Y1k1d0s5V2w4V29FSTNLUWVjVTJMeHJhUnFSaU1FOFpPRFVMRDRPL3hmaVc4Umpla04vSTh4VDRmekE0YVlqSTlPdFN4K0FHSUg3dzlld3IwTmZIOWxFLzNVNHFML2hQYmZEYlZUazVCUFFWMExENWYxbitKelN4V1pKL0Evd0R3RTVLTDRlN1EyK1J1ZlFWQ253OGo4d2Z2Mjdqbml2UVI4UTdkb2lDc1l5T21CMXFpdmpxM0p5V1FmVVpyU0ZETGw5cFA1bk5VeFdhOHk1WU8zWDNURlQ0Ynhoc2lXVG4yem10QlBoeGF4bmtQazhpdFAvaFk4U2NMTU1qZ2VtS3JTL0VhSitQTlU4ZzhDcTVNdFQzWDNtanE1dEpLeXQ4ckNKNEF0QXhCUnpua1o0clJUd0JaSFkzbE9SL3ZZNXFtUGlDbTltTnhqYjM0b2Y0aVFHTC9BRjVPZU1lOVo4dVdwNjJLWDlyeVdyZC9VMGYrRmQ2Y1pjQ0VqSTduaXRTTHdEYVFnTDluRFo0SE9NL2pYRm54N0JzUS9hY24yN1U5UEhjUzVKdVR4emdpclR5M3NnazgyajFaM0NlQXJXVGVQczZ0anJubXBVOEIyRVkrU0JWSHAxL0d1RVg0aktIeWt6QWRDQngxcVp2aUhHUUFaSEhQSXhRNVpkMmo5eG5IKzFMM2JrZXNXSGcydzJ1UmJSbmp1UGJ0VTBIZ3F6R0pFaFFZUEs0eVQrVmVReGZFT0xhd1dTVEFQWS80VnJRZkVLM0M3aVpQdloveDVxT2ZBZjNmdU52WjVqM2tldXI0U2pkdDdXaVJqcWNqcVBhbzRkQXNmTktpMVFybm5JNXpYak54OFJReFprTXd3M09DZWxWbDhlSFp1UXlZWTlUNi93Q05hS3RnYmJyN2pCMHNmZlo3L3dBeDlEUmVGTGNOdVNHTURzVGdmenFuRjRkdGhPdzJ3N2czVGptdkEyK0lxb3k1aVorT2NrbW9vL0hFa2ltVVFIeTg4c2VsWEN0Z1YyOHRET3Joc2UwclJsZnI3eDlFTm9jS3pFUlJRczI3azhBRDhhNkd3MGl5TEVQQkNUbnB3YStWaDQ1WVA4c2JGV3owSkJwbHY4UVFKQ0JESUpNOGNlbER4T0NhZTMzR2NNSG1FWDhML3dEQWo2YmtzSTBsa0RXcXhBa0FjQW10QzIwcXdhUnVVeDNHQjFGZkw4dnhEU1JuL2RIZmdaL0RxYWdqOGZCV0JTQXpjWk8xdVJUK3Q0UzFrdm5ZVU1GamV1cVg5NCtwNWJDeitZS293RDNVR20vMmRGc2JNeWdjZkxnWi9Ldmx4UEg4NUw3TFZtSS9oenpVRW54QmZ6Rk1zRFJuc2V2SXBMR1liUlgvQUFIOVJ4VGJkbDk1OUx6VzluRkhJVnVGUE9WQUdEVmp3cVkxOFU2ZElRR1FaTzMwTmZLci9FVnlTd3QyTFkvaVhpdmMvaFZxemFycXZuU3hDUGJrREI2OFZoaU1YUWxRcVJqZS9LK2gzWUxDWWlPS3BTa2xaU1RQQi9qeHFDSjQwaW02QkpPQU94cmdOTW50cnVXSDk2QXJESmJISVAwcXIrMFZmR1B4QTdMeVJJZUsrZHZEZmllWkpGQlVrRG9SWGowcTlLRUl4YTFzZXpQQ1ZxMHAxSVNzbTNwNW42WGFYcEZ0NUlkcmplb3h5Qmc4OTY5RDhLU0UrSjlIV1JNaExnWVBxdnZYeWpwbmo2NVMwQ1IyaGZaZ2xnT2dyMmI0YWVLWjlROFgyVWNpN0ZWbWtKSXoycnNXSXBTVWtscTBjTU1MaUZPRitqVi9rWnZ4cnQ3YTMrS05yS29YUGxPVlBzUjNyaDlPdUlYM2JtQnlRZU94NzVyNXgrS2Z4RDFMVmZpN3FCaWtVeFdmbVJSZ0Q3Mk9ySFBlcy9UZkV1cUhLRkN1OEg1Z2Y1VmpTektuR2kyb04yWDMyUjFWOHFxdW91YWFYTTIrL0twTnY4RDc0dDdxempFc21BQUZ6eWZTdnBOWXZDN2ZETFI5ZFdWZk9kMmptSWNrWnowSS9oSXI4dXRHdXB0a2l6WE0yK1E3UjgzR01kYTlobDhhNi9lZUhVOFBUUEExbkhjTGNSaEl3a2haQnQrWWpxTVY4N1V6WEUxSlU1S2x5WGRsRzk5Zk0rdG9aVGxsS2hVcHV1NmtucTVXdFpmM2ZNK3FyUzlodm1qV0NSbmZQeTdDT240VjF6TFpiMVVTdUIxYjB6WHd2cE9wWE9qWG4ydTNEeHlSZ2xXREVCZTM4cTdlZnh2cVFoalpXaURIT1dEWUdmYk5mU1liSE9VZjNsUGxmazdudytQeTlVNnRxTlJ6VC9tVnJIMlZEZjJ3S0FTRWhGSTZjazBzczlwSTQzZkx0UExZOWZTdmlZZkVmVmpGNVlsVnBzamtMOG9IdWF1SDRpYW9vWVNTUkhuaHdwWS9USHA3MTN2RzBlbHpqamc4UzQrOXluMm5acGJPVG1ReGprOU9UN1UrZVN5aWI5MEhabDZGandhK0ZtK0l2aUR6R1ZiaFU0eXZ5OXZ4cGcrSWZpSnAxRDNDa0h2aXMxamFUZXpORmdhclZ2ZHYzUHU0M0ZpU3UrS1JXWTlWR1AxcVhkRXFONWlaQVB5akdhK0QzOGZlS0lKaVZuRHNPZzY3YXlwUGlQNHNrRXVKendBY1l4VmZYYVhaL2NDd0ZXNzk1SDNtTHEwUmlSYmpxQmc5S3RRM0duQ2FacFVmYTQ0QUJPTWYwcjgrYmZ4MzRxZVVmdnd3eGxzOXFrYjRnK0tYbTJ4emhqbnNPbFU4YlJhMGl5SGdLMFd2ZVRQMFVsdU5PS0h5NG5HQjFJL1NzNjBuc2tEb1IwNVhJeTFmRlZoNDUxeDdjclBmS2pNU0VBSHo4ZGM1N1ZoeWVQZGUrMEVSM3BBVEFMRVp5ZmJIOHFYMTJGcmNyTFdDbTJtcEwwWjkrUFBhYmsyeGtZeG5BNU5VNTViUlpESnNMY2RjY2l2Z3FQNGkrTEpKQ3JYSlREZks1R0J4MFAwcXpjK1B2RVUxMEM5eW4zZVdqQUFwckgwMXVtRHdNM0Y3SDNNTG0zYUFNcVNySVc1T0JqNlZabTFHMFRkR2JkaVd3YytsZkVFM2pEeEcwTVhrM3JTWlhKS3FBQldCY2VOdkVVTWczM2JHUm1VRGpqODZieDFGUDRXWXJBMXI3cjd6N3B1cjlIWmQ4RERCem5vUHBXeGE2bkRCS3NnaFpqakEzQWNacjRMazhXYTVJNWQ1Z0dRak9BZWFSdkYzaVlNaS9hd1FTY1lYbmpzYVVzZFRhc29zNlk0S2FkK1pKbjZDVytveGVjSE1aK2JJUCtOVC93Qm9XdVJpRmpqSzllUjcxOEFmOEpuNGozS1Z1UWgzNEtrWUgvNnFzeCtOdkVCbTJHK0VRSTV4d3VUOWFsNHltL3NzcjZuTmFLUzNQdjFybUZZUis0K1hITzRmcUt6TDYrdHpDRmUzK1VZRzRZQitsZkMzL0NZK0pKRmtVYWtvQXp0eU92MHFoL3dsWGlHU052TXVuYmpQQXpqSHZTK3QwMXE0c21lRnE4dWtsc2ZlWW5zemhrVGtZR004ZldxN1g4U2tGb3cyM1BJR1AwcjRPSGlmeEJEQWpmYVBsZk8xanpnZDgwK0h4WHJXNTgzRzRZNjB2cnRMK1ZsL1ZLcnRhU3VmZFF2YmNPN21BOXZtSFRIdlNtOHRKVHNFY256Y2pwK1ZmQlQrTXRkQzVXNU9DY1l4eFVhK005ZWp6dG1KaVk3bHp3Ujc4VUxHMDM5bGplQ3JhWGNUNjhzZEMwR0M4bHVZckdPT1ptTE5JRkFkai90ZTlHdjJ1ajM4TU1keENsd2hQS3lJR0g2OTYrUkY4YStKREtnODFYVmhnTU9lQi9Xc2U5OFY2OHZJbCtWUndUeC9PczVZdWcxYjJmeXNPR0RyM1g3eDNYbWZvUDRmRmpvOWhmckdxcm0yRVNJdU1iWFBQU3NDNHVMQjFDanpDUTJEakg2Vjh4K0YvRWVwM0dpNit6WEN0SmIyc1V5QXJnNDM3V3grZGVjdDQzMWNPZm5MZk4xQTYvV29wNHlpcHR1TFdxL0kzcTRPdGFDVXVheTErYlAxYThCNmJaNnJkM25uUk8wRnRadkpJcEFCUEhITmVQWEY3QTB4S2w4YzdWeDFIb2ErV2ZDM3hYOFRhVEZycXhUcGk3c1doRzdnaHM5czk4VjV5UEczaUZwSVNDZ0k5ZXB4VGppb2UwbTN0cFlVc0svWTAwckpxN2I3M1o5NDJGL0hHcmNZT2VCMjVybzExQ0NPSUFxL3pMMUl3UHdyODhoNCsxMFNnQ1JVM0hqdmoxeVRVaitPOWU4N1l0NEdJOWVsZER4MUwrVm1FY0hXL21UUDBLaTFPMkJDbU1GRnowRmMvYzMxZzhraWhNSnp3Y2daUHJYd0dQSFhpVVhCQ1hBSkErWmM5TTFabThZZUlTeFkzUnlSeWhYT2FTeGxLL3dzZFhCMUhCSlNSOXV3WGxpOFNvb2NPT3VGeUJqMnI1TjhlNm9OUThUaEZKMldjUVhHTUR6RzY4ZW9GY1dualRYM0oyeXJINjRIcFZLQVNNR2xseTBrckYzWTljbXVxTmRWTkZINW5uenc4NmRtNWRMV0lMaHVBTzFlaytIWXlMT01rakROdjIrcC93QUs4eHZpNFY4RE9CWHMyaDdJSVlSSkdTUEl3NHo3ZnBYeStiVlBmcFE4N242dndkUmZMaUt2cEZmbWUxK0hZNHJpSzRTVkEwWWlrem5vaEF6bXZmdjJmOUttWWFucU1wZG1ZaUZDeHo4aTlobnRYeng0Ymt1b3RPMUdSRk1paUVnRCtJZytocjc3K0VsaXRyNEx0V3dRWDNPUjlhOHRQM2RQSS9Rc2ZVY01CVlYvaWNZL3F6d3I0bVhMWDN4TDBLejZ4NmZhelhiai9hYjVWcjRZK0pHdHRBUEZGK2pIZGIyYTJzWHZKTHgvV3ZycTZ1RnUvaUI0eXZpY2lBd1dpSDBDRGMxZm56NHhtTjFGb3Rxei93RElUMTVwcE9mK1dWdVMvUHR4WHRVMWFuNXFLKzluNVBpWnhjMHBMUlJWL1Q0MytCOFI2L3BaMWo0aytHdkRxNUtXcTJscTQ5ejg4cC9uWHBta2FqYmEzOGRkZTExeC9vV2h4M0Z3ZzR3cVdpZVhHQitOY1Q4T3Ixcmo0aWVLL0VUdDh1bldlb1hTdjJETURHbjgrSzVMdzVMTnAvd3M4WWFteC9lYWxjdzJLTjNJejVrbjVpdk9sTFc5OUhOdjVSMFJnNlUxZU9yY2FOT25mKzlWbDc3L0FBVE1YdzFkU2pUdkdIaUtkZ1pXamFHTW5xWmJwdVNQY0N1Y3VtL3M3d0Zad0x4THFseTAwdnFZb3VFSDBKNXExcWtjbHA0RzBHeUFJZS91SkxsaDZqN2lWMEdxV2lYM2p6UmRLWEFpczQ3ZUVqc1BMRzk4MTRGMjV0dlc3djhBY2Zid2krV3kwMml2KzNqRDE2MmZQaHpRWXp6RkdqekFjWWx1RHViUHVCVm1OSXRZOGRnQS93Q2lXQXp6d0JEYWpQNmtVeXp2eGQrS3RlMWh4bGJhT2VWQWVtZjlXZ3JsOUptYXo4TjZ6ZG4vQUZsMFZ0VUo5RytaeVB3cmJsZkwyZGpLVXZlZXZYOGpwdEUxV1dYVmRiOFF6OHRicXp4NS93Q2VzdnlvUHdwbWlYejZaNGMxUFUyYi9TYjFtdG9XUDNzTnpJdy9sWE5YNGF6OExhYmFoY1BlU05jdjZsUjhxRDZWb2F6YnlTMzJqYUxHQVBJalJId2YrV2twM09UOU0xTGplMm5VY01SVmhLNmw5NTFCbVRTUEJVVVNnZmF0WGZlNTdpM2o0VWY4Q05hK3FXcjJ1bjZQb0ZxditrM0JTZTZQY3lTZmRVK3lpdVhNa0dvK04xRzdOcFpEQTdEeXJjZjFJcTVvZXN0OXQxdnhCUHk4UVlRZy93RFBTWGhjZlFWelNnMG0xdWZRMGNiU2QxSkphOVRWMTJ3dHRRMWpUOUNzMnhiMlEyTkluQUxkWkpDS3lKVlh4SHJ5MnNHWTlNMDJJOG5nTEZIOTVqN3NhaHNMaHJEd3JmNml4L2YzN20yaEo2aFR5N0QrVlBuSTBUd25iVzBaUDJ2VmNTVFlQSWlCd2kvaWVhdW56YTM3NkhEaTNTY2txYXRwcSs0Q1dIVnRVbnZaMTh1d3MxR0ZBNFZGNFdNZTdWVzB1eTFQeGw0bGkvY3N5TklzY1VTOUIvZFFlZ0E1TlZmRUJlMnRiSFFZRi9lQXJMZEVkV2xjWkNuMlVWK2hYd2g4TjZmNFI4TlhIaUsraHk4YWJMV00vZWRuNEdCL2VjL3BYWkZjelI1c20vWG9sM2ZZOXdzdkM5ajRlMFNId2pwbG5iM3VzYXpIaWRwRTNSd3cvd0FVMGc3QmY0QldMRnFHby9CelVwZkR0dEpaNmcrcWVXMXJxRTUyTmF1L3ladXNaekdQNFRYMEhvc0QrQnZDbDU0ZzFhTDdYNGcxbVJBc0ErKzBzdjhBcXJaUFJWL2lxWFVOSXNmQzNndTcvdGUwaTFueEg0bGN4U1FNdTgzRTBnNGlYKzdEQ08vYXUxS0syMVg1czQ0YzAvZGE1NHVWcmZ6TmRWNUk2YXhmdy84QUQrTkNFbDhRZUxkVzZZSWFlNlk5ODlJcmRmeXhWdlZQRHVoYWFzSGlMNGphckJkM0trTmE2ZU1tenRuN1J3UTlacGY5b2cxOHlhVGM2bDhEcmd4NnRiUTZ4UHJNU1IyRjZzdTE0cFY0K3l5R1FrckFwUERDdnB4N0hTdkMwZHY0cjhaM3k2bHJjbUZ0b2tUekZqZCtWdDdHTG5KN0YrOVR6WGQ5ZFgwM1pzdWRXOTY3bHB6TDRwZVVmNVVqcTAxUDRyK01ZQTJrMjhQaGZTeU1SejNNWW12NVkvVklmdXhEMDNWNHZyR2tmQWZRNzRqeExyZHhyK3BqNzBWMVBKZXlNM29JSWZsWDZWNnRMbzNqYnhiYVBlZUo5VGJ3NW91M2YvWmRyT0k1bVRybTd1UDRjOTFXdUowanhWNFEweFpMRDRmZUNaZFZLbkQzbHVnaHQ4K3JYVXZML1VWTm4wK2R0UHhMakZxL0kzcHVvTkpMMW16dzc0aytMOURYd1ZycTZKOE03K0MzZTFaVGR0cFNXOGFKMExIY04zNDF5M2hueDNkVy9oTzBzaDhPYjI2RU50RXlTUFlRWEFhTUtOMmNja2VocjZMOGRQOEFIRys4RytJcHJxMDhPV05zTENjeVIrWkxkU21QYnlvY0FLR3FUd240YitNbi9DTGFITkcvaFc2alN6aE1LUzIwOExoR1FmS1pFNHpqclhJOTFibCs5a3k1V2syNGZFOTUzNmR6NXFqMXI0RWF4cU5zTGpSZjdCdTJ3clRMNW1seUNRanFwR0FRSzlldC9BSGpUUkxXTFVmRHZpRk5ic3BXREpaMzVDVHVQK21Od3ZCSjdicTMvRWkzb3RXajhXL0RxZU8wOHdzYnZUblhVN2FQUFVtUEc5UVI2ZEs1YSs4R2VISnRKdGJ6NForSlpMWnBabFdXMEVwZXdCNytiRy96UU1lbkZWTG1TdnN2Tjh5TGFhUzk1OHIwOTVxY2Z2V3hsdFA0QzhaZUlMcGJwYm53eDRodFFCR1FQSnYxWWNZS3I4czhaNyt0YzM0ZzA0eFg2YU40OHRvekhkRGJaYXRHQ3NGMFI5MGY5TXBoM0JydFgxWHdyNHgxVlBEM2lmU3BORjhSMkNEeUxoSlI1aU1nL3dCYmF6REc1ZSswMTRGcnZpM1h2RXVyUytEOWYxNkdXd0U3UnlhdkdtSTd4WWVRa1FJd3MvOEFlSXEwN3IwL3JRemRPNlZtMXlxKzkzRmRIRjlVY1JGNG8xZVMrUGhlNzFhUi9EcHUvczdhczhlNTluYTNNblRrOGI2dStMLzJldkNHbmVJYlMrdWplSm90ODZSSlBES0FiYWMvZFdabUIrVnV6VjZwYjZKRDRZeDRZMWRGdk5NdnJkaHBGMDJGamxpUExReVkvd0NXeTl2enJxdkJuaU9MVFpidndaNGtQMnpUcm1CbHM1cFBtODYyUEd4ai93QTlJdXgvR2hwdVA5YkdNcHloc3J4YXUxcDd5ZjJsNW84dDFmOEFaMjhGYVA0djAwYTNGZFM2YnFTckJiWGhtMm1LNkErV09jcU9RLzhBQzFkbVBnUjRMMGo0Z1c5anEyaVIzTnRxb3pwdDNKSzRLelJETFc3a0VBc1J5cFBKcjZmOExpMTFiUmRjK0gzaUNVenZiMndhd3UyLzFrOW1UKzVsVS84QVBTSTRCTllTWE56NHU4Q2FwNGMxTnltdjZIS3NmbjlHODZENW9MbGY5OGRUVVdVdDIvUDA3blR6VDVYN3oyU2JYWjdUMC9FOGc4UC9BQWg4SjJIalhWdEExVFFMT1NXNlJydlRMMWsvZVNRbmlTTU5uL1dSbjhjVmY4TWZEUHcvZTZiNG84SjNXbjJVR3I2Y1NZYnRZRUVrc1QvTkRQbkhQbzFQOFMrTGIveEw0STByWElBRTFyUXBqSXlMbmNza1B5elJuMmNDcVhpcnhoRERKNFg4YjZmSmhNTEJlYmVyVzF4MURlcFJxeWZLM3B2ZTN6UTcxTzc1dXZsS1ArWmRnMDVkYytIMFY3WjI5dGI2OW9VNVo0a2hSUjlvdERoME9CamJJbzRyYzhZNjlZeWVIUERmampUUXYyaXhLeVRvdUZMMjB2RXNSeC9kUFFWd01tcHg2RjhTQk5DeFd4MStITEovRDlvakhCLzRFSzVyd3Zhd3JyZmlMd3ZjWk5uTUh1clVidjhBbG5OOTVCNjRQNVZ6eWNicjNmUDVQZEdhU2VxdFplOVovd0FyMGFQV3ZHZmp6UzdEWGZDL2k2MGtMUUVDMHZSM2Uzbis0VDY3RFY4K09JTkErS0x6UUswbGw0aHRReFVNQXB1NGVBMzFaZXZyWGhmaER3OHVzK0R0ZThOWElDejJNa3R1ck0yY3FmbWpiMnFuZVdmOW9mQ2V3MWRGSDIzUlpWZGdlQ0h0bjJ5S0FQVVZiYlZrdjhQK1JmazNwOEQrZXFaczZaNG1rMCsrOFUrR21qZG9abmxudEkrQVBLdXZ2cmowVTE4K2pWTmZ1dkNGMXBNNWtsK3d5TWlyeVNubG5LOCtsZlJIaTlZTGZXL0IvaWFENWJhNzIyOHZvVW1HVko5T2FvU3h2WS9FaVpCRWdYVTdITzBkREluQndQY2RhdzVudTEwdjgwYXdscmUyNjV2bXRHZkxtcmFqcUY3cDFqcXdjczhFaXFjNU9GNkhOZG45Z2U0U0ppK0E2N2hnY1lOZC9vM2hpTzV0L0ZHakZNTmJ6T1k4Y1pXVVpBL0ExcGVGcmRMdndqYU84UWFhSU5ESXZVallkdVQ3MW1wSzlsMy9BREtuSktMMDJmNTZuakhpclNmdEdoV3pnNWUya0tLd1BRSGtmclhnV3VUL0FHTHh0b0dya1lTOWdqRXZ1NmZ1Mno3OUsreU5RaTJXOTdCZ2ZORjhxRHN3NTZlOWZISGphMmR2Q2x2S0I4MWpmbkpQWlpobkg1aXZjVGJndS9LdnZpZVB5Szlta2x6U1h5bnIrWit2ZDdmUGVmRDNTOVVRL3ZkT21ndU05OElkci9wWDBaOEc3dGJieFA0bHNGUDdzM0VkMUY2YkxoZDNINDE4aS9CbThpMTc0ZlhsbXpidk50aU1FNSsrbitJcjFYNFc2bzZlS2ZEOHpIbTgwaHJlVW4vbnBhUHQ1OXdLOUdiY3FiODliZXVwNXRDOGVhTCt4SnIrdnVaK2dQajVpdmgrN3cyM01aNTlNMStMOS9LMHVvVHN4NTNrWngyRmZ1TnIxZ0wvQUVXYU1xR0RvZVBxTzN2WDR5K0tkQ3U5TDFhNWhreUJ1M0QvQUJ4WHpWZFdxSy9WSDZobGxwNEdTanZHcGQralJudzJscmV6MmRySzRTTzZrampkanpnU0hibkErdGZrbjR6OE55ZUgvR210YVM1Qit5WHNzUkk2RUszR1B3cjlVaEs2U3dTak9ZblJoOVZPYStVZjJ0Tk90N1Q0dzNkN2J0R1k5U3RMUzhHeGdRR2tRYnVudUtXR2hyVTE2TFFlWjh6aFQwMlRkKzFyTDlUMy93Q0NFa1Z6NEdzb1pMWWJZN21kY0FBazg1NXI2WVRTYmNSSjVVY1M3aVRoUmpwNjErZUh3bDhiMm1tK0c1YmR3eGY3U3pjSEhEZ1Y3ZlA4VGJWcGVHUEdBTUgrZGZxV0NyWVQ2clJVcHh1bzJhUDV6ek9oanZydGYyY1pOYzdhMXR2cWZWUjBtSTdncVFFRnVTeVpPVFdERnBWdmNYRENhd2crOWpJVVlPTzROZk9YL0N6N1RsdjNnQkdNQThBK3RYN1g0cFdjQ3Nrbm1CU09nNm11OTFzRS90eCs0OFYwTXc1b3R3bnYzUG9nNkJCRzZsYlpKRlU1MmdaNDlxYTJoYWVXZHhhSUF2TzRnWUgwQnI1NGcrS1ZrWkdaSGFOY2NETlhadmlwcGNrTEY1V0p3UGw3bXBWWEEvelJIN0xINis1Tk05dUhoL1RQM21GUmk0SEdCVlJmQzJtczIzN0lGWW43dU1yOVFhOEtnK0ttaTVJQmJQVWNjL25WZy9FM1QxL2UvYUpNQWpqZHlBYTA5cGw3NngrNFRqbUtTdENldTltZTZ5K0N0R0RoVGE1QlhKMnJqSnFOdkJPaW5HeXhSWE9BUklSejdEM3J4Mkg0czZWSEcvbDNVaE9DUnp6azFORDhXckR5bDMzWHpFNUJiMXFPYkEzV3NCeldQdHBHb3ZLNTZuL3dodWpBaG50RlhiMVVqUFdueCtETkhWOXkyeVl4bmtja0d2TUlmaVpwMHJNVHFXVG5BR0NhUnZpZHB3WXF0eVdDOGJxci9oUDd3TUtmOXJKTFNwWTlObDhFNmRJRlY0SWlEOTA0NmUzMXByZUE5RFppQmJLRGpPU005T3RlYmY4QUN6YmNTSUh1K051N3BuRk5oK0tGa1MrMjdDbmFlK01mbldkOHZmV0IxcDVyZS92L0FETzhuK0hlaEFOc3NnVTZrNDZmNFZtei9EclJodFpiVk9CdUlKNUkrbmV1Ui80V3JHY0w5dE9PUVFBTUg4S3VMOFF0T0xJelhhZ2dIaysvcFZLT1h0YXVCelRubWZORjh0WHpPdHQvaDNwUVZtOGxCazhnakdDUFQwcWkzdzgwcVlrZlpnQ2VTMk04aXNXVDRrd09xaHJrc0R4VFQ4UkxlTlM2eWdMMk9mMHFmWjRCZnlIUTU1a2ttbk0wSXZodG9vdUFURzJTZm1HM0dhcVhQd3YwdFpHK1hPVHg4MmVEN2lraStKZGpMZ05jamc4anAvT3Bibng5cHJFdEZNc1l4MDYxS3A1ZTM5Z3dkWE5lV1RUcWs4UHcwMDRwdE1QVGpBL2lyS3UvaGZwYlJxUkh0R09nN1ZwUWZFUzBlTmdicGR3R0ZQUWo2VlpQeEF0OEVpZUw1UU0vL1hxMVJ5K3p1b2ZlQ3I1cWx2VjI2cEhGUi9DL1I4dmdGV1VjRnM5UlRYK0c5Z0FvUFVEbkhOZFFmSDFnU056eGpjZm1QclNmOEpiWlRPekM0UWRPaHhtbEhENWRmN1AzazFNUm5PNmMvdVBpNCtMNzljZ0JzKzVvL3dDRXJ2M3prak9NL2VycXB2QThzaEJRTjB3Y1U5Zmh6UG5CUmdmWTE4NnFlT2Y4eDlzcTJCVDE1VjZuSW54TnFCQzhqUHBta1R4RnFMRWdPQ2ZjMTZGSDhQZ3JLQ3JrK2hOYWtmdzVKYkFYdHh6VCtyWmcra2lKWXJMbHM0WDlEeU52RU9wYy92Z2MrL1NvRzF6VTJBL2VuR2E5c0h3NEN2dFpRRGoxcTRmaCtxT01LTVo1T2VCVCtwNDU3cVgzaDlleTlMZVAzSGhhNnJxSlhDM0JIOUtwWEY1ZjdmbnVXSlBOZlJ2L0FBZ2tXUmhRZWVhdi93RENBd01nNFVWWDluWXg2L3Fack04RGUxbC80Q2ZMU1hGNlNTYnB1bWNaNC84QTExVmx1TG9FRVR1eEpyNisvd0NFRHM0a0MvdTh0ME9hSDhEMnNlQ1dqQUhxS1A3TnhiVy80aWVhWUpiNmZJK1E0N3Vjc1BuY1o1em5yVjVXa2JkbHBDVCtocjZ1SGhIVGlGZktkY0RqK2Ric1BnM1RpU0FSdUl5ZUtsWlhpTDdvbDV2aExlN0Z2NUh4N0UxMnBLc1pHd09EejNybzRCZE1tQVhJNjU5cSt1SS9DMmt4c0FYVEdQbUpIUStsVFNhRnBzYTcxa2pPMGNEMUZWTExxMGQ1SXkvdFdpL3NNK1Y1Yks2bVViZk1YSHQzckFrczd3U2tlVzVHZWVEWDJZbW4yU2xSNTZFRVpQSE5STHBlbmx4a3J4M3JOWmZOL2FSci9hdFBwQm54dzJtM3UwRkltUFVrNE9CVGZzZDQyM051L0hjOWVhKzJMZlRyTExBU0t1QjM2Y1ZmT25hUTBhNzJHN2pGZE1jcmsvOEFsNGpLcG1zSXYrRzJmRUVlbjNMcnNGcy8zczV3YzFZazAyL1VwSDVEQVo3K3RmYWgwL1N1QXNtRnp5YXRMcHVqZ2t0Tms5aUZ6V3F5bVgvUHhIRTg3cHQyVkpueGZKbzE4Y2JiZVRnRG5GVEpvV29CeVBzY25UdjByN09pdGRLU1FaZmpiZzU0NXFwTWxnck5qbjZucjlLYnl0cmVvVzg1VnY0VDA4ejVGYnc1ckRzcFdCaU1jQURyVnNlSGRZYmdXdURqcjA1L0d2cnVDUFN0dTZTVmtPQmhRTW1yRG5TUVZLTVdHZTU3VTFsU3YvRUVzM200M1ZMUStQaDRXMWZrbTI0NE9NOURXbkQ0WDFiYS9td2dkZHZPZUsrdFNkR0djU2svVHZWY3lhY3dDaktubmtjL25UV1dRLzUrTXpsbTFTLzhKSHlyQjRYMVp4L3g2NEl6bHM5UjZZOWFtaThIYTAwUFJTRzVDWjVGZldzTGFRVlFuS2tkUVBXcjR1OUhYQUFHMGRUM05KNWRCSmZ2QlBOS2oxOW1qNUV0UENldVorV05GQTRZRTVKcXpINFExZ3NzWlJSejFCNjE5Vlc3Nlp1YkFiRFp3ZXZOYVVOM3BTRWlTM3p5Q0dIVVk5cXFXWFVrdmpabERPSzNXRWZ1Wjh5WG5ndlVVQ1BsTThLM3ZWTi9CV3BzQXdLQUJ3Y2NtdnJ4N3JRd0M0UU9XNlo3RDZWVnQ3blQxajNrZFQwQTR4VnJMS2JYeHMwV1oxWEozakZlcDh1cjREMU15TUVraU9SbnFlS293ZUF0Y1dSZ0dqd3JaNEo3OTYrd0UxYlNzSEZ2MEdTVDNxYTMxSFNKSTJBdGlyQThFSEkvK3RUV1hVcmJ5SmVhVkc5RkJmZWZNU2VDZFNjRGNZaWNZSnhnMWFUNGQzNTNOOW9qQjZqcjJyNlBndTdGZC95QUtUMVpzbk5Xcmkvc0N4VWtiZ3ZCQXdQMHFYZ0tON2EvZVZMTWE2aW43djNIeXdmQVdwaVZtRnpHZStlbUtSUGg3cUN6TnV1SWlDY2hsSFhQV3ZweUhVN0tLT1RkRXNyOUZZOERBcTBOUnM1QWptTlNSeHdNQVZvc0JTN3NuKzBLNmpzdGZJK1pSNER1bDNEN2NBTWpCMmpINDFCTjhOcGlHTGFncTRQcG44YSttR3Y3TW1RbTJYcjFVOUtrL3RHektTRjdZUHVHVjNkdnJUZUJvcnY5NXpyTWE3YnMxOXg4enkvRHJFUHkzcWtrZEFPZnBYdEh3aTBWOU51cm1PUnQ1SllqdGpqSEZiTXVwN3dnMlE0WGpDanQ5VFhXK0RwWVpOVHVXamlFYXJHZUJ6ejYvalhMaThMU3AwSnRYdmEzM25xWmZqSzFYRXFNcldUN2VSK2RIeGVzUnEvak9lM0VvVGE3RUU5T0s4aHNmQ1ppYUpmT1U1WTVPSzlJOGNYL0FKZmplNWtJM0FGLzUxdWFMcWtWM2RRUmtBb3BHQnhtdUtHR295cHB0Nm5WSEcxbys3SFpJNmJRdkJwWGFWdlpFQlBPT2dyNkE4QitIQlkrSzRuaHVtZVZsa0FZcUFPbld0TFJsVW9WVzJWeHR5b1kvZDk4ZDZtdTlWMUMzMUdhVzJWRWx0N0NlUk5nNXlxOWF1cFJwVXFVNUxkSjIrNHZENGl2VnhNSXZhVFZ6OHhiYlF4ZS9GVFhvYm1mSkVzN002OXp1NjE3NWIrQ2JFQU5IZHVmbTZZeFh6bjhOTDY1dWZIR3AzRXBEeVNSU00rU0JrczNQV3Z1dVBVNUkvSlFSeHhxdjNWd0QrSnJreXloUWxnWSswU2J2cXowYzlyNGlHTmlxYnN1VmFmTm1ScFhnaTMrME51dXBDMk9nSFQzcjBWZkJPbFJHMWtqMUJqS0NRMlJnWVB2WFU2Uk1KV1ZtV003K3BERDlhOVJ1ZENOdnBPbjZxMDF1NlhFc2thUWdqY25sOVNSVVN3bUhVWVdWN3p1dkxVNFlZdkVPVW4wakhYOGp6YTA4RDZUY1BsNTUyR0R5Q01IOERWWi9oWjRmM1lhNm1DWTZiZWE5ZnRKMWMvdTNHUWZ1a2dBMXRqVjdxSmRqRzNJQzR6a0hqMnIyWVllajJYM25uVmNUVWRyeS9DNTRXdnd6MEJVd2RRbVZPUVNGNmo4YXV3ZkREUXZMSlcrbUdPbnlqZ2ZTdmVrMU1Nc2FyNURBYzdTUnp4VVp2cnRWeDVrSVU4bmdkUFROYnZDWWY4QWxTK1p6ckZZaGRmL0FDVThEWDRhYVN4RFBmei9BQ2tiUnNHQ0IwRldtK0crZ21WcERlemp6UmhseC9uOUs5OWx1ektFQm1nVmhnRlE0NTkrS1pGY1F3SzBqVHhNNXlGR1B1NDZHbEhDNGEyMnZxUjlheEtlL3dDQjRDdndyME56NXYycTU1T0NXSEhIcFdoRjhLUERqYmovQUdsY3BnQWpLNVgzcjMyTy9qZU1aYUlrakFKYkZNTTdSczZpNGhWQ0FDTndZTWFuNnJoKzM0bXp4TmR4VC9ROFFId3o4SjdIUTZoY0ZzZmVWY1kvK3ZWZi9oVjNoZ3czREsxM0oweTdmS1FmdzdWN0srcEl0MHlsWU5wWGhGd0RuL0N0QmRWYlk0V1NOTWRTQ08vcm10RmhjUDIvRXloaXNSS1ZtOXI5RHhKZmhwNGRtaVhkUFB1eUN6Z2dzY2V4cUdYNFgrR3pPVEc4eHgzUHlrKytLOXZHcVJJVUlhSXZ6dU9SZzFhdGRZOHpLdUxjZ01TQ01aeWZjMDNoOFA4QXkvaU40cXZ6V1RTK1I0c3Z3djhBRFVxWXVKcnRDZTZuSlAwejJwVytGZmhPT05Dc2wycWdrS1FNazU5UlhxN1hpS0gzWEtzVzlXR1I3Q21SWFl4NW4ydU9OOTNCSnpqSDlhSGhNTDIvRWlPTHhMZHJmZ2VjUDhPUENpd0x0bXV1QmlSZ051YzlBZlNzaC9oeDRUVWJiaVc2Mk1SOG9BT2E5am1BZGxsa3VvcFNTQ3czRG5IY2pwK0ZUR1NlUjJsamx0eUFBTU00R01lZ3FmcTJHN0lxV0l4VjlGcmZ0YzhmUHc0OFBqY2lmYXlDT1NSMDlLcHllQU5HYWVGSTRaMktubnZqUGV2WW83bTRNbTlydURLOEFGd0ZPZXRXR21iN1NzZ3ZvNGlvR2RqQUJoNmMwMVF3eTZJemRiRnlzN3RhOUxIbWNIdzU4T29wRTBGeGdNZHhKN1ZWbitHL2h5VzRmYzB3aEJBQVlkdXdyMnNhbzVkbGFTR1RJSEpZQTRxckpkUXNHVnBJY09BT0c1R1BwUzloUTZwSFI3ZXZ2K2FQSFcrR2ZoQUtwQm5ZcGtGUURnRDA5cWxmNGUrSFZ0emg3a0p4am5nZStLOWJiVllsZ2FJZVdCakpJUEp4NjFqejY0Q3lvREh0T0FRTVVMRFVleUpsaWF2NGRqem1INGJhRTBaQldjanI5N0ZaOFh3NzBWWkRsSnRyT1JndHlBUFN2V2hxQ0xJKy9hQi9DTjNGUi8yODd5a3FJaWNkdTFOWWZETzlvcjd4ZTN4RWJhdEhsdHg4UHZEQ015bUs0QkNrcVMyQm4zRlppK0JQRDhWb0pHdHB5dWZtQWJuSHRudlhvN1gzbXM3RzRCSlBQelpyWlM4dGtnQ0NSV0IrYko1SklwdkNVRXJhYTlTWVkycks3NW41SG1tdlNlQk5ZMUt4MGpSdEN2aGJReEI1citXRTI1amtIQmp6L0dEK2xibWtSK0NmQ1YxZXlhbHBkNWVySlpsYlJWdGhjcVpEL0MzcG5zYStUUEhueEIxQzA4UTNGaEZkU3JHQU1SUm5DWlBKeVJYZytzL0VEeDJzQ3cybW95Zk9TRWpqa0pjSHRtdmdxcncxT05URDgxU1RqSzNQZlhSbjZUaDhMaXEwYU9LWHNsendpK1MybXFQMFo4SmVEclhVYkxWOVFmVDVkTFNXMmxrK3lodHdpUnY0RG50bXZOazhBV3JFTVRMamNNakZmR2QzNDkrS2Ryb0tXNitJTHRHdUl3dHg4d1AvQUFIR0tkWWY4TFkxUFNnTGJVcnk1bDZCZHh5UjdBZGE2bGpzSkdQd1NleSs0d2VUWTZUVjYwRnZleWI2bjNIY2VBTkViWWYzN1lmNWowSE5XWS9oNTRlbGtMU2VjQW9JRzErZ05mbjAwUHhjMGdMSUk5WFdkV3krZHgvOGRQV3ZwandIOFR2R291NExUV3RKSkV1RU16UmxYd2VoWUN1NmhpOEhPU1VvT04zOGpseFdVNWxDTjZVNHpWcnRXczlPeDY3ZS9EZlFBSS9zN3k4bjVza244NnUvOEszMGRlUHRNbk9PQ09udG12WDdLK1NNdUZLQXMzVGVDUDFycExzYXRGWlcxNlVoTnRkTzZSc0dHNGxPQ0NPb3I2RlliRGMxcnJYelBpL3JPTDVXMHBYU3UvZDJQbHVYNGFhU203eTVKRnl3Sko2bXRFL0RYUm1YaTduM0U4RUd2cVRUSkxkN3JaSTBDZnVtWXN6QVoyajdvejNySGkxQ1V2SnVNUTdJZ1VkK3BKOWFmMWZEcHV5QlluRXVOM0krT2ZGdmhyU3RNK3hMQTd0TFBKZzU3S3ZKTmMweENyMDVyci9FMm9TYWxyOHpIQmp0UjVTWTljNWF1U3VlVkhPRC9LdHFkT01lYTNjem5PY2xGeXZjNTJTTU5JaDdsZ1B3SnIxUjU0RXR6Z3NzZzI0SFVHdUJoaC9md3QvdGJnZnBYUnZHQ0MyY0FjNHI0WE4zL3RTWGFLL0UvY2VGWUtPV2MzODgzK0doOUhlRXBpMmozV1dHQmdrSDE3Q3YwejhOQVJlRnJWdG9IN2dOeDA2WnI4MlBEOWxmMnNPbWkzQW5lZFN6eHJoanM5eDdWK2trOHd0ZkJrcmdBZVhac1IyNkxXTk5PMFYxMFBYemFTK3F4UzZ6ZjRINTJhWmV0L3dqM2lYVVdibTR2NzJUSjlGK1VWOERlTXJ2eU5ic3dCOHVtK0hMeTZJSFo1UnRCL1d2dHBqNVh3cFFrZk5OR3hQdVpaQ2EvT1g0bVhMd1gzanNoc3JEcFZqYUE5L25iSkZlL04ycHQrZjVJL01hcXZXcWJXNTNHLzhBaWFoK1RQblB3bzRzdmhYNDN2Q1NIdTViU3pYM0JZdTFXUEZhL1kvaFA0SXNWeHZ2SjdxOGNBOG5MYkZ6Vks5ait5ZkJUUytNRysxcWR2cXNLQmY1MTBQam0yaWJYUEFPbGhOb2gweXlWMTZuTWpiaitkZVJVZHFTOHFhLzhtZHk2TjNpMjI3OCtLbkpXNktuRGtzL21WTld0UE0rSVBoelREdDJXTnZiS3dIUUZWOHhxNVR3NWV0SnIvaVhWeVQrNXRybVJUNk5LZHEvenJYVzhWL0gvaVc5SkxDQ0c3S24wd3V4YTVUUUNrUGdieEpNVDgwMHR2Q1Bwa3NhOEdONHBla1Y5KzU5blRiZksxM2IrNHliUkd0L0JHb1Q5R3U3dU9MUHFzWTNFZm5UOVpzNVlORDhPMmE4dmNLODdMM3pLMjFmMEZYOVlQbGVDL0R0cXEvTks4MHg5OXpiUlhaWGNRbStJV2pXd1RDMjBkdXBCNXg1YTdqV3Z0RytuZjhBQW4yU1g0WE9ldkxJM1hqcXpzU014MmF4eGtlaXdydWFzWFNidjdSck9zYXErVDVNTTBxK3pQOEFLbjg2NlRTYmxYMWZ4TnFMYzdZWnlEL3RTSGFLNXF6RWR0NEoxS1RnTmMzVWNROWRxRGNhYWx0OGpKMGRYZDZXTW5UejltOE42cGRIL1dYRWlXNk42RDd6L25WblVSSmJlSGRJc1YrOWNzMXk2LzczeXArbGFHcTJnVFEvRHRrbjM1OTB6ZTVsT0JuOEs2cTdoaG44ZFdrYmN4V1lqUTQ1QUVLNS9uVGNrUzZiVDlOU2hxdHNMalhkRjBTTnYzVnFrYVBqKzgzelNFMVVXOVRVZkZ0emV1Qjlsc0ZhUlJqalpEd2cvRTFTMHU5TW1vZUlkVVBWWVpkaC93QnFVN1IrbFkxakZPdmhxZElVWjVyNjRXTUlnTE1WajVJd09lU2FwTzdCdVRUMFo2WjhMZEN1ZkUzalB6WmxMK1pJV2MvN3h5VCtWZnNSb1BoNWRkOGVhYnBpUkQremZEMGFYTnlNZks5eS9FU0gvZEhOZkYzN09PaUxZMjk5ZDNVUmphQlpHbERqQlhZTnhCejBOZmYvQUlUdkx6dzM4R2RZOFNGYzZock1rczhha2NsN2h2TGdYM3dPbGF4ZlJmMDJRMDIzRmI2UlduV1IzR2hvbmlieDlxT3YzVHFOSThPZWJhMlR0OXg3bFJtZWYvZ0E0QnF0NFRuc2I1dGIrSXV0a3gyc1VVc2VsUm4vQUpaV2Nad1hBUDhBSE1lbFVQRXVsWG1pL0R2d2o0TnRjcGQ2eE1scmNzRDh4VnYzdHpJVDZua1pyc3ZFVUZwcjNpN3c1NE50NGZMMDNUSW83L1VJaHd2bHcvTGJ3bi9lWVpOYnVkMHZQOGwvbWFKUVVkTkkyYXYyaEhmNXRubTh1bjJWcjRmMVR4ajR3MDAzYzJyUWVUYmFlNjcvQUxQQkx4RmJJRC95MGs0Skk1elhrdWwzVno4TTczU05XOFlhUk5MYnZhZVRwczRtTjArbnlIa1dwVnVqRUVBUFgxV2s2ZUx2aVBkM01qQTZQNFdiYkVwLzFjdC90eTduc1JFdkE5RFhtMXIvQUdINDBpMVh4ZjRyZ0EwRzBpbmgweTBsNVR5bEpWN2xoM2tjOEo2VmxaYi9BTmE3STBiOTJYTW5acGN5WFMvd3hqNTJObTQwZE5Zc0c4Uy9FUzdqdGRMaXhKYTZLWk1RUktlVk53Vi8xMHJmM2VsVzRkWStKUGllMmpqOE42VmJlSHRJVVlodmI2TE16b09oaHRWd0ZYSFF0WHlmb2VvWFhoYSswdlZ2R1ZuZlRlSFZWejRmRTcvYUJZNU9VV2VQdkt3KzRUMHIwVHgvNDZXU3pqdi9BQmxyVnhvdW1UcHVzL0R0Zy84QXAxekdlUTkwNjhxRC9kSFN0R3IraTI2cGVpSWF0SlJmTExmbDA5MWVVWXJkOTdsTDRoNlA0VnNQRG12UmF4OFdOUnZMOWJXVFpiZmJraFV5a1pDK1RGa0VIME5XZkJsaDhGcm5ROUtqcy9pUHFWamVtMWkzaE5aZVBiSnQrWUJKUnQ2OXErTGRXK1BuZzk5RDFMVFBEdnczMDYydDdpTjRUUFBpU2ZEOGJpeHlkM3ZYb3VnL3RHVy85bTJGaHIvdzJzTHUwU0ZZaThVYU01VkJ0emhoMXJKeWluclAvd0FtU09pTk91NGU3R2U5OUhGYWVpMFAwV2owL3dDTDNoK0NPNTByWExieFhZZ1pGdGVCYmU3WmYrbVZ4RjhqbjJOZWZUYVQ0SzhmWFYzYzZTMDNocnhaYkwvcE1MeCtUTUQ2WE1QM1o0ai9BSGhYRmVDajRTMTJJMy93MDhSeWFQZW9OMDJrVGt5V3NucWtrRGtsUi90SjByamRZMVcrK01Pc3BvZHJaMitoNjVvcXltOTFRVDcyang4bmxXekpocEluUFhQUVUzNS9ON2Y4T2M2YVhNN3BTWHhTVWVWci9GRmFOZWg4OCtLcnJXL0hHcVNlR1JEYTJsN1pUdEplM3FTQ1ZXYUw1ZDFvL3dCNHI2cjJyMjd3WnArbStJdkR0eDhQOWVzdnM5OVl3bWF6bWpHMHYzUzRpOS83d05leWFaNFMwL3hSNE5iUkl0UGgwYnhSNFdjQ05ZeDl5WURJa1U5WGd1TythOER2b3RXMUhUTFB4SnBxbURYOUp1WDg2eWlVdTRlTGlhS1J1eU1COG9yQ1N0Ym9yNmVUSmsyNU5XNWVXVmwzVDNUOUdqdHZEV21YdmlydzVyZmc3eEEwY0dvYWF5K1EyNEIxbFVmdXA0L1p2NHNWNFBzMWJYTkl1YkthQmJmVjlIbUlqSGRMaTM0WWV5eWp0WDFaNGhpMEtWZkRIeEpzRDkwd3g2bGJrZ2o3UE9kcGJBNkdOalhvL2lmUXRQMGo0cGFUcUlpSDJQeEpiZlpacEJnQVhVUzdvcE0rcnJ4NzFzbkpwUDhBcE5ibWFWbGZsN3RMdEtQeEw3ajR1dS9HRjB1bGFENG10ZDR2TkxZUHRIVnJkdmxtaFA4QXU5YTlWOFNlSjRMTHhqNGQ4VVcwaE5ycWNTV2Q2UWVxeWN4TzMwUEZlVitLdEdIaDd4aDRnMHRvaUlKMSszVzY5c1NmTEtvL0htdk05QXVMclZQQW1yYVBndkpadXlRZzhzRlUrWWhCN0VWaEs4YlgyL1JsUlNiVm43dTMvYnN2OGozOVpZTk4rSmQ1QTVFZHByY0ptVHN2bnhqYXdIdXdybGRCMGkyVzM4VitGTG9saEFaSkxiMEVOeDh3SUhvRFdkNGoxSmRSK0gzaDNYaXdGeFl6d3l5Yzg0Qjh0eDlUM3E3cjBsdGErT05DMUJKTVJYdHU5c3pEdWNia3ppc0p5YXYzdCtLSEhtVFYzZDJzL1dIL0FBRHp1LzFHNHZmaDdaeWk0WnJ6UjVsNUE1RFFIQjU5Q3RhbXQ2NnNOOTRXOFJXcEtyNWhnbTduWk1PUitCck9naldQeEY0bDAzaFlMcFZuMkhrWllZT0s4MmdTNXZQQStvV1Ivd0JaWXZKc09jSE1SeUNmd3FFN3RQenY4cEc3cyttbitaOUM2TnEwZGo4VUlyaFpBSTlWdFdSejBCa2k2WTk2N2J3dkhicDRnOGVhSStEYlRqN1VrWjRIK2tMdGJINDE4djZ0ZjNIOWplR05VanlYaG5oWWtEQXcvRGJ2OGE5SjFZeXgvRUhRN2xHZFRlMnJ3c3c5VStZZldwczd1NzFhYStjUnlTYXQxNWYvQUVrMW9iaTUxTDRHMzlrVkRYT21Tc2lrWXlodFgzTG4zeFhZZUtOU2p2Tk04RitJb2lGV0dhMzgxd0FDcXpMc2JQdDYxeVhoUlV0L0UvakhTN2hBVW54TUJqQS9lcGl1SHQ3Njd1ZmhWUEE3bkZxSGpSUi8wd2ZQUDRVU2w3elNYMmsvL0FpNHhmTmZwemZoSkh0R3B0QnBueE10WmtmQzM5bDg3QnZsWmtPUm44SzUzUXBsaDFieFJZWndxM2Zub1FlcXlqT01EdG11UzhSM0x5cjRSdnBwQ3czb3JIMmtYaXNxOG5lMjhaWEx4c284KzBWaUIweWh4eldNZDFwMC9KbFN2S0Z2N3Y1TTdEVWJlSTZzaUtjSEFCei9BQkJoMCt0ZkkydndtUzI4VFdMci93QXVZbWpIVTdvWDVQNVY5TTYxZXN0eHBzeFZtTHFyTVQwR0RpdkI5WWhsWHh0TEQvejlSM1VPUFhmR1NCWHZ3U2JTL3ZXK1VrZUZPVFZPNzNVT2Ivd0JuMHIreWpyTFBZL1oyZjhBaFlBZXUwNXI2TjBSMTAveFRwa1pPRGFlSWJtRWovWXVWM0Fmblh3ZCt5dGVzbXZQYkZzWWtZWStveFgzSjRxQ1duaTNVM3ljcHFXbDNRK2pmSWE3S0tYc1V2STRacHh4TmVQZXovOEFBdFAxUDJGMDZSWkxOQWVUdEZmbnA4ZC9ETWtONS9hRWNlRWI3N0RvRDcxOTgrSFp2TTA5R0o3VjVuOFR2RDh1cmVINTBoQUw3VHhqTzRWNUZlTjRYdGRyVSt6eVhFcUdJVVc3UnFMbGR6OGtJUWJsbzh1UGxqS3FHNEhIT0I2bXZsejlwbXlzSmROOERhaEJhK1NXdExpMXVIUFBteVF2dURmVEJyNld1cldTMHU1SVpBd01iYlRrZE8xY0w4YmRGZzFMNE8rSHJnRDU3VFhibUlzT0RpU01NTS9sWEhoN2UwZHVzV2ZTNWltcUhLMXJ6TlBYeWY4QWtmRnZ3ejBYVU5Rc3RSYTFqRW14bDNET0NNanRYclk4SStJQURpM084RGtldFpYd1V2N2ZUdkVVMmxIY1JmS0dXUnVBclJET0Q5YS9RKzF0TEl5anpENVpPZXB4a2RqWDN1QXdVYTJIakxudHEwMGZnV2FZNnJSeDlXSEpGcXlhYjZwbytBbDhIK0lsSUgyYzRJem1xeDhGK0pZMmtKdEhHMERjU2M1ejZWK2hYazJLQ1ZTNFk0K1VBNDVxODFuRXlLd2RXT1BtNUdmd0ZldC9aSy81K00rZmpuTWxlOUphZVorY1AvQ0dhdWhaVEU2N3djOFlCeFZLRHdYcmpKTVBzanVOM0JIdFg2VnRwVmpLUUhtSEl6dFhyUTJsNldJU3kzQkhiYm5yOWFsWlZiN2JZUE9KdFg5bXJlcCtiVXZoRFYxUkYreE1raWpxQm5KL0NxOG5oYlZFQ3E5bElDMzhSSFUxK2tWeFphU0VXUVhQN3dBRFlxOVFmYzFUdU5OdFZRc3R3aktlbWUzMTlLMC9zdjhBdi9nYzZ6dHhtMTdOZDl6ODVmOEFoSE5XU0lsYk50M3BqdFVVWGh2WEpaTUN4Ykk5Qlg2RHlhYkZISGxwRVp6MEk1QTlxMDlQdHJabUN5T0Z4OTA0NjUvcFV2S0dyUDJuNEZMUElTMGRMWDFQejJUdzFyNmhtRms2Z25rZ1pJcW1uaGJWMlo4V2toR2NqakdUN2l2MHFHbVdnamNzNjVKejFBR1A2MWx4NlpGRzh1SlY2NVVnVW5sVC93Q2ZuNEE4NmxHMzduOFQ4OG0wRFVvVmt6YnpJK0FQdThFMWxmMkJxeGZjbGhJMjNHY3JpdjBqR25XNVlmNlNqc2NISlhQSit2ZWxHbldvbHd6UkZzOGpIYXAvc2wvOC9Qd0tlZHRmOHV2eFB6S09tNmtzZzNXc2k0NjVHSzFmN0IxWmxWMnRKQkczSUlCNXI5R2JuUXJDUnczbXdzdWZ1a2NnMDI4MGFNS3F4elJ0c3dRTzMwclAreUo5S2lmeU9sWjJySzlMMTFQencvc20rampDdEM1eWM4S2VQWTFsU2FOZUpLdVlaQU9ja2cxK2tYMkRUNUlmbktLZHd5Y1pGQjByVFhrQ3VzYjQ5ZW5OVzhvbmI0MTl3M25FRTErN2V2bWZuTGE2VEt4TzVKblRQWUdrT216aHlHaWxKT2V2R0JYNkVOcHVtb1NvQ2dNVHdCakdLbWgwYlQvT2pWUkVkK2ZtSTVINTFIOWt6LzUrTDdpLzdZcEovd0FOL2VmbjZ1aFg2amFvYzVPZU1rQVZUTm5lZVkyNVhZNXdUdFBRVitqaDBTMmprMmdScWVDRG5xYWlHZ1c4alNzeVJnaGdNa1l6L2pSL1pWYnJOR1g5dFVyL0FNTm41N3pXMDZSNTJNUTNBK1hvYXpWaG5qenZWMUpQVEJQODYvUmxmRENoU3E3Q0NUeHQ1K2xadDNvc0ltQWxSY2hRQmxSMDlxUDdMcXY3U0hVenpEcU4zRm55bW54QVJlcEJIcFR6OFFWQlZoTDlhOGt1ZkRsMkpXd293RDJxaC93ajJwYnNBWkhwNlY1eXh1TDZYKzQraGVCd1R1Mm9udC8vQUFuOFRFWWtPZmFsUHhCZ1ZjcTdFL1N2SHg0YzFRTG5DL1RGVER3MXFaQXlBZS9CNlZmMTNIK2YzSEw5VHkvYTBmdlBVeDQrQmZobTRHYzg5YXF2OFFaakdPR0I5UUs0R0x3cnFKeTJPdkdPYXNEd2ZmdU9Qd3hVL1djZC9lR3NObDlyTlJPMWo4ZnpoYzcyUEhUSE5NaytJZDI0NHlCWE1Ed1Zkcmpoc0VkUjFweStEN3RVRzR0blBwMjk2VHhHWS8zaGV3eXROV1VibWtmSDg1d0J1eDA2ZDZpSGp5OExuQ3VRT3hxb25nKzhVc3l1U08yQm1yaWVETHg4Wms2ais3VWMrUGR0WkZ0WmI5cmtGVHh2ZGtETVI1UFhkVjZMeGZxSm13cXVHN25OVlY4RFhLdXBENUk2Y2V0V0Q0TXV5R084dHp6eFdsc2RiWG5NZWJMdVpKS25Zbi80VEs2REtwUWs4NXo2MXNQNHBuS3B1ajZjVkRGNEhsZmJ1YzhIZ1lyb1Q0S3dtU3h6L2hXYit1dmZtTFR3RWRmY1hZNTZieFRPb1ZoRm5IWEZVMjhZYWlFSTRHQitsZDVINE1qQlFBc2VNamlxTXZnaTM0Mk0yU2NFVlVZWTNXMXlYUEx0RytVNE9ieFZxaDVWZVBZNXFmOEE0Uy9WVEdGM0RqZ2MxM0I4RVFJRUc1ejc0NUZXVjhDUW43b2NuMTlhdU5MSFArWXdkZkFQUzhYOGp6aytLdFNKWEl3VHdPZU9LdkR4YnF4UWpQc2VhOUdYd0xEdXc3RWNaT2F0eCtBNFRBeGZlUUQySFVlOVdxT1lONmMzM2c2K1Z4U3VvMzlEeXMrTE5WMjRQMEhPU0tpZnhYcWU1TjI0OGNjMTZ2RjRFdDk1MnJKdEl3RjlDUGVyNytCYlVZTHhPd0hHTTgvcFE2T1lmM3Z2SWxpTXRiVFNpMTZIa3Y4QXdsR3BCUzI0ZTR6U3krS05TWGdTSWM4ZlFWN0hGNEl0ZHF0dGJBNHgvalZmL2hBN1I1RGhTUjJGUjlYeDcvbSs4MGxqTXVTc2xGZkk4bGw4V2F4dHlBcHdNRGpybjFxVzM4VjZwakpJWDZETmV5bndMYWpnd3QvMzFWcUh3SGFSdGsyN3NPM1BINlZYMWJIYWF0Zk01L3J1WFhzK1ZuaDdlSzlVQUg3M2R6MTcxRTNpbld3VkprSFBjZEs5Mi80UUt6bG1iOXdWNHh4LzlldG4vaEFiSHkwVDdNUVZHZXVDTWV0SjRiRzkzNjNOZnJ1WFdTdEYrVnRqd0pQRSt0N1F3bHdRZlRBUDFxOS93aytzeUlHTXd5TUFBTDEvT3ZkSXZBOW1WS1BDZTVBM1ZzZjhJTnBTbGQxbzNBemdtcmVIeHJYeFA3eWZyT1hOM1VVcmYzVDVvazhSNndKRUFrKzkwNHh6NkdueStJZFhUQytZeTUvS3ZwY2VCTktZdVZ0VHdOM1hPS2tUd0ZweFZpYmZkamtEZDBvK3JZMjN4UDd5bmk4Qzk0L2VqNXVPcDY4SVJJYmtGRG5rSG5qc2FvUWE1cXJPeWZhamtuR000SDFyNmtIaERTekVVZXk1eDFQSC93Q3VueCtBdFBqWVNKYWc3UUQxR2FGZ3NaL04vd0NUSE9zd3dLZGxUYjgxRkh6dEpxMnNScU1YQmNZK2JBNkVWU2cxM1dFbEpFek1PdlRQSGV2cDgrRmRLTGo5d29JNEhQQUZiS2VETk5HQ0xXTm1PUVNwemtVTEJZdGE4MzRoTEc0TjZjdXZtajVIT3U2dk1wTFhoQWJPMEFkRC9qN1ZXL3R6VjRveUZ2SDVJeG52bnZYMXBINE8wcEpKRk5pQ2hYcGpvYVdUd2ZwNktnR25yaGpqQi84QXIxb3NKaTM5djhXU3NiaFlyV0YxNkkrV24xVFZsZzNwZFBrdGpBOXZYMk5WMjF2VnlxYnJ4aHRVNTQ1UHNjVjlULzhBQ0pXVWJ4cWJKVWFRbGZ2ZGZTcDRmQjJtaVltU3lUcVJsdTU5c1ZmMVBGVytQOFdaL1hzRTVwK3lmL2dLUGt0OVoxQVd4UDI5L04zRGp0Zys5ZlhQd2VtdUpkSjFHU1dRczIxdm5OTGZlR05CaWlJT253NU9PM0lGZGQ0SXQ0YlN3MXRZazJJb1k3ZmJGY2xYRFY2ZE9UbE82ZHRMK1o2bUh4ZUduV2lveHMwbTcyN0kvSWI0cFRUTjRrbUtTRUV1NXpucnpYT2VITlN1SVpFL2VFTm52M3IzdjdCWlgzaWpVamN3cktxazREZHM1cnROTDhMNkl6ci9BS0VyQVA4QUtSeDByR1dEcnQ4MFpJMHBZM0R4cFJpMXFoTGJ4UHFBaVNTM20yL0tBd1pzbk5kVG9YaW0wczdqVjd5OXVoajdIaEE1eHVMSGxSWG8xcG9ObkVTWk5MamVNb1NHd09QcGp2WHhmOFpiaTBpMVNDRzNqOHRVdGdTdnUxY0dMbzFvVUh6UzMwKzg5bktwNGVyam9xTWRrNVh0MlBuN1Rib3orSU5TdUlSNVljc1FGNEF5ZWxldmFmcWVveFRSN1puUGZrNSt2V3Izd1UwaTB1NDlXdUxpMUUzN3hFVXQyeHpYMkhGbytoeU9vR2xSUmxUamFmWDFyZkM0R3JMRFJsR1NTYWRscVlabm1OQ0dNbEZ3Y21yWGVucWZQK24zK3FLd2VHNmtYSE9QVDhhOVl0OVMxV2FDTUc5Wnd3TEZRUHVIM3IyNjEwVFNVaHgvWmtJVmpra2pwN1Yya0dtNld6eHJGWnhRa2NTWTllMmFoWVNzbEgzamhlTW9UY3ZkNkh6Vzl4ckZ1bTRUdXlPcDV6a0QzckNmVTc1YmZ6RWxtMjhESmJvZS9UdFgyM0JvT255STdmWlkzQzhNQjBPSzNFMGpSMXRveC9ZMFd6R2V3L01WNmNNSFZlMGpobGlxQ1dzVDRFdHJ5OEVlZnRFcmZOeVZrT1I3aWdhanFjcEorMnpZM1pDbHlDTWRqWDMwK2phVjVRMjZWYnFjRThBRWtlaHJSdGRQMER5R0lzSUR1VUEvS0RnbXVqNmpXYStKR0VjZFM1dFV6ODhJZFMxSm5MaTVZQU1NSGNjNDdnQ3R0NzIvbHp1dkpWWW51NSthdnUxOUgwV1djeHBwZHVHd0R1Q2dmenJmU3owWUs1azBxeU8wRU1DQm5BNy9BUDFxaDRHdXVxKzgxK3VVSGZwOGo4NlZ2cnc3MWUrbVZzblB6a3JpcXNNbXVGMFUzRWpnSHFyOEVmWHRYNkt2cE9qeW9aUDdNdDJUWjhxaE9vSFNvb2JMUmpHa2NtZ3hSYlQ4K0FOcjd1ZzlqUytvMTlkZnhIOWRvYlcvQStDNWJ1L0VoWnIxbEFBd0MrV0h0bXBvTld1b0E3TE5LOFp3UXhiSkJyN3h1ZkQybFRzb1N3dHlxNHdBbzZWV2JTZExpM0JMRzFISXlBdkJINDFLd1ZlL3hJVHh0Ri9ZMlBnZE5TdkVpRENXVXRuZHRMRUVmNDFNMTdxRTVhUTN1d25CQTh3OHI2WTlhKzgxMFhTQkVvajA2SGVyRXJsUWNBVk5Ob0dqRllzYVhEdW01SndBQWZwV2l3ZFpPM01qTDYzU2IrQzJ4OEN3WHpyOHhsbmM5QmduSDVVcVhidk8wVDNrc2U0WUpaczQ5eDcxOTR6YVpZMnNoaEduMnhkZ0Nqb0IwSDlha1RSYlVxU2RPZytaVHUzUmhnUG9hSGdLKy9NaXZyOURtdHl2VGZ5UHorUzRsZnpFanVabVVFZ2t1VjNZN2dWZnRycTRhem5NbW9TaDRWTzJMT0dMZlh1Sys0STlGc0hKQ2FaYk1BTTd0dmIvQUFwczJsNlpFK0RwZHNuUE9GREEvU2w5UXJiY3lLZU93NzFzN2VoK2ZzOTlxVFc4TEpOSnZKRzVkeDZmNDB3ejZnelJoN3lWUTJlR3lEeDJGZm9vbGhZckdkMm0ya2dMREFLNC9ETlhsMGF6ekVXMHEyWGtnSEFKL1dsOVRyN2M1VWNYUWJ1a2ZueERjeHhkTlJsY2dqZ3VWSkh0bnVQU3JCdTd1Q1ZYaXVHancyNHN6RmorRmZvRmVhTnBZVWthYmFrL3hmSU1ERll6NmJvOFlKZlRiVmdWNCtYay9TbjlUeEhkZmVWOWJvN3RNK0ZyenhCcWZtc1d1bllFOW1JR1RWVnJ1OW1VdTExTGtZd0FjVjk2VytuYUlnakRhREM0ZkJ4akxBSGdacVc5MG5RakNZeHBGc2hCeGtjY0gvQ2w5VHhDZXN2eEY5Y3cwdGJiZVI4TUc0dmhIajdVKzA0Sy9NYy9yM3FjM1Z5UGxMeWorSGVKTWcvV3Z0aytHdEpWWTBPbnhnRkFRTVpxUWFQcE51cXNkTHQyVURrTVAxRlNzSFcvbVIwU3hsQ09sdndQZ1grMExsR2xYN1JJR0JCK1Z6ajYxbzJzOThWaWRMMlhjVHh5ZHZGZlliYVJvTWp1dzA2RmN2MElxL05wZW5mWlRIQlpSSVpPUmdaNTdVcW1FcnBOcDMwMk0xamNOYTNMYnU3SDVKK0xJdkVNdXVYVHhsdDZ5N1hPM2tISFRtc3pUdEp1NFFzc2hZemtnbGkyQnQ5Yyt0Vy9pYnJXcnY0dTFTOU1ZdGkwL3dBNkljSmxQbDRINFY0ZlA0czFhVlNna0dENkN2enlUbktjbmJXN3Vmck5Ia2pRcHJYU0tzZlJqWEc5NDdVU3BIQ0dZQ2FWdWZVZzlTZnJYMm40Tm5Gcjlpa1dRcHRpWGEyM0FQdlg1SGFiZFNTYXphelhkdzJ3U29YeWMvS0R6eFg2OTZQRG9tcFdkdmN3WHp5SnRCMm9jaVBIc0t6cVBsVWZ4TzJqNzkvTHVlb2FuZXhTeUdTUzVhVXNuSkpKUDBxbGIzZGhjV21ObTUvdW8zOGVQZXNLVzNKV01EQlhxRDZuMHJrTC9WUDdMbmptODVWTVorY25nQVVLbytodnlSaXZRWHhnMzlrNlE4OG94dEdWWUhuUHY2VjgycjhUWDFCVVMyWm1lSlNaTnhQSlBUR0s1YjRwZkVXNThSVHRwVmpkckpFcER1NEczZVIvQVBYM3JpUEFHbXRGSElidTJtVVN6S29rV01zdUI3anBYV3BPMTd0SEM0cHQzaW1mVytrM1dzM0VCbW51c1pRYlVPUWZ6cmV1cmk2T3dXOGpoOFpKOHc5QjZlOWRmb3hzWXRDdkEyUGtUNUNRQ2NEcGl1Q3RERUxqelhYQWJyM0J6MCtsZEVhdFQrWjM5VGtkQ2ttMnFjZlN4b3dtT0t4YVJ5TTRabUxaNU5aTnJKOXF0M21LNFVEdjN6NlZOUER1a2FNc1JESUNDbWNqOGpYTjNsLzlrait6S3pMRG5wd2Y1OXE3b1k3RlFjZjNqYVhRODJybDJDcWN6bFJqZDdNN2VDRU5ORU53TzROam11cGtnU1RZc0tsUVI4NDZqajM5NjRsWmpGUFpnTGtGZWZZRWRhOUFUVWxXNllJZ1R5aXVDUDRzZDZ3elJ2NjQ3OWwrUjlad3hDRHlta2wvTkw4MmU4NkhhWGNUNlFSdWk1QU9NZzRKNS9BMTk3K05wbHQvaDdxN0E0MjJNZ0gvQUh6WDQ2L0Y3NDBhNzRlbTB5TFQxalc5YU1UdkxLZ1lLcDZCVjZjMTdKNFcvYVkwbnhqOE1OVzAvV3A0TFRWL0plSlZWU3FYQUk0WmZRK29xOFBWaE9jVmZWV0ZuRWF2c2FjdVZlN0wza3RYcS95TmpYRVpmaHZvVWU3YVpSYUQ4em12eXcrS3QxdWorSURIcStyV2NQSHBHdWEvVEh4QjRyOEx6K0Z2RDl2RnExdkk4VTFvSkZWdnViQmc1QjdBMStZL3hJMGJXN2lEeE9JYk9XVVhldStiRnNYZDVrWVhBZGNkUlgwTmROMG0xMmwrUitacVQ5cXJwSk9vdC84QUduK2g1UjRzS3I4T2ZoOWFqL2xwOXJsWWU3U1lydlBGOFNOOGE3R0FTaDF0b2JWZDJPbmxRN3Ywcm52R09nNnpEbzNnUkRZVC93Q2oybjc1ZHArUmpKbkI5T0tmcWpYdHo4VXJ2VWx0M1dFNzhTQlRzNGl4MXI1M0dUU1VvODMySS9rZCtXMG5VNUtpanA3VEVYYS92VlArQWVXNlhLN1cvaSs2M2ZlaEtrK3ZtU1ZGNXBoK0hpSUNCNStwTVdIcnNUaXJlbDZWcXNlZ2E4cjJjeXRPSVBMVXJndjgyZUt6NzJ4dlI0WjAyMSt6dUpFbm5kMUk1R2NBWnJ6b3BOeTYrOHZ5UHAwcEpMUi9DL3hacWEyZDkxNFd0YzhSMnNBSUgrMjJUV2hiWDdmOEoxcWwxbi9WSmNFWjdiVjJpc0svaW1mWGJHVlVKaWhqZ0JQcHRHVFhwR2srQkpHbUY3ZTYvcE5uRHFFcGl5MXlKSllsbFA4QXJIUmVRbzcxckdtMmxvS1hOcGROWGVoNWpwTnkwZmhYV216aHA1WW96N2pxYWcxRm92OEFoRnRKaEIrZHBwWkdYOUJYM1I0ZStHM3dTMDd4RkJwZXErT1lkUjA5N1UzRWswVG1DUDdRcHdJOGdFNEk1cjZLOEJhNThBdEIxanhhcVQ2YWx2Rk1xNmFaRU16R01SOGxHY0U0TFZxcU03M3Q1aWRTMEhhRTVQbFR0eXRYdTdXMVB6U1R3bjRwMU8vczcrMjBpN2xzTEtLRHpMa1JrUktGNm5jY0RyWDB2YS9zOWVNN0svMDI4MUs2dGJaZFl1eGJSS2g4NlZmUEc3Y1FPT0JYMGRIOFVmQVMvQWU0MHY4QXR1RTMwaU1CYmhXREF0UHVJNlk2VjNuaS93Q01mdzd1ZFIrSDVnMTZHUkxLL1dXNTJ4eVlSUkZ0Qkl4eno2VnVzT2s3MzAxTTVUckp0S2k3YzAxZHB2U0swZnpQTXZEdjdOL2dyU3ZIMEdnM01seHFjTW1tdmVYSW1QbGplajdVQUNkcTlXOEsrSFBET2thbDQ5bHNkTnRiYTJzTGxZSVZqVGhQS2ozT1ZKeWVUMXFLSDR4L0Q0L0YyLzFKdFlBdGhvOE1DU0NHUWd1SDNNTWJjaml2SnJUNHNlQ1kvQ25qaFJmUDlwdjlSdlpvVThpVERLNjdVT2NZR2ZldFhDS1czUkhJMWlIRjNVOVlSV3pTMWQzb2NuNFh1YmlQNGNhOWQ3ajUyb3lHTlNlNXVaZHY4cS9RdnhucHlJM3cwOE94L0xHOS9GS3k5akhZeDdzWSt0Zmxab2ZqcndsRjRROE8yRWswMjlOUnRIdUZFTG41STJ5MkNCejlCWDN6cXZ4cytIRTN4UzhMWGgxRzZhMnNkTnZBVDlpbUJXV1VnRDVTdWVuY1Z6S0wxZG5lOHY4QWdIWENOVG1jbEZ1enFOYWVWa2U3SWt1cmZIUGN4THhhTG93S2dqaFpieHVTUGZhSzR6d3RyY05wcFB4SDhaU3lndkxlM0tRcWV2bFdTK1dnSHR1cnl2Ui9qNzRMdHZGWHhDMUVQZXN0ekpBbHZJdGxLZmtpaUtqT0I4cHllaHJ5UC9oWm5neFBnUkRwYXRmdGUzRXltWE5uSXFaa24zdis4STJuSTZldERpN0wvdDFHcWkybEZ3bGExT096MjNmNG4wdGN4WFdpZkJqUk5HaGZicVhpSzRqaWQxKzhIdm04eVovcUZycS9GbW1XbXBlSnZDZmdlMTQwelQ0RXZiNUY2TkhiL0xERTJQN3pjbXZuL3dBVmZHSHdaZmVQUEF6SkZxaHNyQlpwbmovcytaV1Z3Z1JDcUVaYkhjanBSNGYrTlBoRzM4WCtQdFdraDFRTkpIREZhTUxHVTRTR004UHg4aDNkaldONTc4cjZ2NXQySS9lT04rU1hNMUtleitLVHQrQzFENHkrTDlDbWo4UTZqcWxzbDFwR2lzMm42ZFpOa1IzZW91dnp5dGpxc0k0SHZYNDhUWE9vNmd2bTNFcGthUUREeU96QlYvaFhKNXdPd3IyWDRwZU1JTlk4UCtFOU50ak9GaGptdXJ2elkyajMzRnc1Wm1HNzd3eDNyaC9EK282UEJvbDZkUXQya2tqamY3TkRnaEdrYmdNeDloeUt3eEZTVk9tdVdMZG5zdCt4NkdGcHh1NDgzS2tuYSsybitlNU12dzcxYXhzR3V0U3U3UzIzeGw0WUpaZHJTai9aVmM0OXMxOVIydmdxRmZEa056UHBNRTl1dHVyTnFXalhabmt0eVJuTnhDZW9IZkZmQ0xYUmFQejd5UXp1d0ErWnkyMGYvV3JvZE8xclVkRG1GeHB0N05iczY3SkZqY3FIUitDRDlSeFhnNHJDNHl0Q05xNlVsSyt6U2Zsby93QTduclVNVFJvdlNucGF6dTd2OFM3cUdvLzJkcjdUV1dyTUprY0w5cHR5WTl5Tnh1NHdjRWRSWDdPK0dMT3k4UWZEclROVzBDemcwN3hGNGF5VWppd0E1UWJwSVhQVm81MTVHZTlma2Y0eFh3VEVIZlM0aUk1b1lTRlk1ZUtSMStaYzl3RFg2Uy9zMGF5OXZONFlrZlBsNnJwZHpheTU1RFRhZStWWSsrMDRyM01IV2xPalRmTEpYaXRKS3owWFZJOFRIcjJkWG01b3V6YlZucHRxdnVQcGpYL0VGazQ4SC9FVFRRVWprOHF6MU5CL0ZiWEIyNGYzaGZwbnBXbzlvUEQvQU1ZNUNkZ3MvRk5temxGWDVSZDJvNU9mVjByaHRNMDFIOE8vRmp3MHlrdzIxMWNTMnkvM1Z1SS9PQUhvQXc0cDJ1YXpOY2VBZmhocnJxV210OVEwL25QWHpSNUxEOGE3dEwyMzZmcWp6M0tEbHlxMXRZTDBrdWFKZThIYVBZeHY4UXZCYndSaVB6WkpiZlBKRUY2dTREL2dMVmgzRjNjNjc4QUlybC9tdjlBa2pZRThrU2FkSmduNmxSWG9keWs5cjhlNENnVlJmK0gzM1o0NXQ1T1B4NXJsL0J0dkNMSDRvNlZJMlZYVWJ6YUFlMXhGdS9uVkpwYStqL1FQYVJiNXRONFQvd0RiWDk1NXA4ZnhEY3hlQy9FZHVnSm5kWUhJR0EwZHl1UUQrTmZGL2dxNGt0ZkdXcDJoSTJ6UWtzUFV4bmFUK1ZmWGZpcTRGNyt6ZDRldUNjdmFHeUliMDh1VGJpdmpkSW8wK0o5b1ZmQ3lQTGpCOVJtdWVzMXl1UGsvd0ZUc2x5cC9DNUw3bWRaNGRXYTUwRHhUcER4cVVpa3VBZ3h5dTRiaFZIVXJwcC9BdmhqVUNTSkxTZTN5VDI1Mkd1NjhPVzBZOFYrTUlrWWpLeE50UGZjdkp4WG5pSUcrRU43azd2Sm1rQ0RQVFpMWEE1WGw4NC9panFmSmRQcmRmaWVnYXpiVzhIanZRN2grWTd1Q1NJNDZFamtWenVsMjFyYitKL0ZWcVlzcVZXUWNjQlpGd2VQcld4NGxqa0QrREppUmszS0twNi9mU3VpdDlMSStLazBKQUszV2xCbUhUSVU5Y1ZLZnViL1pmNE13NWtvcnpqK1RQR3RNZ2E2K0Z1b3hsZjN0bzhveU9UaU5zNE5lbDY4NWV3OERhZ3YzaGV4Wk9jQSthbU90V2ZDV2tlZDRlOGNXNnFNcGMzU1lIUEJYZDBxYS9zbmsrRUhoQ2NrNFc4c0R1NmNGOXVhcVR2SmY0dnpSU2E1dC90UDhVYnYyVXhmRnVXTURJdk5LVnVEbm1OdWF5dkMya0pOcFhqeTJLWUVGemRLaVl4dERwdXIyUFdOTFNMNHNlR0pBT0pOT3UwSEdBU2hCL3JYRlErSWZDMmhlSy9INmFycTl0YVJ6U3hGQTc0M0Y0OEhhQjFOWXB5Y2RQNVl2N21kVWIyYi9BTHFmNDJQR0o3RnBQaGZwVjNLK1RIUEJzWFBPQTIydTQ4V2FYSERydWp5SUZHK0Z3eEhjbm5IMXJ3eTQrS3ZoYUR3VEY0WVdDZWE5ZVQ3d0FFYWZOdlVoanpraXZNdFIrTW10YTViYW04VnREWXZZV3dhQXIrOFlrRUljbHVLMDluVTVsMnUvdVk1TzMvZ1VsWStuL0VNQU5qcDVZYk5oY2NuR09lOWVJK0xMK3lpOGVlSGtXZGZ0SDJ1RmlnT1R0ZE51ZnhyNTU4UWE5ckdxZkRyVHJpNnZKSlpQN1RualppY1pYWUNCeDJxMXE4amp4MzRUbGJxOXRweCt2YXZvbzAya20zL3o3ZjRIeUxxT2FhWGJFUi84bVBlLzJmM0Z2OFFyMklIQlMreC80OFJYNkQvRkFlVnJ1b050eHYweTFrejd4ekN2enMrRDVXTDR1YXdoQXo5dDQ5djNuYXYwdStMVUtEVlhMZzg2SElmZkN5ZzEwMFUxRitUWlZXVGRlTDd3Z2ZwdjRMbE1tajI3RWRVVS9tSzlDbGpSMUlJRmVEK0hmRVdsYU40SkdwYWhkSmIyMXZiTEpMSTV3QUFvL00rZ3J3M3dCKzFUOFB2RnZpWWFOSERkMmswanNMYVdiYjVjMk9nR1B1azlnYTUrU1R1N2FYN25wNGFqWGxROXBHTGNZcFhmeXVlcytNZmhGb211QzVsWE52TTR6bFJ3V0hRa1Y4RmZIdndTUER2d1dpczNsOHgvN2NqbEw3Y2ZlUXJ4WDdGREJUTmZuVCsyR2tmL0FBcWtzYzVGL0R0d2U1eldOT2hCVkxwZEgrUjdjTXd4TmFNS001YzBkYk5yWFJQcWZnaG8rb3k2VDRqdEx6WW02Sm1IcmtZeFgwTTN4WnVqdERSL0wyNHI1WXQwWTZyYVJzdU44eXBuUFRjY1Y5VHpmQ2krUWtlZWhKejJKNjE3R0JuaVZDU3BOMnZkMlB6N01xV0JWV0xyY3ZNNDJWK3lKVStLbDBTUVlrNEhUcG1sZjRyM1pYQXRnRDlhaGwrRWQ0aFRGNnVNWklDbmcxZ1RmRGJVMFB5NEpQY2ptdlU5dm1LL20rNCtjZUd5bHE2VWZ2T2lIeFpuTWdieWNNb3h4bW5TZkZtNEVuTU9jOG5OWTBQd3gxUXVTcFg3aExFOGZsVWt2dzExVkhqR1ZQSFB2Vkt0bVQ2eSs0ZnNjcGlyV2d2bWJ4K0tnZU5nMXV6RVk5c2ZTZy9GcGxUNXJVa1o5ZjBybnBQaHZxeFBEQXNDTUFEK2RSbjRiYXFXQkF3ZDJXUHA3VS9yR1k3ZTk5eG1zSmxTMXRGMzI5NjUyOC94WnRDcXN0bklQUUhyVU1ueFdhWm94NURBRDdvVVk2MXpxL0MvVkpDUDlKaitiamtjak5STDhNTmJUSlM0akcwOFp6MnExWHpIcHpmY1M4RmxDczN5cCtwMTgzeFZtakVhdmFFRXJrNS9yVWFmRmlZUDVxb1ZIR1JqajhqWEdUL0Q3V0pZeWZNWHpNbk80OWYvQUsxVm9maDlyQVloNHdjNHp5ZUtuMjJZTCtiN2pYMk9WUGR3MDh6MFNYNHJSU3lnRkNNTG5rWXorQXJOaytLTVJkV01iaGdPTWVsY3JKNEExV2RqdEVTaERucmdrZmpTRDRZYTdNUjVhUTU2Z2x1bEN4T1piMmw1YUV6dytVU3V1YW5wL2VPNG0rTGxpWEdJSEk3K3RKL3d0cU1SRS9aeUZQSTR3YTRTYjRjNi9Db0xCQ0QyWG5GVUQ4UC9BQkErQXNTOWVwcGZXc3gzOTc3aUo0Ykx0RTVML3dBQ1BSWXZpbHAyQjVxTURqUE9lVDI2VUQ0a1FoZ1VKeWVjRVlBcnptUDRmYTNJRCs3QjIvbFQyOEJhNDd4NGhVWk9EenhtbDlhekgrOTl4c3NMbGUxNDMveEhvZjhBd3RHQU1NeDVYUExDcjgzeE9zdGkrV3UwWjZFWnJnSWZoNXJieUZURkg4b0pZNXdLTHI0ZDZ3dzNLaUVBY2ZNQnhWTEZaaDJmL2dKRHdlVzN1MnYvQUFJOUNUNHAyd0IzZyt2MS9DcFl2aWhBY09XWTV6Mnp4WGx5ZUF0U2pDRTJwWXNQbEFPZnpxckw0TDFlUGIvbzdMK09SelFzWm1Ibi93Q0FtWDluWlczMHYvaVBZMitLVnVyQkNXSUhYQklKcVJ2aWJwazJDN3R3TUFFNHJ4cVR3VnJPZk5NT0ZJd09lZUt6SS9DT3BBSE51ekFuaXIrdVkrMnovd0RBU3ZxR1YycytYL3dJOXpUV3RCMkVzdWNrWUF4VnVMVzlCYmFmbEJ4M0FyNUNaSjBPVDVuV29QdERCeUFaQ1RYS3N6azFiMmNVZGY4QVpNTDM5cEw3ejdKYldkR0tCUUZQcmpIZXBCcjJqSkZ0Vkl3dy9PdmpFU1hJRGY2d1k3Q2hYbkpCS3VUK0pyVlpuTmY4dTBaeXlXbEtWM1ZsOTU5cngrSnRKUEh5Y2ZRVTMvaEo5SkFiQ3FCbjFIRmZGeXlYQUhLUHo2aXJNSm1JdzBUWnpUZWExZWtFUi9ZZEJhT3BKbjJNdmkvU2dvMm92QnoxcUovR0dtS2VOb1ByWHlFcXpEckU1NDlPb29aNUVZRHlYNUhYSFNvV2FWLzVVVzhsd3lYeFMrOCt3VThaYWVnWndxNS9DcTh2anF4SEhrcmpPU1MyRFh5R0RNY255bkpQT2UxVE9aR3hpQnlPTTVGVi9hdUk3SXkvc2JDMzNsOTU5ZC84SjVaQmdmTFVuR01aeHhVa1hqYlRteWhWUUFjZ1ovblh5U2tSM1phSm1IcGcvclI1Y3pNZHNKeU8yS1g5cTRyc3Z1QlpOZ2ViWG0rOCt3UjQwMHRRYzRIUFkwMlR4cllrWVZVRzQ5ejYxOG13MmM3TVNJSkNBZUszVjA2NTRZV3ovd0NOWnl6UEV0YXBmY2FQS2NMZlJ2N3o2WC80VEcyaWRTVlhJNEdhcW54amFmZkNvRHU2WnJ3cVhUWjVJMVlXNzU0N0dzbVN3dlF2L0hveTVJT2NWRWN4eEM2STZKNVhoR3JYZjNuMFdQRzlzTVpDY252V29uajIxVk5wV0xCUEo3OFY4djhBOW4zcGJQa09RT25IU3FnMCsvOEFteEFjazljZnpyV09aNHJ0K0J6dktjRnV2elBxcWZ4dlp5T1Nvak9NZDZzTjhRQjVaaTNwdHdPbjlhK1V6cE4rcEI4aDl4NmdkTTFxaXp2MkEvMEp1UmpPS3BaamlWMis0aDVYaEo3Mys4K21rOGQya1BDc04zQkhla1BqeTFiL0FKYUtDVHlPeHI1cGpndmtPRGFzZlk5cW5ObmV1Vi8wTThub1JqaW1zeHhQbDl4SDlsNGFPaWJ0MnVmVWkrUGJNcHRIbERKNTlLcXplTzdaTXFoUlFjWngxcjV2YTN2RmRkbGl5NDZnalA0MGdzNzFuRzYwWUVEZzQ1TlNzeXhDNkw3amVXVTRWOS92UHBLUHh4YXk1ekpHQU91YXVEeDFhUmtiWGp6bkk0enhYekUxamVGZHh0WEJQQU8zcjlha1d3MUI0OGkyZkk5Qit0T1dZNG5zdnVNWTVSZ3I2L21mVVVuankxR0dNMFpZNEl3S2svNFdERXlzelRvVDMrWCtkZkwwZHRxSWt3YkZpd0J6bGF2ZjJicWUxU3RvekE5UjMvR2s4eHhMK3l2dUxXVllPTDBiWHpQcHUxOGUyeWovQUY4WTV5UVJrNXJUajhkV00wckI3Z1pJemttdmxkZFAxTGFjNmR5ZVEzZklxWmRNMXRuWGZaY2NaSUhKeFZmMmhpUDVZL2NDeXpCZDM2M1BwMS9IV25wSStaZ1NSZ1k3MDVQSEZvWXd3blVIUEI3ZmpYek5Kb2VxN3dEYXNxbnZqbXJ4MHZXREdBYkh1T0J4N1pxWG1HSTdMN2kvN0x3cVQ5OXY1bjBJZkc4TWNuelhpOGM1UFBXb3o0MnRHWm5hWldQQjZjZlVWOCszR2c2b1lWUDJVcWNZeFVDYURyTEVZdGp0SEEvR3FXWVltM3dyN2prZVZZVzM4UnI1bytqRDQxdEhPNXBZeU1BREk3VmRnOGN4UWdsTGxRR0JBSEZmUGlhQnE2RlZFSFVkZXhOSTJnNnNZaVdzSE9EODJHSDZWU3pIRVcrQ1AzRlN5dkMzVDUzOTU3OUg0K2dCeUw3ZGsvZEhOV0pQSHVuc2hCdVZIcUQvQURyNTZYU2I5eEg1ZGl3ZFNQbTZWbEhUZGJFeERhZVY2Z25qQnJUNjlpR2xhSys0UDdQd3R0WnZmdWo2WGc4YzJBanlMdENCakdSbjhxc3llUGJQZ3ZlaGdEay9MZ0N2bVFhUHJCay80OHpnOFlHTWYvcnBaZE0xMVhHMnpabEFPMEVZL09wbGpjVC9BQ3I3Z2VBd2FXa3YvSmo2RjFIeDFwMk0vYVdiZDF3TWc1cjNId25HQjRSMU83M0REcVdBOWlLL1BhYlJ0WnVKb0VOZzBlNHFEZ25hT2VjVjkvelBIcG5nWjQ5MjNFWVVZNmRLZnRLMWFFdVpXU2E2RVJwNGZETzZ1MjR5Nm41UzZ6NGh0dE04UTZvR2NxenVOdUI2VjJ2aGp4bkcyVmRpeTllbkk5NjhEMS9UYi9VZFd1N2lPMloxYVE3VzlRS3NhTnBXc1F5Qmx0MkFCNkVkYTgyV0t4RVp0SmU2bnBvZXpTeS9EU29RYnZ6TlhldXpaK2cxcDR5MGgxVU5kNEpYRzByamoxcjg3L2lsckthaDR0djVGazNSb0FpRURyZ1Y3dGIyV3BPZk1OdTRLcm5rY2NWOFphKzd5WEU4aEdOenQvT3VERjRxcFVoR01ra3IzUGV5bkMwcU5TcE9MYmFqYjczL0FNQSt0dmhKck9uYVY0V1BtemxIbW5kOGJjZzQ0elh1RWZqclMyWUQ3UTdFbmpjdkFOZk9XaCtGZGRYUWJFUldaYjkycis0enowcm9aUERPdlRBUC9aMGhQT1ZDOGZoNzEzVThUaUlVSVFTMFN0c2VOaXNMaHF1TG5PVDE1dHI5dEQ2cFh4OXBvUWJwK282NDYvV3Vsc2ZHMmpFaGxtYkdSbjVjajhhK1NMWHc1cnFvTitudndNSFBldW0wM1FkY1Y1Vlcxa1JHQU8xdWxZUEZWcnJUOEJTd2VGcytWMjA3bjJQWi9FVFFWamtEM0JVNVBLamo2NHJVZjRnYUZER0Q5dU9XVUhPRDByNVh0OUgxVjBFUXNzRGR5YVkvaGp4RUdkWDB5UmxWc2hnNDZWMnh4ZUlTK0ZmY2NOVENZZlQzbjk1OVN6ZU8vRDNtSVh1NWlTT3FMbklxKy94SzhMSEFGekxnSDVWRVlVZyt0ZklVZmhyeE1zb2FQVDJIYkxIdFdsTjRYOFN5U0Yzc0NNZ1lLbnY3WnJmNjVpTlBkL0F3amdzTHI3NzE4MGZYRTN4SDhIeTJsdkYrOUU4Vy93QXlYKzhHNmNlb3JLaitJUGh4VElmdFRsZWh5bU9hK2FyZncxNHFpSUsyZkpYZzhjNDdWbHQ0WThRc1dZV1RidHh6azQ1K2xFY2JpRTJyZmdWVXdkSFJ2ZXlYM2FkRDZ1aStKZmgrRUtvdm5VZW0ycmpmRUR3NCsxL3RiQWVvV3ZqbVh3MXE3Z21UVFdMRnNkU001OS9hckI4S2F5a0FYN0RNZHJaejFQOEE5ZWg0ekVhdXkrNHI2cGhuRzNOYlRvejdFaStKZmg1WDUxRnNJZVdDQTRxS2I0aGVGY0ZrdnljdHpsY2ZpZlN2a3lUdzFyRXFsaHBVb3lCOTNqT1BVVTRlR3RYWnlzZW5UOERsU0FCK2xKWXl2ZlpmY1FzSmg3TmMzNG4xaEo4UlBEd2pPMitrQzU1QVRHZm9hMUkvaVY0UFNGVk4vTkl4VW5CWEFVK25OZkh6YVY0bGhWRWJUbjhyT0dRQUVudm5OVTVORTFWbUxmMlBLbWVoSXorTkw2NVh2ckZmY3pTT0VvTFhtZnpaOWQybmovd21aVHV2N2hBUi9Bb3orWjlLc3Q4UU5Banp0MUNYQzVLdGpQUDByNDV0OUcxeUptMjJVbThua2VYd0tzdm8ycm1ReGpUcHRwOUZPY2ovQUJxdnIySWIyWDNHSDFMRFczZjNuMXpGNCs4TCtZcnJldXhLbmJsY2ZQMzZkcXBYSGp2dys2a1NYTFp6bkFIZjhhK1FvOUkxU0hZSDAyYk83NXdmbE9QUVZvL1lkWW5aMWkwK1ZBaEJYSzVZanRuL0FCbyt2WWhQNGZ3RDZoaDNINHRQVStrNHZIMmdwT3hGMjZKbmpkODNOYkwvQUJJOFBnb2Y3UVlZQUgzT3RmSGsyaTY0MHhEV00yNVNXKzdqbXBWMG5WMjJsN0tiREhvRjZEOEtsNCt1MzhLKzRjY0ZobzZjMzRvK3hGK0plaHFRVjFCaVBaQWNqMHBQK0ZoYUhNeEF2QzJjY0ZPQml2anFUVDcxVkVJMHFZQVp3d1VrOC9oVU1lbWF4SGJ1cldNKzFmdS9KMVBwVFdQclgyWDNHN3dORi9hbDk1OW95ZkVMUUdQRjY0a1BCd3ZHQlZNK1BOQmlaQ2I0TUFmNGwzRVY4WXc2YnJoZkthWmNaNkViZmx3YWZOYTZ1WlZXVFRaUExIQkd3Z3I3KzlMNi9XN1JIOVJvcHJXUjltVC9BQk0wYVJNTmZiQ3JESHlZR1BUNlU3L2hZbWh5cGxiOVNRRG5JcjRpbHN0WndoRmhLMkd6amJqaXBCWjZ1N2d5YWROdElJeHNBL1BGUzhmVnRzdnVLV0JveW5keWYzbjJJdmozUnR3MjNxSEI2QmZXdWhqOGE2V3pNOGQwZ0pRaGlvNmoyelh4R3VrM0xiTWFYS0dEZEFDSzZ5MnRkUmppbXhwN2hSR3grNzdkcUhqNjFyMlgzQThGUmltdGJQcmMrRlBpQnF0MWU2cmR3a0R5eGRTc3I5eUdPZWE4Z2VEeTFIUFVjYzEzdmlReVBxYmtxT1dQMXJsWmxSbFVFWkhwMHI0R1Q5NXUyN2JQMU5hUlM3Skk1Q1IxVnM3aVcrdGVoV211ZUlkRnVoTnAxL05ibGxCM0l4QXdmVWRLNVpvTFpaRHRqeDZaT2E3MlZXbXNJRElVQ3NueW5IVUwyNDcwNVNXbW5xVkJOWGQ3SFFXbnhxK0kxb3hBMWJ6Qm5KOHlOV3orbGJtb2ZITHhqcUVDSmNSV0Rzb3h1OGdLU0QxeUJ3YThCdUxFTEljTmtjWUdLOUtsOFBSeWZENjN2a2lVU3g2azhUdmpCS3N1UU0xRXAwMG8zaXRYYllhZFRxN2xlNjhaMlZ6RENKOUF0RWtqQnhKYnMwVEUrcDZqTmQxNGIrTWVxYWRGTkJNa3R6Yk5Ic1dJdUJ0NXpuT09hK2ZiaTNsSUNyQ0JqMDVOVkUwKzlZL0xDNStnelZxTk8ydjRzbHltblpYc2ZidHY4YnRHTm9zRW1tM01hSDd4UmxKTmVnMlh4bDhGdEpicC9wRUVBR0gzUjVZY2ZyWDV4TmJYUVhtTmhqMnEzOWt2RnNqY0VNRkVtemtkelYzaXJha3ErdTUrbTF0OFJmaHJLWFlheTBaN0xJakRQLzFxNExWUEgzaGU0dWtqczd6N1JJOHF4cWdRZ1lKd1R6WDU2R2FUYmpOZGo0U2ZIaUxUdzR5RE1vcldPclJON3k2cy9UM1Y1WllXMDBwL0cyRCtYU3VpaXZKOTd1K0EzdFhPK0lDeVcrblAweEpqOHgxcUZMZ3ZHT01oZXZ0WG81bEMrS2J0OW1QNUhYdzFWdGx0TlgybFAvMHBucXZqSDRRVCtPZEwwSFVFdmt0NTBpOGhwSFVzR1hQQU9PNDlhK2pMTDluM3cxNEwrRkdzRENYdDRZR25rdVhVY01vemhQUUNtK0FOUlIvQ3NGdVN6TWt3T0Qxd2ZRVjlqNjREYy9EclY0bUhXMGxVZjk4MXpZZWhDTTAwdFcxYzY4M3FWdlo3MlhQOS9WSDV3YS80ZDB1RHdsNGV1WTdTQldsa3RON0NNWllTRGtFK2hyOHZmaUxQYzJ2L0FBbE1NTThrWWcxMGJBcmtiVlpPZ3gycjlhdGZZU2ZDWFJyaGVzSXRDTWR0cmJUWDV3ZUk5S3NMN3hwNHhzN3BOOGIzTnJQd2Nja1l5UDYxNzlhL3M3WDExWDRINTlTL2p5MDJiL0NTL3dBejU4OFMzMnBYbWwrQ1JITk83dFpsV0NzeExGWk1jK3BycmI3d040MGo4UVhsK3RsT21uNUpFOGgyb1E0QzVBNzRKcjdrOEdlSDdCU2tFTm9pQzNoekhzSHpBSHNNMTZIck4weCtGR3FMNVc5akZKMUdjRkhCNHJ6S3RHRTI1TjY4cS9JNjhMWGxSbFNweFdqcXUvOEEyOUs1OG42Uit6N2VXRjFvMWpyT3VsNHRaazIvNkxrdEdZaHZBQmYxcjZ3OERmQ1h3SG92ajdVOU1mU2t2VWdzTGE0Z2E3L2ZPck9TSEl6eHpXLzR0MUpVYjRlMzBlQmk5ZytVOVFzc2VPZnJYV3BxWS80WFA1cGJhYnJSTnVPbURFL1FWRWFkTmREcmRXdktpbTVQV2xPOXROVkwvSTQvU0lOTUh3cjhjeEhUclR6TGU4MUtORDVLN2xDOHJnNHlNZHF6ZkVNbWp2NEErSHQyTEMwRExmYWJ2WVFJQ3d4Z2hqamtIdlZqd3FrODdmRXpTbHdUOXNua1FlMHNlYTVlNm1odS9nSHBFNEkzV0wyck1mUXhTN1RYWEdNZXhsTG5kWGR0T3REci9PajJhK3N0RGkrTlduTDlndEJIUG8wMkY4aEFwWlh6bkdNWjk2VHdoYTZlZkZYeE10QloyeHpkUnRHUEtUQ3E4V01Eamdackk4VTNOdkg4UmZBRjZ6QXJOSGNXek1vNCtaUXk1cTU0YWhsaitMM2kyQUkzK2syRnJNcEI3RDVTYVhLcmZJNW56T2cybTcrd1duK0daNXBHMXBKK3puTXYyU0hmRHVWM0VhN3N4ejg1T00xN0g0cGcwNGE3OE1ibGJhRkZOL3RjN0ZBTytEdmdldGVXK0hyR1M2K0VYalhTZGhFbHBjNmloeng5MXZNWDYxc2VLWlhmNGRlQXRZV1E3WUx2VFoyNDRRTjhoUEhwVjhzVHNTdlZidnZXcUwvd05hSHNPblcxczN4dDFjZVhHQStnVzdMOGd4OHNoQjdWOC82ZllQTDRHK0kwU1FyaE5WMUFaQ2pqSTNZK2xlL1hwZTMrTlhoeWFHUmRsOW85emI1UGRvajVnNit0TjhMYWZJL2lUNGw2UE1nZno1NDdvS3ZHUmN4YmVCOVJ6VVNTNWR1aU9lTm5UNW4vQU0rNmIrVVh5bjVyNkRxcUw0UzhLa3F2N2pVN1UvaUd4WDZDNnhMY1NmR2J3bTdxTmo2YmRvR0dQbUlJYXZ6UzAyeHVJUERtczJ1Mzk3WlhUeVI1SFF3U1pJSDVWK2oydmFuYXl3L0R6eEtwSGt4MzBLU3VEd0V1MDJIL0FNZXJ5SlhUdDVzOXQwMXpXNyswWC9nU3VkeDRUczNieGg4VkxNSUEwczBVc2FuMGxnSUJ4WGpCam5sL1p2dGl4WS9ZWkltZE05UHMxeDgyUjYxOUZLOFdpL0d5R1dWMWloMXpSd0YvMjU3UnM0K3BVMXcyaDI1bnR2aVA0TEVJNXU1NVlOM1h5cjBiMXg3QnFYT2trOU5PVi9kb1ZCUWRwY3VpZE9kL0pMbFp1ZU1vNVlmaVA4TzlTV1lyRmN3WE5zR3pubVJBNEg0MXpPZ1cwc2ZqSDRsNlR2Y2ZhMWp1RTNIN3dtaUtFL1ROY3BmWCtwNjk4SnRKdTRrWjlUOE5UeHlUeGhmbVdTeE95UmZ4V3VyOFMzdHZhYTU0WDhkVzhtZE12SW83VFVISElTRzQ1aWxiSFpXNFBwWE01U3RhMnF2SDVyVkVTd3k1T1ZSVjFGdytjWHpMN3o4bXZpM0hNMm5lRGIxbE9JcktTeGxQWlpMVnlwV3VSaHY5T2wwNjdnbW5CV2UyV1NQSC9QV1BqYWZjaXYwaCtNbnc2c29wOVIwKzVuaWcwdlhKUHRtbTNqRUNLMTFCVithS1J1aXh6RG9mV3Z4cXZvcDdKMmhrZmxXWmR3NUFJT00rNFByV05XbjdWSjNhczdwbzlQRDF2WndiVWRIK1QvcXhwdU5oSGxLR1RjU3VlcWowTmRQcE51dHpORkpmUlBGWnh1UkxJaUVqcDhxN2gwSk5aTmpPcHRWTWtscTVERDVXem5BUDh2V3VwMTd4bnFzNzJjRFhOczlwRjh5MmtNUWpoRGRQdXIxUHVhaWJxTnFNWTczdks5bXZUek4wbzh2TTMyME5QeG40VS9zcWUxaXRwVWZmYXh6eWdIZDVaYm5hZmV2dC93Q0gzd2swdHJ6d05hWHd2Qk5jNmZkWDkyc2R5OGUxRzRqQzdTTnVlK090ZksvdytzN2UrMUcwdS9FRFR3NlExeVBPdXpHeGlWaytZUk0zb2NZcjlYZkNPcVFXdW5lSnZIbXBvWVlaWVJEcHNCNEl0WWVJd0I2eU4wRmI0WDJzSVJVNWMwbG8zM1p3WTZTbE5LbW5EbVR0cmJWcXlYNm5pV24vQUEwOEpOZi9BQkp1SE9vdGI2ZCs3Z1lYOG9PVWkzTnVPZm41OWE1elZQaGQ0YmcrRm5nNmRqZXBkMzkzWWdnM2t1d2lWc25DWndPTzQ2VjdEcXRscUdrZkNtTFRuQkdzK0s3ekxwM1UzVGJtei91SlhvMnUyS1gzalh3RjRjUlFZdFBRM3M2QTVDcGJyNWNlZnFhN25PejM3L2dZcm5qSmZ2RzFkOWQxQlcvRm5pT28vQ2p3bWZpdm8rbXFOU0VBMHVhZVlHL21aZ1EyRncrY2hUNlZ6V2tmRFB3aTJvZkVDVm90UUZ2YVhUeHd2OXRsQkd5UGNkM1B6Yyt0ZlcvaDJDUFUvaXY0dzFSWkFZTk50SUxCU1R3Q0I1a21EN1Y1SHBKK3cvQjN4cnJsd3diKzFibSttaEJQWGUzbEpqNjlxcFMwUzE2TDd6RnF0eXBlMG5lMU9PNzNidjhBa2ZLR3BlQ2ZDOEh3T3N0U1NLOUY1Y21MYWZ0VWhqSmVUQi9kazdjWXJ3aXo4SjZUSjQwMCt4M1hIbE83N2g1ekJnRkhHRzZpdnQzNHJKSHAzdzI4SWFLckR6RExhaGd2SCtyWGMzRmZOUGhTeE56NDVobFpsMlJRUEs3RTRBREhBeWUxWVZIN3JlMmpMcDg3VGJrM2R5ZS9RNmpRL2h2NGN1dkZuaVNBbTg4cTBTTHl5TGx3MldYSjNNRGsrMWN6Yi9EM1JHK0ZlbzZzV3VmdEFsbENZbmJZUXNtMFpYcFhlYVI4UXZDdWg2ajR2ZTkxR0lUWGM1UzJqVWxtYkM3UWVPeFBldkNHK0w5aTNneVh3M2I2ZEtYVlhlYWQyQVViRzNrQURubXVhS3FONk43eC9MVWJsTlRkMjdjMGZ1dHFlNDY5OE5QRE5ySDRQUlB0ZWJ5N2lTUUc1Yy9LVXlkdlB5bjNGYTkzOE9QQlZwOFE0TGFlNXVvTE5OTmFWM2t2WFFodDJBTjVPY2UxZkZPdGZGN3hycnVudmNQY1Iyb3NHaSt5K1F1MG96ZkxuY2NuT0JYaldzNmxxbDlwZHBjWHQ1UGNTelRTa3ZLNWNrTGdkNjFVSHlxOHRmSW1FNVJTdkp2Zjh6N2JXKytEMmpYWGlLRzl2YitXUjdoMHNWdDdpUnR5RmNLekZUaGhudWE4TXVmRi9oNTlGR2wydWtYZ3ViZFdrbHVaTDV5aE1mUHl4RGdBMTQ1Y1d5SFg5S3QwR01MYkszMTZtbTJ5NzczWDV1ZjNjVTMweXpZb1VVdDIzdDFLdlBtYnU5WDM3STA1UEZHdjNOcGNYYlgwNnRDNkxEaVZqNVlicUFTU2F6OVExQytGanBsd3poNVp4S1haMURrNGJBKzltc3VOU25oZWR5UDlaZUlvUCs2dWExdFdoSXQvRGNQZHJjTi8zMjlVM3FheGxPejFleS9NN0thK3VvL0dVRnFWUW9ERUNwUVorNEQxNjAzUWRUdjVyYnhES2ZKLzBPMk1pZnVsNjd3TUhqa2ZXczhzRytJVXpaT0k1WE9UL3NKVjN3cXUzd1o0M3VDRHpGYnhnNDd2Sm5GWlFncFcwK3ltR0pxelVIWi84dkxmSzZSM0V2akhWWVBodFkzU3hXbm15YXBNaHpib1YyaEFlRkl4bjNyck5ZOFdhbkY0bzhMMmkydG1WdUxXd01tKzNRc0RJZWRwSStVZWdIU3ZHTllUeXZobDRaVEdHbXZidVQ2Z1lVVjZOcXNCaytMSGhxREgrcmowOVNQb2dOZS96eVNTdjBwbytOalRnNXVUZ25yaVhxdTBySHF2Z3ZWYnpVdmlScWxtWTRZVmh1V1JaWVlsU2I3K0FTdzZrZTlmVjN4RzBYWExXK1F2cjE5T2ZzRHVUS3dMQkF3QlRwOTBubXZrajROSjlwK0tPc3lEN3I2aVZ5Zjk4bXZ2MzR0U2dhdGREajkzb3dHUDkrVVZjSlhqTDFaMlFwLzdSQ095NVlLM21kcmNmRGo0a2VKdmhmZTZiRjR1aTFHS1czUXJiU3hoQ3JBWkFWKzVIcFh5VjhDdmdCNDhoK0lWdGQ2bll5V2x0cDAvbVNTUHh1Wk9nWDF5YSs5LzJkbXY3dndyY1NPN2svYVgyS1RnQlIycjZqOFBXMTI5N2ZQSVR0YWNuQU9SbjByeFpSbTJyejY5ajc1MDVZYW5XcGM4WHlKTldWcmN5VjlEMzYxM2kzVFBwWDVvL3RrVGFrbmdhQ0o0WXpZdGN4TkpjRi8zaXlaNFZWN2oxTmZwdkZ4RUI3VitNdjdibmlpK0Q2Wm9td0NCd2t5a2NsMkJQNVlydFR0OXpQR3dOT1VxczJrclFweWJ2MnRiVHoxUHlOZ2VGZFRzWkRraGJtSmpqZzREQ3YxcWFTeGtZT1NRSCtaaVRnY2p0WDQwUE1JeXY3cWM4Z2c1WEhCcjNTMzhhNjhWUXZkTUYyRGo2ZEs5dktzWlR3OGFpa20rYTFyZVIrZlo5bDFYRlZLTW95aXVYbVR2NTJQMFlqbXRTVkFsQStibkp5Y2ZqVkIzc2c1K1lja242aXZ6M0hqYnhDRU9KbElCNm5xYWpsOGFlSVBNVmx1QVNPNDRyNkgrMWFLLzVkcytQZVI0cHF6cVJYb2ZvODh1bXJHd1RKYkhJTlVZRjA1M0Fmb1IxejByODdENDA4UjdnUmNLd05hQjhkZUpKVUIrMUFZNENnVmF6ZWd2K1hiSldSNHEydFNMUDBTYzZiR29LbG53Y1p5TTRxZ3oyS01TR0h6RGoxL0d2ejZYeGhyekJRTGtBaGV2cFUwSGpMeEFnM21aVDdOM3BQTnFOMSs3WVJ5YkZKM2RTSytaK2hGdEpaSGNRUnRYSEk5YW5EV2k0dytDVHV5UjByODk1dkd1dGw5eVB0SEhDbmlsazhjZUlmTUcyUmxCNEFMVnJITjZIL1B0a1N5WEZOL0hGbjZGQ1MyM1BnUk1XR2NzTTRBNjlLeWd0czBvSUtFbk9NZEsrREY4WmVJeFBsZzJCak9HL3JTSHh0cjczRGdTRWVpNXppci9BTFlvZjgrNUVTeUxFMlg3eVB5UHZHN2UyZTV3QW5ZRWc4WkZXRXU3ZUxDTkp1WDE3ajJyNElsOGE2K3BKa2w1eDJIVEZTUDQ2MWxZaG1VTVdVZlFVMW0rSDZ3a2M3eUhFYnFvcm42QVhjOWhKYkw1VHFqODVKNm1zOWZzN2dFWEI3QmdTQVQrTmZuMlBHZXZCOE5jQWp0bXJmOEF3bU90K1VXODdCNmNIdFFzM3cxbXVTUnBQSXNXMy9FaDA3bjMwcVdlR3d3NmROM1QycWlwdEZjWW1BVTlRYStGbDhlK0lTRy9lb1FNRHAxcDgzamZ4QUlzZVltRzYrdjUxbi9hMkd2OEV2dUtXUll4YSsxajk1OTQ3YlZtM0xkWURIR004ZnIycCszVDNqR0pBSlZQQTdFZDhrMThEd2VNZFhMOHpaSUhyam1yOGZqZlZHVnd4VUVIR0R6ei9oUi9hdUZmMkpCTEpjYktTYXFSMFZqN211VXRkeUZicFU0SEtqalArTk9GcmFuWXB1QXpidXA0RmZETng4Uk5lYTJpaHpINWNSYmFBTzdkYW94ZVBkWmNGVGdkT090Q3pQQzMrR1gzQ2xrZVB0cTRmZWZlN3cyd3VqSEpqT09kcDRxQklkTzVHOEhCNzlhK0xmOEFoUE5VQTVYQkNnRTByZU90VnpoUXVQZmlrODF3ejJpL3VMV1M0bXl2SmZlZDlIbzFoS1J1S2trMWNYdzNwQlA4T2ZxSythRzEzVUFmdmJjZS9OT0hpVFVCeDVocnc0NHZEZGFSOVRWd09LYjByMlBwL3dENFJqU1F2RG9jSDFINVZmUGhuVEFvSVZNa2VvNHI1ZVh4VHFPMVR1eWMxWlBpN1V6enV4MlBOYmZYTUovejVNb1lIRi84L3dDNTlHdjRkMGQvbERLRyt2V3JSOE1hV20wR1JNOXhYek4vd2t0L3VCSEo3NFBOSXZpSFVHZmh6eDZtbjlkd2YvUHI4Q1hnTWNwZnh0UFUrcXYrRWMwZEZQem9UNzB2L0NQYVM4WSs0RDFQUDVWOHIvOEFDVDZvT04rUjlhWWZFbW9Nek1KY2NZUFBXbjlld3QvNEkzbCtMZXZ0dnhaOVFIdzlwZzZORTJUMlljVk1kQzB4SDI1akpOZksvd0R3a0dva0g1dU1ldE1iWHRTVWY2d25qMXJSWS9CcmVnWlN3R042VnJmTSt1b05CMHpLbmNtT0FlUjFxMCtpNklHQXdtUWNaL3hyNUhpOFE2bjhvVnlEMTYxcE40bTFSc0hKNmpnSE5IOW9ZVHBSL0E1STVWakhmbXhGMmZXcWFUcGFiU05tUVRUL0FMQmJLaEMrV09PaFBXdmtWUEUycXJKbmNUanRtdHFYeERmTWQzT0RqdmlvZU93ei93Q1hkanFobGVJUy9qM1BxaU96dDBJM05HQWUrZTlBMDIyYmR1a2pPT21EWHlsSjRoMU1sYzlNY1lxUmZFdW9veTVKOU90U3NkaC8rZmVnU3l6RTlLdXA5WmZaTlAyWVhhU1FNNEhTcEJwT25ESkRJQ1QzNys5ZkpUZUo3OU41RGtkRDFwVjhXYWdkaTVZK2d6V3l4K0dTMXAzT2Irek1XM2RWckgxdEZwZW5zeExTUkwzT1QxclNqMDNUUXVWa2p6bkhYclh5QTNpaTkzRlMzQTlUVmhQRkdwSXJZZmpCUEJxLzdRd25TbitBZjJYalhkZTFUK2JQcm1UUjlNYVhQblJBNC9XbmpUZE1CNW1YUDByNUhIaW5VaVFNcm4xSnE5SjRtMU14cTRZY0RIWGdVZlg4TmIrRy91TS83THhhMDlvdnZQcS8reTlOQlUrY3JidW9BNXFhVFROUGpQOEFDMmZRaXZsQzM4VzZrWkl3RVRKOTZiTDRvMVJYSWJnZ25qTldzeHdtbjd2OEJySzhVN3BWZFQ2dmkwNnhLc1daUVFjZFJVaHM5UEFjRndNREdSem12bEJmRkdvSU1xeUU5Z2M4L1NtbnhscXNZUEdOM2J0VXl6SEROL0EvdUNPVjR0WHZOWDlUNndmVGRQS2crY25QdnpWK1BTclZRUjlvangySFEvcFh5Vkg0eDFGZ0E4YWRldjhBaldtbml5OVU1WUtDRDF6bjJyUlpoaHJmQy91SmxsbU02VkZmMVByKzMwUFQ1RkJNOGZJKzdub2ExcmZSN0psLzEwUjI4Y2tacjQwWHhwcUt5SzRDbGNrZGVjaXRlMjhjM1h6YjR3R0xEajI5Y1ZqOWR3cmZ3MlhvVXN1eHRsZVNmelByT1RUckVnamZHT2VBVC9PcXNWbFpFSGM2Z2djSHFEaXZsNS9IVjRKY2VWbklQTk1qOFpYcnE1S2tZNTQ0L0duOWV3blovY040REZKTFo5MWMrbzFzckZvOHVSL2VISFkxTEZwOWlxZ0s2NXp5RHhYeXIvd21WK24zVnlTdWV1S2VQSE4rRkdWSEE1NTZWYXgrRnRzL3VNM2wrTHN0Rjk1OWJMWWFlY0FUalBYMi9XblNXdW5xU0dsVTVBUEI2WnI1TGg4Y1hYemZ1c2oxSjRGV0U4YlhlMHNZeGpzYzBsamNMZlpyNUNXWDR2citaOVBwWjJBREFUTDkzclRaOUkwOEZQOEFTNDhFRWtaTmZMUThkNmd6RlJBcHg3ZHFpbThkM3BKQmpCNDRJT1JXc2N3dzkrdjNFenkvRXFMMFQrWjlVcnB0dDVUTUhBR1J4L1dyYmFaWmdGZnRDOGUvK05mSS93RHdzSFdJMDJpSkNBZTU1cFgrSVdyTjFnaTV4M3lhY3N3d3o3L2NUVHk3RWFYUzlMbjBjbG5FMTBBaExLclo2ZFFLNFQ0dCtJRXM5QVczaWNxemdLQjMzTnhYby9oeHBsMGRMdTZ3SFpDN2VpaXZnRDRtZUtKTHZYa01ZM3JHeFlEdDZWM1ltcENuaDFOcTE3ZmllYmhxYzZ1TlZGU3Z1L2tqZnM3SlV0SUl3MkcyZ2RlSzlBMCt6aExiWGRXSjdkQVB4cjVNWHhyZkRidWhBSTZjVjFOaDR3bU9DRGc1eHRyd0hqc1BwcG9mVVBMY1FyMm1rZlZmaVJyS3g4TGFsS3JqZWx1NS9FakFyOHUzc2hjWHVuVytUdW5uUlQvd0kxOU8rTHZHVjNjYUU5c0VDcEt5cVRqcmc1eFh6MXBFMDU4VzZhNnFITVVubVk3Zkx6WGtZeXZTclZLZGxaS3krOW4xT1ZZZXJRd3RhVXBYazNwcjJSK3F1bldxUndLb2x4NUtLaTg5UW94eFhVUnpSQkd6SVdBNTlNL1N2a3VQNGg2Z0dVZlpJdXZQUFN0cVQ0aVhoQkF0WXZZNXordGUvTE1NTW9hSi9jZkdSeTdGT3B6U2EzM3VmVjB0dEVJby93RFNZeXhVSElQQXo2MCswa3RqNWhlUVpVWUhvY2Q2K1c0L0c4NmtLWVV5UmtyOWU5WDdieHBMS29Ia0FIUFhPUHpyait0VU9aUFg3amFXQXhPdHJQNW4yRnBrWG56Z2p5OWpqZzU2ZXVhN2hMTzBkZ1RkeG92SUxOMngvU3ZtS0w0bXlOcG1uMnAwNkVOYUk0RWluRHlBblB6K3BIYXN0dmlSS3ltUmJVaFI5NEU1SStvcnRqak1QWk55cy9RNXFtRXJXdGEvenNqNnpqczQxa0pNeWJDY2duakk2WkZXWlZ0eWcyTXJBTHRHT29JL3BYeVIvd0FMVWtPei9RaXlyam5QSDByV2srTFVrbmxDTFRkb2pIVWtIZDcvQUZwdkdVRzFyK0JsSEExMUYyUys4K3FqYlc1V0VDNWhJR001UFErd3FqSmFJcyt6elVjTTNMREhBcnd6VHZqZEpaeXZjUzZWRGRNOXU4QVNWUjhtOFkzQWp1TzFjUi93czhnWUZpdTdxUG00cW80dWdyM2VsamFXR3JOTFM3NnJiWStzSkxLSm5hTlowQlZqak9BU3AvclRvckpWWUlKbENIZ25yWHlZM3hObkVhczFnR0I0OWhqME5hc0h4Ukx4RmhZRDVCazdUZzQ5NnY2NWh1LzRITExDVjcvRHA2bjA4MWxiQ1IwVzRqSnpuazgvbFZjSTd6L05LRXdRcEtqZ2U5ZkxvK0pyR2Ztd08zcVRudDc1clFUNG52SDg4VnNmbU9BUmc1ei9BQ3BMRTRkNjgzNENqZzhRbjhHbCtqUHBDYXpTT01nekxJeGJBd09HK2xUMmVtcktjeVNKSGdja25rK3dyNWRoK0xGekZOdVMyS3l4dXJjNEpCSEk0cTliL0YrU1c4ZVdhekxNeExFa1lHVDFQRlc4VlF0WlBwMk9tT0dyY3l2Rjc3SDB6UFl3UUZ6NXdIY2J1VCtRcTdIWVNPMG02NVVmTGtnbnJuMDlEWHlkSjhUNERJeGtzczVJSktuSk9hYkw4U2JOaUNrRzRaeHhrYytoeldmMXZEVytQOEROWUtzNmpmTCtKOUhQWnRjMk1qbVNQNVd3QUFDU0J4em1xc1ZvN0ZGM0t2eTljOS9jMTg2SDRsUWxkdjJSZ2NudlRmOEFoWXFJTUd6TER1ZXVQcld5eG1GdHYrQmk4QmlYSmU3MC9tUHBTUzNsYTVVR2VNc0J5eFBQNTk2dVEyeksrUE1CN0VjZCsrYStZQjhTRkFKV3lCeHlOalZFbnhSK2NzTEppYzlTZUtuNjVoZjV2d05GZ2NXdnM5ZTU5TzNWaVlnK3lZQWJ1bU00cWt0dTdvUWNMamhqeHhYejVEOFZMV1Z5SmJVOGZYSDQxWW4rS2VtZ0toMC9ZZWNzTW5wV2J4ZUUvcEduMUxGZEgrSjlJZllYd0NzeURqa2UzdlZUeUxpTkhJZFpCeUZ3UnVJcjVrSHhXdGp1QzJyRmNZQnllOVYzK0tGdnZDR3hZK2hVa0EwdnJXRi9tWDNHc2NIaVV0bjk1OUhTYWNzaXNYWlZLZ0VnMUd1bktKQXhJeHRKelh6ZC93QUxQdGZONXMzendmdjRBclJ1ZmlkRGR6dXdzeEVUajVFSkNnRGpnVWZXc0ozVmlGaE1lbm9uOTU5SlJhWmwvTUFVNXdBTWpyWE0rSWJlNWcwSFVtMnFqckJJUUIyT01kYThjdHZpWlpxQkcwYnJqcWU5TTE3eDVwMC9oN1UwakVqR1NFaU1uUFVtdVN0aThMN09kbXRub2tlaFR3TmFVNlNrbjhjYjYrWitUM2lLZVJ0U2ZkanFjNE9hdzVOdTBjajJGUTZsT2ttb1Q1R0FKR3pqdnpVV1lYSXkzell3Qlg1dStoK3VYUkZJcWdaenpYMEQ4TzdMVHRYdFpiVzRqVXRHNEtqdmhxK2UzUXI5NC9qWHQvdzBsdEk1dFVNbWQ2eElZejdnMWxYdjdLVm5abTFOcFRWelA4WTZQcHRsTjVFRU1tNVhJM2pnRWZRMTN2aG1mUm4rRjNpYlRwN2paZC9iN1M0dFl6MWZibFh4OU0xcTMxOXAwMjlKYmRXZkJJM1NZQSttZWE4NWwwNklGV2RraXdjcVE0SS9PdlA1dWFFWXlidW1uZjBkem9sRmMxMDkrdzZ4MCt6UmQwMFNPVGphTTFvcjlpdDNKTnF2M3UzOHExb0k3ZVdKUzhzWVZUamN2OFI5VFdKUDlsTjFKREZjSkpqRFlCejFyRno1cE5hK1p2WkpMWWJNMWxLdWZzNkFGc2dlbGJjK21hWmNlQjc5bGtLUEZkeDRYZHlkdy9sWElUK1dFS2tZUHI2VnpwWTdXQVluUFVaNE5kRk9PdTczT1dVdDlEejJUVGNBa1BubnVLM3ZDdHNSNGdzR3p5Smx4K2RaOTh6Q1RITmJmaGx3dXMyUlBhVlQrUnIyS2JmTkhYcWpqc3JuNlYrTWg1V2gyY21jRkpvaitCcmxsdVZVTWNiaWNiajA2OXVPdGRiNHFaWi9CTFRIQjJ4bzQvNENhOHpzM2ludGl4a3gwSTlUbjByNkhNbW5WZys4RWNQRG5Nc0hVaDFoV21qN1ErRzg2c0xYTTRMUElGMjUrNksvVGFlMEI4UFhrQTUzd3QzNjdseFg1TS9EM1QxL3RtRllKeTRWVWJEREJ5M1hIMHI5WGRQbWxrc0dVblA3c0QzcmxvN1g3Tkh2WnUyNk1GZlhXNlB6bGhWN240TTZoRDFhMjg5QVBRd3lacjg3dkVyc254UGxLbjViN1RMZVFaNHlWcjlNZkQxcWZzZmpiU0c2eDN0emdIMG1YY0svTXZ4MHBpMTN3WmV0d0piZWEwYy83VVo0elhyVmZndmY3U1BnVTE5WXF1Mzh6WC9iM3Zmb2ZWM3c5YTlqMVdTS1RneTI1R1FjOERvUm11eXRyT1c0OEtlSmJRejRTQnJsY0hISVplZVBXdlBmQ3VvTkJxZW1TK1l1Q0dqYnVNRWREWHVPaExZZjhKTHJkdEtENVYxQWpxVXgwWWZOeDZWenVLczlPaGFzNU9YYXorNDhtdkxlYWY0TitIdFVrZkxXVXRuS09NZ3JHK3c1UHRYcFBpVllySDRnK0RMNFJneFhBbnR5d0hYekYzRC9BT3RYSmFMWmpVUGh0citodEtvRnI5c2lqR2VRVkpkZndyUzhTWHNGeDhNdkIydVJFRnJHV3lsZmpPTmg4dCtuZXVaZWg2VGplYlY5UGExSS9Lb3REcHRQVDdIOFgvRkVhUm5iZTZkYlhFYTlNN2NvMWVTZUhyQnBmaEw0eTB0OTRhenU3MUJHUjNCM3J6NjE2bjR0dm83TDRtZUZOU2pjSWw1YXpXTWg3SGVONjFoK0ZkTGd0UGlCNHUwcDVmTVM5aWl2WTFKd1AzZ0tOK1ZiSTVHMm9jMTlxY0ovT0Q1VGt2RXVxNmhONEc4RWExNWFxYlM4czVpMk9OckR5eVRYc09vM3NGdjhYZkRWMmtiUmpVTk11Ylp4MDNQR2Q2bjM0cnpqd25wejZ0OE1mRTNodkNQUHA4MTFDcEp5UnNPK00vNFUvV3RSbnY4QXdCNE44U3BBMi9Tcm0ya21seUFRb1BsU1pBN1U0N3V5TFVMVDVWcmVVNEwwbXJ4UFl2QlVTUmVPdmlCcGJ3Z1JYWGszaVJ5REc1YmhOalkvR3VGMERTYnpWdmducnVqcmdYR21OZHdqZGs0YTBrOHhBUFRJSEZlcDZ6ZFJXWHhVOEk2cnR4YjZwYVM2ZTdua2IyL2VSRW4wN1YwdWdTeDZOOFpQRXVteWpiQnJObkhxRVNFWUR5Sis3bEFQZkk3VlRrdFhiV3lmM0Z4YjVGSmI4a0pyMWcrVm5GZU5MbU81OEplQVBGOXZzVkxXNnM1WnlxOCtYY0R5cENmb2E2alVWR2hmR2ZSdFFGd0d0OWFzWHNpQ01Za2l4SWg5OGpwVmJ3WG82My9oanh2NEN1dHU2eW5uanQ5dzVNRnptU0Yvd1BURllqU1gzaVQ0TzJtb0xEdTFydzVPcnNtUG1NK250dGtVL3dDOG9vNk5hV3ZiNVBZNkl3cHBxS2Z1M2NML0FOMm9yeFo0RDR3OEltMCtJUGkrQ09QaWJicUVTZ1lFa000Mnk0SCt5MVZQaDVjeGEvOEFEVFd2Qzh6N2JxdzgyTzNZOW5qUG1RdFgxcjQ2dWJHYlQvQ0hqNnpoRTFuYWJmdFlIVTJWNkFzZ1ByNWJjMTh1K01mRHgrSHZ4SXN0WmkzRFJ0WXhDOGljaU4zK2FOdU8xZVJXakpPNjlmbWp1cDgwbEhWODJqWGRTaG8xK3A2WDRrMUs4OFRmRG53NzRxc2h1djhBUTNqdUhoSExaZ0hsM0VaOThaTmRscjE3WmFaNGg4TGVPYlpnK21Yc01kbnFMb1Q4c00vTVV4LzNHNEpyZ3ZDZW90NFY4ZlBZU3d0L1kvaUtScGJOcFB1TGRrZnZJam5vSkJ5QlhmOEFoLzdEb09yYWo0RDFlUE9rYXVrMG1pU1MvZEtTZjYyMFArMGg1U3NGeXRYVzFycjBaYmNZM1c4ZFdsMWNaYnIxUnZYS2Y4SWY4UlRjeUJZOUM4VXlLa2pNQVZndjhZVXQyQ1REdjYxeXNaMC93VHFsOTRVMXhFZncxckJtT21UemY2cUl5Y3kyY3A2TDZvYXpkTHUxc29kUitIbmpPWlpyZG9HT21YMHJiVnVyUk9RQTU2VFEvblh6N0hyTng0dmp0dkNuaVBXMS93Q0VkVzVhSzIxTXhHT1RWUEs0alFTc05xbGVoYnZRMUhieVYvMGE4elJSdW5xM2FLdTExUytHUzh6bHB0WmJXVnQvREdzNmxPZkJjZDI4TnJyRHhFRzQySDkzQThweUZWZWdmdlhYK0xmaFhjd1dOdmJYMmhEeE5wRU1ZVzB2TEpraDFTMmk3S2Y0WjFIYXZXbWZXdkJHbXZvK3ZhWSt1K0Y5bmxSM2NVSWVhM2k3SmN3Z2ZNbzdPS2cwSHd0QzBIMmo0ZStOWTF0aWQzOW5YUDhBcGRzbit5b3o1a2YwN1ZuS1MrTHBmNWZoc3pDVDE1bFpLK2p0N3I4MjFxbjNQeTc4VC9ENzRlV1VKbHMvRXQxQk1aMGpOaGYyRHdUSXJuRE1UOTA3Unp4MXIxVHd6OE9maE5iWEk4dTYxanhOY0RCVzNzck5vbzJQb3p0MEg0MTlIL0dIVS9paEhwVnZEcS9oN1I1VUY3YTdaN1dja3M0YjVRVmtHUUNhOXkwMjQrTTJvaFk0TkowWFNGQkdaSkptdVNQb2tZQU5RNUoycysrMGtQbm1vUmJsdmU3NTQyL0Jma2NSSjRLazFMUjBmeFpGYTZINGN0RjN4YU5ESnRYam8xeEtPcmVpanZYaitnYTNNbXNhUEhyOXhlandWWjNNajZSY1hVTzFaWGo1akZ4MzJML0JuclgwQnJ1aStFZEhtdDlROGFlS3BkY3ZvMnpiMk8wZVdyZGhGYXg1eWZRdFZhLzhQYTE0OHQybThTUW5SdkRrUTh5UFRta0NUVEFEaVM0WWZjVWRRdFBhM1ovTDdyOVJOeGpHL1MrNjB0ZGZadnEzNW5vUGgrL2c4UjZyZStPTlZVVytsMkVFa2VscklOdjdwZnYzTEE5MzZMN1ZtK0hkWWswL3c3NGw4ZmFwYm1PYlV2OEFqeWljWVpiV1A1WUk4ZjNwRHpYeXhvMnZTM2VvNlZvR3E2bk8vZ3VHOVpiSy9taU1hWFpqNVNDV1Qvbm1EMEo2MTllMnQxSDQvd0RGa0V5WVh3djRmazNSbkdJN3k2akhVZjhBVEtMdDcxdnFrN3JmOHV4RHZHOTFwcGUzU0tlaTlXOXptSllkWThML0FBaWEzSnpyWGlHY3FRQmh2dEY4Y24vdmhUUjQ3czJoc1BBM2dxemtVZ3ZFOXdPd2dzeHVZbi9lYXVpMGkvSGl6eG5kZUpwMkM2Sm95eXhhY3o4SkxML3kxdU9ldzZBMTVYbyt1eHlTZUlmSEdwZkpIT3JRYWNwNEsyc1BSaDd5R3IxdC9XNCthU2JUM1RiZitLV3krUjg5ZkhUeEpITDRpa3d3OHZTTE4zSTdlZEx3RlA0VithbXA2aHF0NVBad3ZjeUdTWkZFZ1U3Ujg1NFVnZWdyMkh4bHJWMXF0K1k1YzV2WjJ2YnM5TVJyOTFmd0ZlT2FkTVpiKysxTmx3bHVwZGY5NXZsUmFUZHRDdVZSVVlyb3JEN2RFbDhUTjNqdHR4UGY1WVIvaUt6OU9sQzJlc1hKNnZHSTErc3JjL3BXcHBFVFJhUHFGMHgrYTRQa0o3NStaalcxZGFNc1dpV05xb3hMTzVtWTkrZmxVR3NwVFMzT21HR3FUaHpMcmRuR0dRdytHMFRwOW91aTMxRVl4L00xbzZsQ1NkRXN3T2ZKUWtmN1VyWi9sV3ZyR2lYSDIrdzA2SlMva1Jxa2hISHpzZHpWQkd3bThUenpsR1dLM1YzQTZZV0pjRHI3MCthUGN4bFNuQzZjWDBKbWxXZnhqUEtwR3lFdWZvSWx4V0ZaU01tZzZ4TGs1bWtpait2SlkxRHBzaFN6MWE2YnEwZmxnLzdVaDUvU2x2RDVQaDNUNGNuTTBza3pENmZLS0crbm1aM2R2eExsK2doOEs2VW1mbW5ubWx4N0Q1UlhXWHNSZnhkb2xxdi9BQ3dpdFZ3ZTIwYmpXUHFWc1gxVFE5UHdmM2NNQ3NQUXVkelZmdDd4WmZGdXEzdVR0Z2puWlQ2YlJzV3NXL2RiOG0vdk90TmN5WG5GZmNaMWhNWk5iMXU3SjRTRzVmUCs4ZG8vblhVYWNXdHZoTnJMOGo3WHFkdkdENmlOUzFlZjZhM2w2RHE4eEp6SjVjUTk4bmNhOU8xNjJlMCtHbmhLMEJ5OS9kWEZ6dDc0eUkxL091aWx2UFhaV1BOeGN0TUxIck9wZjdyeS93RGJTMTRtZ2xiUi9oM3AyMFplMjh6YVBXZVhqUHZYcWFwRGMvSDV4SWZManRIYkpBenRGdkRqK2xabW8yWnVQaS80YTB4VHhZUldjUkg5MHhKNWpWZytHTHdYSGl2eHRyRWh5SWJTOWt5ZjcwaDJpdlhtdmVmK05ML3dCSHoxQk9WSG12bzhOSitkOFJLNi9JOXAvWjBnTng0cXVMci9BSjZYN01EL0FMdVQvV3ZzYjRsWEhuZUl0V2pBemkzczRNZXU0bHNWODdmc3phZHR0YmFVZzduTXNnSTkrSzk2dlFkUjhmdkg5N3pkVFJEOUlWcWFhL2MrdHpzNTdZMnJMdFovK0F2L0FJQitpdndMOE12cFhnR3hFbjMyM3V4STUrWTV3ZnBYdjFuRkJDck9Ob0JZbjg2dGFEYXgydWlXOFFIQ3hnWXJnTlkxQVc5dE0zbUJkb09LNFplN0c1OUhRZFRFMVp0dHR5a2V1eFhrYkE0WUhpdnlQL2JaaSsxNmQ0YlNDT0kzRDNMa3VXQ3RzUWNEUHBrMTZ6Y2ZGeTVpdDVyT05zUHZZYnp6eDdWOEIvdGthdFA1dmdleFppMGk2V1ozQko1TXJWalNyS3FwcU9qVUc3MlBjZVh2Q1M1Nmp1bXBxeWVyVmo0cGw4SytJSGx0NGhaeEV6T3FJUk1wR1Q2MTlGMkh3cWJ5SVJjT0JJRkc4S2NybjYxOGpXMnEzdW5pMXVJbkVjc0JWa1BKeVFjODVyOVA5QjhVV045cEdtM2M3QXZQYm83a0hhQ3g2NEhZVjlEa21IcDFWVVZlYWNsYTNSV1B5N2lhdlh3OHFFNkViVTNkTlBWM1BucWI0VnhMSXdEdGpQWFBiNlVwK0ZJR2RzL1Q2a212cDF0YjB6em0yYkdERUg3MzZWRWRjc0hJSWtpakM4REI1RmZYZjJmZ3UvNG53anpYSFBaUDdqNWZId3JSbVVpUjhZL0FWTEg4S0k5L3pYRGhjOEFWOUhycmVuamp6VkRoam5MZFI2VnJ4NnZwQWpPV0FZbk9kL2YyRkN5N0I5L3hJZWFZOWZaZjNIelUzd3JzMm1VTExLRngzOXZlcDIrRlVLWS8wZ3lESGJQNjE5T1BydGpNZ0tNQVZISXlPZmNWR05XMHdSSUFlUURraHM4L1NyV1dZVFRyZnpPZDV0amxKcHUxbDFSODNYSHdyaFJPTGlUUDkzc1BwaXFjZnd2WUVlWmM5TTRIWEZmVWcxcXpVcHRtandUM3dEOURVY25pRFM1STNWdHBLbmpEWXJUK3pjRW50K0poTE5NeFdxbC81S2ZMNy9DcFZoakszOG9MSGxRT01WWXNQaGxiSks1YVdSOTNROU1HdnBtRFh0SGtiYTJGQTdidU9LRHErbEM0WXhxQUQwdzNGWnZMc0hmL0FJSnNzMHpGcExUejkwK2JMajRiRXlZKzBFQWRCV2Uvd3BSLytYcnJnblByWDByZGF2WUNSc09PZlU1eFRsMUxUQkdTMDRJNjV5S3YremNKL1RJbG1lT2c5LzhBeVUrVkpmaFFDd1AyMWo5QnhVc2Z3c21QbUFYUndvL1gycjZYWFY3QXhiVktzUE16a3VNL1N0bGRhMDFRUUFudVN3elV2TE1IMy9FaUdjNDUyNi85dW56SmIvQzNiQ2N6a3lIdVIyck11ZmhneHdmUGZHY0hwWDFqSnJtbU1oK2NFNDVJSXJuWDFQVDEyRVNxZmJPQ1RVLzJkaExML00wbG5HTVV0ZnVzZk92L0FBcTZGV0QrWS9QQXdjMEg0WFNCOXduWUFIQzhaT2ErbEUxN1RvMVhsQ1FUMU9NWitsYWk2MXB5NFlxdk9PUS9IMXB2SzhJdXY0aC9iV01TMlgzSHlXbndzbFhwZEVnazgrcHEyZmhhUnRaTGtsODlQV3ZwbVBWTk1hUmdwWEFJNExjZm5WOU5XMFlTRUJRemcvd3VNSDZVZjJaaExiL2lDem5IUGRmZ2ZLeCtHOTRHUG1UN1ZITzREUDRZcWpKOFBicDIzZmFNN3Vja1lyNjQvdFBUWCswQWtLUjA5aFdYSnFGZ1FvRGdBZWxRc3J3NysxK0pYOXM0dEsvSmY1SHpWZWVBMWQyQ2dIMUk5YTU1dkFSVnNGTVlQclZFK001Um41bXozOTZyM1BqcThTMmNxeEpBeU85ZUdwWmZhN2l6Nmx4elJ0SlNqOHpyWS9oNEdRbmdIcUJVZytIUUdkdyt2cFhQNlI4UTVaYlJXZVFrNHhoaGdnMXV2NDlrTEREbkhUcFd5L3MxcE96TVp4emVOMG1ycnlKZitGZktTTUxnbmppcGg4UEFEd0JrZTlNVHgzSXd6a1pGU1RlUFo0YldWMHdYVVo2ZGFVbGxxMU1ZeXpxK3ZMdVNOOE5XMmdrRERkTWQ2akh3Mko2RGpuUFBURlZkTytKVjNkMlN1WmVNNHdSakJIdFdsL3dubzI0M2pQUDYxVVZsa3JPNys4dHZPVkpyUjIzTTAvRDlsZGhzR0Jqa25pcHg0QUc0QXN2V3JpZVBnQjk0WjdacTJmSGt6c1B1QUgycStUTFV0MlRLZWFiV0tLL0Rwc3FRTWs1QXdjVkt2dy9JMms1SFdtWG54SEZuTkFqeVJxam5nbm5uMHJvbjhlRjBqK2RjQVlGSkxLbW5xOUROck9ZcE5wYTdHZS93K0NNdTVDZU9PZXRiYStCTFZvbHlDRDE2OXFvcDQ1ZVJnRzJrZEI3VmJtOFg1VlYzQUJlbEwyZVgyMFpuN1hOYjY2Q3Q0SHR2TFVGWEkrdjYwSjREdE5wNXlNZXRJZkZlNUZ5NEdLNTdYZmliSnBOZ0pJb0k1UnVBWUU5TTk2VGhsMFUyM29qb3B5eldUU1N1MzZIVHcvRCsxSU85VDE5ZTN2VEpQaDNiNDRRNUo0NS9LdFN6OGV4VFFySVF2S3FSZ2NZTlh2OEFoTW9pL0REam4yL0N0VlR5NytaVzlUbmRUTkUzcExUeU9idXZoL2JvcUFxNEk5ZWFsZytIYStYZ2h5TzRCeGl0dytOMWJqSUpCNUpyWC80VGFPUkNTVkJ4L0t0RlF5OXBlOHZ2SldKelRXeWQvUTVoZmh0YnRuNTN5T3hISXFkZkFzVWNicDgvSit0ZHBGNDJpOHRjU0prQW5QZXFqZVBJSTc5YmVRd3hNWS9NakxFZlA5TVVTbzRDTnRWOTVQMWpOSDltWG5vY25IOFA0Titkc2d3Y2dldFdyM3dPa3R5MGczQUVEOUs3S1R4akJzUWxreVQvQUFpZ2VMNE9RZHZQT2FmMWZBOTE5NVAxak1rL2hlbmtjVTNnQkN1ZHpnK3ZCcW1QaDhXWUh6SkNPdjFyMHIvaEwwTVdNeDQ0NXhVZzhXd2hRbnlINis5U3NObDdlc3Z4Sit1WmsyN0ovd0RnSjV6RjhPNE9WZVNYSFVkcTFZdmh6YmdNL21IYnRQditkZDJ2aWFFc25LWjZEaXF1citPN0hUYlJET0RzZHdDeWpPM1BHVDdVU29ZQ0t2ekszcWEwOFJqNU8xcFg5RGtJZkFGbVJobWY2MXJSL0R1eTh3TnZjQWZTdXp0UEV0cEpHanJzY0gvT2EzN1h4RmFPUzIxUGw3VTQ0WEJ0YU5XOVNKNHJIcDIxVnRIb2VjM0h3N3MzWWJXWWtkODFQYmZEMkVibFozSUM0NjhWNk5KNGtoRXUwQlYyZ2REVmx2RVVRakh5cUNlNDlxSGhjR3UzM2g5YXgzTXJYdDZIamszdzdneW1YYzVHQnp6VVVmd3dpQ29XbGs1N2RxOWJpOFQyNDNFaGM1Nm1wdjhBaElvR2p5ckp3ZWNFL25UV0Z3blpmZWF5eG1MVms3L2NlV1FmRFNBT05zc3JZendlbFNKOE5ZanYyU3V3QjVCSEFyMGIvaE5iYTBualFqYzBod3JaNDNkc24xcmZ0ZkZjRVlkbVVNR09Uemptb1dId2I1ck9MYTg5aFR4T05qeXQ4eVQyZktlRG40YlEyNVp4Y080UEJ3ZjBxU0Q0WFJzck1ibG93ZjRUMHg2MTdKZDY3WVR5Q1IyWGdjQU4rbFRXdXMyb0FlTUFBajV1ZDM0ZlN0WTRMQ3YvQUljNFpZL0dyUjN0M3NlS044TkVWaUZ1RHlPdlhPS3ZXZncxdHZ0TVplNDNZY0VqSFhIYXZXcGRadHZPZHc2bmR3RkIvU3VxMFZKTG1GNXM4RmlGOU9LNklZSENPU2ExdHJ1UThmalZGM2JYUmFISGVPTlV0dEs4T09pNVZpaHowd1VVVjhKd2VBMzFPRkwyV1RCbkpmQlBJVW5qOGE5dytKK3BSMzJzMjFnSkFJM2xDdVNlaUx5YTEwdllpOFVkdkdzaHdFampqK1l0NkFDdE1YR2pVYlZTVm93MWV0dFJaWjlZU1ZTRk84Nmp0R3l2N3EyWHpaOHpYWHd1UU95aThiQTZWUEI4TlVpSUl1V0krblQ2VjduRHJVSDd4VEVWWU9RUkp3UVJ3YW4vQUxYand3NHhqQUFOZVI5VndFb3FVWnBwK1o3VXNabUtrNHlnMDEwc2ZQVC9BQXU4UzY1cnRscEdqUW01dW5pbG4ydXdRS2lkV0pQU3VBK0gzZys2MWJYOVdnbkloa3NYYU56ajdyNXdRY2ZTdjI4K0F1aUt1bDZwclVzWU1rdUlVY2pKOHRCMEI5TTErZUhnZXp0YlBXL0c4cXFNVGE1Y0x1SjVLS2VuNW12TmpnNGZXa3VhOGUzeXVmUTFNd3FRd0hLbzJtNFgrYmFSbGo0WFl3VnVWRERwNkduTDhNRlhjeHVEazljNElyNkVGMGh0MlFjWVBEQnNZeFNTM2V3QlNCaGwvdmMxNjBzRmh1WC9BSUo4cDlleHFmOEF3RHhheitHSWtqd2J4Y0QycXczdysrY0t0d2NnRHQwejZldGV4UmF0REdUdEtqa1o2ZnlxOE5mdHQ3VHlJN01vd1NxNUp4MndLd2xoTUtsZTlsM3VkVkxHWXVlMTVPK3lSNWphL0RwNVdhTnJoUjJ6MHpXMUY4SnBvNFM2WFNaYk80WjNNQjYxNmJwbXIyanhDVlYzZWFOMlN3UFd1MGgxSEcwcVFNam5rYzEweHdXSGFYK1p4MU1YaU9kcHArbGp4YTArRHQxTkdTTlNqaklia01BS1c2K0RWNEhJT3B4Z2RBRlVFZmg3VjlBblVKWkl5ZUNjanNPbGJGdnFFVVNBaUVzM1U1SUhQdFQrcFVVaFF4ZGE5cjI4N0h5Vi93QUtodTR3VS90QlA5cmN1UnpWTzYrRDE4a2lyOXZqS0hrTUJYMmJFMXhmaVZJSUMwMGNUU3R0SU9FajVKOThlbGM4OCtRa3FibXlCdlhIV2hZS2gwZjRta3NiV1RYdS9PMzNueXFQaE5xWWlaVjFSU3ZvM1Q4ajNyb2JiNE1hdXFqZHFFWkJVRU1EaklQcUsra0htbTJueTRqc0l3K2NFajg2MllyMk1CTjVrTzBZNmdkS2lXRHAyMHY5NExHejF1dndQa3lUNE5hOUxLb1c2aTJnN2NrNDU3Y1ZZUHdWMTVZbXhkUkVrWUtnZ1o5NitrSnRYaFc4M1NSeWZ2bE8xOWgydGowUFFtck83NUF3aGRTcmJ0eE83UE5KWU9rMThYNGx4eDAxZGN2Nkh6OTRmK0E5N2Y2dGF4WGQ2WTQ4NGxlTDVuMkRyZ2V0ZlJrUDdMdmhoNWJoZjdkdTRWR0NqSGFDd1BxSzdmd0pxZW1mOEpibVNUeXBYaktvamZ4bnZ0eDZWOVNYdDViUjNzS3NBV2xqeEh4a2JzOURYNXRuV0xxVU1jcVZPdHlxTVk4eTgyZnNIRHVBbzRqTGxWcTBGT1U1UzVXKzBUNHFmOWxqd3FuempYN3RnRXpJQXlkUjZlM3RYQzJ2N1BYZ3hkU2pqT3QzdXg1Y2ViOG8yanVDRFgyanJkdExhWGxzdG9qekZzN2tZRmkyN29GSTc1cnBOTzhHUlc4RWsrcnpKRXJZZDR5ZVV4MDVGZkRQTXMxbmlKVTRWSkwyY3ZlZDlQdlAwU25sR1JVOE1xbFdsRnVjZmRpbDcxL0pYMVBoTFZQMmN2RHN1cDJsblphMWVpU1NUTzUwUWd3b2ZuYmpvZlN0S3gvWno4UFhHdUxIRnFlcGZaUE1LdStWQkFIY0VpdnZuUjVmQWEzczF4YXlOTExFQmJOSTVZQlEzemJSbjFwdXIrSzRiVzhJait6QzFoWGU4Z09CZ0RKR2E5TDYvaklSaktwaTlPYmFPdW5ZOHRaWGdKemxDR1g2OHU4azFyM3NmTThmN0tIZ1lEQ2F4cVpPVHViZW5VL2hYZ21zL0FId1paWGw5RkplNmptTEJWd1FxRW50MDVOZlUramZIQU5aeUc2c1lzdktmS01lU0FtZU40SE9jVjZtczJxWGl3elR2SExiZytiRkc4WUtzR0hUMXhYVFV6U2RTRWZaVjVLWFhSNmZlUlR5R25oNmtuWHdzSEJxeXU5L1N4OER2K3o3OFA4QTdIWXluV05RODJWWDg1VWxUbkI0QnhUL0FBNThDUEEycjNaaVFha1lZQVZsbDg4WnllZ0hHSytqUEV0Zy93RGI1a2gwK09BQ0V2TUlWd3Fuc3grdGZSWGdqVDlOdFBERnViVk1lYWZNa1kvZUw1NUpyR0dMeDFXc2w3ZVNTMWV1OWpycjVkbFZIQ2MvMVNFcFR0YTYrRzU4STZuK3psOFB0TU5sSzF6ZlBBMDZSeWg1ZHJMdVBCR0JXMTRyL1ptOEZSMjZTNmQvYUpZRWxsKzA3dHc3QVpGZmZPdHZaRTdYQ0hiamtnSEI3WTlUWG1xWE1rMGtubHNTeU1SZ251UGJ0bXRhbUt4Rk9VazYwM3pXdFo3V09DamdNRlZqQ1gxYW11WGRPTzl6NGwwTDluVHdCZTZQTDlvR29DNExrRXROZ3JqdGpGYWw3K3pyOE43VFNvNW5lL0JWMkxzYmorQkJ5ZWxlOTIzaTd4SEhyRW1uMzFsQ2Qveld6Yk1aVC9hSTdpdVcrSkdzUzZaNEYxSzZ2dGlLc01pcDVHV0lhWGhmdmRQZXVlbm1GYWZ1cXJPVFdqM1dwMlZNcHdzWnB2RFU0eGJ1cmFxeDh3Nko4S1BoenExbEhkVzBPcXlMS3orV1BPQ2xsUWtBOGp2anJYeXg4YU5EMHJ3dmNwWldobFZwTFR6SkVkOTVVbm9PZ3I3ai9aOTFxSFZBK20zRUpqbHM3WGVHQnp1UThaOWlEWDUrZkhmVWx1L0h2aUFseXkyNnh3STNYb09hNjhIUEZPdTNPdE9VZVdlamQxcG9lZm11R3dOT2hDRU1QQ05SeWg3eVZuM2Y1SDV3ejI2d3pFc003c3RnMWp0Z1p3Qm4xcld2NVRKZlNnWktxY0w3MW1CUms1NzE3TWIyVnp3QlYzWTNGcyt4cnVOQ3VZclpwbkRsTjdLb0hYUHFEWEJzQ0s2TFQ3cTBTR1NLYUZteVZaWFQ3eWtkZUtVbHBzYVEzUFhZdEZsMW04My9BR3FFdEdQOVZKOHB3UHBXTnEvaHUvYU4wOHQxUUVuNWVsY0RMNGgxSWFpa2lqZUNSdFlMdGI4Y1Y2dmErTWcwa2NVOHBaODRadTMwcnk1ckV3bW1yTlcwWFk3WXVqSk5PNmQ5KzU1WEhwOHNXbVhrYVNzWEdHS2s4Z2ZTcFBEbWt1Wml6WGFvekFIYVB2RVZqNjlleXhhek5QQTVWWEo2ZERXeDRia1NUVTRwSkR0WWRBQjFydWZQN0tUdnVybk5GeGMwcmJPeDZmZDZROGFFc3diUFFudlhGUGJFT1JqQnpqclh0OTRVbGgvSHJtdk43eEZSaDlLNHFVMnpwcVFTMVBOYnVGMVlrZ0h0VVdqdHMxR0ZoMURqclhVM0hrWUtzcGF1SGlrUkx2UFREZEs5T205dlU0MnRUOVFOT2xXOThBUkk2aGpMYnVPVDE1UDZWNTVwK2s2aEhCQ3MwWGx2dEIyWTdIK2xiM2d5Nzgvd0xwcDI0L2R1UDFQODYvVFRSL0FPbCtMUEFmaCsvaktwTkZiQ09SbC9pS2NjKzRyNlRNdVowc1BKYSs2ci9jZWRrRTZjTVJqSXpmTEYxbnIyMVo4aWZEMmVXMzFlM3puZDkydjFlMGVSWkxSZWdKV3ZsM1RQaHJGcHR5a2dZRXFjNUF4elgwdnBZU0NGRXorUHZYRGhhamxDMXJXUG9jMVZKcURoTG1Qa0c3VCt6L2lwcmNHUXEzOXBITWc5V1RnMSthSHhrc0RhNlhLNUIzYVZyZ2tIdEhNZjVWK24zeGJnZXg4V2VHTldVNFVTeVc4cDlwT2xmSUh4ZThQUjNjMnRRZjhBUVIwNW1qR1ArV3NISXIyYmMxTGZVK0NuSlJ4RVcxbzRxLzhBMjY3ZmtlSTZUcXNaRVVZa3d5c0NBUGZrVjdzK29UeTNObElzZ2lLd0dObVRuSTZqTmZCZW42L0RGWitIcnVVWUVpQ0tidDg4SjJuUHZYdkxhcTl2NGlTd0xZU2JCaWN0L2ZHUitOY2JuZC8xMU5vVTdKK2ovd0RKZEQyTHcvZlhWanIxL0dmbGh1UWtoSkdjNStVOGQ2cStIZFpnYndkNG84TXpLWEVNMXlzUjdoWCtkRGp0elhsZWs2ekxjWC9seU93a3R5Nk1HNXlCMUlQclZyN05jMi9paUM0VzNNMFdvd21JRlQxa1QrdUs4NlZTU2s3clpucFFweGZOM2FqSmVzZitBZWlhMXE4bXRmQ3ZTZFFTY0c3MHVXR2JyeXJRSGF3NTc0cnA5UzFCclh4SjRRMTNmaGJ0VGFYRGp1czQzSWVQUTE1Vm92aEcvd0Q3VDEzUmlqSVpWRXk1YkNtT1FlL1htdlEvRCtneWExOE1OVjBPWWlQVXRIbGRZbnp5V2krZEQrSTZWZnQ3cFhZT2xUVTNxclhmeWpVWDZIZjZCZjhBL0NPZkZIVUxLTnlZZFl0MW5Edjh1WlllR0Erb3EvNEloczdtVHh0NFBkUTZPOGt0cnVQQWl1aG5wNkJxOG0xTXphbG9Ha2VKTGU1OHk0MHg0WjJoWWRWQTJ5cVNlOWQxNGc4UWFSYWEvb1BpaTB1TGNIY0xXN1JHRzVvSnVqWTc3RFZmV2JOTHYrZ09pN3F5dStWSnYrOURaL2NlaFdyYXI0bitDOGtlUTJyYURNQVA3MzJqVDJ5QVBUY28vR3V2OFc2ejl1OE0rRXZITnVSSSttUEhjVHhyem0zbitTZFArQTljVjRYQjQ5MGpRZmlEcWJ4NnJhQ3cxZUFTekFTcVZpdUl4Z3NjZE53cmkvRG54UDhBQ1dpSHhCcE54ckZ0THBFa2p5d1NCdHlCYmdmUENjRDE2Q29kZDNmdXZ2OEE4QTZGU2hkU1cxM0szOTJla2tmY0hpclZ0UDBMeG40WDhYd3pCckhVRVhUYjl4MDhxYjVvSlQ3S2VEVXNkMUY0UytMc3dKQTB2eFd1Um43a2QvRU9SNllsWDh6WDU1YWQ4WmZCU2VDTlMwSFZkUmFmVGxhUzN0TGhJbWNtTS9NZzltVHRYTGFsOGV0QXZmaDNhYWRxalhjMDhYRnBleFI4aVMzUDd1VEpQRCtvclJWM3M0dnQ4aE9pa2tucXJPRGZWeDNUOVVmcHY0VmZUdEI4UStJUEExK0ErbDMwVTEzcEt0OTFvSjgrZmJmVkNjZ2VsY1hvZHJaYXJvT3VmRGZ4RzRlV3lqSjA2NFk0YWF5Ym1HUkQvZmlQQnI4enZHWDdRVGFocDJpeXoyRnd0L0I1YzlwcUViQUFPdkRFZXgvaVdzRHhsOGZ0VnViL0FFYTdiVGZLdTdVckxhMzhjMmR5Tjk5Y1k1VTkxN1ZFNmszODkvVmRUYmxidTNKSnV6YnZ0TmJTK2ZVKzN0SnQ3alZ0TDFUd1I0aHVXajFQVGlyV3R6L0V5b2YzTnpFZlVkOFZ4RjVMcXV2cmVhVjRyMUlXZXFhSkh2OEF0UmJFMGpaL2RUMnFqQXgvZU5aZHI0dWcrSU9sUTZyYTNTV090NlFubVJTc2NLeTlTakh2RzNmME5ZcUtmalJkeHhlWmI2WEpwVVI4eVZ2M2swc2g0OHNZd1RCbnFhNG9WTFhWckpQWHlmOEFrd2FrazVPMFZ1MnQ0dnV2Sm03WmVJSi9qRExZZUY5ZXZMV3crd0IyRjlIekpxRXFmS0RBV0FBOVdBNjE3OUhkeGFCcFVmaEx4L3BsdStuTW9oc05UV1BiYVRvT0YzN2Y5Vk1QWDFyeW01di9BQWxjYWJENGY4VDZaL1kycWFhb2oweUsxQmppR1A4QWw1dHB1N01lU0QwcjFML2hPL0V2aDdUVTByeHZwOFd1Nk5MRWNhbEZENXI3U09CY1JELzBJVlVtM1oyK1g2cGpTdkxsNUdrbmRSVDF2dmVMNm5hV0dtL0VYd2hFSmREblh4TG91UGxzcmlVQzdoVDBobTZTS0IwRFY1ZnFGLzhBQlRYZFczNnBaM1BoalZTY3RKSXNtblM3dS96eC9JMzFxOTRhc2ZMMCtXLytIK3NYc0Z1WDVzSlFOUXNEM3dCbmZIOU8xZFBEOFRQRjB6bTAxLzRaM1YySS9sYWF5alc1aVllb1Nia2ZTcFRWdDlmSjhyS1hNcnRPN1dqY1h5UythZWpQbnY0b2VINGwwYXhiVHZpUmVYOEl2clVMSExjUTNHM2MrQTRZYy9MMTVyMXVMd3hvTUc0YTk4VnRRYUU1M3gvYm9iVlNQUW1QSi9LdkN2aXhlL0I2NDA5UEo4SzNHblhmMjIyTGg5Tmt0bTJidm5Va2NISTdWNmxwL2lINEp3U29kTjhEejNjcXFwVVJhTzViSTlUSnhVdE5KUFc5MzBSbzFKcU9rOUc3KzZ2STZuUnZFZndzMGgzajhJK0dybld0UllrQzR0NG5jc2ZXUzVtNkQzRmF1bytHTlgxUmpxUGp2VW9MVFRZU0pCcFVFdUxjRWREY1NuQmtJOUJ4Vy9ENHErSm1xSHl0RThIeGFSYnNNTGNhbTZvcTU3ckJGMXJsZGQ4UGVHTkprdDlWOGQrSmpxOTJyWml0NWNSMjZrZEZodGs1WStoTkNhY3ZQMXV6Ryt1K3I2ODNQUDhBRFl4OVpndS9pU2JiUzlOczVMRHdyank1YnN4Qkd1MWo2TEFqZmRRZjNxOGZnMSs4czcyUDRmeDY4ZzBCYm8yMzl0S2hRbVBxYk11dnkrWWVoYnZYMHBLUEZ2ajJKWXhiemVIL0FBOHE1UDhBeXp2YnRCMkFIK3FqeCtOZVUrTHRXMFBWdE1rOEYrRnJLM05qRXFwZTNoVUdDMjJuT0VQOGMyZTRyWnphYVhUMDJNZEx1T2l0clphOHZtMzFaMnZpN1VMUFhHdGZCV2drUTZWWXBIL2FrOFAzRWpYN3R1cEhWbS9pcjVHK01Qam0wTUxhWGJiVTAvVDFRVEJPbTVlRWlYMTk2ejR2RStxZUQ0SnZDVnJjVzBqU3lsb3RSSjJGVms2bWYvYkhZMThjK0tOWXNKcmhZNDNhU3h0SkNTeDYzVngzYjNHYWlNbTM1ZFA4eldFR2xGM2VtcTg3OVdWZkcvaW1UVTQ3VWkyU0NTUzJqaUNJZ1UrVXZUZGpxekhyWG5sOHMxdFoyK21JRDVydUpKMUg5ODhLdjRDdFN3bFBtVDYxZWpkc2ZFQ0hvOHZZQWYzVnFHekRSV3R4cTl5Y3l5T3kyNFBWblBWL290YVhSTFhNL3dDdGpmdGZKazFTeDBwUG1qaDRrY0hqZDk2Umo3Q3V6dDlZMDdVTlhtbkRnUlcyU0FSMGpUZ2ZuWGxrS3RwdWl5M1VuL0h6ZkFwRm5xc2Y4VC9qMEZaODMrZzZNa09DSjdzaDVQYUlmZFg4VHpXTXFha3p2cFl1clNTVmsxYmF4N2hZQmZNdmI4a01TRHQ1ejg3OS93QUtjbHJHdWtYRE1vTFhCMllKenVVY212SHJ0cnEwZ3NOTnQ1R0VyRVNTaFQveTBrNkwrQXJxNWRZdlpOYXROT2laSkk0ZGtUTVIxSzh1d0lyRjA1ZEdlcERIMFo2VGhicDMzTnZVZkM4UjB1enRiZFRFODhubWtkZXZBQnJDMUx3L2N6K0lyUzJqVGZiMjRpaExEKzdIeXhJcnM5UDhWV2wxcTJvWFVpRVFXY1paR0p5TUw4cURIcVRWdlNOUnMzdGIrL0V5a3NwalFIajk1SnlldmNDcytlcEZhcittQ29ZV3E5SkpYN2FiSG1kaE9ibnhKcXVvdHdsckhMS004ZEJzUVZrV0MrVjRZMVc1ZHNOZFNwQ3BQZkIzTlhxODhkdEg0YlpIVWVaZVNBRTQ1OHRPblAxcm5OWTBMZEZwV2xXOGdEY0ZnZVJ2bFBXbDdTTXJKNmFyN282bk5QQ1NpbTAxS3lsOTdPQ3VvR2k4UDZaQW96SmRTdExqMUdkcTE5SmFycEJ2ZmliNE84UHFNcnA5dGFST093S2p6WHpYTWFONGVmVXZpWnB0aVFEYTZjRk1qRGtDTzFHOXZ6SXJWOE02dkxQcm5qcnhaS01pQzNuV0U5QUpMaytXbVBvSzkzQ0pPbkdUKzFPL3lXclBqTXhjdmJTakZlOVRwV2ovQUk2bnV4L1VmNGIxTkxqeDE0eDE5ejhscGEza2lIM2Y5MmxjWm9hdGFmREx4UGVINzk5ZFc5b2g5Y0hlMVNXSWJTL2hWcUU4a1dKTlp2a2hSejFNVnY4QU0yUGJKcm9MMnlLZUgvQStpQmZubmthK25YMTh3NFhQNEN0Wk44cWV0M0Z5ZnJMVDhqV0VJM2tvcjNmYVFndjhORlgvQUR1ajlEL2dGcEFzUEQvbXV1UEtnVDhPTnhyb1BocmJQcVBqYTJsR0hKbG1tUHUwamNmbFhRNk1WMGo0YjZoTGphenhNQjdsL2xBRmVnZnM5NklKdFlrdUNDUkNxcG4xSzEwVDBoRkk4MmtwTjFaUzNjckg2ZzJvWVdDSVJobFhCNHdDUjZlMWZQdnhDdHBGMDEzaWZhUUNTUFgycjZRa1UrV0FEelhuR3I2UEhleGxKUVdCNmpQZXZQclJjb05JK3B5MnNxVmVNbTlFejhpUEl1cjdXZktqZ1l0SklvWGFEMUpyNVA4QTJ0ZFR0MytMcndBYnZzRmphMnhBT01zaVpiOWEvYXlEd3hwT2tlSWttV0htTTdtZHVCd01uOHEvbXcrS25pRmRjK0pIaUsvbWszQ1crbUs5K0EyQlhMaHFYczZkU1V2S0svTStyekhHZTJnM0g0VkZML3dKMy84QWJURWFSYmlJSHlrWU1jQTdzNHhXeHB2aWpWcldHM3RpTmtlNG9tQ2NpdVMvdGZUUkhGd1BsSElXTWpHSzlDMER3N3JmaUhVZE1udGRMdUh0RW5Rdk1WMnBzQitiQlBYRmVqUVVuUDNMdHZvdFQ0UEhUcEtsZXB5Mld0MjB0Zm1iTGFwcVRTRWVjMmVlYWhPcWFoa0R6M0IrdGZiUThBYUdESVZoTEFrN1NUVlkvRG5TMmNONVBUcmptdm92cUdMdHYrSjhBczJ3ZS9zMnZrZkZyNmxxQWNmNlEyZnovV24vQU5xMzVPQmRzQ1R3Yy8xcjdRSHc4MGN2a1JucU1qQXE1UDhBRGpRRzJoSVdCWDd3eDByU09YNHkzL0JEKzFzQnpiUC9BTUJQaXY4QXRyVjQ1TWZiSEFJN2V0VHk2MXFRSUJuYmQ2NXI3U1B3NjBoWWlUYmpyMTcvQUkxRkw4UGRNVVJueUZ3YzhuSEJvK29ZM3Uvdk01WnBsM041K2g4VXRyT29LNHpNdzQ5YVNQVmIwNUlsY1o0QnlhKzViZjRmYU5NRkp0Rnh6eVRpcmRyOE50SXlSNUtJT3ZKQnAvMmZqTy80aS90YkFhYi9BSEh3bEhxbXJDY0VYRFpGWEgxYlVCai9BRWtuMno2MTl0WFh3ODBXRnQzMlpRUjN6OHZOSmJmRHpTUXk3N1FGYzBmMmRqTDcvaVhITnNBMW9ydjBQaWR0YzFKT3N4eGpIV3M0NnJxYjdtKzB2alBRYzE5dnovRGpSeks1TUFLWjRCcVVmRDNRekcySUFEbnBuZ2ZTdGxsMk1hM1gzblBVemJBUmtrMC91UGhpVFVyM2JuN1F4L3hxV1BVOVFaaHV1VzZldnBYMjFIOE50SStjdGJnQVpBNUg1MDZMNGJhQ2o1ZURkbFRnQS9yVWYyYmpmNll2N1h3Qy93Q0dQaVU2dnFCRzBUUG4xQjYxUEpxbW9qeXkwejR5T2MxOXNMOE45QzNoUkVtTUU4bm5Qcm1yTWZnRFFoOHJ4Wkk5RDYwdjdQeGZWL2lXczB3RnRJMytSOE5ycTk4Y2xaMkp5Y2ZUM3E4bXFha0dCYWNqakk1SkFyN1ltK0hlaUl4VklRR3gwUFUvalJCNEIwbkFEVzNRNE5OWURHUHJkZXBqTE5zdWpMNFhmL0NmRmgxZlZTY2k0K2hvVFV0VFdRZjZRUVJ5U090ZmFOejREMEFNd2t0L0xBOU9RVFVTL0RmUVFyY01UaklQcjlLbDVmakYxL0UzV2E1ZkphTDVjcDhidnJPcWtPeHVYM0hqSGVrYld0VjJvRGNTY0RvTzFmWHFmRHpTM1RlUUFWenozcTJQaDdvMkFTamM5L1duOVF4bjgzNG1UelhBYVdqZjVIeWRMNFh2aXpHUGxTZU0xVVBoalZBVDh2YXZiVjhVV2VSdWlUNkNyeWVKTk9MWkVhODl1bFI5VnduL0FEK090WXJNT2IvZDJ6d3VQd2xxYWpLcGdVLy9BSVI3Vk9ubDkrdGZSUytKTk5MY3dyK0JxNHV2YU9RTXg4NCt0V3NIaHRMVmlaWmhqRTJuaHo1c2J3L3JBSkFRWjc1N1ZOL3dqMnNsZjlVUjlLK200dkVXa3NBREVwOS9VVlpYVzlFa0lHTWo2VVBBVUcvNDZSbC9hV0t2L3V6UGxlUFFOUmhYSGxER1QwcUE2SHFSSksyNUl4WDF0THJPaEl5S1loNzRPU00xVi90UFJTamZKakI1SVA2VTFsOUQvbjhnbG1kZGErd3ZmMVBrdVBSTldKSDdqUDhBU3JqNk5xb0gvSHMySytwTFhVZERWK2U5YWsycGFBU05yTUFCMDdVM2wxTnIrT2lYbXRaZjh3OGo0M3VQRCtveVlFdHR1QUlJQkdjZTlYSU5GMU1ZMnduYnUvU3ZzSzN2TkVZZ2gxNDYvU3RGYnZReDFLZ2c4OGRhbit6SWRLcUZIT0tyM29QMFBqNlBTZFdXVGlBbm45SzZjNkxxVG9DTGRqa1o1RmZTNHZkSGFYdDE0NmRLdk5xZWtoZG9mQkgweCtOVi9aeXQvRkwvQUxUazI3MEdqNVdYUjdza2d4UGtDcU4zNGFublhiTFpsZ2VveCt0Zlc2M09tc1NTeWtIdmptcEJOcCtRQTNKOU9jVkt5OU5XNTBRc3puR1N0VGVoOGx3NkxxRVlDTGJQdHhqSDBvYlQ3L25FRGRNWXI3RmcreFlkbmtUSTZmV25TSFNDcGJ6VkRESEFBT2MwZjJacC9GL0FUemg4MnRGL2VmRmNtbGFrcWgvSWNkTThkS21pdHIxUUEwRW1PZTFmWjR0OU9lUlNKb3lEMXlNWStvcTYxdHBEcmpkSG5JLy9BRjBmMlpLLzhSRnl6aUVZcTlKdjBQaTliSzdFWEVFbWM0emc4WnJKdmRCYVo0Ymg3VnpMSGphMjA5cSs2RnQ5TStaUXllbjFvTnBwNmcvdkVQdC9TbThzbC96OFQrUkVjNmhaL3VwTDVueEtrTnc0VmxnbEJ4emtHclJpdWNrYkpCejJCcjdJRm5wM0FKVHJ6a1ZiV3cwc01DenhubnRqcDlhVHl5b2wvRVJuSE42ZDdLbkkrTEhodW1VQUpJUUIxd2VLcjdMMWcyOUpSajJOZmRpNmZwb1FrR0xyanB6V1E5blpBSEN4bkh0aXBobGsvd0RuNHZ1TnA1dkNLczZUMTh6NDRqVzhFT1RISWNqcnp6V2RxdW1IVUxBd3lwS1V5R3dDUWVLKzJmc05wdlFFS0ZiSEhIRmRBdW02ZUJ5STI0eGtkYWNzc3FXK05QNUJTenFuMHBQN3o0YjAwU1Fva0srWnRSY0wxelhRUnkzY2JESG5ZSkF6em12citIUzdDS1pUNVVlRDFQSGV0bGRJc2lRUkhDZlhHS3RaZFZTK05BODFvdVRUcHZjK01QTXZReGI1d2M4NU9lYXVTUGZmWml6UEpnSElBSjVOZlpaMGF4T1I5bmo0NUk5UjYxTkhwZW1La2dNTVJVZ1lCcUZsOVczeG90WmpUYnR5TStEVGZYV2VONTRJeHpUNGIyNEwvT1pSNnFDUlgycStpYWFyYzI4Ylo1NDdVSm9lbU5KZ1dpQnNEblBCcWY3TnJKZkdpWG05RzZYSTM4ejgvTlUwcDc4cDVzOXdGamszb2l5RlJrZHpYV3hYOTJJVVR6bkxLTWRlMWZjYmVHN0xqTnJGejBQQk5Sd2VHTkpjdVBzRVJLam5QRlpSeTZ2ZDZvY3MwcE95Y0dqNGhOOU9mNG02ODg4WS9Dckl2NWVxVHlJT1J3eEkvV3Z0WC9oR05LVi8rUEdFODR6bnRVY25oN1NOckw5alFBZlRyVi8yZmlMNlNYM3NsWmpoM1pLbTM2MlBqdXhTOXZkUWd0a2xsWXl1RkRLM1RQZXYwVmtXSFFmRHlPVUJTS0VScnoxYkhKTmNIcFBoN1RiZThTZGJSRlpCOHB4eitsWVB4WTFoRnNZdFB0bUplVGFnSGN1MWVyaEtFcUhNNU85KzNaSGw0MnU2MFVvUnRaNlg3djhBeVBnZnhEZXlhaHJ0MU1DU3FzVlhuODY1cVNUVTRDSklMdVdDUUg1Wkkzd1ZQcUsreDdid2RvMEZwR3YyZmU0QTNzM0paaDF6VUwrR3RJWmZtdEIweWNkNjg2dmwyS3F6bEp0ZTgyZXZoOHh3MUduVGlrMXlwYkg1N1dVdXBXRXM0TjFMSzBybG1abUpKSit0ZHhCZlh5VHFHa2R1Mk0xOVh2NFMwQXpNeldQQU9SZ0RwVlhWZEIwTzAwcS9uV3pWR2lpYVJXUFFZRmNuOW4xNmNkMVpMdWVqL2FOQ3BKYU50dnNmYy93ZThkNkhiL0RMeFdQUDJTNlRDaXVESUNDcFhPOUI5VHpYNUI2WnJHb1J4VHVMcHo1MXpOS3hCeHUzc1RrMTlIUEJxSGgvOWxHZThDQVhmaVBXSTQxazJmT1lkMk1aNjROZFJZK0ZkR1N4dFk1TEJjckVpbmpCempyUW8xYXpYTG8wcnZwdnAraGVNcVVzUFZrNVNldG9wZWk1bS94UG13NnZxN2JTdDA1M2RpZTN0VWk2dnFjaGIvUzVDQi9Ebkl4WDFqYmVFdkREWkVsazJRUGx3ZU0rOVhFOEcrR1UzZjZJeXFlbzdmOEE2cXVXQnhWdDE5NTV2OW80Ym10Wi9jZkxFT29YVHpSSHpaQjBCQTcvQUoxMWQzcVhpQ3pnU2F5MUZvWmdXVm1qd1dYY01jZzhZTmZRZi9DRytGbzVma3QyWEFCd1IvSWlyUDhBd2hXa084alIyN2hBdzNZUEJ6V01zRlhjYk5KcHJhNTAwOGRRak82dXZOSStYL0NsNXFXajJza2M5MUpQdFlzTng1eXh6eGl0cC9FbW9od1ZlVm1NbWNEN3VLK2xvdkJXaU13SDJlUUFkYzhuRmRCQjRDOE1LNFpZSk1aeDdtdDRZVEVLS1M2ZVpqVXgySGM5WXU3OGo1aWo4UytJWEg3dlVCdDVPd2pCRlRMNGoxZ3VnYTRmbko0NmZUMnI2bVBnYndvZm5lM2tMWnh3TTQ5eVJWNkw0ZStFWkNRMFV1T29JVTUvR3RYaDhVbC93VG5sV3d6YTBYM0h5NS93a21zd0JTdDFJcmtuRGdsZmxJNTVxcmIrTXRjaldSUmRzTjQ2NDVQTmZXLy9BQXIvQU1MU0lWQmxaVkdNRUdvRytIUGc1b1pVRWN5UHR5dWM0SjlxejloaWs5Ry92TDlyaDVmWlMrNCtYejQwMVVqWTl3Y2dZeW82VmJIaTNVWkxTUFplbmNNZ2h2bVA1ZTlmUjBIdzQ4TUdMRXBrQXdjc3ZXb1Q4TlBDc1lMb0pRRDBJT2MrOVU2V0x0MSs4bFZjSHZaTDVIekw0aitKdnhJMWF5MGpURzFXQ0d4MDNkc1NHRFk4bTd0STNmSHRWbUR4cHIwZHNnVzdVY2o1aHljK2xmUU1udzM4THN6Rlo1RWJ1b1VrL25YTzNQdzM4T3BqRnhLdkJKQkJISXJucFlTdlRUVVk4cWJ1OWVyT3FyaTZGYWFsSnFUc2xkbytzUDJmTGlMVTlDa3VienkvdFZ6ZFNvSlNvTGJVN0QwcjZmOEFFYW15dXJSaXU3cVFjNCs3MXJ4VHdybytrK0g5RDBoYk5Rc2NjcUJ6bjVtZHpuY1Ixd2E5UytLTjVkMjlqcEVpTHVUN2FGa0FBSktPTWQ2L0ZNZldkYXRpNXZSeG5kUHl2MVA2T3kvRHJEVU1CQmJTcDJsSHp0clk3Ry9sZVBTWkpJMGNrZ1kySDVnRHprSDFGZVB0Y1hpUW9NeXp0TWpHWVp5U3ZicjNxTFV0YjF5eTBhV3owOW83aTlqZ0x4d3M0VXhyM1o4L3dqUDQxSm9sN0F0djVsNXFhd05IQW9hY3BoR1p1dkhibnBYblZuN1dvbW0wM0ZLM1k5akRRZEtFcnhVclN2ZnYySS9CbHMrb2VhMXdoaFc4bWxBWVpLamFOaWtqMUZlRGZGYnhBdWh3Sm9VVTVlV2VOUXhIVXhnL2ViMHpYMkpDSVlkSEFFZTJPSU5tUW43dzZsczhZelg1cGZFblE3NkR4TkxjR0paL3RFaFpMdm5lVnh4RS9iNWV4SFdvY0l4akNNbmZkMy9RNzhQS1ZTdTVKYUt5dCtvYUhlSXF4Ukt3ZHBIQ2dZNXoycjlMZEttbUthZGJjbHdpZzU2Y0RPUHBYNS9mQ2ZSSHZOWmE0bWdmWmE4NUsvS1g3QUh1YS9SYlN3c0tYRTdMZ3JHMjArd3Jyd2RQM3BTZTF6SE9LOFdvUVdyU3Y4M3NRdGFycWN1b1pkZHpSTXVWSHAycnlmdzU0ci9zNjN1ZFB1VmN5Yno1SVVIQkI2NVBhbStFTll1Wjd1OGlqaU85cG1jU1orVUxqcGoxTmRYb0doTStyYWhKZDJvTVVVVHNDLzhBZTlRSzY0M25VaHlOM3UwMzZuajFJeHBRcXhxV2NVb3RMcm9iTTlwZTNjcTNVMXdHQmlJV0lEQUI5UWZXdVNzZFRSTXliY01yN0psNkVlaEhyWFR2ZTdiSmhHZnVxY2Q4R3ZIOUN2STF0YmlTOGFOR1dWOXpaSkhYaW5pSVJVb3RPejFkeFlkeWxDU2EwMlNTTkh4VnJjSnVyUXhBdGNRa2pmamhRL2MrMVd2RitnWEhpVHdoY2FkNWtVY2wxRWdWNU9FRHFjODQ3VkxhVzFsY3Via2pLT051NERuSDBOVDZwcnQ5YmVYYTJlaDNlcHpDUGRJa01rWU1TWndHYmNSblB0WExSVXBUbStzdHZrYTRpVUlVNmExWEx1N1gzUGw3NGIrRS9pWDRUOFU2dTgvaDIyZU9PemJGd0x6YkV5WnpsQ1J5ZlkxK1MvakRXamZhajQwdUErNGZhU1Z6emdrOXEvY3J4TDVpZUYvRVY5ZHh5UkpCWkY0c1hEL0l4SElaUWNaQjRyK2ZDZUx5ZkNXcHpPZWJxNExaL0hOZlU0QlhvemFpMWF5ZnpaOFhuRlNUeFZHTGttN1hUUEVTMlFTVG5KNUo5YVFna0FqOWFjREZ0QTdqQnF6c1VwOS9tdlNic2VUcllxTVFQYXV5OEhRNmRjZUlMYU82a1pJaUczSDE0NEZjUEloR2NNT0tuMCtlU0s4aEtmZkp3RDNxSkp1RFY3WFE0dlU2clVyS0JiKytFRHV5cEp3eEhWYXAyRmpINWdMRGR4bkZXWVgxQXRPTjJTQ1F5bmc0clNzWkJDZC9sbDI1ejZDc0cybzJ1ZEtTdVptcjZZSGc4d1lHRGtMN1U3d3hiZjZjZDZFZ0oxSFFlNXIxcnc5REZlYXNDOEtGaWhBUWpPUFFVMjRrOGpWMlNXeDhvN3NIYndCanRpdUoxNU5TcDIxdGZjdjJhNWxJdEd6bWhJYmNTcEhUMHJCdnh1VG9Pdk5kOU5MRVVJQkxBOGVsY3JxTUtqSVZ3d0k2WnJucFNsZFhOcGJIbWs0SkxEMXh6WEEzU09rcjd1RDFHRDFyMHAwQmxBem5ucDlPMWNQclVleWRtTVd6STQ3MTdkTjZwZVJ3VFAwQitIcFkvRHpTaVR3UklmZjcxZnJSK3pUcjZYWGhIVU5NZkcreXVXSUhjcEp6bkgxcjhsdmhUKysrSDlnRDFWcEY5dUdyNlUvWnYxYTYwVDRrYWhaWHVzZkpmeU41YWhDd1lBNVNQUGF2cXNXMnNKUmZsRStjd0Y1NHpGd3YxbCtEdWZyeGZXdnpFZ2NWeENKZEc4SUF5ZzlLOWluVU9wRzJzUmJOVk80Y0h2WExUU1I2YnIzaFpycG9mTGZ4bjBTVys4R1hwaUI4MkFDZUlqcnVqNXI1RjhTM0g5b2VFdEcxaGZtYTNhTjNQK3l3MnVEWDZnNjVZeDNWaFBHNjVWa1lFZXhHSy9NUHcxYW1BZUl2RGR5ZjlSTko1WVBJOHVYa2ZrYTlPa3p3TVRGU2cyOWxxMTVQUm41WGVLZEJrdFY4VjZjRUROWTNTMzhHTzhNMzNzZXd6V2ZxdmltNWZ3cm9HcXdRcVhnYzIweE9UdGVMbEQrSXI2QThhMjZXV3M2THFWekdkaGFUU2RSSFRLTndqSDZWODIrSDlJYjdiNGw4S1RzZDB5czlwbm9aNFBtUWovZVd1V2RMM3VWZGRQbnVpVlh0Rk9UK0JLY24wdDhNL3UzTys4U2VNcHRQMW5SZFRndDQvc1dwUVJUT2Y0ZzQrV1FBK29OWlBpTHh0NHFzdkZ5V0QzaXh3SktzbHE2SUJnU0RLU0ErdlBOY1RvbHN1dCtBdFkwMXMvYmRKaysxMjZIcVl2dXlvQjZqclVPc1JEV3ZBV202dEhrM1dsdUxTN09ja3hubUp2dzZWNW1JaW0wN2ZFdnVmVTdNSlVkSnFNcFg5bkp3Zm1uckYvZHA2blIyL2ozNGdYK3RYa1Urc3pKZngyOGlRU0tBcmZKeVUrakN1U3NmRS9pcTkwdlZaRTFlN1c3aUlsbEt1VmFTTWNIT1A3dFllcFhjakRTZGRnZjk2R1ZMZ0R0TEYzUHN3clYxVm90TDhRMmVyVzZCckcvWHpOdU9DcjhTUm5IcFhFbTNiVHArSzZIME50KzJpK1QyTVc2djlXdU5BaHU0citjQ09UeXJoQklRTW5sWElIclZYVlpKeEZwMnF3eU1STHhJTW5DeXg5UmozcnAvc2x0bzNpR2F6a2JkcHVwUmpaSjI4dVRsSCtxbXNxeXNqWmFwZTZIZkhiSE0yMVdQUlpCOXh4N0d0RkwvQURJYWxmVnNndS9zMWxxTnBxVVVZZXl2Rnk4ZU1nWjRrUS9UcUtramhnMG5XWmJhZjU3QzlRQU9PaGpmbFhIdXRTNk5EKzh2ZEJ2eDViT3g4bG0vNVp6cjAvQnVsVDJGdTk3WlRhSGRMdHZMWjJhMDNkYy94UmMrdlVWZHhOYUo5TGxTMGlUUzlSdmRJdm0vMFc1d3ZtRG9wNnBLUGIxcUN6VVdGMWVhTnFaSWdsWVljSGlPVCtHVmZZOS9ha2lrR3NhYUxHUVl2clFOOW5KNE1pRHJFZjhBYUhhcXNNbjl0V1Myc3pIN2RiSnR0bVBXVkIxaWIvYUg4UDVWTGZrVEpJbHRpTGMzR2k2bGhJeStZcFR5SVpPemoxUnU5UVc1RURTYVJxU0VKdnpGSU9URTU2TXZxamR4VGJWNDlWaGpzTHB2THU0aHN0cFg0emovQUpaU2YwUGF2V05LdFZzYmUxZ3ZwSWplQkhFTXBYY2JiUEFESHY4QTBxWlNTUTRVNVQyUnc4RTh2aGxvNHBMbG5lYkpkWXlkZ2pQdi9GdTdpdnRydzU0bDBuV0lyQ2Ewdkl0SzFXMGpBdExtSUJWZFIveXpjRGhsUGNIa1Y4WXRwTjlhaDdQVjR3OXVTV2ptRGd2SG4rSkQzVStsWU05dHFPZ2xacmVRWE5uTDBsVVpSdlkvM1dGWnl0SmFQWG96ZGM4VmFTZGxzZnNmYitMZkNYaXF3R2crTmRQaXRyNWlCQk1mbGljOXBMZVVmZGIycmVFZnhUOEgrZFBaeHdlS3JRUWlHTHpqdHZJSVZIQ3FQdXlEMzYxK1dPaitQa3U3WDdMZFJDN2hQM3JlWTVkZmRHNy9BTTYraXZCL3hKMW5SblZkSTFsSjRPRC9BR2RxQkpLK3lTZFJXVnB4L3dBbnQvd0MvWnhhMHMxMmUzeTdIWjZaSjRHMWJVclJJTHE0OFBhcTZFVCtUSTFwS1ppMmQ4aU5oU0JYdGZoTFhQak1uaU1XdW0rSUxiV0lZeklWYStCaTNvbkdTMGVmd3Jqcm40cytBOVlqOHJ4YjRaOHBqeHZsaUU2ZjhBbFRrVlU4T2FkOEx4ZlMzdmh6eFplYUxJNXdGdGI0ZmQ5Q3MyZVBhcWN0TnJXNys4dnZNcGEzVGkvKzNsekk5SytNR3ZmRTFmQ1czVS9DOWtGT29XaCswMitvK2NkeXZsVjJzTWdFOSsxYTFsNGgrTHNzZ2FIdzNwa0cvZ2lmVVN3L0VJSzhMK0kxejRoYlNMWkc4Znk2a2phamJZam5naUpVaHVIM0ovZDlLNk41dFJqbmI3ZDhTcmlFRWRZcmVHUFA4elUzaFpmQzdOOUdZelVlV0s1WWJ2cEo5ajZUZnc5OFVOU3RTdXJlTUxYU0xkZ0M2YWREaDhlbm15OUJYbE1PcWZCendycU1oc3hMcjJzQWtiMUp2N29uL2ZPVlN2bmZWTmErR2NUYnRVMW5WTmFLL3dEUHpkUDVaLzRBbUFhNWVENHpSRW5UdkMzaFNOZHhDcjVTQkFmOTRyeit0T1RmUk8zeWl2bVVuSzNMclpyWkpSWHo2czk5OFllS3ZGK3MyWmJXcjMreE5La0pEV0Z2SisvbVgwbWwvaDkxRmNsNFp0dkVQaWlOYkR3cllyWmFYQWRzMm9NdUlveDBQbC8zM3JvTkMrRmsycVJ4NjU4UU5ZamdzNHZuRm9XOHFGUi90SHEzMEZmVU52cmZpTHhCb2tlbCtEZEtPbDZPZ01iYXhjUStXQ3ZURnBDY0ZpZjd4NHJSSnlpdGR2OEF3SC9nalRTaTFHS3RmV1cwVi9tejh5dmpUZGFaNFlqdC9EdW5FSkJuejc2NmZFbHhjeWpwa25wbjA3VjhkaTJ0OVdSTGxwekREQ1NKWWd2M1Y2L0pqcVRYMUY4ZHZBbWc2UjRtMDJDM3YybWJ5R04yenk3NW5rM2RXOUdOZk52MmZWRHFNQWg4dTB0YlliZzQ1UlY3bHovRXhyWkpKSlgrWlZtMHQybnI1c3dZMS90ZTd5ZjNGaGFMejZJZzdlN3RWeUlSYXZmdExKbURUck5SeC9kUWRGSHF6VnRYRnNOY2daZE9lS0cyaGx6T2grVEFQL0xadlVlM2F1ZW1adFJsdDlKMDFEOW5qWWtzZVBNWWZlbGYwQS9RVVdWdTFqUGxhYTB2ZjhTM0ZJTlkxTzQxQzdCU3l0RlU3T2dDcndrUys1ck90M2E4dXJ6VmJyaU9JN2xYc3ovd0lQcFZ5NWpXK3VyYlNOTk82R00vTktla2oveFNOL3NqdFJjUWpVTDYzMHF4Yi9ScmZkbVE4QmlQdnl0N2VsSlMwN2Y1RGFiODlkZk5sZlNwWHRvN3JXSnh1a3l5VytmNHBYNnQvd0FCRlZyUjJzZEl1THRqKy91OTBVUlBVTC9HL3dDUFN0TzQ4dldkV3Q3TzJIbFdWcW1BM1pZMTVlUnZjMDZGclRVdFhhZDFNZW5XS0FoVC93QTgwKzZ2MWMwZEcyTkxhejh2bjFaUTFCRFlhSmFXVzM5L2RFVHpBZGRwL3dCV3AvblZqVkxlUURUTkdoNWRTR2x4M2xsNjUvM1JVbGhjQzcxRzkxaTdYOTNBZDZwMlp6d2lENlV6VFpwSUxhKzFpZHN6T1dqdDg5VEkvd0I1aC91aXNydGVxL05scXpYcitTTmhaamRlSW9MWkoyRnBZcGduUEd5RVpZL2lhN1B3VnF6emF2cSt0WFNLWU5QZ2ViSFRMdDhzYWoxTmVWZ0RUL0R4WW45L3FCL0ZZbFAvQUxNYTdiVjdhZlNmQ21rNk5HaCsyYW5JdDFjb0I4MkQ4c0tFZnJXVXFjWmFXMzAvekxuV3FSU3RKcStyOU94NnA0WDFlTFRmQVBpelg1VktUNmdScDlteDY3cER2bFlmaFdQcVcvVFBoaG9ta3gvNi9XYmszc3dIVW92eVJDbmVKOUlhNjF6d3Q0SnNuTExZcW91aU9ubnpmUE14L3dCMGNWYXNudFBFWHhQbXUyRzNTOUVoM0QwRU5tTUlQK0JFVjcwS2FoRnhUL3VMNTZzK1plSzlwVVZXY0xxN3J1M2FLNVlMNTdyekpQR2VsM0UrcytFdkNOdUN6V2NFTVRxUCtlMXdkN2svVE5kbnBrSDl0L0U2L2tpSDdqVDFqczdmYnlQM2Z5REg1WnJ6cnd0cThyYW40bjhXWFFETkRGTDVPNy9udmNmS3VQZFJYMTMrenA0WU1nczU1VUpkbWE2bEpHY2tuQ2cxVithYTAwbEsvd0QyNnRFYVQ1cWRHemQ1UWh5dDk1ejk2VFBwNzRpVFEybWthSm82Y05JVmQvOEFkaUgrTmZadndHMElXWGg4U1kvMWhMRTQ1T2EvT1h4M3IwRjM0N3VHTHI1RnFGZ0RleWN1ZnpyOVB2aDU0bTBtUHd6WWlOeGxrenR4eUIrRlZVdTZsdWx0anBvWVN2TER4YWhLU1Qxa2wxZXA5SXpzZVFNVnpxM2tjck1veUNwNU9PdGVjNng0ckUyblhhMlV5QzU4cytXVHlBMzByd1BSdkZ2aUM3bVZab3hHNWRVazlNNTV4N1Z4VmFxaE5SYTNQZG9aZlZsU2xLUzViZEh1ZHQ4YU5kajBUNGY2L3FHN2E4Vm5JRWJ2dWtHMFk5Ni9sS2U0V1Yya2tiNW1ZbHM5eVRYOUNQN1cvaUNHSHdiWjZTQVhONjdNd0hPVWlIZjhhL0JmUTladDdlZUptMDZCbFFqS2hBV2IzQmJQTlZpbTRVS2RvM2J1K3c2Rm5SaEJ5Y2J5Y24xMDJSa3ZMYXVnMmdqOGlQMHI3MitGdmlUUzdQd1hhUlNTNU1ja28yK21UbXZDTHp4ekFZeVliU1pGTzRNck9nQkhwaFZHS2hqa00xdEZLRks3bDNGZnJSbFdKcjA2MHB1a28rN2JlKzU4L24yQ3cxZWhUaEtvNUpWRTlGYlpNKzNadkhtbThlV3pZL0RqRlp0dDhSclM0djVMYURMdXNmbU5naGVCOWErTEZTNnpqeXlWeDE1NU5ZVnhwUmU2am1FYjd3T29KSEh2aXZxWjVuaUxLeVI4VERLY0d2aXUxNm4zeW5qZlRIYmMwaEh5OERwZzFySjQ3MFZrR0pDRDY5L29hK0EvSm0yWUtTREJIcnhXZ3NVeXJrYnVub2U5Ynh6U3ZiWkhMTEo4TnZkbjNUSDQ4MGxKWDh5VjlwUTQyNEhQYk9lb3F2YmVNZExrdVBuWU54d2M0cjRlSG1Ba2JHT1Jqa0hOWExhM2w4c3lBT3A2RGc1L0NyL3RTdXVpWnh2SjhNMnZlbDk1OTJmOEp6WkQ1TndJWHZ4M3BxZU9OSzNZTW9KSkdWQUZmREppdUN6N1ZrR2VPUlZZeHkrYW9DT1RrWjYwdjdWcmZ5eE5QN0V3emFTbEpmTSs3cC9IT25lZnM4N0k5TURqODZnZnh2WU5kTGk0QlVBZFZ4MDdWOE9QYnkrYy93QWp0ejc4ZlNwYmUzdVZra0Jqa0EyNDVCcC8ycFhhK0ZGTEpjTEY2T1I5WGVMdml4WjZaWWt3eCtjek1xaGVBdVQ2MWEwYjRnUVgxb0pHL2RPUHZKa0g4cStOZFFzUmR4bU9XSm1YQStYYWNIRk9nc1h0b1VXTlhSUU9hNS83VXhmdGI2Y3R2aE9xcmsrQmROYVBudnJLL1ErMmg0djA1WFkrWmcvblZtTHh6YS9LRm54ejFJQTROZkRza2NneHRqZHNBNTY4bW15RzhNWCtyZkJQNlYwTE5zVGRlN0g3anpwWkZoZCthV3ZtZmRFL2pPMFVnNVZsTFl5Q08xRGVOZFBrREZ1UGx4bjZldGZFUzJWeHMzN1dQUTk4bXRTVnBIZ1JSRTZkZ2NIbjYxYnpTdHA3cUxqaytIMlVtZlljZmpXMEdWTTN5OVJuK1ZYUjQ5c1dqTWFNcWx1R1BVbXZpT09HVERneE9jOXgvU252SGNiQ1ZpYjVSMTVwZjJyWGYyWWsvd0JpWVIzdTVQNW4yYXZqcXpXTmxhUWUyY0VIRmVkK0p2akJIWVIycXhXaVNUeU9GWGMyMVFCM09LK2RZcmE1Q0VnRThjOEg5S3h0UTBkcnRrV2FFdnprQWpwajByQ3JtZUtsRnFOays5anB3K1VZS25WaTVweWoxVFo5dDZaOFNiVzZzQThrU3BLQjg2akhYMnJmWDRnV3FvTVNGYzlzQTE4Tlc5bTBFQVNLTndRZWVEVjVkTjFCeHVYZitPUlZSelRFS01VNHB1MnI3bVVzbndqbkp4bEpLK2lUMlJ6N1EzS2tneHZ4MDRxZU0zQzUvZHYvQVBycjZ2ZzAvUVhkdDBpYmoycTlEb09pU09RWlJqNjF4UnkybzFkVGlldTgzcEtYSzZjdnVQa1VtWUFIRW5IVHJVWDJpZmdaa0hQdlgxK2ZET2xxY0pJaDY5NnRKNFUwd2dIekkvWEhCcTFsbUlXMGw5NW5MTmFITmJsbDl4OGhpZVZTcE1qOFZNTHU0RG5FN1l6eDcxOWJONFAwMHluRHhra2RnT0txeWVCTFUvTXNpL1RBeFV2TDhSZnA5NWY5cFlmWnBueVlidWNOa3pTZGZ3cVlYMDI3L1d0WDFDM2dXMlBRcHdjMEh3RmJOeHRqK3RKNWZpN2Y4RXhlYVlKT3owK1I4MFBmVHFQOWFTZXZyVlgrMWJvWXhLY2Q2K20vK0ZmeFpQN3VQajI3VkUzdytod1NVVUhIY1V2cWVNN1A3enBlWVlEcTE5eDg0SnExemppWTFkWFY3eFZ4NW1SL0t2ZW8vaC9iajcwU2tkalZtUDRkeGdnK1d1M2tIR2FGaE1aL0t5RmpzdWVuUEg3andSTlh1dzR5L0I2VnF2cU44dVBuNzVyMWVmd0NpdGxGWGI2bmlyMG5nMjJJVWJSeDE1cXZxK05TMmYza0xGNEhtdTdQNUhsTU9yWHhUaHhrZE92U3RGZFp2RmRjc09UNjE2YmJlQ1lkNUFUalBBelVrbmdxRU1QM1RaeU0wZXd4aTZQN3lmcldDdjBzZVZIWDcvRHFHSS9Hb1I0Z3ZReDZ0L0t2Vmo0R1ZwQ1NHNjgvU3N5YndNcFlnWng5VC9TcGRIRnJwSXI2eGcyOUpSUFAvd0RoSXI5Wk1ad0Q2SHZXckg0a3ZQbVhPZllHdWluOENISUViTmtkUWZTcTZmRCtmQ3NRK1BVR3VkMDhhbm9wSFNxMkJhczNFekkvRlYySHd6RWZRMXBqeFBjZ2NjNTYrMVdFOERYRWJ0ODV3VHdhdVIrQzVtbEkzdHdPdGJKWTYyMGptZFRMcjZPbVl4OFUzdTdIOWFRZUw3MWNBcTJmVDF4V2pQNElrREFpVnM3dTFNLzRRQzhreTMyaGdjNXhpczFMR3AvYk51YkFOZllFZnhoZFlCQ25qdURUNC9GOHBYTEJzL1hta2J3UE92Q3pGaWZVVlNUd0xxSmJpWWY3cEg5YXBWY2JmZVhvUXFlWFBwRDFOdGZGOHcyNVZ1ZVJnMWVQaldmeTJBeWNIa1k0ckUvNFFuVkJnaGxIT01WSi93QUlmcUxERE9Cd1JrVlNxNDlPejV3OWpsdG55cUhucWJDZU5Ma0FNOFpOYk1YanZHUGtPRDByaUY4RTZwakF1VngySkJxeW5ndlZ3UGxkSkR4dXdNZnBXbnRzWi9lTWZZNEZQVGxWL003MXZIQnlDd2Nic1k0cU9UeDJGZkdHSUgrelhPeitEdFYySTI1UVFPaHJOZndqckRKdHd1ZXVSNlVuWHh2OTc3ZzloZ0ZxdVg3enJqNCtWUWVUMDRIWG1uUmZFQkNNc3JEUGNjVjUydmhEVndHWGF1TThIUFAwTk9Yd2JyT1crVmM5ZXVUV2F4V04vdmZjS1dHd0Rmd3h2NjZucTF2NDJpVmQyNXdTU2ZXcko4ZHhjYldaejNHRC9XdkxrOEo2Nk4rMk5lZmZwU040YjFrSXg4a1k3ODg1clg2MWkrdC91SDlUd2R0RXZ2UFMyOGRSaHpsWDQrdUJVYitONFdIM241T0FPYThpSGg3WFM0SWpPZWNZYml2YS9oTDhQdFoxM3g1cGRwY1FFVzRrOHljNXlDcTg0L0dpR0t4Y3BwWGE4N0MrbzRTeXNrMzZuMUhwRU56YTZORGRYS1NJUEw4MEZzaklQWVo2MThUK0l2RThFM2l4SG1rM0NETDRIOTQ5UHlyOU4vMmg1N0t5OE5XVjViWENyQ2hrdEJBT0FCRHlTUHhyOFhJTkcxeTZhYTUreVB1bWN1TThjSHAxcnNyNHFYczR1S2QyL3dBamtvWVdNY1JVNXBLeXV2VzZQZVI0M3NRcC9lUHg2ZHpXVmRlTnJOc0VPK004WjROZU4vMk5xNkZzMjJmWEhQNVZuemFGcTdrN1lHeDNCNUpyayt2NHIra2R6eS9DUzZXK1o3QXZqS3ozZ2VhVDNQUEZjbDQzOFZRU2VIcnFHS1FzOCsxQjlDYTgyaTBMVnhqL0FFU1RCeU1pc2k1MHU2dU5ZMG15bVBrQ1dkVTN2d0Z6eHVQc085WVZNYlhjSko3TkhiZzh1b0t0QnJXenY5eDlLZUwvQUl0YURyZndyOEVlRlRGNVY1cDk5Yk5JRkIyTkhIazdnZXplb3JwSS9HV25zeFV6dGpPZnBYeGI0ZzhPVFdQeE52Tk1pdTRyNyt6M2RmT3Qvd0RWdUZIM2w2OFY2VU5IMUpsQkZ1NElIOTNtdWZENHFwRzhvOWJIVm1XRHc5V3A3MjdibHYxZW42SDA3SDR6MHdFRHppY0hzUDFyYy80VE93SkErMVl3T2hQRmZKZjluNmtoWGJieURJNStUaXBUWmFpdUNiZVEvd0RBRHhYZExIVjdIaVF5ekQ4MTlUNnN0dkZ0aDV3Vkp5U1R3TVpHYTJqNHNpY2Y4ZlE5TUR0WHg2dHJxQzdXRUVtYzlRT2xiOXY5c0FIK2pTTGc1enQ2L1dqNjlWYld3UEFVa21ydTU5ZFduaWlOVHRhY2JjanA2ZXRkWEw0d2oyc25tZ0RHTTRIU3ZpcDRaL01CVlhKUFBDRUVmNDFhQ1g2NURwS3dIVTRPQ1BhdWxZK292c293ZVh3L25QcysyOFYyeXVUSGRoZU1ZQUJINDEwc0hpbFp3QUx2N3ZvY1Y4RnFaa2VQOXl3QmJzRGtmV3JhaTVaM3c3S1c5RklGT1dZVkwvQ2lQN1BwNzh6UHZXUHhVa1lZTGNnQUE5aDFIb2ZXcTQ4VHd5QU8xMkdQYi82OWZCeU5kSkcyL3dBeVE1SStVSEg1bWxWcjNPVmRrK1gwUFQzRkpZK2QvZ1JwOVFnbHJObjNzL2lxT1FGVE9oeU1iZG9wc21zUWkyS0djQUhyanFNVitmVnZlWEVVMjdMQUVqSUpKL0wwcnA3YS9TUXpLclNCejk3T2VmOEFkOXFIajVLMTRMNUdUeTVPOXA3K1I5clJlSUlZVlBsM2FqSXd4eFV0bGVycU4zRkNaVWRUSXBiR1B1amsvcFh3VkZlT2x4bDJsSzhqdVFQZXZwbjRCYWZhNjE4UklsbmpkN2UxaGFWZzRJRE4wR2NkYTRNWG1zcWVIcXk1Yk5SZG41OUQyOHR5aWxWeFdIZzIybk5YWGt0V2ZwUmFSYVJlekNUYnZWNGhGR3VNSEE3ak5ldndRUlIyOTBURXN3OHRValYvbXc0NEdNOUtyRFJyRzJacmxiYUpCQ1RnaGlCZ2UzUVZkdHIyMFpacG1LckREKzhadzJSZ0ROZmlXSG95Z256OHQ1TjJmeTNQNkZ4TmVOVng1RkswVWsxNTlsWThYOFFXRU5wTmVUUndSK2ZkUlJwTEovR3dUa0w5S2lzdEgwbytHdFF1dFZoQmhHMTFRa2pMSWNyK09hcmp4VFphekxKUERBM2xJeFRhNjVKUHJ4WG5ueE1lUjlROE9RSVpXRWV5Vm9Vemh2bTZFZHpYblJjWXluTGRSMFh6UGZoU3F5Vk9uckZ5ZDVOYjZhbnJQeEsxT1NQd0xCS0EwY3Q4cXhzdU9xa1pQME5mTC9naTIxSFY5S24waTZqODZHQUY0cE9yeERzcFBwNmUxZlF1dXRyT3FQRU5SZ1NMYnNNTnN2SVJHT1BtSjZuRmU0NlY0WTAzUzBXU0dNREVlMDRVTHVCNXlRTzlhcGZXY1JOSzZqRlJUYjM5YkdQdG80TENKTktVNXVVbFozWHBjOFE4SDJ0NExXRzN1N2kzTWdKQ3hRTHNXTlFlTUE4bjNKcjF5UzJodmJhZFlKRmFGaDVLa0hqZ2ZOMDc1cnp6VnRQaTBXTzYxQnJYeWlwS3dtRmZNWXEzVW5QUVZ6UGhEeERwOGVsL1liZlVQTVl6UElzYzZnT29jNUlHUU1qOWE2YVVyV2hQVFIrUjU5YUVxaWxWaHJxajE3UmRHaDB5MnRiVUZIbFRjelNLTUg1andLN1BXUmJmMlJOT0c4dDRsMmlRbkE1NmcrMVl1aXpOY084MGlnSG9jZTM5SzRYeGZxcWFpdHRiWUg5bS9hRDV6bmd6dkdNN1YvMkFlcDcxNzlMa2pSazB0R3JMOGo1K3I3U2VJaW0zZE83ZjRuR2ZiWm90THVaUi9xakZJd09NRThkUjdlbGVSNmJaUzZqWnhmdm5WZGdrY0o5NHYwNVBhdmFwekJxMGtkZ2pnQ1lZNDdLdkpJK2xTYVZvRm5vOWdzYWJwUVpXTFBnN21HY2pJOUs4ZXRHYnN1bHR6M2FWU01OYmF2b2VmYUhaYXBhM0dxcklnYXhSaE41alBneC9MMjljMXduaFc3OFhXdC9ydXV4NkZQcUJ1NUNrQ3hTSXZrMjhRd3JFdVIxUGF2ZDlmOE8yV3Uyc2hzdFFTM2RodFpRMjRISFlybklxTFFORjFheDA2OHRaOE1CQ0VpS2tiV09NSEhwK05aVVlUaFBSTnByZjhlaEZlY0trZmk1WGZiOE9wOFFmRmZ4eDRpdHZoQnFFVjdwRjFhdGV1QWwwN1JtT1FidVFDaFBOZmxSNHZTQ1B3VnBqSW9IbVNISUhmNjE5bmZ0UjZoSm8ra2FYb3NWMisyYVFTU1d6Tm55bXp6ajYxOGUrSWJ1YUg0ZmFERGdBM0x5TTVJeWRvUEdNMTlsZ2ZhUndENW9wT1U3L0FDK1o4Qm1DaTh6YlVtMUdOa3o1eEwyN0tRdUFmZXNkNVhZNEJ4aXRZMnNReVNNdG5JUHBWV1dNcGtnQXNmU3VpNnVZOUNyR3prL2hWcUxDenhuY1F3WVlJK3RRUXBNQXhaY0hIUHRRY0RrSHB6VldKMTBQYmJpeDFDMzFFU3lTcThMZ1lrWmNjRG5CcnFyaTVhUlVDeDJ6d09NbmFvOHpINGREWEk2cDRybWxzYmVHT0pUdmpVQjJPQ0FCam1zZXlndGhjeHdYTndDWkR1YVdOdW50WGt6cHQ2dnBzZC9NazlEMVh3Ulp3UDRnV1J6SkRBc2dKVVpKWWQ2cGVJSjdhLzhBRXR4OWt1bVdKRzI0WWNrajE5NmwwM1N6YVhDeUpkVG5QYm44T2xWRzAxWUxpZTVlOHkwckVzdTNuLzhBWFhISGtkZHo1bTN5MlNPcXo5bWxicnFaODhjeXBscmd2dDdEdldBMFZnSnpMNUk4d25yazRxUzR2THB4dFFnajEyOG1zSnpOdUdSalBVMTN4WFM1ek9TSkpKRkU0SUhHY1ordFlmaU5ma1U0R0F1TWl0WkkwZkN0M0g0MWlhekVzZHBzYVhjM2JuZ1YwdzBsRTVwdlJuMlA4RXRadHJ2d2xQcDR5SjdTUm1JOVVmb1IrTmRkZDNONXB1cEM4dDNLelJTcElyQTRPVU9jVjhPL0RQeFF1Z2VKN2FhV1FyYnk1aW45QXJkL3dOZmZHc3hKSjh5RU1yQU1yRGtFSGtISTlhK3ZwdFZzUEZOZkNyTStiY1hoc1g3V0wrTnFYbzF1ZnZCNEs4VFdmaVh3dHBPclc3WlM2dDBZNTRJWUREQS9RMTNUSlg1dWZzb2VLa05ocS9oNmFVNzdlYjdUYktlaGprNGNMOURYNldHdU9ucGVQV09oMTRoUmpWbHkvQy9lajZNeEo0d3lNcEZmbWo4VjlPZncvd0NOOU0xZFJpQzUvd0JHdWZRWis2VFg2ZHlxSytkUGl4NFRqMS93emVXMjM1eW01RDZNdklJcjBLY3JIbHpTYjEyNitoK1h2eE04TVI2Z21vV3hJQ2FsQmxDQjkyNGk1VWo2MStkdmlTZThObm9YaVdBRkx5eWxXMHZoM0Uxdjkxai9BTHdyOVRkT0VtdmVFNUlaRHR2N0Z0akE5UkpEMFA0aXZpSHhEcGRySDRtdWJTVEM2ZjRsajJFbnBEZXA5MCszTkZWTnU5N0o5ZXpXeHdxUExvNHFUcHQzWDgwV3JTWDNhL0k4YjFLL1R3NzQwMG54Slp4QnRQMVJQT1pPcWtTZkxORWZjSHRWMksyc3ZEZmpxNzAyUmcyaTYzRUZSajkzeVorVWY2b1RXUjRlMCs2MUxTdGE4SFhnMlh0cExKYzZlRzRJbWo0a2lHZjc0NUh2VHRKaUhpdndKYzZVd1A4QWEraDc1N1FFZk5MYmY4dEl2cW5VQ3VhZnZ4YXQ4VDVvK1VsdWhVNHFpNDh6WExUU3BUZS9OQi93NTM4dG0vVTRpSFNYMHJ4QnFmaDdVVzJMSzVpRDloSU9ZNUI3R3JHaVc3M3R0ZjhBaHU4K1M0amRwTE10L0RNblZQbzRyYzFPTStLdkJ5YXJFTjJwYU9peFh3SDNwTGZvazMvQWVocmo3eTRrMUhUN2ZWN2RtVzlzaWkzUlhxUXYzSmY2R3ZDbXBKclhlMnZabjErSHE4MGJQZURha3Y2KzgwYkdPWFdkQ2wwbVJTTC9BRTh2SmFnOVhRZmZpK282aWxaUDdlMEFTWlA5bzZZbUhCKzlMQU9oK3FWYTF1OE4xRlplSnRQQWluV1JWdlVUL2xuT3ZSOGYzWHJNMU82Wlo3YnhEcGlpTU8rTGlJY2lLYitKU1A3ajlxVVpOOUxmbyt4MXo1VnM3MlN0NW9XN2wvdDdTRGRSdC94TUxCRkV3L2lsaFhwSVA5cGUvdFZPN21sMXl4Uy9pSkdvMmFqN1FGNGFTTmZ1ekQvYVgrS283NG14dWJiVzlLWXJCSzN6SjE4bVEvZWlZZjNUMjlSVUZ3eldjOEd0NlVka1JrK2VQcjVNaDZ4c082TjI5cTJWMmMwNU1TVkpkVmdiVXJYSzNsc0E5MGluQmJIU1pQOEEyYXBUYXRycS9hN1hDMzhaQnVJaHh2OEErbXFlL3FLdXlRekNTSFc5RVVxUE1BbXQxK1l3U04vQ1IzamJ0K1ZlcTMrbjJHazZiZDZsYTZlVXZwSTBMd0J0d3RtUDNtWEg4UDhBS2xLY1U0cTJyMENsQnU3YTkxRmVlZU8xVjRFV3lrMXByY0VrZ1pKSTVHZW5tWXJtZkQrc3k2a2t0aGV5TGJUeC93Q3J1Q2d5TW43cmcvenJ6MmRJTlp6YzIySXI3TzZXQUhBa1A5K0wzOVZxL1k2aHAyb1NKRnFSOGk2VDVZN3ZHQWNjYlpoLzdOVWNpNWRqYjZ4SlRWbHA1SFc2aHJWN3BOeStuNmlwdWJjak1VdTBCNDgveEllaEh0V0kxeDRnMCtKcnUwbmp2TEZzYnlFREx6MmxUK0UxV3ZyelVMQ1JyUFZyUDdSYXVkMFp6a2dkbWhrSGI5S3EybW42amJicjNSTHRwMEErZEY0a1Vla2tmOFE5K2xTb0t5MFZ4eXExWGRjei9Valo5TDFWd1lKMXNKei9BTXNwRCs1Si93QmwrcS9qVUZ6TnIrbmJCZVcvbVIvd3UzSUkvd0JtUmFiTGVhRHFKeGRXcHNiak9HbWhYTVpQcTBaNmZoV3JhNmQ0bXMwWnRNdTF2SUQxRURlWUNQOEFhamJuOUsyMDdITE9wUGUvVTlCOEphVDRtOFRSWFRhVGJYRXd0eXZteGVZR3dHNll6ak5XdFM4TmVJN1IyKzFhUE5FUjFNbHN3SDVnVjJQd1A4VGVJNC9ISzJGazFocDF6ZXhzak5OYm55M1pPUXJJTVlQdUsvVkZwL2k5YktmdEhoalI5UVVINzl0ZXRFeC80REtLOCtyT3JHcFpLTFdsazNaL2lkbE9jYks4bGZvcjIvTS9FQzZqdXdNYmxpeTJNQjJYbjZOVXE2ZGV6bFM5L0N2MEx5SDlCWDZUZkZMWHRmbTB6VFV2ZmgvUGFCZFR0MkQ3NHBRN0E4SUN2T1dydEp2RUhpY1JNTFg0YzNVWlBJM1NRb0I5Y1ZwejFlVmU0ay84U0UzZTIzL2dTUGdUd3o0QXM3MXR6NlpyV3F5ZjNMZTJNYWZpNzQ0cjc5OEdmRHp4M0hheFJhWm9tbmVIb1g0ODY0UDJ1NS8zdHE0VUd1aHNkVCtMVjBxQzA4UDZYWWM1TWx4ZEdUOENzWTZlMWR4ZCtGL0dGMGdrOFNmRUVXZHBqNTRkUGpXelJRZXhrYkxZcHBLZHVacCtWNy9sb1pYU3RmazE4M0w4alV1ZEcrR25oVzZqdi9GV3ZTNjVxYWhSQ3QyUk8yNzBndFkrQWZUaXV6bTFQNGorTjdUeTdHMmJ3enBCQkRYTXlocitkUFNLUHBFTWR6elh6OW9uaVg0WStITlRrZzhNYU5McjJwTWNHYTNWcDNKLzJyaVRJWDN4WHR4MGp4OTRtc1pwZkUrcXg2SHBXM2RKcDlqTGgyVWRyaTVQUWVvV3ZTaTB2a3RML29qS1RhNVhMVHM1N3IvREZINWMvSGpTZkF1azZocE52cGVvckpKYithTDFsYnpwcEhZNUJkendXL2xYeVpiNnpyZC9LVmdlTzJ0SUI4eFpRWTBYMWJQVmpYMkw4ZU5WK0h6NmZwRnJwTm8zMkd5bmxWWHQ0U3NVckVjanpUOTQrcHI0WWlqMURWOHFteTNzNGpra25iRkdQVW51MzYxazBtbTNkZXBwS2JVWTZ5VysrK3ZjOWF0ZFlpMTJWN0N6MnhUUnFyeFNtTUtMZ3AxRW9VY0E5cXdkU1QvUkwySFI0VjN1NFM5OHM1WWsvd0FNZWVmTHoxcms0NzkweFlhTEc1TGtlWlBqRXNwSC9vS2UzNTE2UmZUazJWeGU2ZmJSU2FqbEk3eG9pVzJFOFpSUjFEZHpYTmJsYVhSbmJGZTFnK3JpdW42SG5FdWRNZ09uV29NbDdjWVc0ZE9kdWY4QWxrdVAxcXhmQWFUWkhTcmZFbDVjRmZ0YnB5UjZRcmo5YTZ1OGl0ZElobnU3TzNZYWd5RHpVRGJ4Wjd4eVIvdEg5SzR5REdoMjR1cGVkUm1CTUtOeVlWYi9BSmFOL3RIdFZiNi9oM1p6eWk0M1czbjJYK1l0N0VkUHRrMHEyL2VYZHdWKzFGZWVmNFloOU85SnFmN21LMzBTenhJMjhOY3N2L0xTWS93LzdxMHlBLzJQWi9hcERtL3VWSmhCNnhJM1dRLzdSN1ZUaVo5SnNqTXhJdkxsRHN6MWpqYnF4LzJtN1VkdXV2M3N5OTMwL1JGdThUN1JOWmFQYVkyUlArOGNmeHlIN3puMlh0VnE0amgxTFZJYk8zTzJ5c2tJTGR0cTh1NTkyTlpyckpwRmpzNlhsMG56RCtLT051ZytyVmJ2SXY3TjArUFQ0Z1d2TG9LMXhqcW9QM1loNyt0SGF6dmZiOVdhTjZPNjdYOU9pTjdRYk9QWGZFYlhFdzJhZFlKNXNweDhxUXhkRityVjZINFl1djdSMTNXL0dHb3JtMzAwYjRVUFJwajhzTVkvM2V0Wk91V054cEdsYWY0VXNWTW1vWHNrY3QrRTVKa2Y3a09SMlhQSXJwZkV1bnU5em9mZ0xTWEQvWjVkMTlLdjNYdVg1ZGlmN3NZNHJ2b1F0TlMzY2JjcTgraDg5aXFxclJjRzdScXB1VXUxTmZFL0sreU12dy9jejZaNFk4UStLcm81dmRUZVN6c1NldTZUbWFRZlFjVllrVStHdmhmSEFDUHR2aU54TElQNGt0WWo4b1ArKzNOYTk1YVd2aWZ4bnAyaDJjdTNSdEZpS05ML0FBaUtMbVdVL3dDOGFMZTd0dkZIamU5MVc0QWowdlNJUklxRTRVUXdjUlJyN3NhN1pKY3RrNy9aVDd2ZVRKcHVNSnlrNHUxbFZtcmJKYVFnbDNlOXU1QmY2TThOcjRYOExJcFdlZGx2TlFIUWd5Y3FwK2kxK3FuZ2hiYnc1NER2dFVZQlJ0SWpYR1B1RGFnR2V0ZkF2d2wwTy84QUUvaWk2MW02eTB0L093WFA4TVFPV3g3QWNDdnVING82bEhKSHAyaFdyQlVqdzBnempidEh5aW5Uc2xLZXlXaXY1RTFFcHlqVGI5NVhsTzIxM3EvK0FmTEZycDE1cm10UlcwY3FxOHhlU1JtSkc3Qnl3SHFTYS9WYjRlK0g1TEMyeXNqYmtoKzlqSVhBNXJ5djRJL0MrOVMvbDFxWlFpZVY1VUc1Y25CNnNNK3RmZHAweTNzTEdaWXdRV1UxektXOG5jL1RLV01vMGNERERRczVUczV0YTZ2cDhqNFYxN1ZoYjZ0TVN4QkxFa0x3YTZqd1pxVnE5ODhyU3VJSTBKa2NvV0NNZW1jVjVGOFFTc0dwQjFPMThGblA5YTRmUmZFM2lMVHRQMUc5aHZaTFd5c28ydXJyWStQT0FHRWpJNkhjM0dLOENVcWs2MTFycm9lM2lZMDRZV1NiUzkxYW5pZng2K0xtbXQ4VHRRdEdzRnZyYXl0eGJ4dnZ3VVlqTE1CMFBOZmxaWnlJMDh6a1lVc3piZlRucFhmZUlibldHOFFYMHVxMjhzTjFQSzAwaVNLVWI5NGQzZnRYbU5xUWJsZ09oSnIzc1RVYzR3V2xvN0g1ekJ4V0ptMG5iUksvYU9oM2tkdTBxdEp1OU9QYXYwZytIT202ZGQrQ3RJZVMwaEpFVGhuWWNzUXhyODI0N2hWRzNkOHA2anB6WDJoOFBQR0VOaDRXdG9KUnlyeTdjbkhVNXIwY29xVW9WMzdTMW5GbnpYRXRLclV3ZEwyU2ZNcXFiczdhV1o5Sm5SdEpZYkRhUWtrOWR2TlFSNkJwNG1RcmJSOTg1eDFyeVdYNGlRaWJDbGNub1BhcUwvRVczK2Zlb0lYT05weCtkZlpQRVplLzVmdVB6WDZybVZuWnkvOEFBajJpSFJMQXF4bHQ0VGtuanJXMFBEMWtzYUFXc1dNWjZWODVKOFFMSldZWXpubnBXdjhBOExKZ0NMdGxHN29PdkZVcStYOW8vY2MzMVRNMDllZHArYlo3YTJoYWN1R05taHljWTRCNXJVajBDMldGUXRuRWVUa01Sa1Y4OG40aVE3U2NyN21tL3dEQ3pJdnVuR2NFZFRWUEU1ZTlORjhpbzRMTWI5YmVwOUxmMkhwN01TTFNGR1BVOFk0OUtrazBQUlZkdzFsRVg0K1llOWZOTVB4S2lWVVVBbkhwbk9ha2Y0bVJaQmJPY0hnLzQxTHI0RHB5L2NheHd1WTYzVCs4OTRoOE42WUpEc3Q0aTRQWEhKL3dxV0xTTENMYzMyUk53SjY4akZmUEIrSjBCYkNvUGZtb1I4VFlSS3VEZzRBeGcxWDFyQTZhUis0NTNnc3g3eStjajZNaTBuU3R6N3JLSWxzNEhwNzFWZzBUVFNYWDdEQzMvQWV0ZlBiL0FCSVZHNGJrSHRVQy9FYkxqYzN2ME5QNjFsL1pmY0ZUQlpxNHJWdi9BTGVQb2Vidy9wTEZ2OUNpVURxUnprK3RReCtIdE9VS2ZzVWJkczRGZUhINGdXL2xxK2VjOGptcThueEdRZ1p5TUhQVTFmMXZMMS9MOXhqREE1bmQ2U3QvaVBweDlOMGsyOGF4V01hc3JmTXg2L1QyRlF5YVRwZXhXZTNRa0VkczE4MGo0aXI1WkFYcWZ2ZTFQVDRoNWpjTm5HS1gxckFQdDl4djlTekZ5V2pTN1hzZlRMYVJwTElTTEdFQWtZSUg0MHI2SHAwbHZ0TnJBdWY0dW5XdmxvL0VHUXN4d0N2R09UV3VmaWF5eHFOcWoyTlQ5YXdGckpyN2lWZ3MxVXRZdEwvRWZRTS9oZXdESUVnUUFBWkhhbVhPZ2FNU0ZOakdHR09hOEZQeE1qTnNUdkpiY2VNZXRaRGZFWnlTVk9lTzQ3MUgxckw3V2FUK1Jzc0hta1cyazlmN3g5SUhRTlBaVi8wV01iVzRQcDlUVzFiNlBhRkNEQkNNSHRYekEveEdkck1rQmczSDBxR0w0bXlCZm5ZWitsVEhGWUZkdnVNMWdNeWVyMzdjeDh2cDRnMUZjL1BXckY0bzFER1JJZU9NNXIydFBBa016NENKamsvbFY3L2hXOE9NN0V4am9EWHkzMWZHNldiUHY1NG5MMDllWDdqeDZMeGJmcXBMRXMzVG1yc2ZpL1VDRDEvT3ZUUjhPb3BEeEZuazlQYWh2aHdnVS9JM2J2MHBPbGp2N3hQdDh2a3Zzbm5rZmpLK1hJK1lFKzlhQ2VPTHpJenU2OStsZExMOE9WM1lVT01kUjNxdW53OVppdy9lQUR2aWxmSEwrWWZObHozNVRNLzRUeTUzRUhQNFpxZGZIODVrUHpNUFQvNjlUSDRmVERIenlEbjA2VlJrK0g5eHorOGI4QlRWWEhMK1l5OWpsa25lMFRZVDRqeXFmdjhBVHZ6V3RIOFNXSTVtUDN2MHJ6aVR3UmVnL0xJZU8rS2dmd1BxQkdSTUtQck9PWFdSVHdtWFNXMFQxcGZpU1h3REpqQnhWai9oWmZsbmFIR2ZyWGk1OEhhaVR5NEdSMnFBK0VOVEpYRWdiR2FheHVOWFZtUDluWmJ2YVAzbnVTK1AvTXhseG1wNHZIY2U1MVprWTlpZTFlRUh3dHE2WVlMa2Rhc1NlR3RXREl3UWZOMk5hckc0elM5L3VKbGdjQzlGYS9xZlE4SGpjaFdJY0RBNHhWdFBITVpCM09DZWE4R3QvRG10QkdBZ3llaEg5UlVMZUc5YmpjWnRHUDYvblZ2SFluY3grb1lQNGRQdlBvdVB4M0NGQUpIMTR6K05TcDQrakxZSVhHYzhpdm1VNkRyQ3RnVzdHczZUU3RWQjVoYyszU29XWTRsUGEveUxXVjRKTFIzK1o5ZFJlT3JXVEp4R2VlM3ZXdC93bkZrb1VCd0VBN0RyWHc2Mm02ckc0S3d5Yzlha2p0dFdIM3JlVEh0VGVhVmw5a2Y5azRXYStKbjI5L3dtdGpLMk1JQWVSeGpQdFYySHhkWWd0bFVQb09uTmZEa0Z2cVI2eHlEcU80TmFpUjN4WVlXVlJnNXpuUEhwVFdhMVdyY2h6dkljTHpYNTNjKzB4NG9zVElHSVVBZTlXajRtMDg1T1Y1L0d2aFpyalV0d0FXWVk5S25TNjFEb1djSGs1SVBOQ3ppcTFibFJvc2tvYnFiUHQ5UEVsZ0Y2S1FEeHlLMFJyMm1GVkc1YzU5cStEV3ZyMWVESkpuNlZKRHFWNnE3bWtjOCtuTlVzMWJhOXdsNU5DTjJwbjNrTlcwOHlFQWdFa2RDSzBwTlRzUEtHRkFZZHlSeUsrRVJxZDhtTmtoNE9jSGl0QTZyZUFBaWMvd0JSbXEvdGJYK0dSL1lzWEcvdEhjKzFmN1VzUUFHSDVjVmRoMUhUUWNrbGM5YStHVzF1K1gvbHFjMDFmRVdwbDF4SnhubmprVmF6V0xmd0hLOGxjYmZ2TGZpZmYwbXJhVHd1U2VPU1I2MVQrMmFRNXlyTW94K05mRlRhN2ZqRCtibmpIWHY3MUEvaVRVOEVySU1ZN2NZSXEzbWNPbE1jTW5xTjNkWHIwUHQ4eldCSEs0RzNPZTVwNHVOUFJSZ2hzOWV4cjRsbThXYXNZay9mak8zai9DbzRmRmVxdnRLdXBQdVQyck5abFR2OEJvOHBxSmFWRDdvaXVkTEJKRE12SGZ1VDJxUXo2WnRZQ1FjSDByNHpnOFpha1lXSHlrOXo2VlVrOFhha04yWEF6bkZiZjJqUlgyR1pmMlhpYlc5cEZuMktoMDV3REdjWTlhK3ZQaElrTmhwZXVhb2hEU3hXamtOL2RQUWZUTmZrNW9IaXZXTCs4dExSWVZaNUpWWElQT004NUh0WDdBK1BGaDhNZkRIUzdhemoybWVGWkxsNHh3eXQwTGtlL1N0ZnJWT3RUU1VMWGR2MVpFTUZXd3pkUnp2eXAvZTlFZkFIeEI4VjMzaU84MHZ3K3pnVzZYRDNNamRUZy9lejlUV3FMV3daaXU3QTQvQUFWOGd5ZUo1RThRWHQwdklEZVVwOWw2bXJoK0lsMnU0ckNEZzg4NTRyQ0dOdzhlYTZ2ZC9nYTFjdnhWV01HcEtOb3EvcXo2cGUxc0ZJOHREOWF5NTdXMEg4WVU5L3JYek9ueE12Rlk1Z1BQVG1vcmo0ZzNRakI4c2RlYTdJNWhnLzVIOXg1enluSHE5cWkvOEFBajZZamhnOHZQWG5xZUJYeWI4VlpkMnRhWkZFRTNyQTdFOVB2SHZXekQ4UnBFUUF3SG12R1BFMnVqVlBFUG40d0VqUlF2ZnJYbDQ3RjBKMDdRV3JhNkgwV1M1ZGlxZU1VcWtrMGsrdC9JOUw4RCtGYi9TdkgrcndhbkdJNWxzWUhHRHVBRXczTCtZcjY0amhod3VXOU9Selh6NzRzOFZRUmZFZlZya0ZaQzlsWUtDdlE3WWhWZGZpRmJxb1l4TnlmU2xoSytIcDAwcGF1N3VUbWVHeGRYRXVVZE5FbHFmVDBObmJGbUJPVGpwbXRNV05zc0hZblBJRmZOdHI4UjdSamcyN1pIY2NjVnEvOExGdFdkUjVSVVk1K1hPUHJYZkxHNFBvdndQSFdCekRxM2IxUG9hS0N5WEJhSk1IakdlYXFRV0ZuOXNIeUFjTjFKSUpOZUhEeDlac28vY25PZjd1TTFxMi9qcTB3dnlZR2ZlbEhFWVZ5M1JoTEJZdGEya2ZSS2FOYVkyb0VZakI5Z2ZTdDJMU0kzREJZbzFJNVpjakg0WnI1cFR4N3B5T1J1Y0hyeUswRStJMWlmOEFscDgzOTNhZWZwVy8xakNQc2pQNnBpazdwU1o3K3VqV1U4KzB3eGs5K01BKzlNdTlQczdhYUlDM2daUnhqc005elhoeWZFUFQxKzgrUHo2KzFhRGVPTk1rVlNCakl5ZUt0VnNGMWxIMUI0Zkh0ZkRMVG9lOEpZV2NqYnhEQ3dQOTBESEZVN2p3N3ByTWtpMkNBdm5QWWZYOGE4bHQvSG5oK01qekNRRDk0QmlweDlmV3Rwdkh1anFoMkZ6ay9KbCtkdjhBaldhcllLL3hSTGRMSGFhU1IzN2VHdFBsU1FOYUlTVGdkTUg5S3NSZUhMU0lLVFpRZ0wvRU1aL0Rpdk5vZkgyaUdKbE56eWY0YzhWT1BIR2llV3FtN1pjYzRMNEFxWFV3VGYyVFpVc2Q5cFRmek9xdWZEVnFaR2thMmlDOG50MitsZTIvQ3JUcHRKMWx0UXRJSXZzMDBiUXpxMkZJUFZXVDhlb3I1UWw4Y2FBemtpNjY1NXptdmNOSTFlU08rOE4yRnZiR2FIVTdQejVaRmszWUxOd2NkdG9ITmZIOFM0bWpUeXlmc2xIbmJXM1phcy9SdURjRlZxNXRGMWI4a0lOdGViMFg1bjZYV3lNdG95WEcxdDJkNFBRN3VjR3ZsRyt2TDdYTlp1ZEQwcUg3UHB2bkJya29NWVZldUQ2TjJGZHo0bTF1NHM5SVNPMllpV2ZFTWVlVGpvU1BldlUvaHRvTWVtYWJKR3dKdUpHU1NaajEzSHQrRmZsZE9YMW1wU3B4dkdNVnE5NytSK3pUU3dsT3JWbGFVbkwzVnNyOTdlUjRObzJteFdseERieFJNbzg0NGpmZ25uZ2ZVMUQ0M0NhZDR5MEhVTCtWbGdqbjJTQkI4cU1SOHZUdFgwVjRwMGdUZUpOSmtqVll6RXhlUnh3eHh5Qmp2WGtmakxSdFIxVFhyZUJyUlpMU2FZTks1WWZLb0hRcjcxald3MHFNV3QycWkvSTdNTmpvMTZzSlhVVTZVcjNQYlV1Tk8rd1EzVThTYjVNWVpnQ1I2YzFKTmVSTVVLdndUeUs0UUNOYmRZUi9xcmRCRWc2OU9CMXFqSEV1SXlwa0FQSVhzY2Q2MitzdHV5aXRsZDlicmRubS9WWXgxY251N0xzbWN6NHkxTy9sUmdiV1VSSTJQTUcweHNENmpPUlhId1hXbDMxaVltampkNDF3Nk5IZ2o2VjZWcmJQSHA3RlNyTjFVTU1qajFGZVA2RnJMYWhxQzJyUlF4TzV3dTBZVnZZMW5KODFUVjZ1eVBUcHh0aHZkalpRYmQwejNYdzFIYVNhUEZiU3NxQ1JNRUsrRGowejFya2ZIUnNCY3dRcmRDRDdKYkZrUkZERDk1eDAvQ3ZHL0V4MVMxdVV0NUhNVXNSTWpiZWhKUEcwK21LcVcycjNUYU5LMFVIbVNISW1jcndpOUJuUGV0YW1NNUllemNMVzYrblE1S2VDY3F2dGxPOStucjF1ZW1hVXVtV0Z0YmxydHJtL3VZMlFlWGhWaVZoMUlIUTEydHBibDBpdHd6T3lqQUxITEh0bXZNdkRHaXd3VGJtNWRRSExaQkpMRG9TT21LN2k4dTlRdGROdnBiUkY4K1JESEU3SGxjOEVqMzlLcW5QbWdtMVpKZmtLdEZScVNTZDNmYzh1dC9DV2kzM2o2ZXp0NUpERGJXNUZ6T0Q4OGt6Ky9UNWUxWnIyT29lRWRDdnBialhyMi9zN2FZdkQ5b3hKTW5PQWl0eHVIMXIwdjRYYUpxT2xRVHphZ2N5VEZuNTViay8zdTljWDR3anRienhKb0duWExJOXJjWFVzOXhHellEcGJLWk1IOGF0MDVPRkpMM2VhVHVrN1dTMU9OMUxWS2wvZTVJS3pmZG40cy9IaldoNHIrSXFGbzNYeThLeXRqY01ESE9PTTE1YjhTN2VPMHMvRHRwR2Y5WGJFa1o5VG1ybXJhM0JxWHhDMWU0VUt5TmRTQk05QU54eFZmNHN5TE40aDA1QmdlWFlSQTQ2WnhYNkQ3S0ZQQTBVbnJiVS9ONDFaVmNiWGs5bTlQUStkWEg3dzg4R2dnNTQ2NDYxUE11SHhtbzlwUEo5ZWE4K3gzdnNWbVU3T1NNWnJGdWNMR2VlVFcvS0Y0eU9uV3VjdmlOeWdIcU9SVngzRTNvZWdDSEdsNmVYRzN6SVN5bGhnRUE0NHJFblh6RkcwL01veVNLK2h2aUJjYUpjZUZ2aDk5ajNadHRFV0M1d29VaVpaR1p2cjE2MTRaQUlHUmtTM1ptSU9DZWV2Zmowcm1zMDM2bHBxVnJlbjNIZFduaVVXdHBGRWtyUGtLTUhucDcxU04xSk5JekZpVG5QTmNaYjZKY1JOdlp4dERaSFk4MTB0dkFkMk1qOGE1ZlowazNiNXM2ZWFlaVowS3NHWGdBWlBhc3UrY0JRekhHQnpXOXNoVGpqSVRlVG5vQjZWNXhyMTJSaFE0SnllYXVuRzhnbTdJc1FYS2x6akJKOTY0dStrbGxsbGRpS3FSVHNoem5uMXE5NWlrRXVNaHM5YTdlV3pPTjZvNVJNN2p4WDIzOEtmRnFYOXBIb2Q0VzgrTUg3Sy93RGZUcnNQdU8xZkVqc1JJU094cnROS1hVb2JtMXU3T09ReVJ1SDNvRHd3N1pyMGFWZDBwcVhSN281SlVWV2hLUFhvK3pQMW8rRk91WFhoejRqV055ditxeVVuVW5hREd4MmtrbjByOTRZM1YwVmxPUVJrRWR3YS9uTDhKZUp0SjhRVE9raGEwdnBiWmthR1JjQjM5VWJwejZHdjJlK0RQaldiWFBEdjJhNmk4dTdzTnNFbm80VVlERDhPdGRzM1Q5cnpSa21wOXU1eXFGWDZ2RlZJdFNwM1R2MmI2Zk0razNIQjRyQ3U0VmxpZFQzSGV0OGtFWTRxQm8rOWRNV2NFa2ZsSDQ5MFp2Q2ZqMk85WEtXV3BzRW1JNkxMMlkvV3ZuYjRvK0NJcnlHNmdRRkJkSHo3VndjZVhjb000SHB1cjlkUGlUNEtzL0VYaDI3dFhHR1pTWTJ4OTF1eHI4L05LdEpkWjBPODBpOUpUVU5QYnkySjZncDl4L3hycVZwUmFiT1dhbkhscVJqckZxL3AwWitVUGlYN2JkNmRZZUxMUW1MVWRQdUV0dFRRY01rMGZDU2tlall3ZmVzL1dieWJUOVUwbnhybzY3SXJtYk0wWTZSM0MvNnlOdjhBWmNjaXZmUEdOai9ZR3V5NmxMYWJyRy9CczladDhjQmp4dkg4d2ZXdkNMT0syOE5hN2U2QnFjdm02SHF5cVVuSElDdC9xcmhQZGU5Y09pYlRkcnZmdEpiUDVpcVllUzVKeGhmbGkxeWI4MU9YeFE5WTlEVzFTOHQvRFhpT3c4VWFSRDVtamF3aitiYi9BTUs3K0pyWnUyUjFGY0o0aHNZUERYaUNPODAvTnhvK294bDRNOUhoays5RTMrMHZTdWswalpvZXA2bjRRMStUL2lYWGpqWk9PVmlrUCtxdVl6L2RQZjJwOWhCTFl6M3ZnbnhESUlZSGwzMmR3UmxZWm1IeVNLMy9BRHpjZGE1cXNFNFh0dTdOZG1hNGVkU25WdGU3akZjc3QrZW4wZm5LUFU4K1JsMERVRmxUTnhwV29Sa0VmODlJajFVK2pwVmFSVDRlMUU0LzByVGIyUGcvd3l4SCtUci9BRHF6OW11Tkh2N3p3OXJhR09Mek9HNitUSWZ1eW9lNm52NmltMm1MU1M0MExWOHJBemJvcHV2a09mdXlMNm8zZXZLa25GdStydHF1NjcrcVBwcWNvempGeGQwMWVMV3Evd0NHWldZSFE3bkgvSDFwVjh1ZU9raWYwa1NxcUpjYUxlbzBTL2E3RzlYYUY2ck1oUDNUam80L01HclZvSmRPdTVkRzFPSm50cG1HQ28zRkMzM1pZdlVIOWE5RzAzVHBQRDl6Qlp0NWw0YmlRdUNpL0pHdlFQR1QvSDYxVG5aZC93QlRXRkgya2t0bGY3amMwYlF0UDBLRzQxR0c0Y3h1RGxuNDhsRjVNYnFPcjVyeWpXNzZlNXZQN1gweTRjb2dHK0xHR2c5bUhkVDYxMVBpUFU3blJ6RkJERkhjMk11N3puYmtUc2Z2S3hIUmgycnpVVzh0dm5VZEtsZG9rLzFpSGw0Z2VxdU82Ky9TbERWOHpPckZPTUY3S0MyK0lFdElkVmJ6YkVDRzhCM05iQTQza2M3b2o2LzdQNVZvd3o2WHFXYmZWQzFwZGpJVzcyOEUra3k5ZnhGUlFhZmFhdy9tV0RDM3ZSOHh0aWNLNUhPWVQ2LzdOYXJYdW42Z3h0dGFqZUc1VWJWdkVYNXdSMmxYK0llL1dyYmUxMy9rZWZHTjFjb0c1MWpSWXphM2x2SGQyVW4zVmM3NDJIOTZKeDkwL1NrdDlLdEx1UVRhTmZtS2NjaTJtZnk1QjdJL0FhdFRacitnUS9Na1Y5cHN2UDhBejF0M3ozOVZiOGpXWi9aL2h2VXptMHV2c0U1Nlc5d2QwWlAreElPbjQwdWF6L1ZGT01uWlgxWFFXNjFLUkpQcyt1YVR2Y0RIbWdlVE9QZmNPRy9HcUM2WnBza2drMHpXUExjWXhIY2Z1SkFmUU1NZzF0WEY3NHIwaUVRWHR1dHphOWhNZ21pSVA5MXgwL0ExakNid2plTVRMYjNOZ3g3d2tUUjUrallJL09yYnU3Nm1QTHIvQUpuWVdGNzQyMC9VckNhZVc2OHFPNGovQU5KVEVqSU04bEpCbkJ4MHI5d05LOEllUEpiR0tYVFBpTGR0RzZLeXJkMnNWemtFWis4dURYNE9RNk15cVRwM2lLMllIK0F5TmJ1Yyt6WUZmcUI4T3JMNFBYUGhUUzIxWFdqcG1xckh0dXZLMUdXQWxsNDNaQktuUHRVeTFhMys2NVZwMlRYTnBwcEJUL002L3dDTE9pL0ZhMTByU3hkNi9wZDNHZFR0Z2hXemFKaElXK1ZqeWNnZHhYYnA0WitNTTQyeStJZEpoeWVkbG01SS9NMTQ1OFI5RjhBcHBlbHRwdmoyK3VTK3AyNnZHK3BpY0lqSGx4bmtGZXg3VjNGeDRlK0hJejUveEMxS1ZjODd0WEdEOWR0TkxSZDlmc2cvaGhwMWwveTcvUTZlYndYNHdDRCswL2lGY1F4Wnc0dG9ZN2NmOTlISnJrSjlQK0J1bU9UcU9ydnJOMlBtQ3pUeVhyTWZUWW55NXJubnQvZ0piTis5dlRmc0NNRjdpYTZZa2RzQTRydnRNOFhhTEM4WThNK0JyeWJISG1SV2d0bEgxZHdEUWsvUC93QkpOVjdSTC9sNThrcWErODM3THhaNG52cmFLSHdyNExUVDdWU0FMcStVVzBROXhFdnpHdFM1OEw2WHMvdFB4OTRwKzFxdnpMYU0vd0JuczFZZEFzSzh2K05aTDJueFQxR1Zua3VMRFFvWCs4c0svYXJqSHV6ZklEV0ZDZmhaNGMxQXlYczkzcitza1pRU2Y2Wk51OUZSY3FsVkYyMi9BelZydFIwL3dlOC9tMmZMM3g0OFQ2SnFuaDJ4ZTE4TzNDYVpiM243aVprRnZISWNZQ3FuVUxqdlh3VzhPcWF0RWsxd1VzdFBqT0UrWFpFbzlFWHF6VitsSHgzMUx4bmUrQjQ3Ni8wQzFzck9HN2pOdmJ6dDVseXhiZ0ZsWGdLUFN2emx1Yk8rdXpIZTY5ZXRidzQvZHhZSG1zdnBIR09GSHVlS3pTc3RQUHJjMGtsYU9pMDZMVzNxeWhITEpjc2RQMFMza1ZHLzFzeDRra0E3dTNSVTlxMzlJMW14OFBYSWhzMU41Y1NrSmNTcmtMdFBWSXNkVC90VmxwY1grcTc3RFI3TTIxb0JtVDV1U0IvRk5JZjVkS3IvQUd5eDBjZVZwNUZ6Zk44clhXTWlNbitHRWV2KzFTYVRqWnJmcC9tT2xPVk9Ta250MS95TzExS3l0UENWMjkyazczRnhjQW1DTWdoWXczSjgwL3hNUDd0WlV0aFpwQi9ibHg1c3pTSnZTMmtHU1pNNDNOLzB5SGIxcnI5Rit6MnRsSFlhMUpETmRYRXZtMnNFcExHQ1FqNzBwSFRkL2QvT3VXamp2OU4xR2ZVOWJsS3Zsa1MxNExUL0FPenQ2Q0lWektiMVRldmYrYjBQVHFRaTBwSldpOWJmeVB1empZMWNoOVcxRTd5N0h5SXp3WlhIZkhaRnBMWm1CZlZyOGVZV1krUWpmOHRISGZIOTFhNmk4czAxTlYxaTZ1TnRrcTdmS0Eyc0N2OEF5eWpIVEh2V0ZiUmYydmN5WGw0UkJZV29BSVhnQlI5MkpQVW10WXU2YitUOHZJODZwRGxzay9OZWZtTFlNWXZNMW0rSG1Pekg3T2pjK1pKL2V4L2RXdlFQQzhNV2xhZmMrSzlUQ3lTNzJUVFlaT3NzNS81YTQ3cW44Nnp2RDJrRHhOcU54Zlh6ZlpkSDAyTU5Nd09Ba1krN0VucTdWMk5vc1BqSFhKdFR2bEZuNGUwZU5RVVhnTEV2M0lVOVhmdlhUQ25PVFNXLzVKSGs0aXZHMXIyakczTys5OWt2Tmp2RDkxTjRiMG02OFc2Z1BNMVBVUE1YVEZmcnVmaDdnZzloMnFld00zaEh3ZGNhbk9UL0FHMXI4VHBiaGgrOGh0WFB6Uyt4azZEMnAxaEpiK0xQRU4zcityUitSb2VsS0JIQU9GSVQvVlc2ZTU3MUxwZDZOYzF2VWZGbXRvRFpXVEFRVy9SWkpCL3FvVUg5MWVwcjFvcEpLMm1sby9ySm5qT0ZTVG02cVV0VTZrWTIxYWQ0VVY5K3YvQktWM3Y4SytEbDB4VnhxZXVMSEpkSCtPS0RPVWo5aTNVMWExRFNwYlN4MHp3cmFrZmFydDB1TlNjZndrOHJHZjhBZEhKOTZ6OUx2SkpyelVQRjJxa1A1Y3grelJ0eUpaejkxUVA3cVY5SC9CcndUcUdzYXAvYVY0R2U1dm1Nc3JucXNXZWZ4YnRUYTVtbEhSV3N2S0s2K3JPcm1sU1V1Wjgwb3ljcHZwS285a3ZLS1ByWDRiYUpaK0hmRGo2cE1nanQ3ZUFyRUR4a0R2OEE4Q05SZUFORG04WGVKVGR5SnVNbHh2WWtaMjQ2TCtGTStLV3ROZFhOajRkc2d1Mk1xWmxROFpIQ3FjZWxmb1o4RnZCc09qZUg0cEhqQW1rR1dPUDVWcFV0WkpiZFVZVVZ5eFRidk9YZnNmU0dsYVhCWWFkRkJHZ0FSUU1DdVY4UVNyRkE3c2NLRk9UWFlYdHcwY0p3Y1k3MThLL0V6eDZGTTlta3UwNDVCR2VQZkZlYmlKS01HZlo1UmhKMXF5ZlJhdG55eDQ0dm83dlZiaGo4eWs4SDJIOUsrUHZqaDRuazBEd3hZNkxidDVkMXFja2Q3Y01yQTdZSS93RFZJTWRNbmtnMTlBNmpMTGNSeVNzNnQ1aThiRGc0emo4S2Y0ZDhKZUdMeTZlRysweTNtS29Od2xVdVMrZXVXN2l2S3d5Zk8zMjErWjlIbk9KakdueXhlK2krUitTV3RlSk5lMSthRzQxTy9tdlpJWXhFa2tweXdRZEJudUJYRDI3N0oyK3ByOTN2RUh3NzhDNm0ySjlCdDJkRjJLeUw1UUFQZjVjWnhYNG4rTGRKaTBueGJxdGxHSDJRWERvbThZTzN0bXZSbGR4dTBmRTArYTkyK29rTGdNQ1JuSE5lMGVIN2JVNTlPZHJlRGVvbDZrZEQxcnhLMWlMSnljWXlmL3JWOTMvQlhFdWlhZ3JGUnN1QVJuM1d2UXkrajdYRVJoZTEwenpjNnJld3krZFMxN09PbnE3SGo3YVJxa3JBcmF1T3VlS2lPaTZtZzJOYk42OUsvUW1DQzNKSUFqT2UyTy90VWMybTJpeGx0bzM1OWUxZlhQS0d2K1huNEg1dkRPNHUvd0M2dDh6ODgvN0cxU1Z2M1Z1N0FEa1U2UFJOYVo4Q3lkUVB2WkZmb0dsaGJ4eU02K1dBd3lUaitsWG80ckJ5d0VZejNPQnpSL1pNditmbjRDZWV4YjBvL2lmbjcvWXVzYzdyUmlDUDRSVkpORTFwblpoYk9WempwZzEraW8wZTFWZU01UEp6Z2cxWE9uV2c0WlU1NUZVc3BuMW1aeno2bXRxYnVmQVVYaDdXeTRJdG5IK0ZVLzdBMXA1U3YyZGlBZVBTdjBORnJaeHJ3dVN3SVBvUGVxY2VsMkt5S1R0M01lRDlmV3FlVHZUOTZaUno1dC93dFBVK0FvL0RXdEIvK1BZN2oxeU04ZTFTUDRlMVZILzQ5VytVY3RqdjZWK2cxclpXRnZjTkl6SUNRVktrWnFuTGEyQ0lSOHJLVGswZjJUTC9BSitmZ2JQT29KYVUvd0FUOC9oNGYxZHdNV0Q1eDZjbjZVcmFCcjhjdVdzcEJ4MElyOUFZWVlDdzJsUmc4RTg4VnVMQnArTU15YmlUMTZqNlV2N0lsL1ArQm4vYm1uOE5mZWZuTkpvdXVlV3ViTnd1ZnpxT1hRZGRLcWZzekJlQnlLL1F4N1cyQTJqeWozNmRLdXlXdGpOQnNEcVR3VHVJeCtGUCt4NzZlMFpjYzcwL2hmcWZuZkxvR3RJbUd0ams4K2xUbnc5cmVEdHQyNUhOZmZ4c2RMZFZqYVZCZy9lNHppczVyYTFERGF5bFFjRDBPS1A3STZlMEllZlJkdjNXcDhHZjhJNXJJd3ZrdGc4NEhKSnJRUGhuV1BMQk5zM0E2ZDYrOFlMT3lKWTVRRWM5T09hdFQyMWlzUXd5azl6NzBsa3pmL0wwMmxuc1ZIK0V6OC81TkExY3hITnR0Sjk2b0xvZXJJU0Z0KytENzE5OEcwc1pBUUFHWW50Z2dVK094MDVWM1NGRHRJd0ZIODZieWRML0FKZUdNYy9iVC9kV1BndVhRTllaUWl3a0xuOGFhM2gzV0c1VzNKSFN2dnk4ZzA5NVE2b3BDbkF6Mzk2WmEyOW9BMkF2SjdFVTFsQ3YvRU0vN2Z0SnAwdGZVK0tySHgvc2lZR2NBNDRHSzE3ZjRoTVNmM3dPUFhpdkh2OEFoRHBRZjlhUitGUFR3ZmRqN3NvT2U1R0srVStzNDFXMWxvZm9Ed3VCZDN5UnUvSStoSVBpTHRqNGtqSmIzeFc1RDhRRDVZQThzL2lLK1pXOEY2bVB1eXFSNlUrSHdsckJ6Z0tSOWEyampzWjVuRi9adUJ2ZTZSOVNKNCs1Sk1FWnp3Y01LMG9mSGFGaUhqWGs4VjhmU2VHTmVSK0U0ejJOTmswWFhVLzVaT1QxNE5hTE1jVXVqKzRtV1Y0T1gybDk1OW9EeHJiRWtHSHAzRlRqeHBZWUdJemdIcjFyNG5odFBFVVdTQktPM1gxcUR5OWVqWThUWjV6ZzFTekt2Mi9BaFpUaExhZm1mYkk4VjZXelpJQXhra1lxUnZGT2hzQUNvNTlBSytIL0FEOWVRY3JMZysxVkgxRFZsZjdyNTc4VVBNNmoreXZ1SS9zYWovTy92UHVjK0k5RjNEYXFEMEcwWnEzRnJ1aXNneWlkK2NDdmhFNnpxaXNDTTVISFN0R0hXOVJCR1FNRDJxdjdTZjhBS3Z1TFdVUWl0SnY3ejdmR282SzhueWxlT25GU3RxV2xOZ0RheDl4WHhkRDRndmZNSWJhS3ZuWHIySmxKalZoMTYxYXpCTlc1VWM3eXB2YWJQdFdPOTBzQS9NdkE3Y2MxWWp1ZEprazNHVlY1SkhOZkdhZUo1ejFRZTNOSC9DVHpvTnJSSGpQZnNhcFkySFdLTW5sa3Y1MmZhQi9zdHVESXAraHFrYmJUVElDekllZU9lZ3I0OEhpdVQ1aDViRDIzVTBlTGZtKzYvR2M4MExHMGVzQ2Y3TnJKM1UyZmFiV09tU3hqRWlncjJHRFF1a1dYREtWeTNZNHI0Mmk4WkJjQUdRSFBjOFk5NjNWOGJFQWZ2SkQxQTlPYWw0M0MzMXBvMC9zL0UyMHF0SDFZMmgyVW5McmpIZkE1L0trWFJMTmlkcDR6NlY4dFIrT3dTVk16ajM2ODF1V3ZqZEF6ZzNMampzRFYvVzhHL3dEbDJqTjVkalV2NHg5REhRYlpuWVpVYnVPZzRwNDhPV3liaUFqNDZmTHh6WHpzUEhrZTRMOXIvSGJXcEo0MlRaa1hveitJckIxOEczOEJ0REM0NksxbW1lMnQ0WHM1SERiRVVuL1pxeEY0UHRZLytXU0Vaem5HYThiaDhiS0dIK2xxQmoxNjFzUStORjh3ZjZXdU8yV3FWVXdiYTBKbFJ4cWsycEhxOC9obXdRTCs1aUp4MkZJdmhIVFRFV0Z2R0RqMC93QWE4dGZ4dkY1bUd1RTYrdGJxK05JaWk3Wng3YzFmUGdleEtvWm5wNytqOHpxNS9COW1YM0cyajl1bFZrOEZhWVFOMXNoWTg4MXgzL0NaWmMvNlFNYzl4Vy9ENHpVckgrOVQ4eC9Pa25nWDJOZlpZM3p2Nm5XbndSbzRzeG0xWExIZ0wxT1BXc2IvQUlRYlNIRFlzeGcrOVczOFlGMEFEZ0JWR2ZtSDZWQko0dkJ5b2NaUHBqbXRtc0ZzN0dVLzdRV3pkdlVwcjhQdEo4dGY5RUk1OWNpcVMvRHpSbU1wV0Irdk9EbkJyVWw4Vm9BcWhpTVZiVHhkSHRHM2c5em1wZExBM1Ztam45cG1Mdm96R3RQaDFveWg5OGI4SHNhejUvaDdwWG5qL1doVHlNOG11MGo4VG93enVHRDF5T3RTTDRrVHpBRkl5T1JrMTBLaGdtdEdyK3BLcjQ5TDNrL3VKZkFYaFhUdEcxQzh2NDRwSlpsaGVPQVl6dGQrTTQ3MTlVZnRCK0s1dE4wV3kwWk4zbVh1aTJVVVM0NnZuSkorbEh3dnVQTDhSNlJNbG9iZzVkMmlVY3NXR0JqUFlkYThFK01maWFMVy9qQzJKbGtnMHVCVkM1eW9reGdxUG9hMGRPTUhDQzBTVy9teldkU3BWdzkyN3R5dTQrVVYrclo0QkI4TzlQVzFSSkpwTjIzRFlIVW52V2IvQU1LeHNoTVF0dzVCR09SL092WlRyVnNTQnVDa1p5TTlhMFYxeTNFWkt5TGtZSDNnYVU4SGhYczE5NW5ERjQzckYrbGo1M2wrRk51WlFSZE1veHlNVStUNFd4cXFvYjBsYzU1RmZSaTZ2YlNkQXVlTWpJeUtnZlVJSDNESzVIR0NSazFVTUZoV3QveEpuanNZbjhOdmtmTXpmREJYWUlMd2pIY2l2bVB4Tm80MG5YdFN0MGtNbmxJcExkODR6WDZZUGN4YzRBVUVldkZmbmQ4Ukp3M2l2WEdYT05xRHJudFhsWTdEVXFkT0xpMjN6SDBPVFltdlV4TWxMWlFiL0lsK0cvaFc4MS9TTHU2YTQya1Q3Rko1NFVlOWU1ajRYekhZRnZpZVA3dFovd0FFWllrOEg0T01tNmxZL3dBcStwWXJ1UEkrWVk1K3Y0VnRoOEhTbFNpM0o2cnVjT1B4dUloaXFrVkZXVFhUeVBtZi9oV04vd0NZUjlzVTU3YmFkRjhOZFgzbFZ1a1BwakkvblgwK3R4QmpJNjV3eDlmcFV5em56Y3F2VWNaNjF2TEw2WFNUT0tPWTRpMXVWZmNmTlNmRGJXdUQ5cVVuUFExMEZwOE9OYVppUk5IdEhYclgwWkZlb3FqcmtEQkJIUWlyc1YrZ0hxU2VUaXFqbDlKMjk1bU04d3hDV3krNCtjWmZoeHJTSDcwVERHRG4zcW4vQU1LMzhRb3F1dmxBRHVUWDFwQmRSenFWTVROams3UVNRQjFQSGF0RDdiWnNzYWJnbzcvU3JsZ2FkL2lmM21kUE1LcmVzVjl4OGF5L0QveEpKdUcxQ1FjOEhwNzBnK0gzaWxSOHlvUFFicy9uWDJUSkxhcnVhT1VZM2NWTjlvZ2tHMEtYNllQYzFoL1o4SDl0blk4d3FSMmlqNGxtOEZlS0pDQThDa2dZRzBnWnAwWGczeFdma2t0dW5LamNNK25GZmJNZ3NZV0VqUHRIOXc1eitWT2drdG1jRU1NOXQzSDRWSDluZjMySlptM2IzVWZFQjhHK0xCbGZzSk96cWU5Vi93RGhEdkZKaTNteUlIZnVjVjk1K1piRlpQM3pLL3FHNE5ZNWxWWE9KbXgwRGJ1TS9TcCtvTCtabXp6QjJYdW8rQzRQQ25pVTNNVVlzOHRJNm9wSHF4d00xK3JlbFdGbm82MlErenhJMW5iaU9Rcjk3ZmpIWDByeWZ3ekJQY2VLYk5ZZ3NtMlh6TU8yQWRneitGZlRGMXBHcHVzUW50d0VubXdYVmNqazV5VDNyOG80d2pVcHpvVTR0dlJ5ZGwzMDFQM0RnSjA1VWNUV21sRzhsRmE5RXI2ZmVYL0Qxck5xZmlLSzh1VWNXOE1lWUEzM1djOVdIc0srdy9ETXR2T3M4aUg1eXdEZmgwcnlxVjdhSFNtMkt1NktObHo2S0IxRmRSOE9vNDQ5R2trU1FzWlpNODlCZ2R2YXZNeW1QczYwS2F0Sk5PVGZZOXpPSnF0UXFWTE9OcEtNVjh5eDR5MVJiTytzenZ3eEREcjI5cTg4ajFDM3VyaHBOck5MZ3F4eGpiNjVySjhWM3h1dkVVaGxtVlk3ZENGUFlFbnFhTE84UlRCSEpPSkM2c3hDRUVLaThrK3dyUEdWblV4TTR4ZW5NdjhBSTJ3V0dqVHdkT1V2aTViL0FINmtranNOa0NrNUxkUnlTVzQ2VmV0dEhHZzJWdkJQcTczTWhlUWdTY0g5NGM0QTdCZTFjanEybDJONUZOZEtrNDJnUEdZcFNqOGYzU0QzOURXTHJYaSt4dDdmU0xKTE9TVzZsQ3llWTdmTXVUakRaNXpXTUtYc29UVGF2YThUYVVuV25CeFR0ek5TUjN0OUZHOEw1WExLT1QxNHI1NzB5SzQwenhBWmJlUkN5N3lONHlOcmRzZXRlajJuaXUzdWRZZXpzTG0xdXBzYkhoTDhxY2NnKzlhdW0rRjdyKzJJNUx0b1BzMGFlYUFnSUlZbjdyRTlxbUVKVGxIbFR2emJuUXFzYVVhaW0xeXVEMDdsZldyclVtMG1KdFJTRTNOMU1rVnRHcTdTdS9qa244elNhdlkyOWhvbHpiT0F5QkdSeU9wT09UVWZ4QzAyWFVydTJuVmkwZHBESzRUT0JrREt0WENMY1c5ejRCbGtFcXpDMGlaYmdCOGxIS2s0SlBldXV2VFh0R3JOeVVmaWZZNXNQSnlwUWxkUmk1NnhTMmIySGVBZE9zTkw4QzJrRTkwWldraWtkMlpqa2duSUF6enhWbXgxTzNtUm1hNGtJRGp5NHllR2J0Z1Z5Mmo2cmEzdmh6UzdPMFFIeTdKWkpYUHpFczNSUWUxWlhobXkrMGEzTTBqTjVkcmtrQVlBZkhRMTU3bktkV01WYnpmcWR2czRRcFZKU3Y1TDBQcWZTb2lOQkxxQ0NTN012cGs5SytIUGpicDA4T2h5Njh1cHZicGFXazBKaUVmM2pOL0VHUElQWTE5djJGNU1ORm5aRkJ3R1pCMko3RDg2L0wzOXBIeEZlNlI4UGwwZWU4a3VMcTl1QkpMSVFBQVR5VlgyRmZUVWFQTlVwS0t2c2o0ekUxbkNuV2I2WGExUHhnMGk1a2JVV2NCaVhsSi9NMTZYNDluRXVzeGxYeHRoUmNkZWdyb3ZCdWl3Tjh6cXVRdWVhOGk4Unp1MnVYbVpNZ09RUHdyNi9Fd2xGUXYyWjhSaEtrSnluYmRGUkVHMDg4MDB5QUVER2ZVWnJOU0tVZ3Nyc2UzSFNueUpNbkJHQ01kZmF2TTZucjJkdGhaamozTllNVUxYTjdGRUJrdTZxTWY3UnhXMHFUem5hc2JNZWVBTTF0K0RMUlpQRytoeDNEckRFMS9CdmtrNFJGRGpKWTloV3NOd2hGT2NVOW0wZnBEKzBuNFcwUFFmQ1hnRzJzOVBndHg5bFpaWFZNWmJBTEZqM05mbkZiM01SZEg4NERDa0FEaklIU3YyTC9hK1RRdFUrR21sM2VuYXRZM2JXV29iV1dDWlpDRWxYR2NEdHhYNGYyNVh6QUN3T0J4V01hZnVLNnMrcUJPU1N1clBYeTZuME5wc1F1UmdJWCtYT092WHYrRlpsMVlPajVYT0I3ZGE1UzAxTzRXMlpVbUs5c2c0T0JXa05adkJFTXR1STlSbk5lZjdLb3BOcHF4MTg4V2xjanVYWUx0SURZNkFpdk1kUmRtbCtiMTZWM0Q2Z2p0eUFPT1I2ZlN1U3ZtaGtsQld1NmttdDBjczdOYm1Fak5rNDV4VmlTVWxkdTRrRHBrWXFXS01sOEFkS1Y3ZVdXZllvSHBuMHJvZGpHeksrbDZkSmYzNnhLY0RPV2IwRmUrK05DdW1hQnBscEFnaVNSV1lGU1F4eDYrdFkzaC9UNGJZUTdUOHhZYmozSi93cnV2SDNoM1ZkUWowMTR5cDhxSWdKa1pCUE5lZlZxUmxYcFhkb3B2OGowcVZLVWFGU3k5NXBIeThMdTdRZ2lkOGprSGNjaXZ2NzlsbjR3VCtHUEhpV3VvWE1qMm1va0l4WnM3SFBBYm12aGVUUWRZamNoclorTzQ1Rk90OUsxV0tSSmxoZFdWZ1ViSGNIdFhxVTYxTlA0azBjOEUrYTBsSnhla2w1UDhBVS9zZDFieEZwdW1hY3QzY3pMSEV5Z2h5ZURucFdGcDNqVFJyK0xkYlhzTWgvd0I0ZEsvS3JTUEdXcitOUGdiQ2lSc1o5TGNKZmd2dVlmM1cyOVFoOWErZHRPdkwremtMUnp1ckwwSWJBcm9qaTNmNGRuWm5SVHluRDhqNTV5Y3J2Vld0NWFIN3FYM2k3Ulk4aVc3alU1MkZTY2NucFh3ZDhRNzJ5cy9FTUhpSFRjTzhCRWQ5R3ZTV0E4YnNkeXRmTXc4VzZyZFFxbHhPV1VFRWM4NUg5YXliMjd2L0FEUE5XY3NTRGtFNURBOWpUZUxuZE5LeDZFY3B3aXB2M205TmUxajN2NGllRjlOMW5SbTFDMlh6clc4dHdMbFJ6bU05SEgrMGg2MStYOTU0ZGx1STM4S2Fnd0YxQnVsMFM2Ym80Ym55Yy8zWDdlaHI3MCtHUHhEdHJTOW0wTzh5SUpHWm9kM093dDFYbnFEWE9mRnY0YnBkMjZtM1ZrdzdTYWZOM1J4eVlpZlEvd0FOZGJrcWtlWlAxUjhuUER6b1ZIUms3MjFweTdyL0FEUjhCNmRFZkZHa0h3N2ZKNVd1YWFYWFRwSlBsTXFyOTYxa0o3aitEOHFkcDhyZUw5SWowRFVHOHZXdE9ESnAwc25EU292VzFrSjdqK0d0TFhiTzY4UzJqNmpDalErSWRMQUY3RWcydmNKRjBuWEgvTFJjZk42OWF4cnNEeHBZSFZMSWVYNGdza0Qza1VmeW02UlArWGlQSC9MUmY0Z1ByVXdidjMwMVhkZjVuallpbktLMGZzL2V1cEpYNUp2cjV4ZDlUUXN5UEdHbkpvR3BEeU5mMDhORllUUy9LWjFYL2wybEovaUg4SnJ6R0JKYncvMkxxUWEzdkxabWp0cEpBUXlNUCtXTC93Q3lUMFBhdlRTQjQvczBudGdJdkUxbWdNaXFkdjI5SStqci93Qk5sNyt0VDNtcTNmaUM2Z3Q1aGJKNGtTRVFmYURoZnRHT0FyazhDWURqUGV1YkVRaXFhYTlWTC9QME44dm5KMXFrYktFSS93QVNtOUhGNzNqM2pMb1o5cGNRV01WcHBWL2RiTDlJMldHNENiamFGK2k1N3FmMDdWYysyRHd0cHNkbHFGdzl3Ym91Y3huTFJLM0JrUmozUHBUTk9qbWlqQ2VJN1lRWE5qTDVVY2t3MlNBOW81UFVaNzlxNEsrMXk1ZTVsc2RkdDkwSmNtTjBIelE1Nk5FZTYrM2V2SVVXMjAxZnE3ZGZRKzFVNDA2YW1uWnlYdU45RSs1alNSM21pRU9DbDlwdDMzNnh5ajM3cElQenFCYk9hQXRxT2pUU1BGSHpJaEdaSWdlenIvRXZ2MHEwZnQyZ3NTcGp2dE51ZXZlS1VIMUg4RGo4NnVXMm16QmpxWGg2NmtKaUc2UzN6Ky9pSGZqK05LNjNQbFdyMzY5UG1lTzR4YmVucXVxOU80bG5hYVhyWDd5M1pMSy9CejVKTzJLVStzWi9oYjJyVnVMNUhZMm12MmNwa1RnWEtqRXlBZXZaeFVoYlE5YVRsWTlPMUVINytNVzhyZWhIOEJQNVZabXZ0VTAwSlo2N3B4dVlDdnlNeCtZRDFpa0hVZTFaOHliMTM3SFdxYWpHMmo4MFY3WFQvRUdseFNYV2szYTMxa3crZnlodlVqMGxpUEk5NnBOUDRUMVRkOW90bTB1ZkhNa0tsNEMzcVVQSy9oVzFwMmpTK2Y4QWEvRGVybHBCejluWnZLdUY5c2RIRlV0WDF5em5meU5kMFVyY0EvTmN3cjVFMy9BbFB5dFFuNzF1djRpa3VWWHRwK0JteGFmNHIwMVhrMDIrRjViZHpidUpVSS8ybzI1SDVWaXRybW5TT1UxTFFJUzJmbWVIZGJ5RDhPbjZWSkRvdHBKSjVtazY1SHZ6eEhNVGJ5ajhlaFA0MTBNOTk0NXRZeUwyd0Y1RjZ6UUNkY2V1OWVmMXJSZkp2N21jS3Z2MCs5SE5HMzhFWEp6SGUzMW9TZWswU3pLUHhRZy9wWDZCZnMrK0svRFdrNlJxZWszRmkrdVJpVVhDTmIyUG50R3JjSGNyaklHZlN2ejZiVi9Ea3JnWEhoOFJuK0l3VHRIK2pacjZSK0J2aW1QUnZIVnFkQnRwWHVieFRiaUc2bUNSTnU1R1hYa0gwcTBtOTc3OVRTbkZPTWxhTDA3dFBUVSt3dmliNGsrRTl6WWFVSVBERDIwdzFPM2VVdnBUUUV4Zy9NdWNEZG4wNzEzcmVJL2hRaFUyZmdhNG1QWVI2TXcvOUNGYWZ4VDEzNGtUYVpvaVgzZytGQU5ZdERGSkZxQ3pCNUEzeW9RUmtBK3RlcTNPdGZHUzRZQ1B3cnAxdjgyVDV1cGJqK08wVjBOSmN0dnpNWk5jc0xXdHIveTlYOU04dnR2RjEraWoreS9odGZxRzRCa2dpdFZINDlhaWpuK01kM0hKTEhZYVpwa0lmQmQyYTVkTTlpRjRycTVvUGpYTEp1TjFvZGo4M0JSSG5JeDllSzgrbThQNjdOTk9kYzhkM1hrdVMwcTI1UzBSajZldkZZWDFhMHY5N0MwT3ZzL3htLzhBSXZhcDRac2RxbnhiNDNua2laTStTSmx0SU0rbTFQbU5jem92amJ3L3BGeTFwNFM4Tm03TG5iNTRoOHFOdnJJL0pGV0lwL2dmcEYwRGJ4cnFsNWdiUU4rb1RGdmJPUUt5Ynp4YjR6djlRZ1hUTkRYVEF4Q3JOZUFibFgxRVMxYmRvKzh2djBMYWs3SnFUVC9tdENQM0l5ZmpEWWZFR2Z3RmU2amZhb2l6cE5GNU9uMmNZTVM3ampKWnNsMkh0WDVlUHBGcGJTTmM2N2ZzMHpIUDJXSi9NbmMvN2JjaEIrdGZxRDhVUEI3UitDTlR1OVc4V1NYbXJHTWZaVmFjUVJxVDFFY1M5L2MxK1Y4ZHY0ZTA3NTd1VTM4L1h5SW14RUQvQUxjbmY2Q292N3VqdnE5a0M1WEJXYTBiNldYeU5VWFd0YTVHMXBZV3lXZW54bkxJcDJ4cUIvRkxJZnZINjFWaXZiTFMyOGpTVk4xZXVkcHU5djNUNlFyL0FPekdyczBldWF2YXBMY3ZGcCttSWYzWXg1Y1FIK3dnNWMrOVpFZDhGWVdtaTIwZ2RzaDdnOHl2OVA3aTFHdmI1ZFBteFI1ZWoveitSYlFXZWl5bTR2Q0x2VVNkeXdrN2tpWS94U251M3RYYzNGcEZyV214YWpmMjgzMnkzalo1WWs2M0VZNURZNnFQWDJyelhPbmFRMjVpbDVlOWZXS0p2VS8zbS9TdXUwSkxtenVGMTNWYjE0Vk9mS2k2eTNPUjkwTDJUMVBTc1p4ZG03dS9mdjVMeU8yaFdpdmNrazR2cDI4MlllbjZqcU43ZkpjU3lKQlpRcVVLc1AzU3gvM0ZYdVQrZGRERnBjM2lPNHRvTEtTTzIweUhjenN4MnJDQnl6UDZuMHJxYm53dkw0aU1lb3Bkd1dXaG9tNlNVallsdWU4YXIvRTU3QVZUdHJ4OWF2NHRJMEN4RU9sUUVOTzh2SG1LdjNwYmgrdzlCMnJXRk50eDVZNjdKZHYrQ2NHSnJ4cHhuR2M3UlN2S285a3Y2NkY4K2Y0cXU3VHc3b1MvWnRIc1FaSnBuK1VNRisvY3puK1FxZlVIVHhKZldYaG53OGhoMG16K2FXZC9sRGxmdjNNeC9rSzJOVUxUNmNuaDN3ZGJ2SlozRnh0dTdrSDU3aVVjL01mNFlWN2RxeWJ4aGF3eGVFUERoKzAzTnpJcTZoZVI5YmlUL25tcDdSSjM5ZXRlMVRzb3RhNjZTdDE3UlI4OTdLcnozK0d5YnBxWDJiNzFaK2ZaRnUvK3orSXRUdFBEdWhaaDBiVGdXbG5QOFczL0FGbHpKN25zS1plZVQ0azFlejBmUzhXK2tXQ0hFamNBSXYzNTVQOEFhYXJHcVJ4YVZBUENtaHlDNnVKMlVhaGRSLzhBTGVVZjhza1AvUE5QMXF0ZVd2MmNMNGEwbHhKSzVCMU82WGtNdy81WmcvM0Y3K3ByV2U3NW11bDdmaEZlaDFRaktMVGk3S3o1RTdhZnpWWmViNkd2cHVuRHhWcnR0YjJzYkxvK21rUndKM2tPZXZ1em12MVlNdGg0RThJS3hhTnIrNFg1RVh1NUdGVWY3SzF3bndtOEVhVjRlMEJOVHVnaVF3Umt3cTNVbnZLM3VmNGF3cktLNzhjZU5VeXVZeGhZWTE1Q0puR2NlL3JUL2hxN2VzamkwclRhVi9ad3Q4MzUrcDZ4OEcvQXR6cTJvTGZYYU5MdmtNa3JzTTdtSjVQMEhhdjF3dFlZcldCRVZjS0FBQlhEZUQvRFZ0b21sUTI4YUFFS01uR0s5SXlnR01aNDZWbWxaZXJ1YXdqZVhNMXF6SHY0VmxoWUZzWkdLL01uNHArRnIxZFIvZHVDOG40OGYwcjlOTHlVbUFmSzBmeWxtSjdZN0UxOFZlUDdyU05EMGpXL0Z0OFl3TFdENUVNbVVsZGZ1RDY1cmlyd2MxRkpYZHo3akpzUzZEbmQ2Tld0M2JQa2FMd28xbmIyOWpjRkRjaTRpdXJvS2NzaVl6SEY3RTlUWGh1di9FNWRQK0lOcHBFV2t2TVpXQWFZWnd1ZjdvSEhIYzEwUHdIMTI4OFFhYjRqMXEvbExTM21vTkk1YmtBWTdld0ZmU0ZucG1rVFNyZUpCRTVLbmJKdEdRRDNCcHFtNFEwYXU5VHdzVmlQYlY1dDdjenQ5NXo5eGUzamJDRVZSZ0VuT1B4T2EvR2o0dDNTWFh4SDFpVlNyQnBGK1pXM0E0R01naXYyaDFuU283M1RMbXpkMmpXZEdqODJQNzZCdU1pdnhhK0szaDdUL0QvamlmVDdJTjVNTU1RQmJPV2JIekhuMU5KMzVIOGpLazVjKytoeGxpeFZjbEN3SXgrZmV2b1g0ZCtLVzBlTFVrQk8yUW9jWXowNHI1enRnNVJ5RDkwWklyMTN3Um9ONXJGemRwQWVSR3JFZXhPSzB3azZrSzBYQy9OcmF3WmxUcFR3YzFVUzVkRzc3YU0ralpQaVhzQTJqT1Qwd00xbnI4U1dJNVVuazlLNVdYNGFhNTV2QlFnSG9LWC9BSVZ2cXJqRzhBOU1ZcjZmMjJZLzMvbWZuM3NNcC82ZG5VbjRsRVlBUWRCejNxNnZ4T1JtT0ZLOERnanFhNHYvQUlWZHJoNkZTZXc5S2Y4QThLcTE0SEoyZ2YxcWxXekgrOTl3cFlmS2U4Rjh6dC8rRm95cGpnbkJ3QmpQQnFnUGlaS0plT2ZxdlNzQi9obnJNUlRMaGllUmozcXYvd0FLMTF4NUdMTXZmdDBxWFd6RGIzeVZoY3FiMmg5NTBqL0V1VWxWQ01DTzlNLzRXVE9TQ0VKSVBXdWVUNGI2c0hBTTY1eHh3YXNSZkRMVjVKVkN5cUc5ZTFKVnNmOEEzaW5oY3NTZWtMZkl2VGZFYTg4ekpMZGZUR0tRL0VXNVorQXhxcXZ3ejFVeXkvdk1ybkJKRldVK0dHcW5PMllEampQcDZWb3F1WXRmYklkREtscGFuK0JKL3dBSi9kcUNWM2NITlA4QStGaTNFcWplQ01kLzZWRWZoZnJwaWNCczU3REZVRStHZXNTZktycU1kUmtEbXA5cG1leTlvVjdISjRxOGxUOVdhZjhBd3NTNkxaeXcrbzZVcmZFVzZaY2hTZm9PZUtwSDRYNnlDVDVoSUI1SEhGWG9maGRyQlVONStCMStZWXhUY3N5NnFaYWpsTnJ4bFRYM0ZHYjRnM0xTSXltUUE5UWNVbytJRjhpNCtiMUhGVFNmRFc5REhkSVRnOGRLc1MvRFhVRzVOd2M5ODRxYjVnK2t5ZjhBaExXN3A2K2hUWDRoNmd5TVBNWUU5ZWcvV2tQeEF2ZHdET3hBR0I2VkUvdzV1a2tLbWJJUHRWcTMrR04wKzh0YzdlT0IxelFubVRka3BBMWxWcjNoWWlIeEkxQmM3UUJ4Z0VkNnpEOFFOUUx0dUxBSHRtdWgvd0NGVlhTZ2Jya0VkUnQ3VlRiNFlYYnNUNXgyZzhzU0JRMW1YVlRGRjVWWjYwL3dJRitJRjlnSExZQTZaNjFYL3dDRmk2Z0NlR0g0MXNyOE1iaFRuN1FTRHdNRWZuVC9BUGhWazVBUG01SjY1TlZGNWpiVG1PZHh5ZVV2K1habHgrTHJNQUFoV05iOXQ0bzA1OGZ1MXorRmZMVDZCcXFuQVRuNjFkc05NdVJPRm5hUlIxd3B5YThHT05xYUt4OXI5UmhQN1RaOWdSYS9wTG5CaTlQVG10K1BVZEV3Y3g0SHFLK1ZJNHRMZ2RGbCsxQXNlRzNZcm9OMmlCY3g2bEtyOUNoWVovV3QxalgxVVRsbmxjWXU2Y2w4ejZRYTcwR1QyNzhpdGZTOVAwdlVMbFlJWHk1Um03NEFBem12a1pybTRMWWhrbmY2QU5uOHEyTE84OFEyenBQRExQRTRCQVlKa2pQSFFWcjliaS9zTFV5L3M2cHVxa2tmVjBtaldjZG9zLzhBeXlZa0srY0JpdlhHYTV1UzMwdDJLbWRNWTlxOFhzZkZXdFJSVzhGeWkzVnJGTVdNTFpUNzNVWjdackcxVFY1NXRTdUpMSkVqaGI1a2paaGxSNlZheEZQWnhNcW1BcjZjc3UyclBvQTZicHhBeE1wNEk2Q3N4dEp0c0VEeTMraWl2bSszMXJWa25rUndqTjFVQit4clVPdmFsRTJERnlSMmJOU3F0SCtYOEFXQ3hLWHhwbnZFWGgrM2NuaUVIUEkyOU1VNGVITEpuR1lveHp6WGk4V3Q2bndmSWw1UGF1aFh4SGVFRlNrZ2IwcTFVd3kzaitBbmg4VXRwZmllbS84QUNNMkx6QStRaDI5cUovQ3VuTVZIMlpPbnJYQVcvaWlaQnRMU3J4NkdtcjRuY3ljeXZnZE9LMDVzSjJYM0hHNk9NdnJKcjVuWmp3anBoVWhyWWZuVFpQQmVsdEoveDc5T3RjNG5pN2EyVE9jajFxeC93bXYvQUUzVUh0eFZYd2pRK1RHSlh2ZjFOR1h3RnBFbjNZTUQxcWkvdzYwdFFTRWNEUFhyVm1QeHJ3Zm5qWmdldVA4QUN0S0x4ZVpHSkJUYU8zUVZoS09GOURSZlhMOVRsSmZoMVlCeGplQWFyLzhBQ3VMVUU0bWZyd0JuaXZRQjR2QlVnK1hrZHM0RlREeGdtQ1FzYll4d0QwckwyV0VmMmpSVHhjZDQvaWVZZjhLM3QzSi8wb3JWMWZocHNHUmR1Y2NWNmduaXkzSlViRUdSL2U3MXJSK0pMUFl4Mlo2Y1o1L0NuN0RDN2N4bkxFWXhQU0o0Yk44TXBEbGhkOU8zSE9Lb3I4T3JzQnY5TFVMOU0xOUVEeExZbGNGRDlPS1A3YzBzcmtLUVQxOUt3bGg2RjlKNmVwb3NUaXJhdy9BK1ozOEFhaVdHeTRSZ0Q2WXFlUHdIcktFL3ZWNXlLK2wwMVRUOTJTbzdkcW1mVTlKY3FBaERFODhWSDFTbi9PYkxGVmJmQWZMbDc4UHRkQlVveUVrZEtqaDhFZUpSR1BsSGZxYStuMzFIVDNZQTU0UEdCZ1ZweDN0aDVZeXd3RHp5YXhXR2pkKzhiL1c2aVN2SFgwUGplNDhHK0kwZkhsQnNuakJweStGL0VDSVI5bjVIUERjMTlYUGRhZGtCWkRqTldvSk5NMkErYjh4Sjc4NHJuK3J5djhSdjlZZHRZbnluY2VIUEVubEk1dFpPZWh6bkZaQ2FQNG1HNExiU1lVY25KN2V0ZmFjOXpiQkZSSnVQUUdvMSt5bEpkc3BEU0hubnRWT2hKSzNNWkxFcitUUStNRHAzaVhnR0dZbm9PcC9sVk0yL2lhTWtORGNLUitYNTE5NFc5bGJiR2J6MFRhdVJsc0UvU3FEUXhFUGwxSXgzeGloWVdwcDd4VXNaVDFhaWZITnJMNGgyRUdPNHdCeHhrWnJvOUF0ZGIxRFh0UHRuTXdFMHlLeEk0QzU1cjZ5c2JTRWM1UWNESHk1L0N1MzBxd2pqMUtHWUttQU04QVpCcjFhV0VuelF2TFM2djZIbHl4OEdwcFFzN1BVOXN0TmR1dkN0aHFWM2FtSVN2QTF2RS9VeHFSZ3NQZXZ5TGw4UWFtZFkxRzRqZVRNa2g1eG5jQjN6WDZUZkV5Nm50UENrVy9reWwyempCSXhnVjRob09pUnhhZGFLMFVaL2RLeFlxRG5kelhwWWluVXF5anl1M2RubDRXcDdLVW5QVmFSU2ZUcXo1QW0xM1hEeUdma2YzS3BueEhyM0paU2VuSVRGZmZVbWsyeEdUYVI4S1A0ZjFyRWJSTEdVWUZyRnowOUs4NldEcnA2VFg0bnJ4eDFHM3dIeGRiZU1OYlNVZ01NZC9sNy9BSTFZdWZGK3NxZVdRZ25uNU9hK3dFOE02YXM0WnJDSlI2QVZxVCtIOUVjSGZwY1dCNzFjY0hpTFg1a2pDZVlZYU1yY3JQakVlTk5aZU5SOG94N1Y0aHE5KzkzZDZwUEljczVBUDRERmZwUEw0YTBBUjdScHlLZStBRCtkZm5ONHlnaGgxL1hvWVZDb2ttRlVkdUs1TVRScTAxSG1sZE5uc1paaWFWV3BVVVl0TlJ2OGpYOENlSTdyVHRFRVVlMEswa25Ydm12VElQSG1veDhiWXpqT0s2UDRWZUhOSnUvQjFqTE5aaVIza2tKYyt4L2xYdXYvQUFnbmhwbEord1k2OWFxbGhzUk9LYWVsdE5UbnhPS3cwS3MxTmEzUG0zL2hQYjhEZDVRTzcwUFN0bVA0aTM2dHhHdlRwbmppdmFaZkFYaDh5aFdzMkF4MEZSRDRkK0V4OHhpa0djOEFkVFJLaGlvdXllcGhIR1lONmNyKzQ4dUh4SXVUSGdXK0Q2N3VhNmkwOGQzTEJNeDQ0UE9hNmFQNGRlSEJLQ0E0WHBnQ3Q2UDRkZUhzTGd6QVp4MTZlMmE2S2RQR0xyK0p6VmErQ2ExZy91TURUL2lscWVsM0VqMndaREpDOFRrRWZNa2d3dzU5YXcyK0ljcGxJOGc0eHh6MHIwYWY0ZCtIVng4MG81OStQcFdkZC9EM1FXMk1rMHlsVkk1NzA2bEhGM2YrWk5PcmhMYmZnY2tueExPUkV5UHljNXlLUmZpZkxCS0NHbERCdU1lbnBWK2Y0YWFMSVNmdExnOWlEM3FGZmhqcGJLNEY4NEE0eWVheDVjWmJyOTV0ellKN1d2NW9zei9GVHo3b3kzRU1qbDg3bnp5VDdtcmtIeE10R3lVV1E0NkE0ckkvNFZmYStTU3QrV0RkU1c1UDRVNkw0VTJRNlg3Y0RpcGNzWXJYdVdvWUY5RWRVdnhQMHdxM0VvSUk0S2pwVlgvaFllbEZpV2RzNUpJd0t6UCtGU1FNQ1YxRncyUFRpc2wvaE44dTRhajh4OVIxb1VzWGZhUmZKZyswYm4ycjhDdFJ0dGMxVFdyaUxmaTN0bFZXeGphWkR6Zy9RVjljM25pSzdzcnZUSTRMUkxyVDVsY3p6dExzOGhGNDM0UDhPZW5yWHozOEYvaDVmNkQ0T21pYWR0bXFYTHMwb09Qa2pYSEdPZ3hYc1Z4RXZpSHdsNHFpU0pVaEZzSTdYNWVSSGJkQitKR2EvTGN6cXlyNCtyelh2SDNWZis2ajl6eVdoVG9aVlJWbForOUszVG1aMS9qYjdVL2hLOWkwMlg5N0tVQ0JSa3lBOHNvUFlrZEtUNFEvRS9UN3ZUSk5ObVVyZTJoSUtiZHU5QU1CZ0QwSTZNUFd0RHc3Y1IzWGhqUzVEZ2dXeU14QTUzQVlCcjQwK0tuaG0yZzB1WHhCYVhmMlRVSTV0KytOeis5YlAzY0p5SC9uWGpVY1RPalZqeTZPV2lkcnBlcDc5VEMwYXRHckdhYlVYZmV6MFB2TFVMT0hVL01meWRtVHN1RnhnbFNjaHZjVmovRUtSTk0weVJiV0NLSnJxRVcrNVZ3dzNja2pIdFhrdndrOFlXdHg0STB5OHU5VyswM3dSMHVrWUVTS3diSkRnOThkSzlLOFdUeGF2THBBUWt3YjJrWWdjWlVjRE5iUnFxRk9yZHIycmR0UHpPVDJNbldvcXo5bEZONjZkTDJMdHVrTjFwTWZsdCs2U05RUUR3d0F4ejdWOHRlT05adTROWXZiN3kxUVcxcmxVNmJRQmdWOVhXbHRaVzFqYjI4ekJYbVptamlCNUlYa2srd3I0aitOdGpxa1Y0a28ydEJxVWlRUWJUMXgxeVBwV3NtNVZWZTFtbGNkSnFLbDg3WFBPZmc5cE41UHFxWFRCZzAxeUpHUGZrNTRyOUFQSHV1WFdud3JERHd6c2hjOWNKa1pOZUErRXRLdXROdHJkNC9rWkYza2h0dUZBNU9lMksyZFIxZlR2RUdvSkFMbzdibU1RUnlLRG5QVWtFOVRtdFhVMWRtN3RtNm9SY3FkOVl3aTcrcDlDK0pqWk40YnVwM1FzSTdjeWhWeVN3akc0Z0R2OUsrUFBoUHJPbS8yVDR2R3J4UERwbXAvUEZMS3BFZThEZ0hIM1NlMWZWK3NYZ3R0SmF4Yzc1NG9PWkc0SEM5VGoxNzE0RDROMTlWOEw2bForWDVqeTNyYjJaQjVlSEhRRHB4MnJTdldoR3BmUy9MYVgrUndZV2hVbFFtdWptbkgvTXMrRExlMHNORGVRSWdlUWwyVlJ3UDdvSHNCWEpSUmFpbmlEVDdlRi9LTjNjVFNUK1hJY1B0WE9PZS90VmZ4UDRnc2ZEN3hXNVltV2RmbFRvTVp4eWEzZkRaOFB5NnZwRjVjNmtFU0IyZFN6YlZKYis5L0t2RnAzNTRwcTEzdXoyYW5Lb1ZHdFdsdGE1N0Q4U0x6VXREK0Y5N05ZT0V1NGJZdW00Wk80Y2s0NzErRGZqTHh6NHE4YStUSnF0MkxsWVNmTEFpQ0FFOWM0Nm12MkkrS2VvK005YnY3N1Q5T3U3T3owTjlGdUo1ZFdWQmN5ZVl1UWJkVUp3dTRmeGRhL0ZDeDhUU2FmYnFzVnBISXEvZDh3WkI5elg2UmdmWkxtMWkrVzFtdFQ4cngzdEc3Ti9GcTQvTXF4YUg0bXRvMWxqaktSdVFPQjF6MDRxUzE4SFhsM0tCNVNzZXJFeDlEOWE2V2Y0azNUUmdyWndxT003ZUJrZWxPdHZpbTl1V2J5ZHJjRWZMbnBYdGUwakw0ancxQndYdXBJN1hUL0FPdUxiaG9kSmpKenk1QXdjZTFhMFB3MjFEeTFsYTBBUElZa2pCUDA5SzgvVDR3ZUlMbjVvbjJaNElBMjRGUGsrSStzcVZVenNHM1lKTFo2K2xaMnc5N2NyWnUzV2NWckg4VHV6NEkxS2FTTUphUlpqUXBsVTI1Qi92WTZuM3Evd0NIL0NENmJkWFhuZUdiZS9FcTRIbkZsQ2U2N2E0cUQ0bStJdE5XVklwMmJlQVdKNXFCdmkzcWhSWG5Zc1FwR0IwSHZSSlUxc2pPRHJLV3NvMlhtN25yRVBncUxjUU5FZ1lOd1F4YmFjOWlQU3VJOFdmQWg5VXVGbTA2MGlzSmdtV1NOc3h0NllCNlZIcFh4WnVMeTVXS1NkOE53cU4wL092U0l2RThVakdTUzRKSkdPdU5vOVJXTGROYnhkeTVQRXpuOFViZk5uNThlSS9DbXY4QWhpK2EydmtWV1BSbCtaVDlDS3o3UnZNVDV2d05lNi9GeThoazB5MW1pbDNiNWlBYzU0RmZLU1gwdUFOMkJqRmNUanpLNlIwUW03YTdyYzE5UklqbEFSZ1IzckhmY1ZCelNsdDJEbk9UVW5Uc0tFcldGZlZzSVpIRGdMeXpjYzEydGpidEd1R1VGeTI3ZDdlbGNWQ1VEYnVwelhWVzkra1RLNzUyTDJIOHFpYWRqYURQWFV1N1BTclZibDlwY2ZjalA4VGY0VjU1ZGE1cWw1TzBqem5rbkFIR1BZVnhkN3FNMS9lR1IrQjBWQjBBOUJXaEFFVURrL1N1ZFUxRkp2ZG5WS3Ezb3RFYk1kMXFPUmlZL1R0USt0YTdISGczR1IwSEF4VlZwbEM5UDFySHVMd1liaW5HS3Y4QUN2dU1sVWE2cytrL2hIOFlKL0NYaXVHUzhIbWFmZUliYlVZeHh2aGs0TGZWZW9yN0QxalJSYlRHU0xEVzBqa3dUajVsWkc1VTUrbGZqOUk3TS9UbXYyNi9aZDFlZFBENDhOZUpZN2N4NmlQK0pjMXdtNHdNZnVxeDdidTNwWFo3R3JOSndXa1Y3eThqdG80eW5IbVZSNnV5V3U5angxYmJiTElHNUtjbGh5dGRQRzBCVUVjQXIzNXlmclgxWDhSdmdocU9neW03c1kydUxRakxxT1NuNWRoWHljaXlOUHRDSGNEMCtsQzNzMGUvU2tweFVvTlNpOW1qamRmMER6Vlc3ZytTYUlobGNkalgwUjRCOFhXdXZhVkxwV3BuRW9VS1ZQM3Nqb3krL3BYQkV4YkdqQndvNm5ybXZJdFZzNzZ6djR0UnNHS3lwenQ2WkE3VmNLbnM1ZVQzSXhXRVZlblpyM2xxbjJaSjhTUGgvck9tNnV1cTZZeFhVTFVlWnZRWUZ4R3ZmSDk3SEJGZkttbzZiY1hjMFhpWHcwclFYVVVpbTl0SXVHdDVpY2IwSC9QTmoxSGF2MVgwanhkb1BpancwNXZKaGJ6d0o4ekhobGNEcVBYUGNkNitGOWQwNjhzYmg5YjBHSGJMdllUTHRJOHhRY0g1RHdVYnZYYkp4M2kyNzZueEZXblBuY1pLMGxwYm8vSitUUE85V2dzTCtDNjFMUllZN2J4SEJzZSt0WVcrNlY1YWExQTduK0pSMDdWazZiWWFiOFJwTjNtcFkrSTR5cGNZMlJhZ0IzQjRDVC9vMVlONW9UYWhKSnIvQUlaMzI5eGJNSmJxeFZ2M3R1M2VTTHUwV2V2cDNyczdoOVA4VGFiS2xnMEZqNGxJUjVZVXdpWHVPY3hIb2szY2p2VlIxaTFlN2U2NytubWVJNHhwelU1WGpUcDZLVzhxZjkyZmVMRThRZUtOTDhUaGZEMnZHUzB2TlBZdzJlcHlyaHlSeDVkMk9wWFBSdW9yeEs5dHI3UmJrNlZyOWs3UkFaaWNISlFIcEpDL1JrUHAwcnNtMVRUL0FCSVgwL3hLV3N0WGh4SERxVHJqSlhqeTd0ZXYwZnFLamt2OVUwSUxvUGlpd2U2MC9HWUdCQmVKVDBrdFplaFgyNkdzNVU0MlNUMDc5VjZsUnhWWG5sKzd0SjZ1a25vMTNnM2Evb2NFME9vNk5DSjRKRXZOT3VEZ25HNk4vd0Raa1grRjZ0V3RsRmNPbDNvVjA4TjBoeTFvellrWDNqYitOZmJyVzdjYUpxV2pRdnFPaTNpNm5wVGo5NHlwa0tEL0FBWEVSKzZSNjlQZXVaU3gwdlZYV1RUWlJhWGVjL1pYZkNsdittTG4rUnJuY1pLOS92OEE4ejFLRmFNNHFTMVh6VFgrVE9wWFZkRjFndkRxMEFzTDllUHRTTHRWejZTcDJQdUtVM2V0NkxHSXBSSGUyREhBVnYzc0xEL1pQOEpybXJqVjJrZjdIcjFrN1NSNFVUZ2JMaU1lL1p4OWF2V050ck9uaHJuUnIxYjIzNnZHQmxzZWtrVGYwcmw1RnIyN2RQa3owWTFXN2FYOCt2M0dsRHAzaFhVTGdTMlY4K20zUFVRenRtUGQ2TElPUitOTjFIVlBGbG1naTFTMFMrdFJ3cGxVU3B0LzJaRjVINTFsVDZoNFYxVmlMcTBmVExnOE5KQU44SlBxMFo1WDhLSU5OOFMyQ0Y5TXZsdW9mU0I5NHgvdFJ0L2hRdDFmUjluL0FKbDFKcHIzVjF1M0g5VVlwUGhLOC9odWJCL2I5L0huOUdGYjlocG1yUk5uU2ZFTUQ0NklzNWhZL3dEQVh3S3dYMWkwZVFwcU9qUkYrN1I1dDVQeEE0UDVVb3RmQjl3cDJYMTVhdVR3Sll4SXY1cGcxczdycS91dWNtajdYKzQ3U2UrOGZSWisxNmN0Mk1ZekphcE1NZlZSVmF4MXkvc3BWdlYwU0cxbnRuU1JaRWllTXFRZUNQcFdBdWt5eEZQc1hpUzFiUFlUUENSLzMwSzdlenQvRzdXbHlScUhuRlV6SGk1UitSOVRXZk1razFiZGVSMVllNmsxcmF6OHo5U2ZGdW5lTzlSOEwrRnJ3ZU5vcnFHOTFTeE1LdlpLaGplWGxYeXArWUw2VjdsZmVEZmlWQ3pHNCtJeklBY01ZN0dKTS9Rc2EvT253eW5ndTcrSHVnRFdkU250dFdpMXFOTHVNM2JnRzEzWk1nVVpBd080NlY5WWFpbjdPTUxFRFZUZEgwKzIzTTM4cTcxZHBidjVISXFjdVdLVVphT1cxR0pQcjNoMjBqaHpxbnhKMUNiZVR1WDdURkFQd0MxNWM4UHdOc3B3SmJrYXJLU0RocFpidGlmWUxXa2J6NEh3eUUybmgyVzZJUHk3TENhWXQrTDEwVmo0aXVvYmd0b3Z3OXUxUWdBTzBjZHFBZng1RlphcVhYOGlIS2Y5OWV0b0hUV1BpcHZMY2VHL2gvY0twUWJaWllsc291T0FTVDh4cndmWG9mR3VwYWlzbXFhdmJhZkdXdzYyZVhjRDNkc2ZuWHVkL2RmRnVlMDNzMm1hVkNSZ3FwYTdtQVBmbkFGZk1PdWFabzR1dDJzYTFOZU1PdStRSXBQK3lpVmkyL1g4UlJrbEphUnY1WGsvdjJPKzhTMi93cnMvQmVyMjFwdXY5VW10WFY3a0JyeVJNOGxuYzhJUHBYNWh4WDJpV1d5UFQ3RnIyNVBBbW5YSzUvMkloL1d2MVhieEg1bmdmVTdMdy80WmY3R0xabHVMdmFMZVBCSEpBUExIRmZsNWFhdnFNam0xMERTZkliRzFwSTFNczU5MmMvZC9ERk8vVFhmWFg4dzU1Y25XOTk1TzcvNEJIcUdsMzdlWGRhL2Z0RnVYTWNHUTB4SG9FSENENjFWaHV0UzFJZjJmbzFnWVljRGZzNWQvOXFXUTlCK2xhMDNoL1JkTEtUNjNxZ3ViaGp1YXl0WDN5ZlNXWG9wOWhrMXNXUThVK0tJbXN0SXNJN0hUWXY4QVdsRDVVS2orOVBLMzNqUnl5azFaWGQ5T3h6KzJqRlNrNVdTV3Nub2puQ3VnYUFWd1k5UzFBZmpid3QvN093L0t0NkRSRlkvMng0cXVaWTRuRzZLMUhGeGNlaXFwKzRuditWWC9BTGY0VDhLTUUwd0pyR3FnZ2ZiSFhOdEMzL1RGRDk5aDJZMW9udzBJMi90dnhyZlRLWmh2anNRMytsM09lUmtIL1ZwN211bFVwWGZXeTFmWTRwMTQyaTdPS2xwSFQzNWVTUnQ2RmNYL0FJd2trdDdtT0RUUERsc2hVdjhBZGh0QjFCVS94eW44elZiV0pydThuLzRSWHd2cDBrRmt1R21rWTRrdXNmOEFMZTRjY0JPNEhRVnowdjhBYmZpNWQrMkxTZEJzK0JqSzI4STl1OGtoL00xMThPcXorSWJSZkRIaGEzbWpoVlFKcmw4TEpjcXZWNTMvQUlJeDJYb0s2b1E1WXExMHBhZWN2SmVRZTE1NDhrdVhtcDZwdldGUHM1UHJMcVlkcHJNT2k0MEh3K2pYdHpkdXNkOWRSNTNUK3NVT1B1b1BYdlhZYWhEWWVFOVB1cmZSbzVKcjY2Y1EzTjF3NWczZjh1OFpIZjFidldDejZmNFlqYlRORGY3WHFNNDh1NDFCQmtrdHdZN2NkUXZxM1UxcGFmTEw0V2sreXhNYnJXYnZhcnhJUXlXNm5uM3pMNzlxdCs2bmExL3dqNUx6RkNMY0lYNXBYZDdTMGRUKzlMc2wyS1VNYmVITGRiRzBWWnRmMUJkc2pMODMyT04vNEFmK2VqZHoycjdaK0N2d2t0NEVlOHZlYmVMbTRsUFNSeHpzQi91aitJMXlId2grSEduM2V2WFhtWEgra1o4eTVlUmdaWTBiK0VlNTdtdnFQeHA0cC8wZUxRUEQ0d3B3anZFTUJSMDJxUFU5elcxT0ZydVM5TG1kYVU1emNJUzFlczViZW55N0dQNHgxcWJ4SnFrT2o2VkZtemhrQ3liRndKV0hiL2RGZmN2d2MrR0VHZ3ZMZHpnbTRrQUp5TWRmYjBIYXNUNFAvQ2hOT2dqdkx0UVpXWEo0emdkY0QrdGZheUxIRUdPN0lBMjRQdFdGUmM4NHQ5R2JVWSs0NHhYdTJWdlh1WFpHQzllMU5pbml4dFVnQ3ZuZnh6OFI3TFJBcUFndVd3VGtFTDlSWHpKWi9HKzlsdWsyMjVKTXBYTDUyN2ZVVkU2OU9Palo5RlF5ZkUxS2ZOcEcrMTN1ZmRldmVkTkROQ1Nyd1NSc0hVbkJPZTJmU3Y1K3YybC9pS3VxU1FlRWJDNWI3RHByc1ppclpFa3ZvVDNDMTk0L3RIZkhLWHdqNE10b2JTUURWTlVRaU5mK2VjVEQ3L3Q3VitFY2lYRTBJdUpHWm1seVdkdXBicWVhbVU0MmpKYnY4aTR3blJvT0xlc3RsMlcxL1ZuNmQvczdwQkI0S3VZNDAzdUxubEFjZFY3NTlhK3BMTFZiSU0wVXlMYnlLeC9kbGgrYWtkUlh6dDhCNTdHMzhBSzdzaVN5M2JCUDd6bkdBTWR6UnJQd2Y4UTZwOFJyVFcyMWlTTzBRQW0zR1FSdDdlbUszZG5DTDh6NUNsenVjN1N2WnkwK1o5UVgxaTBpZ3d1cTU1REVaR0RYNE8vR0VhK3Z4QzFSZFcyZmFGWUFiQmhQTEgzTnVlMksvZmhTb2hqNU9PQjduRmZociswSmVHNitKbW95TWhVZ2hGeU1Bb293Q0s1cFg1SHI4ajJZT3p0M1BJTEdLUmt3TUV1dkFJNHI2YStDc3lRK0liMk9RY3RhNEdEeDhyWnI1ZTBpWnhNaXNRUVZJd1QyeFhiK0VOVU9tNnM4bVhJMk11RlByVjRPcXFXSnB5YTJsY25NcUxyWmZYcC96UVAxTFNXMldiYnVYMXlUL1dwL050V0dTRjQ5UFd2aHlYeCs0WUVLNXg3MUVueEN1QVRnU0FkZnZWOTRzM28veW41SkxJcXpqWlQxOHo3b2FXMURCbFZWeDllYWtEMjdTWkxMakhwMzlLK0VKUGlEY3ZnWVljWjRiclNwOFFwY1lLeVovd0I3aXEvdGJEL3lFUnlIRXFOblYvQSsrVmtzTis0a2NIcFN5U1dSSkk0SGJpdmhSZkhydkd6QVNMdFUvd0FYRlV4OFFHNENpUSt1V3BMT0tLZndHbjlnVm5HenFOUDBQdW9HMFdRSElQSEFZVko1MWpnblltN3NhK0YzOGUzWlhDaVRqMWVxeCtJRTJjRU4rZEo1eFJlMERPSEQ5ZVAvQUM4YlB2THo3WVc1RzBmeXJQUzl0RWJBa0hBeHdPdjFyNGRYeDVjRmxCRWdIKy9VUjhjVEJ4OGpEME9jMVg5c1V0UGNIREk2MGY4QWw0ZmZYMit5Qzh1VklBSVpldFowVTFsMlBMSEo2RHJYd24vd25WeHZHWTkyQi9lSXFML2hONXk1YlljLzcxWi8yelRUK0FxcGtkYXBGZStmZjRrdFFybHprZXVhZEZlMllUaGtZZW5manRYd0ovd25sOWpHekl6MDNIdFZWL0cxMHo3aENGSDFxLzdZcHY3Qmd1SDYwVXZmdWZlVXQ3YkRjd1BmTzA0eUt6b3IreWtRcVhYY1JrNXdNZTFmQ2g4V1haSnlNODU2bWsvNFRLNFZUbU5ldlFtcGVjVTFaY2hyL1lWYTN4SDN0RHFOcG5EVFJxQU80Qk5YeHF1bnJHTXpSOVBiSnI4OC93RGhOTHZHUExRRWpyVUI4WFhtNE1RRHp4UkhPWUovQWFmMkJVYXM1bjZIblZMQWtZbVRISEFJcWpOcVdudSt6Y2k0Nm5PYzE4QnY0dnU4L2NVY1ZRbDhaWDNQeWdaOURSTE9vUGVBbzhQVFRUVlJuNkVQcTJtQk1iMVBQWE5SdHJtbTU0blJmeEZmbndQR0Y4RXdGWDY5RFFuaW5VY2NBRWVwNjFtODRqL0lpM3c4NVN2N1JvOU5qdjdHYU5jRlFUN1Y0bjR1a2FMVlZNRXJvREdNbERpcWNlcGhYVlkwbDlBQ0RtazFTN3RZNVZrbmprM0ZCaFNQOGErSHF6VGhvdXArblVhY28xTDMwSmJWSTU3V00zT3BYSFhqUHpWMHNXaitGWllqSkxxa3VlaCtYdlhtTVdyVzBqNENNTzRXdFNTTGZ5QmorUnJnYlBVM09vL3NUUzhNMW5xN0U5aGdyL0t0VTZENGpnaFdXTFZNWkhHSEkvblhuOE1icmNJcXVQWDJyc2JyV0pwRWhnODFkeUhqRlBtZlF1eXN5N0hhZUp6RzBadlNRNStZRitDZnhyS24wclhMUnN1K2QyT1ZJUFd1bGp1SjJoVGpkeGdZOWEwNUROTEFwWlNDT2FubWwzSHlSc2VXcmFha1oxM1J5SEF4bi82OVVieU85SmRmTmxYanJ6WHQwc0d5eVp3VHllTWY1NjF4UVdUNW1MQndjZ2c5UlJ6UHVIS3RqQnQ3V3lHbnhnNmxNMHFnRUx2SUJOZXAyV3F3UVJCeEtHY0pqRGM4MTV2NVFLbkFVYlQweFhSNlkxc0VBYUlHVFB5c2ZUM3ArMFlleml5NXJmakM0aDB4bjh4SGJHMlA1Y1lKL25YeXRjYXRxc3NyUEpkeWxqL3RFVjdONDllVjRvQ3AvZEszVEdCbjFyd1IzQkpPZWVsYUtia3IzT1NWT0trZWkrRHBacm54QmFSU1R5SHpaRVFiamtjbnZtdjFNMFBRZnM4VWlHM2djZzR3VURZOXhtdnlyOEVzUjRtMHphZXR6SDJ6M3I5ZXJ1ZTl0YlZHdG9nenNlbU1HdmxjNG5VNXFjWXl0YytpeStFZlpOdEorOFowK2hOall0akV6YlQ4eW9CbjY0cTAzaEZwTlBXVm9FWGdZSzRCL0gxcVhTZFUxbS9tOG96ckh4Z3FvQUl4NjVyMGlXQzhpdGd2bU16RG9EWHpVc1hYaFpjK3ZxejIvWTBaSjNndnVQR0xmdzVhdUNra0VtTTlRRno5ZWxTLzJCNFlqbWJ6TGFRWStWaVU0L0N2VklydVI1OE5BTStvSEF4VzRBejUvd0JIWGs4anJXaXg5ZS94eVhvekY0UEQyK0NMZm1qem1Ed1g0UmxpekpMQ09PRndBVFhrdmo3UjlFMGJTSmJxenNZc3E0R1M1Yk9mYXZkN3pTTENTVm5JeGdZd0R4ajFyNVYrSittcmI2RkxMSE96UitZbzYxNkdIeEZlVldONjA5WHMzb2NHSXcySDltN1VvcDI2SStjcGZGbHpncUxlSmZmSnJQOEErRWgxTEl3UWc2akhldUdqbFdSc0hrK2xkUmIyNUtxR3lPY1pOZlRPclVXOG1lRXFWUDhBbFJYdXZHK3FXMHlvejV5TWl0S3k4ZWFrMG9ZdnhtdUcxTzBpbTFCRUJIQUFydmRGOE5XN3NDUUdISFR0WHMwMVVsU2kwM3FqeDZ6b3htMDB2dU9rajhYMzIvNWlmcFYvL2hOTDFrNGRldmZ0aXZRYlh3bnA1UUVScStBUHFEWG5xZUVkYkdwQ0lXcWl4M2wvTWJCeVIySGVvWHRrbnVSRjBIMktaOFkzb09EdHdmUS9yVzFCNHltK1hnY2Q2NGZXdkRtb1cxOTVRdDh3dUNUSU1ZWDJyMVBUZkJOdDlpaE1pSGVVRzc2MURsVlMwYkxWT2sreGxTZU5wL000VE9CVmx2SFkzcm1MQjJqT005cTZLWHdGcDdiVG1RWTRHT2hxbEw0QXNTbWZPY0hQUURrVkh0S3lXdHpaVTZUNklUL2hQMXd2N3NIUHFNMVloOGYyNk5rcm42MWxqd0JHNXdzNVhuSEk1RlFwOFBYT1EwNTYvZ2FJMTZ5ZDd2N2pLZEREdUxUaWtqdWs4ZFFtUG9UbjAvclhxZmdQeFIvYUd2SkVuUlVZdDlLOEFoOENTbUp3dHl3QTR6aXZkL2hqNFVsMC9WN21XU1FuTnZqSTY1elhyNE90V25YcHB0MmJQRnhWS2hDalVjVXRFZW1mR0RVQ05KdHdYNFdBbkdlZ3pYejlwM2o2MGlndDR6SytBb0dldVFCWHAzeGtqbWNSUW9SdWFKRTU5NitaWXZBT3FsQU9GSSt0ZWhpNnRXblZTaDFSNUdCalJxVTV1YjE1MmUyeWZFR3lPUUoyUFk1NDRwUCtFNXRmSkFTWWdFWjY5YThmajhBNjY4WUEybGdTQ3hQcjYwaCtIMnN4bFZNWXlUakFiak5jMzFuRnZvL3VQUytyNE8rc2w5NTdkRDQ1dENjbTVPZTMwcllIakd3eW9hNUp5ZmF2blNmd0hyMXU0QVFFUHlvM1pxdXZnN1hsa0pOcExnZGVPUHdOZFVjWGlrcmNyKzQ1S21Dd2psZFNXcDlNVCtLdE9KSCtsYy9xSy9QdnhmZlFUNnpycnhESWVWaUdyMjl2Q212YlNWc25PN3AzL0gxcjVXMVNPYTNsMUpKRklkWlNyRHVDTzFjZUtxMVpLSE1qMThyb1VhYzZqaTd2bHN6N1IrRm1yMnR2NE9zWTVKd3VBL0JQVDVxOXVnOFIycHlCT3BBeU0rb3I0YjhLNkRyRW1nMjBzY0VqSXlGaHQrdld1d2ZRUEVPSXg5bm1BWUU4WnJhbGlxMElSU1dpUnc0bkIwS3RhYmJzK1puMkZjZUpJSHdCTW1NQWJoVlYvRVVBS0RmR2NEMTVyNHltMHJYb2lQM2M0QTY0eldKUEhxMFRjaWJuMlBhaVdQcVh1MFRITGNQM1o5NVIrSTR6L3dBdEV3QjlLNjYyMXBXWGpZQjE2NXI4NDRadFhVL01KVkdPaEI1cnRkUHZ0UkhSNUFjQUhyV3NNd21uZmxNcW1YVTVhSm42WCtHZFBUWGY3WmI3UWtLMkZnOTA1TGZlS25BVWU1cnppTFd5Q3daUXdLa0FaR2VlL1BldmkwZUlkZXM1VzhtNm1UekZLT1FjRmxQVlQ3R3FVMnM2a1pGWnAyNUhyVHFaako5QnJMNlN0WnZZKzROTXVaYnE4amhqaEVra3Npb2dCR1dMY0FmV3J0eE5KYnlUMjhsc1k1RmtkSkV6eXBVNElyNEFqOFM2dkU0WmJpUkczQXF3YkJCSHVLbWZ4anJqTVpEZHlGOC9NeFBKejF5VFdNY3gwMWlXOHFUMVVySDN0SGRKdFZURnRaY0hCN2c5L3BWNyswVlFSZnVzZ01UbnQrRmZuMmZGMnJLK1Z1WCtwUHBXakI0MzE0Z0R6Z1ZQUHIwcXY3VGgvSXcvc3lkdmpSOTdTNm9oUmNKd3g1SjZWVGt2R3VGSlNBbFFRcGtBenkzQ2o4K2xmRHc4YTZ6aGw4d0tRYzRIT2E5TytIdXM2MXJYalBROU9FaDJ6WGFGeDErUlBtUDhxSlpyVFVHM0ZxeWJmeUNobGRhZGFNZWRQbWtrdm1mc2w0eDFHZnd6NEIwalRMWm1lNWt0NDQyYkdjQmhsdW41VmplRnJlN3M5T1FxYm43Ukxia01xNGFNcXcrNjZuMTlxK2dEb0ZucTlzVmtRSzB5RVJ5cGtQR0FPTVo0cmt2RVZoYWFSRnBtbXF6dHlKcmwxT0djcndCbnQ2MStMNDZuaUoxdmJYU2k5YjMxMTZIOUY0R3RoNDRaWWFNVzU4MnVtalM2bk0vRCtHN2w4SnJHQ0k1SW5taVpOb09DcFBIMXI1UWpqdnRUK0tXa1htbFRSWE9tbzhzVnp0RzJXQzRDbktYQ0hvZjdyZERYMlg0RE52QmY2L0hFem1FekpOQ3pMamR1R0c1UFhrZGErY3ZDbnc2azAzNDU2cHFpeWdXMXl4ZUtNRWpQbThucHdjR2lNS1RwUWJhdkpPSzY2dDJIT3BVV0lxUlY3UmFtK21pVnp4alV0MmkvRUtPOGd0bld6MUMrVzN2RndTZ2N0Z1AvQUkxOXplSXA3ZXh2RnRVVElWdzBhZmRWV3gwNDdFVjUzck9tNmZIckVrTTE0NlFmMm41alBJbzI3bE9RZzlCNzFqK052RThGclpYV3NTMjdUdVp6YjJWdU0vdloyNFVuSDhJOWE0WnhicHVNVXVmbVN2M1NQUzlwRnloS1RhZ290MjgyZGpxOTV2aXRadFN1VWpramtMVzJNb295TWJDUjJOZkQ5eDRuYnhWOFNMQ0JnMzJiVFBNQ0tlbTg4RTE5bWFIWlRhTDRIbXZ0V2thYTVFTFN6TXczRExub2luc09nRmZOdDFwY05uNC84NVBNQ3pXVUxxN1JGQys3NXNjREhGZEZGUGVXcnM5Ym5QSzEwb3V5VDFWajY0MGF3aHVwSlFjRklZeHg2NUZZazJtYVpwRXd1bzdWVFB1Q29NOExuK0xIcjcxMEhoU1g3UnArb1BHd3dzcUJ5RG5IRlV0UWVOWE1oWGU0VWdEUFgycXNSTGxzMXBwdVlVazVUa3I2WDFSNDk0cjhSWG9zcnBIZVFobGI5NlRuT094Tk44RnJmSjRFdDdrV3BhTjFhWjVkdUJ5ZnZFbnI3VlExVzJ2Ny9UcmJTb0lmTXU3cHBDSXNnZFR6eWV3RmU2ZUlybzIzaHNhSllpT0x5clpZdHA0R1ZIUVZ5VTRxZEtjcHpkazlIM2ZZNzZrM0NkT0VJUnU5V3V5N255Ny9BR0pwbW96UnFMV1Nja2IyQklieXdUOTQ1UEFyMHlQNGVhVE5iVG9rbVpXaVo0WXlkd1lqdHgyelhFVy9obS90SkxTOHZKSXZNZERISEZHeEpLSHJ2SS9sWHFtbTI5bm9HbWFoNGtlWU5CSFlzcGhHZUFyWk9EMnowcTZWS002a1kzYlhXeGxYcXVuVGxKV1QyUmtlRFBEYlcvaG54WExxbG5OWW4rejVsMlBJckJGMkhMRGI3OXpYNFNGWUVnT1FTTThBZENQL0FLOWZvLzhBRXJWRDRaK0ZPczZtc3NubWF0Y2hZbFNkbVZZNVJsb3hucUIzcjh3NEx5U1N5TXhKWVNFYlFCd294elgzZUNoYW0ybDF0OXgrWlpoSytJVjk3SnUvbVlseG56WFpOdXdrNUhwV1ROS2hRNEF5T2hyZSt6U3RpVGFTcmNZOWF6WkVoZ1k3aHgvZHIyWW5qUzNIYWRidjViZ25CYm5qMHJmV3lKd1F1U0NPV1BXczJIVTdlTkZRTGhoM1BwVzNEZkNiYStNTDJGVmQzSVdoTjVOeGN5dnN3dU9EbnBXTGYybHdFMmtBN2oxWDJxd3VvM01kM0ZHb0tveEpiM3ExYzN5dE9jTWQyQmpQb0tUYkJkVG1vZE9FVjFHeGwyTG5CejFIclhaV2VvWEVzN1F4WEI4b2Z5SGFxdDc1YzlvM21IRGJjanZnMVU4UDJ4dGc3bm9laFBlaDdNZlV2ZU5oZFMrR2tZeDRqamxBVTE4elJ0aHh6eDNyNlA4QUVONU5ONGR1NDJPVkRLeWdkQnozcjVyQUpQQXpVUldqOVNWcDk1cWVhQjA2VTFwbUpBelZaWVoyNlJzZndOYVNhVnFUQU1MV1hCNkhhYUxJdTdFakc5dURqdm1vN201TG5hT2dyVmJSdFRTUDVvd2c3NU5jekpHMGJGVGo4RFNTVGU1YmswalVna1ZleE5iUzNHUmtHdVlpT01WYzh3RTUvU3NwUjFMVGRqYmttR3dZckpsa1UvNTZWV1p5V1BOTVpoMEE1NzAxR3c3cytnL2c5WStIcnZ4VVB0MjFwSTR5OXRFLzNaSkIySTc0NjRyN2QxT1dRVDd3NVJnZHlrY0VFY2o4cS9LelRiNmZUOVN0cnVJNGVDVlpGLzRDZWxmcG1MK0xVYk8ydW96bExpTlpCanR1NXgrRmZWWmZPUHNaUXRxbmYxdWZNWmhDY2NUVHFjenRhMXV6UitzSHdnK04xcHJXanc2VnJKa212MFpZc3JIdUR4NHg1aHg2ZnhWNU44VnZEM2hlMThSM0F0bzBSMitZb0RqaysxZm4zcG1xNmhwV3BXOTVaenRGUEMyNUhCeCtCOWozcnFOYitJRjlyT3Z6VFhpckhQTUZZQlNkcDI4ZktUNlY1R093OG95dkg0ZnlQdDhpeHRKU2x6WFVuRjNYU1haMlBhTGZ3OEx4dGtQK3NJNzk2MHBmaDlyRWNQbk5ibDFBUEtqUFgwckE4S2VMWHNMbHlDa2pTSnR5UndQcG5vYSsvZkNmaTdUTCt4amhrTVlkUndPTUd2TXB3akoyY3JIMjlhdTFEbWhTVWwxN241R2F6NE44VGFWZE5kMjFvZktjNGxoY0hiSXZ2am9mUTE3VjRZL3N6eEJZUGFrZVJjeEtBcUVZZU0vVHVEMzlhL1ZTNjhPYWRxVm5JNXRWS2tmZEhldmxueDc4RTFML0FOcGFTVGFYY1FCUms3a2Z3c0IycnRoUXFRYnUwNCtSOFpqY1JoNjdzazRUMjc2bjVYK012QU91NlJyU2FqcGF0YWFoRVMveWNMS0IxWmZYUGNWNERxbWgyZmllZDdpeGpHbjYraExUMldmTGp1R0g4VUIvaGY4QTJmeXI5VG0xNkxWRy9zclhZZnNtcEtTQStkcXlFY2JrUFkxOHUrUFBocXMwL21NRERPcEhsWGNmQUpIUVBqb2E2dVNOazByMzNYK1I4dFBuNTdUYmhLT3pYYnMrNlBpOGF2cG12RTZmNG5EMm1veGZ1NHRUMmZNQ09BbDB2OFFIOTdxS251cm5YUERjS2FQNGdzUnFHbFNEZGJ1RzNBQTlKTFdVZFBwK1lydWRhU3p2bVhUL0FCVmJ0YjNpamJiNnhFdVN3SFFUQWZmWDM2aXVOa2w4VCtEb2haYWhheGFwb2wwY29ySHpMZVVmM29YL0FJSCtuSXFsS3p1NWEveld2OHBJODJwaG90Y3NZSnh2ektueldWMTlxbkxvL3dDdENLRFF0WDBvSFd2Q1dxUGYyaXJtWlZYOTlDdmRMaUhuSys0eURXRzBuaEh4TTdNNWkwUFVXNmJWUDJPVnZvT1lpZnlycTdIdzRsek4vYW5nalZwbHVJd1diVHBIQ1hjWTdoRDBsWDI2MWhUNnA0WTF5ZDRkZXNuMG5VUWRyWHR2RmhHYi9wdkJ4ZytwV3NHazlsYS8zZkpoN1dhMzU1dVBWSzFTSy92UiswdlQ1R0xxc0d2Nk9rZHZyV25pN3RTY1F6YnR3STlZcGx6K1ZVYlBSTEc5bFdUUmRXRVU0NUZ2Y1A1TWdQb2ovZGI5SzdGYmJ4djRYczNrdFpZdFQwZVEvTVVBdWJWeC90b2Z1SDY0TllIbStBTmFQenh5NkhjbitOTXoycFB1djNrL0ROWU9rNzIyOWRqdHA0dHVDbGZuaXZ0d1Y3VzdyZjVGYlVkUTFPM2tXRHhEb3Ztc0R4SzZHR1kvU1JlR0ZZWXN0Qm1ZU1dHclBhU2RvN2dGY2ZTUk9LOVd0N1A0aTZUYU8xbE5EclduQWNpTXJlUmJUNm8yV1g4cTR1YlZmQTkrN0MrMEtmVFp1alBaUGxNanVZcGVuMEJybmxSbkI2eGNmVGI3bWRsTEdScXB0T05STGRwNnIxNmswY25qYUdNanlJOVJoWG5sRnVWeCtITlk4MnNhRXhLWC9obFlYeDk2QjNoT2Y5MXNpdEMzOE9XTE9yNlI0dHRRNVBDVEY3U1FlMlRsYy9qWFV0WmZGT0tBNXQyMUNCZTRFZDJ2NWpKcE9EMzArK3czaTZYT2s1MmZhZWorVnp6Tm8vQmt4eXR4ZlcvczBheTQvSWl1aXROTDhQQ3l2QkRydVE4Zk8rMlpkdUQzSUpxcGRhbThaSDIvd25icVFlVDVVa0JQNUVWY3ROUzhPeTJ0OFUwYVNCZksvZUJMbGprWjdiZ2F6bnphZkZ1dXg2ZUhsRnpiVFd6czBlci9BQXMxbXkwdlVJYkErVnFnbjFHem5qaGlpTFNzOEpQeXJ2SDhRUFRwWDYxeStPTlZ6SWJiNFc2a0RrL2VqdDRjVitJdmduVmRMc1BGV25YVmxGTkhORk9oak0wZ01ha2tETEVBSEFyOXM3cFBpOWRXMmZ0MmdJckFmTXNjclk5eG11cUc3MCs4NHFxaDdqZkpmWGVUWDVIRlgzaXY0bDNEdUlQQ0VkcU1ZeFBlcHdQVWhLWnA5bjhXZFRsQ05xR2wyQ2taTG9qVHQrRzdnbXN2VVBEL0FNUmhJR2s4U1dwSjZyRGE0eDcvQURHcmRwNFRuZjhBNC84QXhYZnN1TUZWa1NBRC92bm1uWlBzY3psVGk3TGtYb20vekwrdmVDMldCUnJmaTIrdWlWeVkxa1czVEgrNnRmT2QxRDRQMHlLZGJhRzNlUnVGZkJtZkh0MXdhOXJ2Tk0rSFZsS3JBcGN6SmpPK1o3aDIvQWsxd1dwU2FaY1Fzc01FeXg1SlZFUVJBRDBCYkZEZy9QOEFJdjJqZW52TmVTc3Z3SlBDc25paTY4TzZoYVdhUmkxZUZ6SkxPTWtnaitGUjByODg0cmZ4L3JTejIxbGJDeXNFZGtrZU5SYTIrQWVydWNicS9SM3c3Y2FnMXUxcmJUTHAwYjVYSCt0ZHVPU1NlSytBUEVQaGZ4amZYOTBkYzF1T3hzbzVuRWJYYzJBVnp3WTRVeVRuNlU0MFcwMmw4N2FIUE90Q0RrbktNWGRPejFldlpkZmtjbjloOEFhQXIvYkxsdGN2UmpFTnV4anRGUDhBdFNINW54N1Z1eHhlTi9GbGdQTWVMU2RDaE9jc1BzOW5HUFlkWkcvTTFpUmF2NEUwR1FMcG1tdHJWMzBXNXZWS3dxM1l4d3IxNTZiald2cW1sK0s5WVdLLzhVNnAvWjFtY0dOSlJodHA3UTI2NC9wWFhDbXBTMnY1SjJYemJQTmxXbEZYYmNlWjZTcWF5Yi91UVhVZ2gxM3c3b0VxVzNodXliVWRTWTdmN1JuaTNIY2VQOUhoNXg3RTgxZXVOQnM5TWtiVlBHTjlMY1gwcDNwcGF5YnAzUHJPL3dEeXpYMjYxSHB2aU13eURUUEJlalNpNGwrVnI5MTh5OGtCNE8wOUlsK2xhUytIL0RIaHlScnJ4SGRmMnRxaE83K3pvWk4wYU42M0VvNm4xVmE2VnJIbzB2bEJmNXN4YWFxMlRrcFRWM0ZQbXJUWHJvb1IvclFxbUR4RjQxVkxtN2VIU05CdFBsVGFteUNKUi9ERWc1a2MxWVRVTGk3L0FPSkI0VXRKWUxWOGVkSVRpVzQyOVpKMy9oVC9BR2VnclhtdHRkOFNySHFXdFhpYVhwRVF4RDhteEFvNlIyOFF4ays5V2JSTDNXN1k2Ym9WbzFocFNzQk5jdC9yWno2eU1PcFBaUlU2ZWV1NyswL1RzanBwd1NWdVdGNmIwaXY0ZE52cS93Q2FReTNhMjBtUTZib0RMZjZ0S3V5ZlVWSHlRWis4c0dlZzlXcjYxK0V2d1gzcUx5Nlk3U1MxeGVIcVIxS1JFL3ExZWovRHY0UDZUcE9tcmQzcUxiMnlLSGs4ei9XVFk3eUgrRmY5bXZvV0Y5WDhheXJZNk9qMmVqUm5aSmNxdTB6QWZ3eGpzdnZWUmkxN3owdHN1eFVaU25KeGkzWnYzNmt0My9YUkkrWi9IbXRlRmwxQ3p0dEN0dkt1YmNHTlpyY2xXWlc0S25IM3MxOW1mQnY0WHl3Q0xVTlNVL2FKQnVLc01sUWVmenIyRHc1OElQRE9tbTJuYTBpRHhxQXJNdVNENmpQYzFkOFJmRUhUOUh1RGJRbFdkZUJ0cm1uVWIxZWlSOUpoTUE2eTVZY3p0M2Y1cytqZFMxZXgwcXdaMmtTTlVVWUovd0RyVjhNK0ovaTlxaXZjeHhrY01WUjQraHowL0d2UGZHSGozVUx5MU1mMmhjTno4dlg2Vjh4QVhWdzNtT3hKQTRJT051RDFyaXFWWk5xenNySDJPR3dGREN3OTZFYWszM1YwaTlxdDlmNm5leXkzRWpsbkpMQTVQUHY2VXlIVXJQU2NUM0V3WkkwTG1FRVpiMEdENm4wclF1SEN3R2E0dWNNUVM4a2g0VlIxSnhYeGRxMnFMZmF4UEpDOGpSbC9sTEhyampPUGVqRFlhV0lxVzE1VnUvME9ITTgwV0ZvODJqcVMrRlgvQUswT2MrTStyM25pQzJPcVgwck5jQ1pGakE0VlZJeHRBOUFLK1diQzd2SmZKZ056S0l5NmdnTng4eHhYdnZ4QmYvaW0xQlBKdUZ4OUsrZHRKQk4xYmpubVZNZm5YclkybkNGZU1ZcEpjc2RENERCVjY5V2hVblVtNVNibHF6OTRmZ0xaMnR0NElqMnhLMjI2bVZYWlFXd09PdGZURTEzc2tqeC9FRG12bjM0TFE3ZkFWcVFTTjF6T2YxcW40bitKL2hiUmZGbGxvdHhkc0x5WXFBQU1xbTc3b1krOVMwbEYrck1NTkoremkzdTFkbnR0N052VWpQSVBwMHI4U3YybGtWZmlaTVY2RzFoL1BGZnRMY1hTR01OdEdCMXhYNDVmdEhXYlhIaTI3MUVaQ3I1RUlHTyt6Sk5aelY2VDAyUFFoTzBuZDc3SHlycGNRa3VZMTNxdTdvVDJyMVR3WHBDYW40bHQ3Tm53SldjRnVoNDVyeWl3OG9ScklRQ1ZQekQxcjEzd0hlSkg0MDB1WlJoVEtlQjdpdVdnazYwRTl1WlhPckZTYXdsWnJkVTVOZXRqNmRtK0UxaGdzYjRIL1pKeFVkdjhLTER5eVd2Q01qZ1l6ajYxNzI5NUZ1emxoN2pCRlc1TDJHS01Fc2pLdzR3d09hKy9oZ2NJNzZmaWZrczh5eGtWcTNmMFBuZy9DYXpQSDJsaDlCVnlMNFFhVzBPOXJ0d2Y3dGZRTUYvQUlWY3FBdURnQTU2MU1tcVdvTzNjb1VqMXF2N1B3aWZUMHVjMGMwekdTZTY4N0h6di93QUt0c0FwSG10ejF6VThmd28wZjVzM0wvaFgwVmQzMWhHZHJNRGpHR3prZmhWT1Mvc1ZRTjVxc0NjZGNNS2F5L0JwOVB2RCsxTWZiVnY3anhJL0NmUlNGeGNTQUFEUGMxV1B3cDBnT2YzN1k2NXhYdUkxYUtOQWQrRlp1Q2NkcWlsMXF6R0Zaa3lldk9mNVVmVWNFdDB2dkVzeXpDVDBjcmVoNHgvd3FyUkFvSmVUcjJCcEI4S05FSUxDWjhZNEI2bXZjZjdhc0N1QUJnSEErYjFxdU5hc1YzSUNvUDFxMWdzSDJqOTVoTE1jd2M3S1V2dVBLRStGT2hJb0xJM1RnNTlhbFg0VDZHeDVrSzQ3NFA4QUt2WGsxcXdJd3NxaGw1UHpkS2dtMSt3aUlMU0kyUncyNEgrVk5ZUEFYMmo5NWJ4Mlp4YVh2M2V5c2VSLzhLcjBSZDI4dVRqZ2djYzBxL0MzUUFRR2NrOVJ4MXIySzMxTzNsdFpwUThmbHhBRjh1QVFDY2NEdlZKZkVHbGtsaTYvSWVNa1ZwOVR3T251eCs4eGVQek82VGMvdVBLQjhNTkRCSUlMRG5nazFGSDhNTkp3Mlk5M0hGZXIzUGlLeENyaGtPNDlqL2hWT0R4TGF4eThnZE1kYzA1WVBMMHRlVy9xS09ZWmxLVFh2VzlEeXh2aGpvMjBIeW0zQThqMCtsVzQvaHZvd2Nob0R4bkhIcFhyUC9DUjZUc1g5L0hnOWVlUlVCOFRhTXJIRThaR2VEbm5GUjlWeTlOYXgrODFlS3pMazBjNytod0QvRFB3K0pJejVMTmtaSU5aemZEZlFSSVQ1RGV3NjVOZW5TZUxOTVRheGtUQTlEemlzNlR4VnBiUnZoeHQ2a2c4NXFYaHNCZlRsKzh6V0t6WngvNWVMenNjYi93cnZRVEhrVzVIQjR4VW8rSG1naEZ6YWxzampuSDhxNlpmR3RnRVZONmdEcVNlU0t0bnhucFI2enI3WXdPS2o2dmdyL1orODNoWHpSSmMzdFB1L3dBamxMNzRlZUYyOFJYdGhiNkxPeTJ5QXl5d1NIQXo2NVBGZWNlTHZoSHB0OVlidE8xRXJjTDBpbGZjUjdIbmluK0gvRXVzYWhGUHFZdVBJbHVwWE9GQks0SjRCcTFEcU9xcGNQbVpneFBKNC9XdnlxV0llcTdIN2RERHBSalp2Nys1OHBQOEt2SEZzeFpMYUtZZ1pLckt1N0hyZ21zb2VHdkcrU0UwZVpzZFFDR3grdGZaVjlxK29QYUZ0c0RTRHVFQVA0WXFwcCtyM2l4cVdXTWtFa2JRUlV4cXllNlJicFBvejR2ZlNQRjBHNXBOSHZGN1pFUnJBa09wMjhxczlsY0tRZjRvMkZmb1FtcGE1ZFRHSjFDUmJja0ZpUit0ZGRwMGQxTkd1KzNqYU5DV0hybjM0NlZicXhWdE5CUnB6YTNQemtzZkU4a0VoODIza1ZPdU9hNzJEeFpwRHhqTnl5WXh3YSsvVFoyazgwVWJXYWJHYmxnb0l6NzhjMTNscm8zaDVZSGpsMEt6bVVqTzVyZU52NlpGWiszcDh5VDA4eS9aMWJPMnZrZm1rM2lYVHBFWC9Ub3dvOStUK0ZUalVkSEliWmVSYzgvZkZmYnV1ZUR2QkpqamtiUXJVRFBBTnVveitLMW0yL3cxK0ZWd0Q5bzBZTDh1Y3hsa0pKN1lyV01vU2RyMjgzc1JLTlJLL0xmeVc1OFRTSFRaMmZPcnJFcmZ3S2VuNDFoM05ubzBNTE91dnlFZzlBY2srM0ZmYXR2OEd2aFpkVEZmTG1qSVk1VXlsZndxaGRmQWp3Q3J5QlRjcU8yTG5PUHpGTG1na25mZGp0Szl1VStOTlR2Tkt1ZkRzeW5Xcm02a1VncEMwV0FENjd2YXZBODErb2NYN08zaG1hR1JvYis2VUE0NW5RQTU5Y2l1Y2svWjIwQWxsanY3amNveVNXVWo5SzBoS0tXKzVoT003dlRZK0p2QVZ4NVBpN1J6c0RBM1VmSDQxK3pWdmNlVmNyTkphekZWNXh0NHI1SzA3OW02QmJpQzRqMVdXSFl5c3JOZzhqbnRYMVNQRFBqVDdLNkRVN1Y0bEFWUzhUZ3RqNlp6WGdacFFuVzltNHE2czB6MjhCWGpUaEtNcnAzdWpGazFUUy83UXY3bGQ4Y29Dc29WZWNEcU1lOWVTajRwNnhGcTFzOXo5bk5oTmNlV0l0aDNxT21kdzZuMnJ1b3ZBbmlxMnVaQ3pXVTdsVHR4STZCUjdraXNEL2hYK3IyZDBsNGRCU1F1UzNFeGROMzk1UVJYbVF3TVVwWHB1YTViWDdIYzhUelNWcDhyYlBvbE5WdDFnV1JZZ3lOeUNucDcxT210MmV4eXlTcWV4Q0UxNUZFdmppMnRWWk5LQlhQeUF1dVRuOGF1dHJIankxUmkraHQ5QUZibjhEWEFzQkpQNGZ4T242ekI5VFgxRFg3Qnd5eGVlWGJnZnV5T3RmS1h4SW5lVFJKZ3NVcXA1aWc3K09mWEZlNFRhdjQzbFl5U2FLOFJDNVZoQ1dINkd2Q2ZIT2tlTTdyU1RJZEx2SlRKTXVWV0Joa0QwcjFNUFFsR3JIVFpuQlhuR1VYcWU4ZnMyVDZSTG9kM0ZiNk5ZVDNzZHppOW51bFJzUVB3QUEyRGdqMDZWNDk4YXZCZW0rRWZGckxZM0Z2UFkzd00xdDVVZ2tFZWZ2Um5CT05wNlY4cER3LzRuaGRtVFQ5UWlaMXd5aUoxSkErbldzeDdIVklUKzkwKzdERWQ0V0hYMXI2bXM2ZFNsVGlvV2xIcXVwOHJHbEtPS2xVOXJwSzN1dmJRNTdYTDNacWNXeis1azQ0cjAzdy80djBtMWd4TmNiV3dRQUFTYy9oWGc5OWE2bTkxODl0Tnh3QnNQUVZVOHhZaXA4cGtkVHhsYTdhVXB4cHhTNklpclRwemJ2MzNQb1B3UDRvdXJmeERkQzV2bTh1NFFoREljZ0hPUjE2VjIydS9FUzgwM1Y0N1pWamxpM29aSkFjOWZUNlY4aFhPbzNzeTRMY0E1NFhGWkpNemRTeC9PdEl6YWpZbVZLbTUzc3JIMzVlK0liYTh2OVBoRTBiNzVRekVFTU5xODg0cjJwZFF0VndRRUhxTTg4OWEvTnJ3L3FSc0xpT1VXaGxJaks3U1FNNXI2QXM5WWdualEvWjJqSjZicmxQMXpXbDduSlVoeXRXMFI3NXFQaWF6dG9uZnl5NEdjS0RUdEw4UngzMXVrN1JiVWNaVUU1eDlNVjR0TkpCSU1tRm40d1Y4MUdCL0kxV2hra2doU0sxc1pJNDF6akdEeWZ4cUpSYld3b3lzZlREYXJCRWhPemRqMW8vdFcyY2NwZzR6eU9CNzE4enRmYXg5b1NOYmVSMFBWdjd2MXJlVzR2aElRZk5LWS91R3M0eG10TEJOTGwwWjlBRHhQcGNkekZhN3N5TUN5QUw4cEhmQjdtdmN2RElNc3pzbzZLSytBNW9yUVh0dmNYVWsvbXdnaEUyc3FnbnZqRmZidndmaTFiVnZ0ZjJhMm11UkVBemxGenRYM3IyOExWVVpybnNsMzJQSHhHR2xPSHUzZmRISS9FNlJKZkZ0akVXTzBTUmJ2ZkFycWpOYlJoVDVpazhrN3ZTdkJmaWhya3R2NDlXR1Q5M0lqL3hIR01Eb2E1NlR4VnVqYmZPaFlEa2dnNHJwbFdoN1J0YTIyT0NuZ3VhbnZhN2JQcGF6MW5UN2lOeEM2czJmdzRyUlo0Q0Zsa0cwNVBCNS9HdmlMUmRUa3RIbmthOFNYekpTNjdSdDIrMks5S244Y3lETzdiNm5HSzJwNHVEajc4TE15cjVkVVV2M2NycnV6NmdOeEZ1UXFnTzBZQmJyaXFNdXF3VzZFdjVXdy9LU3pBS00rL3JYenJGNHdpS2J6SU9SMUo0cmt0Y3VaOVdzR2h0VEc4aEJLN213bWE2UHJjRkYyamZ5T1dPQnFxUzVwOWR6NjJYVVlabVE1aDJLT29PTncrdGZsSjRwYU9iVU5ma1U4RzdrSUhUdlgxOTRZYTh0OUxpdDU1MWtlUEFkVHlNaXZpcnhCTkZKZTZxZUZacDVUdHh3T2UxZU5qNnlxS2w3dHR6NnJLcUtoT3M3MzB0YysvdmhzOEtlRGRFWGdFMitjLzN1YTlsQlJuaUxrRlFPY25CR08xZk92Z21hS1B3cHBJS0hiOW5VZGVNbjFyUDhhYXRxTWx0TDlsZ2VSc0tGQ0hrWTcxNlVhdEtuU2kycjZMUThTcmhxMVhGVFNseTNrOWZtZlNkeDlpa1VMbEZBYzg5RGc5cXlyaTMwOEVFcUN1TURqcWUxZWZhZnFNTUdnMnNkMWJpV2Z5OHN4SjZub0NmYXFjbmlDeUpLTGJsV0lBenZKSS9DczZrNlRkN0xVcUZLc3JxN2RuWTdxSFQ3ZmRsMWl4M0dQNVYwVm5vMm1yR3h3bkxIQUtqajJyeVJmRUZ1MGlGTGR0MjBncVh5b3gzcmsvRi9pZS9zckNLZTBsWUhrU2tLV3g2RGorZFFwWWVLYmNiaWRQRlRsRktUaWZSbDFvdWxtS0xNQ0t4eWM3ZXRaVXVnYVVGT1k0eGs1NVVaRmNGcEhpUnJuVElUT1hNbTBiczllUi9PdWhnMUsxdUpRcVNrc0FCc0s1SkhjZytvcVpTd3oyU05JTEV4ZG5KN2xlUFF0S2sza1c0WUFqNXNEOGVQNjBYUGgvUjE1TnRFT1J3QjY5NjN0STFUUTR0WXRqcUVrdjJOWmxFcXFBR2FNbmtVL3dDTGwxNGIwTFhibUhRYnZOckg1ZUhrTzdHOWR4eVQyOUs1WFR3OXIyUjBMNnc1SzE5N0hHM1BoL1JnR0xXa1FVZHdNNU5SUWVHOUpkQzMyUlZ5TWhPaHg2Ly9BRnF3ZkRYaTIxdjdGR3U1QUNaT1dDNUdPMkJYUXphall2ZUlpM1BsSVQ4bTdCeG4xOXFsVThPMG5vYU40aFNhOTdRZ2s4SmFHNTNlUXlnZXB3VG4rbGZYSDdNM2duUkI0MHZOUWUxeC9aMXN6S3c2YjM0QXI1bXViaXhTTnhEZEtBRlVmTjh6RTl5RFg2VS9zNmFjWVBET3BYcjRjMzF5b1JzLzhzNGhnSDhUWG5ZMVVZVVhhMTIwa2VybFVhMVRGUnZleVRmb2ZabG5jUVdxVFhUc1Q1S2JFUUg3elB5ZVBXc21hNGh1aVp2SUtzNEFmY0FTY2RQeXJub2I2S2FLOVh5V1haT3dERWc3dm9QU3JhenJIWjd1VHpnRDFyNFp6alV0cW5HMXo5UGpTblRkN1BtdWpEa2l0TFM2YVlTdXU2TWlRTy95QUh2ajE5SzVEeENrY1d2NlZjd3lFR0JvVlhhYzd0N2NnL2hYTjMwMGQzck1EU01DaU93ZFNjZ1k1eGoxcnVMT3hpbWRadkxScEhiOTJwOWUzNVY0ei9lS2NZSlJVWnF6OU5UMzFGMHBRbFViazVRZDE2NldQRy9FUGlXNXNmR09wV3BoamxTUzRSb1Vib3djWWJKTmE5eXR2cWI2T3BoeXlTdVVRZk1GYnBuOEIwckh2NWhxbmpSSUUwMVpFdHQzbTNCWUhhdzQyZ0QxUGV1NjBaN2V5dU5ha1FIZENwQ25yakk1QXJuU2xOeXZzNU03VzR4akhTOG94WCtSMVhpU3hTOXM3V3hTRmlBeU13QXpueStkcHJ6dlY3aTg4dVpabFcyQUlhT1JYM3liaDJDNHdCVzlvbmpDUWFJV2FOUk94ZE9TUWVUMVhQdFhtbDNmWE1tcFdtMFIvSVFYZVFrS3k1NUhIZjB6VzFTY0Vrb3U3YU9hbFNxdTdsR3lUKzg2ZndiTkxEbyt1ckpNRWVlNWJ5aTR4dVVBZk5qM3JMaHVaV2xram1kV1plNm5QSHY2R3U0MUJkUDBYdzdBWWxqemRYWXdEem5meVNNK2xjM3EwY3Iyc3NDK1ZHODVLSy84UlhHY1pIcFhIaVZVbEtFWDltUFR6T3ZET0VZMUpwUDNwZGZJeXRNYTN0OWVpdmRvTWl4TWtiSG91N2l1aTEyU3hsdGJkMXRXV2VNdDVqczI0dXA5ZjZWeTlqb3R4UEhEUEc0YUJRWTl6Y3VXSERaL29hN2ZVWVRGWkpDQ1drd3FoeU9DUFErOVRGelZPY0xhZW41RG55T3JDb243eTAzT0JOckRkckRJcWxjREpLalBIMHJZMTdVMnMvQzB0dnB0cGEzVXl3U3ltenVXSTh5TWRmbEhYSnJ6Nnk4VjZQcE1keC9hRjFGYS92SEtLeEpMS0QvQ3ZOY3Jxbng1K0d0c0ZhNDBXNDFLU1BjSXBQS1ZDb2JxTnpIT0RYZGwrRXhibmRVSnlqM3RwOTV3WmppOFA3Tkwyc1UwMXB6SzU4QmZ0QitNdFdtK0d1ZzZUZWFDbW5OUGV5M0VXQzNFYURhVlhJeGpKN0d2a2Z3Z3FYdmg0eHNCdWdjanBra0huTmZWbnhjOFc2ZjQ5MXUxdTMwbnlMYXpqSzIxcUpTVVVIcXpaN24yNHJ4ZXhOckExd2l4SkJ1aStWVHhuSGNWK2swTVBLR0hncHBSbGE5azcyUHk2dlg5cmlhajZYM09FdUw1TFdCNGxBTG5qSjV4OVBldktaTGlkcG15TWpQNFYxOTJDQys5d1ZMRWc1NzFueXh3bEFXWlY5T2V0YUxsVE9lVnpKamo4OU9lbzZZcm9iQ0ZsVGFUbGVUV1JiR0ZaeisrVlJqam52WFFKYzJjZTQrZkY4dzdzS1RscVpwTTFDc0J5VkJCQXJ6alVwNVk1enQ2RTlhN1FhbnBxWkJ1WTgrdWFvdGMrR25jdExjcVQ2QUdsekpNMDVXUHNacERHcXVNa0ROYm8xSTNBMkNNcUJ4bm9CV1dkYThPSUJ0bDJsZWdBT0traDhRK0hmTlQ1bjVQemdMd2ZwNzFMbjVNYWllcDZGbzZYV2szbHNKSThUSWN5UG5qSHAxcnpwTkNrc0kya2tnNFE0WW5vZmNHdlY3RHhqNGVzWUFMUkppMjBoZmxIR2ZXdXBzZkVjR3EyLzJPV09PUjV1RDhveXEvVTFwU1VYek42ZGpPbzZpYXNrMXBmVThZdEx2VDU1TVc4RWJNaUVuQytuMXFscStyM1MyQStTTEczSVFFazRQZk5kUGNXc1dpM2NzZHVRNGNrT0NNWUhvSzgwdldielh3UGxPY2lrNmFSMXhXaG5XK3VsZE91TFY3ZUoxbElQbUhKZGNkaDdIdlhrMCswcm5ITzdyWFdYVWtlMTQ4QVlHYTVOMXpDM0hRMWtsWjNKazNheFVCRldGeFZRVVp3YTBhTVV5ZDJLdHgxcUJTZDJhZWczR3BzQlc2Y1V0RVZadDNMVHJtdnNYNFVhMHQxbzF4cDhqL0FMeTBiZEhucVkzN2ZnYStQa1lGU2ZUaXU3OEQ2NS9aUGlXMG1ZL3U1RDVVdis2L0dmd05kV0RxK3pyeGIyZWorWmpqS1h0YUVrdDkxNm8rOWluemtjNTc4VlV2Tk1ndW9nalpWZ2NvNDZvM3FLMUpCOCtDYzRQcjEvS3RDT1BKQjdubXZwcXNVMDAxb3o1cWxPVUhGeGRtbm96RjBDOGxGMkxTN1hFbzZFY0xJUFZmOEs5M0p1N2VLTWlSbElHUVFjRWVuTmVTM09tck0wZVFReUhjampncVI2VjlBZUZKRzhUNnJIcEx4aUdab1daY2RIMkRzZmYwcjVERlllVktWMXJGbjYxbE9ZMGExSnFVbENhVzNSMlBmdmgxOFQzV0Z0TjFDUTdaRTJMTnU1SDFyN1I4RjI5ci9ZSytXWElaM1p0NUozSFBYa212eDcxL1FOUTB2VVpyYVVGSkViQjlNZXRlbytDUGlkcnVndkhidGNGNHQ0NGtKT0IzeFcxREViS1QwN211T3dDcjA1ZXp0Q1VtbSswckgzTjQzK0UrZytJYkdiOTBCTHZMcklCdGRHSGRUWHd0ZXJxL2hpUjlPMSszYVd5enRqdmd1UnQvdXlxZTN2WDZEK0ZmSFdtNmhDR2E3UXN6bjVjNTY5SzcvVnRHMGJXYk9XS2VPT1ZaRklJWUFnZzE2bkttcngyWjhEWGhWcFRjS3NHOWZUNXBuNDJlSy9oelpYMW9acktKTDZ5bDVFWU9YVDNRKzNwMXI1R3VOSDFudzVGT2xoalVOUGR2OUkwNjVUZVBmY3ZZajFITmZxaHIzd3U4U2VGYnU1dWZEcmVmYTVMUzJNcDQ5ZmtQYjJyeWVLTHdyNGxlV05nMm5hb2hJYU4vbGtCOXM4TUtseGk5ZXR6amFtbG91YUZ0VmJiMVg2bjVZUytFOUUxaVpianc3ZHRwOThHeU5PdVpOakJ2K21FdkdmWUhtb2IzeE5PWmY3TzhhYUU5eThZMmk3QThpOWlBL3dCcnBJUDk3TmZadmpuNFdTcUQ5cnR5bUQ4bDViamo2dXZVVjRWZXA0bTArekZ0cWxuQnIybUlQbForWkloL3NPUG1YK1ZjelRpbmE2dnYyKzR1VUlWSEcvdld2eTYybkgwa2p5clN2RE9yeHlOZCtDL0VQMnpJTzYxRGVUY2dlanhOdy80WnJtcm5XZEJ1cnA0UEVuaDZXMHVRY1BjMmErUktENnZFM3lrL2xYVG53ajRhMVdVVGFGclAySzZVNVcwdlc4cHdmU09ZY0g4Y1ZvNmpyZmp6UjQxdFBFbWpSYXBiQVlYN2JIdk9QV09kT2Z4elV4bHBLTGRsNlhSeFZjUEtWU0Z2ZmtrOVhKMHF2NGFTL0k0dXg4SnpHWVhIaG54UERQSU9WaU1oczdrWTdiV0lCUDBOVGFoNGo4V1dSRWZpSFFJYnhlbSs3dHRybi9kbFRCUDF6VG1zL2hocW8zUlhON29VNTZKS3YycTN6N011R0ErdGRwcHVoL0UrMHR6L0FHSnJWdnE5c0JueW9MaGJnWTk0WmVSK1ZiSnRKOHQwbnZ5dTYrNW5KT01lWmUybEZ0ZkM2ME9TVWZTcEhUN2p5WTNQdzR2djlaWmFqcHJudkRJdHhHRC9BTHI0YjlhdTJuaDNTV083VGZHdHRHM1paeExhdCtmSXJkMVBXWklwR1RYL0FBSmJoOC9NNlF5V1RuMytYNWYwcmwzYjRaM1hTTFZyRW5zR1M0VUg4ZHBybWs0dDJ0Ri9MbE85UnF4aXVWMWt2SnFvbjgzZG5iSllmRkJOaVd1dFIzcWo3b2p2bzVSajZPYTJaWXZpZ2xwZUcrMGxuOHVQcWJXTndmWWxSeUs4d0hodndiS2l0QjR3U05qL0FBVDJraUVmVXJ1RmI5cjRkOHFPNFdIeGRwMGdhSTdkdHhJaHoyNElGZWRXVWVmYU8vYS80bm80RG1UbGRydC9DY0grSnpNRno0ZzNTc05CaFVoRHlMTXIrSEZmcVg0Rit6Nno0VDB5NjFIeFpxa0UwbHNBOXVMcFk5aktjRWJTTTQ5Sy9McUhUdkVLSyszeEJBVnh4dHZ1L3dDZGZXbndaMUhRN2V3dnJQV2JhM3Y3anp2TWlaVDlvZllSZ2hpdVNBRDByU0Q3VytSdFY1dVdMMXVuc3JIMTNKNGU4Snd1Uyt2M1Uzb0pMd2pQNVYwV20ydnd5dFhWbWhpdXBBQ2VTOXdmcGpuSnJrVHFQaDlZL3dCM29haE9NRmJRbjlTSzlNMDNVcDFpVXc2RGNyd1F1UWtLL3JqRmQ4WUpyVnY3eno1VktyVzh0Zk94WE90YVdzTHRZYUxjTEhnNFpiVHlnQjlXeFhqR3A2bEJOSkkvOWxMdTZabWZPZjhBZ0svNDE3RnF1cGEwMFNsN1czallIN2tseVdJOXZsRmVRWDB1cUZaTm9Da24vbGhHT1B4Yk5hMmlrdFY5M01acS9OZHgrZk5iOGpoWjV2RTg3d3h3U2JMWGRsaEZHSUZDOTl6bm45YStJZkVuaDd3N2E2M2V6NnQ0aldVbVppTGF6elBMZzhnRjIrVmYxcjZqMW0xTFNFMzJwUnhEUFNlZmMzMENMbm12bGZXcC9oNVphdGN5aTJ1OVNsTFpDTWZJZ0IvRDVtRlh5NksvL2t6L0FFUk1weWNaS0YyKzFLS3U3ZEhLV2d6U3ZFZHdKV3RQQ25odFk1bkczN1N5ZmFyckI3aGlOcWZnSzE1L0N0aGJYRFhuaTd4QTh0d2VUWlcwbm4zTEgrNjduNVUvV3RDenUvSHV0MmJSYWZaeGFWcHgrOTVRRnJBQi90TzNMZm5WSzMwZndqcHMySjVwTmN1KzBOdnVqdHczKzA1K1p2d3FaU2paYnUzZlNQM0hMU3B5WE0wbEYydEpRZnRLai94VGx0NmZpYmRqcSt2NnJISnB2aFhSMTB5eVlZbWFJL015K3M4N2ZyemlxbHBiZUdkQ25DcW45dmF0dU9FWEp0SVg5KzhwL1N2VFlQRDNqTHhLSXJXNElzTE1rZVZwMW5IdDNEM1ZlU2ZkcSsxdkJYd1JzTk1nRWwzNWRqQ2locE1zREtSL3R1ZUZIc0sxakp5ZTJxMmJXM29qZXB5UWoyVDNqRjZ5Zjk2VzdQa0RSL0FYaVh4YnEwTTJzU1NYVStCNWRxcENSeEwyQnh3aWowRmZvVnBuaGJ3ejRMMDYybHYvQUMzdWVCQmJ4b0RrK2tVZlVuL2FOYk5yck1FK05OOEo2VEhKNVRFQzlaZjNDSHV3UFYycjZMOEFmQ3BMZTVPcWFoTTE5cUVuRFhFdk8zUDl3ZEZIMHBybGpkeXZmdjFZL1p6bW8zWExGYlFXbHY4QUk4ZzBMd1RyM2pPOGl1dGFqYTAwK053WU5OQnh1eDNtUGMrMWZlZWxhTnAya3d4UXJFRlVMd0FvQ3FCMjlxNmVLS3kwK0UvS0NSN2Q2K1kvSFB4QmhqdDd5SzNtWHpJMUpQT0NNZHF6bEtUMzJQZHdPQmxXcXBKV2l1dlJHajhRdmlOWVdFYjJrRDdwWFhxQjkwZXRmbmxmMzBjdDNMSkxJN3N4TzNuakhYSkhwV0ZxV3AzVjVlTktYWXVjazUvcFNKRXNreU8yT1J1WW5ucFhsMUtyYjhqOUdvVTZWQ2txZE5YWFY5MmFFNE15bGdvVUVBWXprNDlhejcvVXJEUzdZM04xSkZDb0l3N25DajYxNXo0MThjdytIN1JYajhsM0tIQ0E3Mkg0RHBYd2svajJUeERxR3pWN29pMVEvdW8raWoxSjk2NGx6U2J0M09iRjR1blJUNXJ1VFdpUFIvRmZ4Q2o4UytMTGV6c1N5V2tJWU15dVN0dy9VeVk3RDBGYTF2WmhSa1l5Zld2bUh4RmRhYmJlSXZ0R25BSkVxeE1nNlpJNjR4NjE5UjZCcUZ0cVZsSGN4aGdyZzhNT2NqdFgxK1VxQ1ZTSFc5MGZrSEVOYXRVbmg1dlp4YWR1bXQwanp6NGtvVjhQeERIL0FDM1hwOUsrY2RKazIzVnNmK21xL3dBNitrZmlXVC9ZTVkvNmVGL2xYelJwYll1SU1qUDd4Znc1cm56SC9lVjZJMHluWENmT1IvUWg4SUU4bjRmNlo4M1ZwVy9OcXdmRXZ3cThLYXg0amgxeTR0eWIyRXFRd2NnTnQ2WkhmRmRKOE5sK3krQTlLM1l5WU4zNW11enVKbDh0aWUrY0d1Uk9MZ3I2OVRwb3huR0VOTjRxL3dBempacndRYnNnWVhrZmhYNUMvSHpXek40dHZiUk1pUDhBY3lZem5uYlg2bzNsd0FaSTJ5UzQ0OXEvSG40MXpSeStQdFIyZ2phc2FuanVCelZUbmVrL2tkRVllOWM4eDA2RkpMSmdUZzV6OWEzZFBtK3lYMXRMRStXUmdRUndjMXkybUZqR0Z4a0JzMTJsb2l2cTF1R1RDdEtnMm5xUVRpdUNGK2I1bnB5dDdKK2g2TE40dDFmUCt2TzMwejFyUEhpM1V3VCs4YkdlbGZTNytCOUhXVUkwQUxuOU0xZGs4Q2FPa3J4K1ZFd0NqNXdEMTlLK2lXR3hmUnY3ejRoWWpDeSt5ZkwzL0NXYXB1eUppQWZlb204VWFzWEJFNXllcHpYMHBINE4wTVNNaHRsWTRHQ0J4K0pQU3JCOEZhU0pnbjJhTUQwWS93QXZXbDlYeFg4eis4bDR2RFJ2N3A4MHkrSnRWS0Q5KzNiZ21vditFbjFVa2d6a2V3TmZVcStBOURkZUlWNTlRZVBwU2Y4QUNFYUl0d29FQUJJTzA0NGFqNnJpbi93NExHWVZyYjcwZkw1OFM2bzJNVHVjQ21mOEpEcVJVNHVHNHI2MkhnYlJmSkRZVFA4QUg4dU1WRkw0RjBkRlJsZ1ZzamtoZTlXc0ppdjV2eE12cnVGL2wvQStUby9FbXFkQk1lZlNvVDRoMUlIUG12MS9sWDFWRjRRMG5maHJiREFISUlGYTQ4QzZNSTFmYWhMRG9SM3ExZzhVMThYNGtQSFlQK1JYOUQ0OU90NmhrdDV6RFBiUFdvanJlb2cvNjFobjNyN05IaERUZ0FSYXhnZEFNZC9Xa1R3bHA1bTJMQW1CL3NqbWw5UnhQY3A1bGhGYlErTzExM1UvTDIrYkp6MXgzcXFkWDFEcDVzZ3oxN0N2dTZQd2hvaUxtUzFXUXF1Y0tNRS8vWHFqSDRUMHlTTm1OdXFZNkRBTmFQQTRyVDN0L001Vm1PRmJmdVBUeVBpaE5UMUJReE16OENvRHFWKzJCdmwrdk5mZEgvQ0phU3NLa3hMdVplbTNQLzZxb3A0WHNGMmp5RURldkJ6V3F5M0V1TzlqSjV2aGVaMmc5R2ZFQjFEVUFRUXprL1ExTDlyMUJ5ZVhYMDYxOXUvOEl2YmxoKzZRZ2M1eFd0SDRZMHpNYkdOUzJmN2dIRlp4eTNFNis5WTZYbW1HU3Z5bndJMTFxUllnR1E4KytPS1F6YWxqcEoxN1pyN3h2ZkMybXA4K3hBU0NjRGppcyszMGUwSVRFYWtBakpJNlZMeSt1dnRGZjJuUXRmbFBpTmpxT0J1RW5UME5RRjlUSDhFaC9PdnZadEgwOThnUjg5d1FPS2hQaDlGQStSUm5uQkdLYXdGYnVZLzJwUi9sc2MxNE0wYU9Idy9id3pSbkRKa0VOdE9jWjRxMUhhT2tySzdLUUcrNzk0ajYxNkZwdW5PTEdGZklEckdXVnNrZ0RqMHBiQ3l0b1pDSm85b0w0WFByN0VkcS9OK1pOeTlUOWM1ZEVjVU5OZGJhNll4OFl5dTMxL0dzdUxUTHJ5RUJnQUJIeXNPQUNlL3ZYdm1xYVNXc0paWVpFVXF3NFBHUWZUSFd1ZDAyMGtObk96ZmVUNWd1TS9XcFU1Sk1ianJZNDNTcktjZ2gyRGJWeG5QSnIyVFNOS3RWZ2pnWWtOTEd6Wnh4OU05cXdZbVNUeWlVUlg2WVFZNTdIaXZYdEh0SkVobklrK2FSQWZtSFRiWE5Wbkk2YWNFWkZocEVVTW5sNEJDZ1lMZC9kc2Q2N2Y4QXMrMUEyK1QrOVk4eUFsa0lQWVk2VkhwbHRiWmtEZ2drWnlSbFNUNys5ZFZZcjVLT1ZCeGdnY1lGYzZiZTdOVkd5UEo5UTAxVVl4ay9MdURaN0QyclBzdEMrME0wamxnUWgyWjRHZTFlbFh0azgwcXQ4ZzM1eUdQUEZYN0pJa2xLT2MvdStCanA3MVhQSko2aTVVOTBlRlBwWXRiZDVXYk11NzUrT2d6MnJMMW5TSmZJVXJDenlGZ1VCYmFwQjlUWHZOb3M3WDhrVDI4UlV1b0RaNUl6MWF1LzFqUnJPUlZqeHNaQWNLUjZlbnRSN1dUczk5U0hUVmo1bXN0S2hhMkMzRVlXWFo4NEhZK29xb3VqUVI3aXVjTU94enhYczM5aVNDTnBDNlNKbjVRUHZBZWhxTWFZQUk5MGFvQjN6eVRXYnFUUlhLdE5EZ3JHeHRsVW96U1I0R2VPQmoxcVFXOXd6eUtMdVlISVpIQklCWHZ6NjEzeXhSdEc2K1I5M0kzNXprMVNaZkl3Rmg1NjVEZk1ENlZwN1M5dFI4aTdIQTYxZjZsOW1seGZTQlVYN3hPZHA5VGlzSFE3L1hibTBpenFNb1hqYVpPb0grNmNWNlFZWjR0MGczakRaSktqajNxYTJnaW5sTE04VG5kdU9CK28vcldzYXJVV2t4Y2ljdGpJZTIxUnRoYTZFZ1huZ1lPUHBTMmt0K1kyL2Y3OWpaNEhVSCs4UFVWNlY5bDJuY3dYYVJ3UU85WEYwNjJsVjhreDRBeHRHZHg5Q2F4YzVKbW5za2VaelQ2bThhUjI1OHVRT0NXWmR5Z2Q4amlvYlhYdGRqaGxpdVZWakdTVmJiOTRld3J1cHROMllDb3pFZy9NRFQ3UFRNSzJZMmxrRVp5RzZmZ080ck9OZWQ3RXVsZG80ai9oSXRUYXh3dHBHNUw4U0ZPVkE5Nm4xclVvNzFJMmtzWTI0WEkyWVg4YTZhRFJVVzFqalliTnI1eG5rQTlqVXQ3cGtNYTRHOGhzY0E5dmF1eFlpczF5dVh1dTJub1lyRFUwK2EycDVqdGdabUg5aFd5dGpJSUhHUHg0cU45TThQeUtYT2dRa2xUdXhFdkJ6Nlk2VjNnczBWOEpJNERNRzJ0MDRyZDArMHUxVUV5SXBMRUQ1TWdaUG9hbVdKckxSUFJ2VWo2clNjazNIWThhUGg3d2xmaDFiU29FRVM4cXNLalBydU9LclJlQXZDVndTRnNrQ2taSTJMZ2ZTdmE1TkZtRnpkc0pOdUU1MnFBcHpUTk9zU0Z3WFE1YkcwZ2pnOTgwVHhWZVQrTjM4bllxT0RvUlZ1UmZjZU5uNFovRHdvcGswdE1LZm1BVEJjZXZ0VkYvaFA4QURoNDJrL3NXTUIzeEdwRzdZUFhQK05mU2YyVXFQTG5qaStYa2JYeTJQclVDNmZHV3dpN1ZJQVBjZlhOUDYxVmpGTG1sdVJMQzBYSzdnanh1MitCSHcxbVJDYktESUdTTTdjNCtuU2x1dmdQOE95TVJXcXhIY0FGU1E0QTljbnJYdXBzWVJJcW9WWlVVN2lPQXA3WnBpV0s3Q0drQzdjNGJQSDRaNzFheDFaUDQzOTRQQTBIOWhlbGp3aVg5bmZ3QXlNeG5ETU1aQ3lmMHJoYm40RWVFL3RDeFc5NUxHTW5jVm5JT1BZRTlhK3I1SUZuQ2czT1l6MGtVamo2VmpYV21hVDVLcE5iaWVTVEs1R2VQeEhRMXQ5ZnJKcDh4Zzh2b08vdS9pejVabi9aeXNOdyt4K0liOXU3QjVpQ1BUR0NhK3cvMmJkSGk4TGFQNDNrdUozZGJHVUk4ckVzeENybk9lOWM5UHBlbkxwbHRjUnhOakR3b041VnZrUFFrZWxkeDhITDNSTFR3UDQzVzh2RWplYTlsM0NSanYyQmNENjU3R3ZTcDRtZFduVmpMWFNQNW5tVnNMR2o3MEhxb3kzOUQ4ZnZpWEpCcnZ4VU12bXNFbnVTd2M5UXZiclhYeCtCZnRFdUxlL2FZNXdCNWFmMUhOZU4rSVp6ZStPR2EyblVGWGRrYnB3ditOZXYrSDV0Zk0xc0liMlVPcnJ1UW5PZWZXdldyWW1GTG1TWG9lTGhjTTZsR0YzYlE3N1R2Z2xyVnl6Q083Q25vV2EzVGFNK3VjVmRmOW5yWFBreGZ4c3hPQVRhb3luSC9BQUt2cVRRSnRYTW9rYTZtSzQ0dzMzRDN5TzRyMENYVXRUWFlzVndKUXdKTFNLQnRQb01WNGp6VFIzV3FQZmVWWGl2ZWFQemgxSDltN3hMTTdScnI4U3NNc0k0N1Fqajg2ekIrekQ0NmdpQmk4U21QbmdHSmt6K1JyOUwxdWZGTW9qSnVJblJUbFQ1WlU1OUd4MUZkR2JmeEI4bHhjYWpHN0VZYU1SQlZYSHB6VVJ6RGR0RGpselNYdk4vY2ZsV2YyZjhBNGxXMlRGckVjcEJ5M3l5QS9sem12aHJXYmVlS1M5amxHWkVadzVIcUR6MXIrZ0xVOVp2WTNJaTJ5c3U5aUFDQTIwZHpYNEkrSTVZNXBOVHVOMkhrdVpTVityR3VtamlYV2IxK0g5UlNvZXl2NW85YzBQUmRmL3NleGVLVzFaR2hWa0N6dXJBZjdRd1JtdXR0TkM4YWIzayt5aVdQb1F0d1JqMzVXdFQ0TzZoT1JicTBVTEZZL2xMZWc3Vjk4d2FwcXNscjVxUWlRZ25jMjRLMlJ4K0lycXE0dU1IYTE5dXB4d3djcHB5dmI1WFB6c21zL0ZhTXZ5M0dCemhXVndQOGFndG9mRVR2dmx0N2hSM1pvMVlIMDZWK21rZXJSUTZiS0k5THR6Y1AyM0RHQjZuSDhxcGFacS9tU3VzMm53eEprRmtTTkhKeHp4dTlhRm1FTHBPT25xWnZMcDMrSmV0ajg1ZHVxTElNd3lFay9lOGdqYjljR3BYdHRWV0NTUnJoQnNPQkg1YkIzejZEb2EvUmJYZkdlbVg4TFFXMmp0YmhNSWQwU2phUFhLOTZYVDdudzVMWWlDYVM2SmpmcERCR0J4MXl4NUpOZFR4bEc4dDJscys1Z3NEVlQzVy9WSDV5Q0hWb2dXOCtCZk13dzNiaHRQcHgwcXBIZTZyYTNoUVhpSzRHN0tLekE1OUQzcjlLNDlTOElXc3J4TFl0Y0JjR1IyalU4ZXgvblhaVzhmZ2llNHR6SnBhbFhHUnVUZ2srbUQwQXJKNDJnMnR5L3dDejYxM3JIN2o4bFg4V0JSc2U0amQxSnlwamNmcml0TjlYdXJsSTVaUWtoa1hDSGZuY0J4Z2dqdFg2b1hWbjRDaXU1NC83SVR5NFQ4eitVVlZzL3dCM1BPUGVudzJId3NuVm5rMHRJU0Z5eXZHY0xqdjlLaDR5bDZmTWF3RlhYWS9LNTlSbWhNYW1HR0pzRFlva0J6NzRGTGVUM3hSWlpZTmpFSERoaGhzZTNiRmZxWnBlamZCdSt1VEN1bjI0d1R1azhwZ25zQzNTc1R4Qm92d2dhL1NIem9DOFkyaFV5YzQ2RE9LVHhkSkxxU3NEVzhqODFiZlUyanNtODIxWmcrR0RieDI3aXYzSytGL242RDRKOExXY2tESjlvc3Z0RHliY0tHa09RRDdtdmplNytIdmdrWFZrUDdPaC9mc2hFYXZra01lQ2VPUHBYNlZYV2tMYzZYWmxUc2tzSGpDQURBTVdBQ3VQU3ZDelBFcVZLRVlQWFYvY2ZWNVBoZloxS2txaVZuYVAzbGFQVDgyNFZaM0xCeXpFakdTMWRETTBkdlpndTNFUzVQMXJIYVNVWE1JUlN5c1R1WTlBQlhRVzJtUjZwY0NPV1RiQkZpU1hCKzhCL0RuMDlhK2ZvUVVlYmxqcmF4OVpXbGZsY243cWQvTStjcExjUmF6S1l3Vlo0L05aZjk3djlhOTMwQzJlMmppbnVQOEFXemZKRW5UQ24rdGVaNm5kMjgrdVRRV3dWSVBQVkZKSXpzN2daN1Y5QjJTUXp5Skw4cENqRWVmNGUyUlhIUmpGVHNyWHZjNnNUVmxLa20wMHVXM242SEczdW02WllTaG9iZEVsWkNYWURCWWRSay9XdkRMUy9lMnUybVpjaWFSbEs5VGsvcFdsOFhiM3hURjRlMVBVTkpsaEtqeWxnWUVsaUEyMXdRZUFmU3VQZzFOWi9EbHBIczJ2RmNCcFhKQkJaK2NjZHhWVm4rOFNUVVZHN1Z1K2dZZHYyTHZlVGxaUHlEeEhIcGFhY1ptTHd5Uk1DRWtKQWIvZHJLMDNVYmUxUzJudllodHVadHNhZ1piYi9lNTdWN2pyMms2ZmUyMm5SM2FKNUVaTWpidU1sUnhqM05mUDk3TXIzdm5ORVpCSGtSSUJrNTZBL1FWdzFxZnM1SysrbmtlaGhhanJSa3J0SkYzeExvZGhlWHNGeFozWjgySjl5L09RcDlpT2dycXRNMXExdnJtNGdrdFNzMXFJeDVoYklKWWM0OTZ6TlRzNzNTZkNkemYzRWIzVTZvR1lnRGNCbmppc3o0YTYxWmF2UE5jend5ckxzRzFDaE9lZWVlbkZPTUorMFV1ak5KK3o5bEt6dnk5dXA3NERGcG1neFlqSmN2aU9Mb1dkK3hyd1h4NzRsdXJIdzdxZTJCdk1FYklrbkcwRitEK0sxMlhpWFVydDVUOW1ZbVpKa1JFL3VodUNmd3I1WStNNnZIb09vTEc3TVlHalYzM0VqTDlSWFhRbno0dWtyV1hPbDYyUE14RVBaNFNwSy92T0xrZm5scTNpSzVadGtWdy95SHF4enorTmVVYXQ0aXZYay9lVE5rOU93T085TjFKamJGd0hKQVB6Yy9wWGt0NU85MUlTRHg2R3YweDFKWHRkMlB5U1h2U2JhMU9yazhSU3l5Y00yM2J6empCcEYxVVBjeEdia3NoVGRub2V1YTRsWVp0dVdYYi9BUFdxaGRseUZLbm9SeFdWMjN1YUpwVzBPczFlQ05YRHE0Y0ZlbzZWeTJvV3Nrc01iZzRHQU1WcFNPNzJ5SVRrWXJ0ZEwwd1hlbXpneUtHaVhPMGtBa0N1S2NuSFcvVTJTdmM4RW1oWkc1cG9nWWduMEZkck5CRVhKMjhEMXJSVFRrYVBmdUF3TWtIK2xiKzEwUkNpcnM4MDhzNHB3aUpyVGtqMnk0OWMxcnhSSnRCYnBpdEhOa3FLWmdSMnBibXQ3VGJMTStUeGdqRmJjTUNHUE9RTVYxbHZhUW9oazNqZDNBcktWUm1uTFk2S0RSVE5hTTZQc0tETG50OWE2UHc1cFl0cjhSdFA1bTlDeEk3ajBxbHBXclFKcDExRUQ4N0tRQVIxcWZTSXJpMXZJNUplQThlQUR3UUtoU2xxcjdiR2xsb2RMcnZrU3dzenJpV0xqZC9lSGJOZUsza3ZscGtMOSt1ODFtNGNhZzhKWGdFZE1qZy8wcmpOY3hrWjdIaXZRaTd3MUlrN094NXJjS1M0OVRXUk9OcU9NRHIxcnIzdHNnTmtWeXQxeHV5RDByTHFTOWl4b09qWE9yNm5CYVE0M1NIa25vb0hVL2hYZmVQUENNT2lUV2IyKzR3U3B0Skp5Zk1Ycm42OWFwZkRlV09QeFhhczdoUnNrR1QwNlY5WmVNTk1zdFc4UDNNTWNzYlNLbm1SNFlFNzE1eCtOZXBTb3huUW0vdFgwK1I1RldyT05lQyt6YlUrQ1lsSEZTenFvSDN1YXJ4c0ZPR0dDTTFCSys1dmYxcnlMUG1QWDVrb2wyQjF5QWVocXpOQmhqaXNwR3hpdXBYRXNHN1BXcGxveTR1NlB1VHdQcXgxWHc3YXpNY3lSRHlwT2Y0ay93QVJYcjBETVdUSjVPTVY4Q2VDUEdMK0hyaWRKVkJ0cHl1ODdkMnhoMFlBZGZldnBuVGZpWG9GdzRqWFVyTlczY0dhRjR4ejdtdnFLTmVOU2pHOGx6TFJxNTh6Vnc4NFZwV2o3dDdvK2hOZ0pBUHB3ZmF2QlBIUGpQVmZEK3NhZWRKdTN0N3EzL2VtVkR5Q2VBdjA5UlhzNjYvYy9ZZnRCRmc4SVVzSGp5Y2dWOGh5SkpyL0FJblpuaUxGNU43S0J3TTlCK0FyaXhsV05PaTIyZlQ1RmhKNGpHS3kwaitaOUhXSHg2c3RYdGJWZGJ0bS90R1BLUElEOHJqKzhNOS9hdlRwbzRaWUlicU1Gb1pSdVZsOTYvTHp4dFovWXRWbGlYSUt0Z0R1SytxL0J2amJ4VnBIaHFDenZyTmIyMXhsSEhFMGVlM3VLK1hqZVVWS096NkgzMWZGMDZOZVZDcTBuSFoyUHBTMTFTOXNKQk5hemtiZVRuZ2o4SytsZkRQeHV2N2Z5SXJ1UGVwSUJmOEF1MThsNmRlNmRyTmw1OXBNcDI0M29PR1UraEZUM0VVYVJLVUcxZ0R1UFhKOWE3S1ZhY0crV1ZqbHFRcDFWYWNGT1BUL0FJQit3dmgveGZwbXR3RjRwczVPR0JHQ0QrTmVlK05QaFI0WThSaVdRUkNLN3hsSm96dFpXN0hJcjg0dkQvaXJWOU1uUm81Q0FDT09hKysvQi94TXNyNkNKWnBRSkIzUEdhOXVuaUlWRlo2U1BtcStVemcrZWpLNi9sNm84RnZ0SytKSGhMTVY5YkRYTk1BeHVVZjZSRXY5YTVpMjBYd0w0cWpuT21YUXNyMytLTDdqWkhaNHp3ZndyOU5Jci9UN3RFRGJUdUgxelhpL2k3NFFlRXZFQk04Y1BrM1NuS3pRL3U1TS9VZGEzbGUxMC91UG5aVWx6ZTlIbGQ5MHZ6UitXdmkzNE1URHpEY2FXSk5vejlwdEJodnFVTmZQWTBQeG5vNnl4NlpxWXZMY2ZldFpSdUdQUW8rUitWZnFQZmVHdmlwNFhkeEhLbXMyaURoSmppUUFlakR2WEEzbmlMd1JxT1lOWjB5YlRibkhJbVRqUCt6SXZPSzVaS04rM29OMDY2aTlGVWoyMy9CbjVaM1V2aHlkaW10ZUZwTEtYQi8waXpZeGduMUtQa2ZsV0V2Z253L080bDB2eFRERkoxVkxsV3QyL3dDK2x5Sy9WNjYrR1dqNnBBRzAzVVk3aVBia3JJVm5RL2x5SytadkVYd0tCTE9kUGRNamhyVi8vWld4V01yZDR2OEFCbWNHN3RxYzQzNlh1dnVsdDhqNXZHbi9BQm5zYlFDRzltdjdZY0RiS2w1R1I3QTVyaDd2WE5aVm0vdFR3ZHAxd2VoWTJyUXYrY2VLOUx1L2hYcjJtN21zZGFtdHoxQ3lLMFp5TzJSV0tyZkZxeWJhazV1Vnh6OHdmZGoyYk5aUm03UFYvbVovVnFhbHpleXBPWDh5VHB2NzFjOHFrdlBCODRCbThLenc0R1AzRjB3NCtqZzFGQmIrRFNseVV0dFZoRFJrQU1ZM3g5T2xlcVNlSWZHck9UZWFDa2g2RnZzeWtmOEFqb0ZJWjdhN0RlZllRUVNBWUt0QTY4L2dhNVpubzBvOHN0bXYrMzNMOHo1Mml0UEM0TDV1YjRmS1IvcVZ5RDc4MTZ6OEw5WjA3UXZGdHJMYVhGMDhzK1lGRG9JME8vZ2JqazA2K3NiR01XNU1GdXBlVUt3QWY1VlBmM3BCRnBOcmRobDA5SmRwQlYxV1RnanVNR2tucjFOSnd2Rld2MVAxUWE1OFVzaU5KWldhWndNdE9UMDduQXFPODhSWDFtNDgvVmRPdHdSZ2xBMG1QenhYNTV6K050V25RS0xDN2NEQUg3dHlEajZ0V1NMN3hWT0NJdE5uVFBka1JSK2JacjBGT0t0cWNIc1pPMmkwL3J6UHVYVXZFdW1OdUthN0xjTnpueWJjQWZuelhrMnErSW8rZUNVNjdycTUyRC92a2Y0VjRKYTZKNHN2a0VjK29DM1FrL0laaTJmK0FwWGM2VDhJTHU5K1pqZFM4OGJVRVkvTnVhT2RONmZuWWJwMlNUZjNLNTV6cmQ5NGV1SkMwOTJjcVNSSFp4OEgvZ2I0cXZwYTNrMTM1K2plR28xa0gvTDFjcjU3RDMrZkNnL2hYM3A0YitBOXJGSERNMGRySHh5eEJsazk4bHNETmV6UmVIUGh4bytQdDExNXpnOHF6N3lNZWlKZ0N0b1hlMWsvSkhQVWpxMXl5bXV6ZW4zTGY1bndCcC93NzhUK0lyamRxZC9kWHJjWWhnWGNvOWllRld2c1h3cjhCYlBUclZKYm00aXNJOXVTVkllUUQvYWR1QitGZXR6K0tOWHZMU1NQdzk0ZmRJa1U3WjVWQ0E0N3Fvcks4Qy9EL3dBU2VLOVV6ck41Y3RiaFM4bHV4TzBNVHdDUDZVcHlwUW5GT1RjcFAxWUtqaUpVckpSaENDMWlscDZXSmJYV2ZET2l0TGFlR05NYlU3dHVIbFVrcVcvMjVEMitsZGpwdnc0OFJhMy9BS1o0bTFEZGJMaC9zVVFNY0NnZG03dCtOZmEraWVCUEQrandxbHZCRkR3T0ZBNXhXTjQydTRMSFFMbG95dTVSa0E4NUE3VlU1eVVicFd0OTUzWVREYzlXRWY1bXRldjNtMzRkMEh3OXAxakMwQ1JMR3E0WGFBQUFPM0ZjOTRuK0lPazZQSDhqNVlad0Yvd0hXdmh1ODhiWGNWZ1lZSkdpVmlXQXpnYzE1bTl4ZVgwYVNHVTdnSFlIZHlTdnA2VmlweGNWMzh6NjJubE5DazI1UzVyUFNOckw1bjBUNGgrTVYxUGJ5aUYyaUJIRzdrbjI0NlY4dnphaFBPNW1jTkxKSS9CUEdRZlUrMVUydFoyYU5sZnpKSkJnSHY4QXJTUHFPbjJVelEzUVVZWDd1Y0FFOVNNOTY1SjFVM3FlekJjc1VvUlVWZm9Xb0VnY1R5U3lQSEtxL3V3b0czSzlpUlhuODJvNnpxdXB2cCtrUW1XNElQbXNCaU9JZjNuUFRQdFhnWGpQNHR3ZmEyMDNSdDJSOHNrN0VIbnZ0eDJyMkw0SGVMaHBqYWpaNmsyR2tEVHBLZXJGVnlRZnIycmhuVWp6SlgzTWE4cXNjTlVuVDk1eFd2a2VtYVY4TjlPdExBeTNDaTd1WlNSTk5JTTg5d29QUUN2eTc4WWFGWVJlTU5XczEyaC90cXZEamhYalk0WkI2RVYrMW53LzhSYWY0aThQUjNVVnZLSFNSMGtTUlNtR0JKSjU2Z2pvYS9LWDQyNlUybStJV244dEVhTzhMQW9jZ2hqdUdENlZyaDZOcWtuNVhmeVBncTFlcEp5VW0yMjNabm1maVBRTk0wdlZ0SFlXNE51L3lPakVzT0Q3L1d2VVBEeE9sYXRQcERrbUpnWnJOajNSdXEvZ2ExZkUrbEhWL0RCYVBtVlkxbWl4Nmdad1ByWEpRUEpyUGhTMTFDM0diL1MyRFlIVWhmdktmWWl2cjRXcFloMldqU2NmTkxkSHpOUlNyWUdtbTd1TGNaTjlHL2hmNkRQaWVXL3NhSWRQMzYveXI1ajA5aUxpSC9mR1BybXZvLzRnM2x2ZStGckM2aWNGWnBGWWVveU9SK0ZmTmRreFdlQStqci9PdVBNYlBFcXp1bkZIVmxQTXNLMDAwMUtTc2Z2ZjRPOGErRVA3RzBYUkk5WGdrMUVXeWI3YU03bVVnYmlXN0FEdlhBZU92aUpkYVJlMk5qYWVTMDEyekxHN0g1Y2o2OFpyNG44SitMZkJuaER4Rm8xeWtyWGQxZVhKWFY0WllNTGJ4a2pZWVpCeTNYNXErNmZFdXNmRHU4dHRXaGw4RDNWK1lYRDI5M0JDWm9KRllaeW9YQlVpc0l4aHp0TzFyOVdkZk5WalNzazlJcXo3NkhJeCtNNUpOSnNiaTV0dzA1VmxrMkRqY3B4eDlhL083NG4yOE9vYTVyR292ZHdRU3FZeUxaOGlWOGpHVjdFVjlmTDhUdkNXbTIvMllxMEVlNEh5WjdaMVpQWUFpdmtENHYzdGpxL2lVWHRsSkZMQzluR2QwZlFGZU1IME5henB4alNrMDAvSk15bzFLMHBwT01vcTE3dGRqeHZSSC9lQlZmQnoweG11MWFPV1BVWXBEemgwSVA0MXcrZ2xoY0tRQVNEME5kZGVTekJSNWd4dUpJUHRYbHhQZFdzYk0vUWVmVmRFTnRiT2RYamQzdDFabFZXTEkzVFl4UGV2Tk5WOGNXMGQvSGFSbE1KSDFjNEpQcGtWODZpNW1SRVBKRzBIcVB6cm41NDJsazNtTHpHQnprNDRyNkNlTnE4dG8yUjhUVHdGR0RlcmZxZlhzSGlXem5nUm1PMzF4MHpXdEo0ZzBuZWpmYXhKa0E1VVlLbjB3YStQWVRkS3BQemV2dFQzYTVLNTJrRDJZVVJ4dFQrWFV5bGdJTy92T3pQc00rSzdFUmxUY0xqSndNYzQ5YXFYbmluUzFRTThwbDJqSUFPUHBYeVVwdnRvQlFNUFhOSkpCZkZnQWgvRTFieDFYK1ZHc2N2b3BXNWozSHc3OFM3bWZVWmttaWorejd5dVN4TGpIVElyMnUrOFhhU1ZqYUc1eTIzNXZsMjRQcHgxcjRjaDBlN2pZdXR1aXN4NU83cld0SkhyQ28rSWV2dmlvcFkzRUtMVDErUlZiQTRaelRpcmFKV1RQcjZIeGRwakVnTXdiQUc0ZFR6eld0L3dsZW5tUmZNbSs2ZW1PUjlhK0daZjdlaTJOOWltVlNNN3hrcitkWG11ZGJFSWY3TEl3NkZnVC9oVy93RGFOVmRQd09MK3lxRFdqZjNuMDU0bDhmd1dscS8yWm1KMzU4eHh3UGZGWC9EM2phRmhKTGN5eHk0VWJYUVl6bjM5cStNTHZWcnVSZkxOaklEMEplTm5IOHFsdGRZdVl2bEVMZE1GVmpjZnBpdWIrMEszdEZMbStYUTZsbFZEMlNUaHJmZTU5K3orT2RHTTVXR2JnSEc4OEVqNlZBdmpIU0JKOTltSGZIQnI0cGl2cDdoRllJRUdjRU1yQS9YcFdyQUp2TFoydTR4bHNiU0d6K1dPbGRjY3hydlhUN2puZVdZYU95bDk1OWEzUGpUVHQ0S093VWRNOG11UmcrSk9rUzNhMjdvSVdqeVEvSmFYUFFZNkRGZk9VcVR0dE1Wd2tneWVBamY0VllqMC9WV1F1c0dmOW9Sbk5SVXpIRXl0NzF2UUlaWmc0L1kxdDNQcjF2R0dqT2g4dDVEd09DY2tuMnJKWHhyYVFLdVdkaDJ6eCtYdFh6VkJwMnFOeVJqSEFCUnY1VStUVGRhUWdORVRqcDhoeFYvMmppTk52dUpsbFdGdDErOCtqdFM4ZDJNaWo5eDFYRGZObk5lRytNL0htcHBwUUZoSzhXR0c1bDlLeW4wM1VDQUhWZ3g3Qk8zdFZkOUV2SkZZSmtuMDJaQi9Pc2F1TXhFNHRYdGRiclJtMkh3ZUdwemkzRk8zUjZvOUg4S2VQNzF0R3QvdHVaSlJrYnNZSkhZbjNydVc4ZWh1V2o1OStlSytjUDdLMUMzZFVNVW1EemtKbjhzVm9EVDdrcVBrdWZ3aHorZEtuaTY2aWx6UFR1WFV3T0ZuSnYyYVYzMFAwWmh0ZFFzN1M3bGFDSjQyM0FiVzNFSEhYaW9ORkZwTlp1NXQwUmw0M0xtUlNQUWc5RFU4Wmx0N1c4QUxJTGdHUkdRN2g3ajJQdFJvQW5qMHRTRkIzazdHQXp6bnVLL05rbGFiODFZL1ZGOFM5Q3BGcUp1YkM3Z3ViSnJKMWxDcUMyZHc2aHZiTllUMjBxUllTYmJ0VWJtVnVldlhuaXZSTmNOeFBwc2JDUkRJcENuUHkvaDdWeThhVHkyeks5djV1MERLRGpPUFgyb2pMbVQ5UWFTdDE4emYwQ3dXemhkeVZkNW15U293V0g0OTY3clNwWTcrVzVGMXA4bHNJcEI1YnM1eEo2RWJlbjBOWitnTklZNGkwUkVZVXN2eWJzZ2RnYTlhc3J0TG0yWnpiQmdjN1FmbCtuRmNVMitkM1J2RmJITTJNWml2a3hKQ0NXT1ZjOGtBZEY5YTcrQzEzRjJYeTBRNUxnODd2VEhwV05HTGNlWnVXUGVSMGY1U251TTEwdHF0bUxFeGJnUTZZSlU1em4wcGN5Yk5tZU1YMHlKY016WFd6RC9LaDdZNjROZFRHMW5JVmVXV1FBZ1krbmJrVnp0M2FvTDRHSlF5b1RrRURQSGJtdWd0R1I1Q01Md2h5RDF3T293S2NrdVZFSFQ2WGJXODF3OG9RN1dJeGs0KzczcmN2Zk5sbEFSbUxET0NHemtmV3VSczVuaVlJdWRqQW5HMzVRQjJHSzZheFJvOTVNWlZlUXJCdldvdXVSYURzMlp4VnRoSkczQTQ5Nnl6YVc1Y3lzVVV1UVdPVGdub0FSWFFtTjQwVGV5S1Myd0FuN3hQWWU5WG10NEE0eEdOMjBmU3BsZHE1UngxMUJJUTRYQzdlakFZL0N1YjAzUzdhT1IvS25samszRW5jKzhObjY5cTlOMVdHOVMzTFJ4aG8yQVUrLzVkRFhITkVGVGhBcmdubmdqQnJOWHVKclptZExabWVPY0pjNWtWaGd1ZmxiOHFxNlJadkVyaVJWUnpKdUcza2NkdmFtejZmQXhWNVNjbzI1QUcyZk42bjFycmRMdFo3bU54RmNMYnlwZzcyVGNNOWVoN210bDBXekYxdWJsdlliN2N5SXdrM01NZ2Z3L2pWZ3dJMGZDa0VqR2ZmMHJWL3dCS1FBUEVGWjI2Zy9LM3VLNkJZSVpRbzJxcjdUMC9pUHJqdWFiVnRTcnM0bUVTS0hWaUNvUTl1djBxR0xUVSsxTS9sc1BsM1o1MjQrdnZXeWRQa01rZTVncTU1NHBpdE1tOVEyNVJrYlBXb2hGWHVWZGs5dmEyc2lMOGh3UWNrOC81RlVwTFdFektxN2p6eHpXaWt5aUVablNGOXdVSVNCeWVnNTYvU3JzTnIrOUp3Y2tIcHlCVFNkMERaekRXY0d3b1hCUXNDVnh6a2RPYWJERmJ1LzhBR2NIQkJ6L1d0UjdlVHpFVlRJeXJMaGloR1BxM3Q2MTBrRmh2Nk9Ca2pQR1QrQnEycE5yUVZ6bUpMYVVJKzFoeldUWldiU09XUUx0akpMazV4bjJydHJxeENib2xtV1ZXNVhJSWNIdm1ydWxXMHdLUkZBQnp1QS9yVXJjVFo1bERwZXB2cWx3UWtQMlVvcFdRaytZejl3UjB4NzFwdzJVMFFHNUdYazRDanI5YzE2WGRJN1Rzc1RydUhSRHdXSGZGYUFpam1zMEJQenFmWFBQdldyaXJYRm9jMVoyaGEzWlE2TDhtU0dYR1Q3MWxORmFJUzhrRWNwVnR5YnNnS1IzOUs5RVp5RndWVW5iMjYxancycXROTXNXMFlVTXk1eVJuMUI3R3Nta3lremg3aUZacFAzaXdxamM3VlVKZy93QXE1bTVqYU9hWGJCdHdvMmdEajZnK3Rlcm1LeGxWVmt0QTVQcW1RUGNIK2xlZTZqNWh2V2l3eXhnRGFtTUU0N1ZuSmZjQ3ZjNUxVN2g1TkxXSXN5cUpPbkdmY2o2MTZsOEpOUXNJUERQaUNWMWpZeHl5Y3NvSjJnZXByZ3RYc3JjN042dEd1ekF5d0JZam5BelhsUGgyNWxnOEcrSUNwWlJJOHBDNXpubm9TSytteWFrNjA2cWIyU1BtYzVyK3hwSjkwejRDMWcvMmg0NTFpNml0WXdxdWZuQ2dFYmp3UU85ZXMrRU5QbTh3T2tNYkhmemx3cEdPcDU2L1N2T3RGaGRyaldwamdmdmtWUjM5YTl4OElXc1p1TWJIWnlwS3hNUnNKSFRCUFFtbmoxNzlSTG94WUNLVkdqNXBIMlI0ZVRmQXFxQWdHMVN3eG5udWE2cTR0STRic1JxVUpVRmhqb2ZUbXNYUWtQOEFaNk84UVJ3UmxTY0VaNmpJNjEzdHBEdWxWMlVHTWNBRWdzUFVHdm1uQjNQcDR5c2lWYmhUQkQ1YXlsaUFIK1RnRThjRCt0VnBiTWJsU1ZqemtQaGUxZDFaSWlxMGlwbmFTRUJQOWE1ZldXY21JdG56Q3B4Z2NEbXFWdWJVemIxUEkvRU1FSGxORERHd1JRM3piUU8zYzk2L25wMSszaGl0THh5eExQZFNoZlFBTjErdGZ0djhYUGlCYitCOUNlNHVYanU1NXZsZ3RnK3dzVzRKSHN2ZXZ3ejFYV2t2WUhoRnY1WTN2Smt0azVZNUlyMmNEQ1NsT1Z0SGI4RHpzVktMVnI2cGZtZlhQd2owcVNlTzI4dkgzRHV6MkJIODYrKzlKdGJnMjd3QzNHMVZ3c2pMaHNlb1BwWDUvZkFhOWx2WG1qa1g1WUdWZHd5TURIR2EvVVBTVVNlemtWQXhWVkp5dzlmUTF5NHh0VlY5NXRoVXVSSEdtMGhIbHg1Q1NqSVhjRGhoNmVsV29ORWplSStiT09uM0F1U2ZwN1Y2WlpReHlRQjhiVlU0eDk0TjZFWjZVMmV5V0F4M0prVmdXWUZRZVZIb2NWQzVuRzl0RnVidmxVcmQ5anlZV1lTUXlmNndxb3dSemdkT25ldWh0clMwVzBTTzRTTGZJY1J1RndXSjljZFJYYW5TNEdqa2FER1pPVzJnNS80RjJwNkcwdDR5c3lSNzFYYWpTS1RuUFlZNkgzckpPNjNEbHNjamIrR3RObUJFOWlTSTM3WlJnTWM5T3ErbGM0TkxqV2E0TU1ua3JFcFVSK1Z1MksvR1FEWHNpUnkrVXNzY21kNjR3T21QcWFwUXlYTDNFSlluQWNEYWNIT1R3ZndyV093bkZPeHpNR2pXMENCa3VaTnlKdEhuNUlYSTl2V3EybjZaYnl3VE93ams0SzRSVGdaNU8zUFd2Vm50THFXVzhpVkViak9BZVhQdXBybmpiYWpIYWdTYklGVnMvS1BtK21LeW5MYlVwUlNabTJXbHd3M0szRUJpZHdySzBjMGVZenVIZGVPUjJOWWV0ZUdOTFdTU1NPMjJUREQ1aUhBYnFTU2E3K0NDNGUxTXJmSU1mTnVYZG42VmthMUJEWmFXYnE3dVQ1Qi8xa3JLUVBVY0RuRkVyeWo2RHRHNTU1NGMwS0crOFVhZk5ieHF6Sk9aSjJMa2o1Qm5BSFk1cjdnOFVlT05LOE4rSHRPdnRSRWhnbmwrenlTUnJ2RVpib3pZN1Y4eS9DalZOSnViblV0UUdRc1Nzc1NPdXhuSUdlUFhQYXZWTGRyTHhGOExySjVkTlM2V1NkcG10WlNWQWRaRHdjZWxlWHp2MmxSTnZTRnJmaWUxVHBwVUtUc3RaM3YrQmU4TmE5ZDZ0NUt3d0FpVElNaGZBVk04TVI2a2RxOTRUVDU0SWpHODZlVElBWkRnaG14Mkh0WGtWdnF5NmQ0ZHY3MVlJSWxqVWhVaVhhQzZENXVUNmRLK1p0RitMZXY2dnJWeTVlS0MzZUl4UnhuTFB1QTRJTmNxbjdPRnB6YmRybnEvVjZsYVRkT0NVVTdIMHZwMWo0UnZ0Y25qc2pGSmR3U01aSG15V1VkL0xIVEh2WFVlTmRRdmRKMEM0dWJDNEVaZ1VBUWtiekswaDJxZ1BZblBCcnpuNFhlSG9OTjAzVnRZdW5VZWE3SkhJeDVBSDMzSlBxYTVPZTUxblhQRUZyUGF5eGkxaXZ4TE9rb0pEeFJJUXFqME9lYTUwNHhpbTlISmFlaGJoS2RWcE51Tk5wTyt1b21pYTNkYWlMM1E3clQ1clc3V0FTZlpweGxYMjhuWWUvNFY1dmQrT05DYlRqcDMyR1MxbmluUG5rWWJlVjdnRHZYdXVxV0Z4ZndXT3BUUDVib0pwWWNaUjFVWkFBUGF2ei8wRkh1L0Zsdk02Ym5hNkRQazlWVnNuTlpKcHJxbW9vOVdsRG41blpXM3N1NlAxTklUVWRJdHBTckFQR2ppTmhoMFYxd04zMXJ6RHc1b3dHcHp5ekVFUkZoajhlQlhVZUQ5V3U5VHZQRU1zd1hZeUk2RWZ3aE9NRDJBcXJZYWZxTW11UGNyTTVzd2dkaHQ0UDhBczVOZWpWVWFzS003YnRyN3REeGFQTlJuaUtibGF5VCsvV3g2ZGVhYXQzcGx6SElnMlN3TUc3NEI2Y1Y4emVHdEsxVHcvYzZteVdUWENRUi82cU5nQzJlaktEMTk2K21iL1VHdE5PbGxSQy95NENyMUo3Q3ZKL0RuaVdDNjBaZ3dYN1M3dVpTUDRUbmdldjQxdlhqVFVxZHBXYVYyYytIblY1S3Z1M1VwSkhpOFQ2cFBmMmw3Y005dnNMRm9EMElidWZldkp2aVBKSGZlRXRlUk56RkFKTnpjYjJWcSt1NzIyaG5LdTIwRmVoSTZmVVY4NStOTlRzWXRFMW5UWkNnbWx0Y2dzaEFJejFEWTUrbGNHSFQrc1VmS2EvTTlURldsaEsybThYMThqOFdQRXRsT3E3a1loMk9aRVBKUDByaGJTMEpsVXZrQWNuaXZhSjBSN2krZVNKa1lTNERmMUFyakhZL2FRaXJsTSttRFg2UktWa2ZqaVdwaTZsYnlTeUFvdUZWT2dIRmNzSU4wanFlT0JrSCtkZXA2aEtqVzJFRzBZdzNybXZQWkxxVkNTNEdBUU00NVB0V0VKTm8wYVZ4bDFZdUxWSk93SFVWbFJNVlUvT1Y1Nml1dHVaVmx0RUkrNkJ3bzRybFZiOTd0QUkzZEFPbEMxV3BSU1hydUp5T2EyTGE0VGhjWVBmUFQ4YWptaVRjb3dWWTlxbE5rNHlEbmRqK1ZKOHRocTZPWjF5R0tHNmdaRDk0SEk5RFcxcCtueVNRYnd1ZWVTZWdySTE2RmtqdEdiK0xOZTRlR3JYL2lVcEpnbmVPbnBqdldkU2JqU2k5OWJGUlNjbWNCQnA3a25jQ0JYUVMyanlSTUdHQWk4TjA2VjZUL0FHYVBuazJqSUFKRmM3cU12emJmTEJCVVpIZjYxTVpPVmkzSHpPRnQxU0syVnZNK1lQbnBqajFyMnlhZUY3RkxpSlBOOHRRYzdjampxSzh3ZXpMV2JJU09HR0FmUTE2M3BkbHQwOHhPVzJ4a0hBTzNqdUsyMGJYcVl4dmM1SHhiOW11Ykd6dW8yWGNjSzIwODgrdGVSNm1qallUZ2VvemsxN0pyVnBiSnA4a1VTUlJnUzdoZ2tsdnhyeHZWWm5YYWpSaFN3NjE2Rk5KUUluOFJqc1dNUVpSbko2MXhkenVmSko2Z2o4cTlCdUkyK3pCdnU0WEdCWEJ5S3dHZlhwVWRSdTlpYncxZk5aYXpiemlGWmR1Zmtib2NqdlgwaEQ0ejAvelZFK2hnRWtZTVpIOWErZnZCc1FrOFQ2Y2h4ekxqQjVIU3ZvVHh2WUpwZGhlM0NScis4VlkweC9BWDdpdVNlTXEwcThLY2Z0Sy80Mk5ZWWVuVW95bEpiSHpMcmsxbE5xOTVKYXhsSVdsSlJUempQVVZpaUoyKzZ1Y0RwVllIQnJkdDJDc0s2Wk5vd2hGUFF5OWtpL2VVZ2ZTdHZUU2R6SVNNSGtaclNhNFZzZzR4aXNwWTJpbEJBNHprZTRyRnl1dGREZFJzMDBYcm1NR0tUNlpySXNtMDhUUm1hR1NWZWQ2Syt3bjZIQnJidTVjUk5nZFIvT3VNVmlweUs2S01rdDBjOVpYT3J0TlMxaUdPZTB0Ym1XT0dmaG9nM0JCUEg0KzRyN2c4RTZlbWk2S2J5U1V0TnM2dHlRZng2bXZqN3dacHIzdXJ4eU9tVWk1OXM5cStwL0VsMjhPbkJOMjFRcE5mUFpyaVZPcENncFB1L3dESS9ZK0RzdGpUd0dKeHRTR3JWb2VpM1o4OTYxSi9hT3MzRTd6S3JlWmxTeDR5RG5OZW9EeGJyQ1FoQmQ2V0FQVlRYeTFjeXZQUEt3YmpkVlh5NXM4TWE5S0ZLVVlSU255MlhZK0VyWTdEVks5U2RUQ3FvMjNaM1BmNVBGT3EyMStsM0hxTm9rZys5NUtGZDQ5RzlhK252Q1B4SDB2VzVFdHJnTEhjYmNaM1lESDFyODNpOHlqRzZpT2VkSkZkWEtzcHlHSEJGYWV4bGI0OWU1S3pPbEZwUm9jc2UxejltMzA1aENyUmtrQWM5T3A5TWRxcndNMXRLanJsZWNIbm12eng4Si9GalhkS21VWFROY3dZdzNQelkrcHI3SDhLZVBOQjE1bVZaVmpmUEN1Y1pybms1UTMyWFU5dkQ0aWpWdHl5MXY4QUM5ejdNMEw0a1MyYUtrdzZZMmxlYy9YTmU5MlB4azBkWXg1bTRON2MxOE1TV0xDQTVLa2RSeldCSkVGS2haQTJlcHJ2bzRtYVdrcm1tSnd0Q2J2T2tyK1doK25zWHhUOFB6NEx2MTQrYXMvVTdqd05yVHJIUEZieWx4MElCem12elFMU0lRV0xaOXpXelo2aE5DNGwzT1NPblhBcm8rc09UMVNQT1dDd2lhdEdTK2R6NjF1L2hGNGZhZHBkT3VacktUa2d3dVZINVZ6V3BhTjhTTkFFWiszdzZuQ3k1UVM4TmozSXJ6V1B4ZnE2cUpVdVdBenRKempKK2xlaDJualhVcFlHV1JZWmtRbHR4SHpjRCtWVGRkOVNKWUNtN2JOZGJuQzNIaW02U1F4NmpvSlZYeUhNUkIyKytLNU85dVBCVnhFVWRIWFAzZDl1VllmOENGZTVEeFBwZW9LUlBCRmtqcTN0OUs1NDZUb2R5R1lRaGR4NDJtdWFvbHpKL2tVc3BXdG5ZOENsMDd3Z1F2bFh4aGJwZ1N1UHp6MHJnTmE4TzZZSEJHcUFsczRIbkE1SDQxOWhENGY2Vk9xRmJsd1dYK1BERFB0N1VsMzhJOU1hM2RwWjBmQTRIbGo4OGlzWktwYnI5NTUwOElvN3RINU8rSWRObmp1b1V0N3d2bVREZk9yWVd2Uy9EUGhhK3ZMZ2lUV1piYUlKOHpJeUUrdzVyRytKZWhhTnAvaWVHM2drVHlVS21XUlIwSjdjZDYrbFBoejRUOExhMmtxV3NuNzJKUTMzUTJWUGZIdFVVK2FVckhMT2xhSzdIbXNuZ1M2Q3NwOFJNWThnamZPRi9INWFmYmVHZER0aVJQcThUbnZ1ZHBNL2dLK3JuK0ZvYmt6bmIvc3FvNHAxdjhLdFBHVEpOSWNZNFppTTE2OGNKWGwwL0V5U293dTMrQ1BDWWJqdzFab1ZFa2pNTUVLa09GT1BWbXJ2dFA4QUd0dzhLeFdNQVJoME9keC9JY1Y5QzZQOFB2Q3RoYnM3NmRCTTZ1cEJreXhBNzhIcUs5cXRMM3czOW9qKzAyTUN3aE52K2p4TEhqQTR6am9hM1dCcWRXbCtKYTltNzJoS1I4eDZaby9pZld3cVhsOU1rUk9Xalg1TSt4QXI2MThPZkNIdy9hV3FYTDJjYkhBYmU3QWs1NzQ2bXZNTHZ4cnBzS1RScTZLNnNRaTRBYmI2Zld1S3YvaVBlMjl3akxueTBRYmN2bjhqV2pwd2d0YWpaMnJDU3FXWEtvZXV2K1IraWVtMk9pMmxvSVJGR0FSOTBBQ3A0NXJIVFlpSTBTTmUyTzlmbVhlZkZqVy9PV1NKeW94eXZYOGpWcUw0c1hreTdaRkxzb3lCMlByeldIdEtTYWR0alJaUHAvR2kwN1hXeDk0Njk0Z1dDemtuQnlNSEJKd0srRS9GdmpLNzFBeVJ5VEZZbVUvTGpKejJybTlmK0lPbzNzQ0lvSkdPVkh6WSt0ZVF0Y1R5SHFXZHNveTl3TWNrNXJtcTFrMDdQUTl2RFVhV0doYXljdS9ZcTJqTTdZTE9Uazg5Y0E5Y0N1cWdzck5ZcFEvbTRJL2RaeGdudVc5SzhoMVh4ZG9XZ1cvNzI0UUZRUUVESGQrTmZJSGlUNHhhbHFkMDBOcTd3d0U0SkI1TmNpazdhSWwxcVVaSlNrcnZaWFBzdnhCNCs4SmVISUNKN2p6WlI5Mk9NNXlSNytsZm41NHUrSWVwYTlkeXlDWHlvMnp0alVIalBmUHJXVDRxdFptMDJ3dTBZdkZ1TzRrY2hqNm4zcnJQRGMzMmZ5cnkzU05aRlhLT1VWOFpISEI0TmM4cEtNVko2M2YzRTh0YkUxS3RLUExIbGltayt0L004V3NCTGFYc0x0R3dKNUc1U01qMUdhK3RZRnViaTJndUlYQVpvOE0zWmErYXZFWGlueERyTjdESnFOd0pYdHNvaDJCZG96MDRyMjd3MXFMTmJ4amNTUFRzRFhEaithTGhOZEQwT0dXcHhxMGFpU3V0VXRUOUd0SjhmYU5vZWlXZGtXamQvTVVOdGxCVlF3QUp5ZWNWOFUvSDZiU2J6VjNnMC9VTFc0M0NObmFPWU1pTU9vQjR4OUs4cjhVeDZSWlgxaGMyL3dCcyszVFRiaXBaV3RpT2d3QnlEbnJYaC9pdlROYjB2V3A0TlJqVkpuQ3k0Vmd5TXNvM0t5a2RqWHRVTVQ3V1BPb2N2TW5lNThManN1V0N4RlNqT1hQeVBScnoxVno2cDBuV0hYVHJWQnFkdEdFaVZDeUlYSUlHT3A0cmpScEFzTmFXNXM3dnpyYTVCKzF4bk1XU2U2WXI1VlY1RkJBWWdIcUFjVnF4NmxmckUwWXVKTnA3YmpYcFR4TlNVWXBwZTdzenlLT0hveGJ0ZjN0MXBZOXAxclFNV2wxYld6eExBMXo1MFBtRnQ2QWpsT21NVkY0TytFbmpUeEhxS1JhZGFMTWticVpaVmJDSVBjbnY3VjdGOExmaEo0dzhSaU83dnIyV3gwMXVRejh5VEFka0I2ZlUxK3J2aHpRclBTYktLeTAyQVdpTW9BSkhKUDhBZTl5Zld2TnFWWnV6aTBiV29wMmpkdnFlUTZCOEhiUFRMeXhsdUxTR2U1andWTEtweGp1QjNQMXI3QzAzUTRWdDFRYm9neE9ka2ZmdnpYVzZKbzhOdkEwbHlRcnVQbUorK2Y4QUN0OVg4eTNOdkZBclJzZjRpYTQ2a25PU2N6ZW5RcHhoTGtYWFhzZWNYdWk2RE16Ulh0cGJYQ01vQWQ0d1hCOWlRYThROFMvQXZ3UnF1bnpwOWd0a1diSWFSVjJTRFA4QUVDdmNWOVlpMjhxUlUySkl4WElDaklBL0dtM2l4VzBZRndqQXlENVVYbmoxcnNqS0NXanNjcmpVVXJJL0JQeDMrenA0cDhJU3RkNmUzOXFXR2NsNDAvZVJBZjMxL3FLK1diNUdjRXNTQ3VRZU9udGl2NmJIMDVWQjhtVGRFNlkya1pBejBOZkozaWI0SGVFdkU3VFJ6UnJGY25KKzB3cjVmekgxN0dvK3RVNHV6T3FNS25MckhUeVBpWFFkRDhFZjJOWU9MVUdTU0NNdXpNUHZFY211d3R0RjhCbTRXSUpDanN3VGVKRkE1NDV5T0I3MWthejhKZGUwQ1ZMT0NLYWZ5Y2dTSURrcjdqMHJob2JXV0dVQjdFRURndjhBVDJyZjZ4SmJJNVhSaSt4N25Ob253L3Q3Z1FOTWo3U1Z6SEtHVEk5OGRLaWgwYjRjbmNXdWt5dlZTeThrZWh4WG1vMDJhT1llVmJDVFBKQnh6bnAxNllxU0xTWloza01jVWFOa0ZnWThuNlZFc1ZPN3M3QXNOVHRySDhEMCsydFBBN0FpUm93TjN5bU4xUHkrcDRyUnRJUEFqUVRxR2lFaXNOcmw4S1IzeU1aelhoMXRvMDhibVlSaFAzbURHQmdFZXVmNlYwQzJVU1hZVmtMTDk1ZG8rOFBTcSt1eXRheUorclV0TkQwbnl2QThZKy92WlY0RWI1d2Z5cVI3SHc0Mm5yY1RXOGtSSU8xbm5BRFkvdWpGZWZYR254aE14MnhVbGM3aHpqMzlxdldtbXp5V3E4eXpBZDJ5UVBRRFBGWnJGVkxiOVMvcXROdGU2dnVPMzBPYndTSjVEZlgwZXdSNWpnKzBGUzNyakE3ZWxhVWVvZURwN3FDS0lJc2J2anpwTGdxcTUvdllIU3ZPSmRPdHBKQVJCODZqR1FvUFA0MXkxOGRVZ2NLOFVTd2RBd0dTZlp2ZXRJWXlwemZvWnl3bEsxcmZPeDczZkw0ZVhVSllJTGFJaE1FUExmaFJqdVZ3T2ZhbTJsaFkrWGMzSmZUZkxRY2VaS1dZZy8zUU9wRmZObHZvclQzQmtCQzd1VHVHZnBpdXdpMEc3blpHeVZPRHRCWEdBSzJsaTI1WHN1by9xOFhHeVBiSUw3d3ZiV29rS2FkT3hVbHZORXlCY2UzUS9VVnpNT3UrQzc2VHpCRlpvRmJHUkMzVWY3M09LME5WOE4zQzJFYlJoVzJSTHRHNForZ3JoTGJSM3VVQ2xBSERmS0R6eU8xY2p4VHQzTkZoNHJSSmE5MGRMYzZqcENPalJ0YlNFTmpIa1lCSDUxeVBpclU5TXQ3ZXdNTXNidk1DMGlRakJRK2hyS2JTYjY0bWhQa255aXhEbkFES3krM1dzNjUwTzJpMUJEUEkyQ3BDSmpCSjc1TldzVEt6MnY4QWtaL1ZZYVhQUU5MOGIrSGJhRkh1dEd0NVcyYmR4RGR4MXg2MWxueHhwbTZSVkVYem5BTFFjS08yUlhuOHRvcXBzQzVBenV6eHdPbjQxU2tzN1lSK1dWSjV6bHV1RHppdFBydGRwYXJUeU9mNmxRVGVqMTg3bnVhK1A5SmkwVVc5ellReXlvL0VzVUtvU1BxZWE0cWI0a2FNc01xR3hadk15RkxSTG44TVZoVDZkYS9ZQWQ3aFNNZ3VtQjA2Y1ZWMGUwOFB6Rmt1WVVaZ3BFTWpFallUNlZpOFZVbHEyYkxEMGxzakFoOFFTenBJVnRaVi93QmxYQkE5eFhXeDZ2Y2lOUE5pa1E3UmpCeG4zcVdhMmhzNHBIYTBFZ0tsVTU2TjJQRmErbldVRnpiS1owa2RsNHlId01lMVRMRTFmNWpYMkZOTDRUNkd1NG9MMjVsWklpa2YzM2FQRzBuSFhGUWVGYmU1UzNrOHY1anZ5dUR0d1B4cjBHemdodGtueENwRE1RQXZRZzhFNFBTdHpTQmF2RjVNY0lCSkpKQkhHT1BtOUs4V01yVTVIMFRqN3lPWjhRb1pyYU1NNmxnTU1HNEp4OU9wcnppTzR0STJLdWNuWVIxSXIxWFg3UVRDRlkxSmJvZHZPZmMxNTYxakNnS012TEFydFk0ejlLNTFLNmI3c0QwUFFvSGgwMFJmd09wS2pQUmZRR3ZSSUlJUHNvYUdObVJqODQ5L2F1WDA3VFVPZ3JMSXUyU0lnQUFudDZWMDF2Y29rTEtzaVNEQVlFUHRBQjlSNjFGUk8xemFMU3NqUXR4THVkWFFNakxnb3czWit0YWtja01rSGx3UnFoVGdxQjB4MkZaK2tyNTFyaFY1U1RuTGNuMXJTblIwTGNuWjBCQzFFVXI2amJQRzc1dFRpMUF5eDRsSVB6SUZBS0EveEd1ZzA2MXZSY29Ra1k4My9XRTVMN2ZUMklOVnIyYWQ3eGx3b08zSWNIYVRqc1RXN2FUVDI5b2greVNURm1BTzF3REdEL0djOVJXMFZHL2tSZG16SlkyNGtWSHVBaTg5K1FUNjEwU1FBbmJobjQrOHZBT1BRVnpWdDlwbG5JbGpVb0ZESzVQekU5L3lydlhIN2tiSk53NjljZGUxVEsyMWpTTE9TdTNtK1RkR3Z5RUZWa0dTcC92SEhjVk1CT3NxaFpWQWJuT2M0K2xiVG9reDJKQ0N4d0I2bHNldFU1Tk5FYUFFZk9wQmtqSjNiUDhBNjFaOXlyMmFMbDlOZExZRlk1RlorUDNTOFp6MzlxNHVhRllZZkxtVXF6WkkzanY2VjJFbGpiUGV4WE1iYkhFWVZpQmt5RDBQcGlzclVJcmgzaitaZVhBSXprNCt2UVUzRmMxMCtsaE42SERiWm95bjdneWNESC8xcTY3VFpYREIwa1U4WVpXSEtqMHJJYTRZeU9nZFNRY1lCMmtZN1YzR2lRTTl3SkRHL3dBaXRrS09wUFROWk9MY3R4WDBOd1IzVHhveGpYYUpNS3hQM1NlK0sxWTdoN1M3UzNrdFdsR0NWbmpVR01Edms1eXBwSTJ2cExaMGVQWUdiZzkrUFlkUHJWUGVWOHhaUVZ3dURqcG4xUHJXOFY3eER2M0pyOW81cG8xU0hDNFBmcjlmU3NtSjRWZFF2UmlmZk9LNVdTUGZOS3JYS0VNUDRYNUk3akZXTEZFamlEUmx6R3ZSYzV4ais3bXFsR3oyS1d4djNLMkpWV3VJWTJqUmc0UmwzQUgxSHZWOU1oeVVPRkk0RzdBeDdWUldXTGVXT0NlQ0QxL09xQ1R5UExJaXNrRXhRNDNFTVVEY0JnUFNrb3V3bTlUZnQxaWpnbFZSM0pHRHlXTlRXa2pxKzZUNU1rQlZKNHo2QTF6dW54WGxwWnJITGVyZHpvTU5NRjJGeWVlUjJOZDVBVkVNSlpOcFk4OFpDbjM5QlZxOTE1QTNaR1ZkUU9zbTh1V0JISUE0R2ZTdGl3SytkTG1Kd3dUcWVoL0dsdkh1ZzJWaEVrYXFXSlE1YmQ3TDNxM1pYc2MwYkVxMjFrNmtiU1BxRDBwS01ia3R1eFBDaXY4QXg1YnJ4aml0aUt4S0RkdTVZSElBRmMrbHVnQUtNY0U1NmNtdDYyTENWZDVEYlRnODlxMDA1ZGhPL2NsTWNRQUdWT08vMXJMa2lZcVZXSUt3NUQ3Y0JoNkVqMHJvcG1qTHI4aFZqL0RrZk43aWtVN2NxRmRjZXRSS094U2RqakxoUEt0b3dPUXBIdVIrWFd2UFo0alBkelNZeUVJT0NUbm4rUnIxK1pZRkhHZHlqNWR2M2VmWDNyeTIvVjNtbGxCSWZKSjV3RCtWWU9CMHdkMXNjbnJpYWUwRUUwc2FTU1c0Wm9zL2VRa2NrSHBYenZCS1kvaDVldHV4NWpzUWZxYzE3M3FOOExlMnVIWXNvU055UmpnOGU5ZlBXc3NMWDRkQU1QOEFXTW4vQUk4U2ErMDRkalo0aCtTUGdPSlp0UnBKZWR6NVU4T0tacHRUN0JyZ25uZzVBcjZPOEhTUVBHTXRrZ0hJQzVPQjZEdlh6cjRVZ1ZyUzZtbDJiVGNNeUhPQ0Q3MTlUK0N3KzZPUUxqRGNNQU1FSHJ0NzE1T05rdmFWUE4yUG9NREg5MVI5RWZSdWlRR2NxaXpqQjY1NmtEKzZEWHF1bkphWll4cDg2ZkxKSmpCYjBKRmNKbzlsTjVMTVkyWXErNW55QXc5T1BYNlY2VERiV0pqYVpZRk03c0ZhVVozTUIycnhveGRyM1BhbGE5anBJUmxEd20zc1ZQOEFucFhIYW1GanUxK2NzTnJFajM3WXJxSTJqemdNY2tlbk5jTnFKdUpMeDFWeVZNZU51S2lmSzRQdVNrMUkrSWZqNzRXajEvd3piMnhzNTVwUHRLdnZoWGM4U3FDV09TT2xmaXJxZWdMWTJhM0tTUElqU1BHQ1Y2TXZiUHJYOUxON0hkMkduNmpjdElzbmwya3hUQjZuYVFjOTYvQzd4cnBTV0hnbXhLOC9hSGFWaC90TTFkT0JxVFh1dHY0bHA2bkZYcHh2TjJWN1h1ZXFmczhhVElsbGV1M1c0ZFQ5RkZmcGZhS2JYVG44dU1OZ0JWR04zWHVmZXZnbjRCUUt1a3ZJUTZsV1grTHNlT2xmZThBbWNUS0dBU001dzJBVDlCNmU5WllsdDFwczZLU1NwUmE3Rmg3Uy93RDdQalNLZGtaaWR1RGpCUGNpcy9SZkQydFdOclBIcWVxaVdReUZnVlRCQ0hvQjdWdXJQS3JSSVNBL1gzT2E4VjhmL0dMd240WjF0ckxVUmN4em1FTis2UXliZ2ZiSXhSU1U2cWNZcHQ2YUNtNFF0S1R0MDFQZUxlT0dKdHFPL3dBeWtCdDNMSHRXejVMK1ErNE1yN0FDdkJ4NzE4UjJYN1Ivd3lqbmdqKzB6QU1RQWZzeHdwWS94Wk5mWTlucmR2cWFYcVF4eXFzYklQTzZLNUkzZklldjFxcWxHclR0ZURRUnF3bnRKTTA0N0dYN0wrNnVFK1hBOG81NmVvckpXQjF2SS9NVUlYSUNnanV2V3V0ajhwb3p1dVhMWXlXNEJ4NlpyTWttaVVvc1VyTUNlUG0zbWx5dTNxWGZVNmVlN2tnMDE0bFdOQzV4NWlmNnduUFkwbjluWDUwZHJxZHpjWmt4c09FMnFPK2Y0bXJMa2hpbURTbEpXZEYyamErd0RQc2VDYTNGbHVqcGtVYStZVGcvS3pEYjlhVWt0bXI5ZzMyN25nV3UrTTlVL3QyeTB6VDdPU1o5d2E1YVJEc0NlZ2JwdUZkZHJtdlNpMFpYaWo4bUhPMUdHVHUrbGR0cHpvSTVvWGNpUThZWmNZSjdFamo4YThLOFZSdVZhM2VVNzNtVVIvS1FEempnKzFYN1JjaWpieWJKNUpYYnZmc2ZUZmdYUnJMVS9EWW11NFk4bGpJckJkdTFPMk1lbGR4cHVqeGZaTGVHQ1h5Qk83U1JJM1IxSjVQc2U5V3RQMGxiVHc3QkRBN0FSSUluQzkrT1dOY0w0eHZZdE8wVStXL21TTkdVVUsreDFVL2VJQjYvaFh5NzVWVmRSNnA2L0puMmtZeWROVTA5ZEZ0czBqd3o0dWVKcEZlNTAyM0FTeWlDb2dYcS93RGViODYrTXBMRzgwM1ViYVpKSlltajJTYkdIREszZjJ5SzkzWFE5UjFZMjl5VmMvYVppZ1FuY3piT21QYjNwZkhlbXlIVXJmeklDSlRFRUp4amhCaXZNK3N1ZFdUZXpmOEFTUHJLV0hoU293cHBxNlh6YjduMVhKNG0wcy9EeXdodHp2aUs3WlRrTU9UemtqamttdU44TGE3ZTJyWFZyREFsekZkU0JJd3JjS1J3U1RYenRaZUk0VThMdGJtRVJXcGtXMWoycmdCMStabU5mVVhocVcyc3RKanVWalUrVHRPOGNFSUJXdGFiVHB2cnN2UTgyTkpSVlRSTlg1dCtyUFdmRjJwV05ycDl4dlVSSWxtWTBZdDFmYmpZSy9OWHdUQmZYbmlLVlZ0NUdTSldKS0tYSVp1QndLL1EzNGtXN1RlRFVtV0FTeG9qWGN6NUdJeGo1UWZldVYrRnlEUy9BcjNkbkVrZDVkckpONXpybk9QdXJqK1ZkdG01enZzMHRmeE9LalU1TVBlUHhjMXJYK1I2RjRRMHU1MFN5KzAzNmkxZVdNcDluSkRNYzlNNHJyQzd2WlJxanNxRTVaRDYrOWVPZURkZm4xR1ltY3ZQY0ZpUzhnT1dQY2c5T093cjBLSnJ1NDFXUzIrVkk0OHl5eTRPRmlINmJpZWxkZEdVZlpxUFJ0MlBNeEVKZTFsT1RWOUcyZFJGNXNzckt2bGtSSXp1SEpWUU1Zem50WDV6NnY0djhVYUxjNnRKRFpHU0M2bWpoaHVZTGRybVMyQ3R5eFZlcW12b2xOZWp1ZkVkM0ZlM0Rpd2xZTEVFYmFzdU9nbC93cnd2Uk5ROFhXR29YRnJHOE1XazNONU15aGdmT0dHSk8zdUI2VmxPc25KV3M3RlU2RTBwYXRYc2V4ZUROYzFMVW9KcDdqYklZMk1iT2dLeEUrcXEyR0h1RDBwZkUxb2JxMW5UeWh0RUVwS2tlM3ZVWGhQV2JPTFczYWVNc3NnT1d6eGc5aVBmMXJXc2RPMVM4aDF5WmtJd0pFU005VlJoMnhuT0s1NHE4NHVPN2UzYXg2RXBXcFRVdGxGZTgrdHo4ZHJ5Qm4xcjdPUVdRL2ViT09lbVByWG5PdFcxbmIzTWl4N2dGT1B4cjAvWGRNdklkZWtpdzM3cVQ1V0FPTWo2OTY0N1VQRGVvbFRjeW8ySkhPZU8vdlg2VFVkbzY2SDQyMmxPVm10endtNm1sODlsVjI0NlZHc3JoWEw3V1BRZDhlNXJwOVIwMmExbllzZ0lQUWYxclcwMkhRMGphV2R5Ry91cU0xeHV0QlFUV3ZvWEdMdWNwR3dhSGF3d2M4bkZaOFVCVzVKa1U0VWZMNzE3ZytsUXZESTlxc0VTdU53TXAzdi9BTUJVY1Y4NitJcnk0dHI2SlRkUElTdnpncUZIWGdERlRTcSswazB1dzNKSm5WVzRpL3RLTlo4Yk1qa2RSWHE5M2EyazBFbHhCRUZqUVlCSTVQNFY0TWs4c3dqZmNBTURvSzlDdGRhdURZTkRJVHRBeUFvd1B6ck92U3FTNVhGN2JvdFNQTFBFNGsvZHMyVGh2d3IyYndmZVhUYWFrQ3drcnRQejlxOGMxNVdhMTNIR2R3TmVsZUQ5WlJkRGFFcVE4UWJCQTY5eFhWT0w5Z3RMMlpuQnZtUFpySXhzeEVqNWtPUmcxd2R5cVI2aTZ5bk8zT0I3ZGF1V2NrazZRM0FrQUp5Q0ZQNVZuNi9IQ3Q5Qk9KQUd4ODZrOVI2MDZVYkkxYjFKSnIyMlcyYWJad0NCd09oelhaMjE5SVJnN3RrZ0JCR0IxcnpDNzFDQjRGdDF4KzhkVDB5UjcxNkRiUjcwaVhjRkNwaklYUDhBazFvbzJhTTcySnRWdHRIWFQ3cVJwUzh5Yk5wSjVKcndqV1laWjdxTC9hUTQ5d0s5N3Z0SGdHaVhyTEdXZmJ1RWo4SDVmU3ZuSzd2cFpCQVNjN0Z4bXU2bTF5dlVpV3JSVWxsWVFlWGc4RHBYSVNmZFhQclhTZVl2a3V4NjlCWE56L2Q1SXBTSHFXUEMxeEZiK0pkT2xrbFNKRW5CWjMrNm85VFhiK1BmRlIxYTlNVUxrMjhSNjluWWQrUDByekJiUlhreURrSHQvU3EwOFhsNEZZT0VIVVV1cVZrV3BWSTAzRytqZXBGYTJ0eGQzTVVFS0Y1SldDb282a211czF6UUwvUk5STm5kRlM0Uld5cHlwRGVoOXEyL0JPdjZKb3Q1TGMzZHBQTkxqYkVZeXVFQjZubnZYY2VPL0ZlZ2VKYmF5TmpZM1VWeGJaVW1UYVEwWjl4M3pYUE9kYjI4VnlmdTdhdnpOS2NLZnNuTG45N292SThHbExyd09udFRFdUpRUHZaRlBjeUxHQ1FNRSt2cDdWWFNPU1I4SWhKOUJYWWtySE0yNzZNc2VleFFqMnJPQXllbFdENWdPU3AvS3QvUXJKcnEvakczSVVna1VwU2pDRXBQWks1dFJwVHIxNmRPT3NwU1NYelBvM3dGWWZaTEFzNHh1K1luMzlLdy9IdXM3NDlpdDF3SzZtWFVSWjI1aUFYQUhCOXNWODA2N2ZmYUx3ODhMMHhYeDJDcE92ajVWWmQ3bjc5bm1McDVYdzlUd2xLWHZPUEo1NjdtYmFTeHBKdGRCaGpqY08yYTlBL3NzZ1pDY2ZTdk1QUEdNQmZ6cTdIcWVvSXlrWEVnMjlPYSt3cTB1WnJsbDZuOC93QktxbDhTOURRdnJjeHNRUmdqcldiYncrWWVsWGY3UjgzaWI1aDZqclhVYWVsbUJsU0RrZCsxWk5UakZxMnBvcFFjNzlEbVpMWmw5Y1ZtcE5MQk1ybzdLdzV5cHdhOU1ramdjRVpIUFQyRmNtZEpsZG1JYVBIdWFWUG1kN291YlYxWjJQV2ZESHhoOFNhU2ZMdUQ5c2diN3l5SEp4N0d2b0hUZmpKb04xSWl6VzVpQjY1UEl6WHhFK2tTamdNaC9HcXJhWTRQMzEvT2oyVUwzU2NmUTdZNWhpVXJPcHpycHpINndXSGlMUU5TdHdFdXh1d0RFR0dDUU8yYTZ0ZzhNY01xcklZeGtCemdwbjBIcUsvSCtDYlViUUF3M1JCOUFUWG9XbC9FUHhEWXFVTXpNaDZqY2VmenFsRjlHZDBNeGpkYzBUOU5HdW9XWmNZQjV5Q00xME1MVzhrTWtpdVE0eCs3QXlNVjhNNmY4WjRYaFNLY0VEK01NTTdpT0FRUjByMG5TL2lScFRvVlNXTUZnUXhKSjRxWHpKN0hiSEdVcFBwdjBaOUxTeU5MR1VWZUNja0tNRVkrbGE5amNMWlFrQzRjeWJnQ3Z0N0d2bit5OGNhZTBqTDU3cXY5OWVRSzBrOFZXcDQzczJUOHZwelVwdStxTytHTHBjeWJrajZXWHhKY0tBQSsxbFBJeDY5NjdCUEdWMWNXaHdtMFJ4bmV5Z25jT25QWVY4NnBxQ1hkdkp0bWwrMHh4bHBGT0NubHIzM0QwckFHcjZna2M2MnQzRXF5cGg0dyszSTdyaHVEU25PeTMzTXExV25VdFpMMVBrRHhpanJxZW9LVWQwbG5kNDJQSjVQUSs0cjdNL1oyc1l0R3M3M1VidC9MODlQTGpVbmtEdWNWOHJlT1pFaUZ2c1pTN2N0dHljZTNOZTdlRWRYa0dtMjF0SktWaWRkeDJLR2JJSFQ2WnJqcDFaS3RidHFja3FjSEJYZTU5dTNYakZ0b0hsWldQN3BBMjd1ZXB6MXhYQ1gzakc2M3NWazVLOGUxZVczdW9Xb3Q3Smxta1p5cFVoanR3ZXVUMXpYTERWWWpLMGJTaEQzQlBIUHZYdVBGMWJhU0xWSERKTDNGOHoxci9oSjc5MU81M0libktyazFVdmRaMUFyRzhWMFFHWTVVTmxnUi9lSFRtdlAxMXNSZ2xmS0czQUxyalA0L1dzaTQxdTUweVdHU1NQeS9QaUU4ZlFsa0p4dTU3Vms2OG45cG0zdEtNVmE4VmM3dnkzZWRaYmlVT0E2aGlEay9NZjBxenEweGtNU203MytVV1JFUFVEcjFQWTE4L1hYeEYwV0NHYk0rUXpqZEc1d3B4ejgyT2E4enZ2aXhwaXJLa0t0SVNlTnA0UDR0UTV5YXNZeXhGS0wxWjlaUlBiU01WUDd2Zno4eEk1OWhXTnFtdGFWcDBUeG5MdXB3R0h5RGI2NDc1cjRWdi9pcjRnbUVma0RZeWNLNGJrRHBpdkl0UjFueExxSkhuWFRzQjIzWUFySzBtOTBjTThmRlg1VTJmYitzL0ZheHNVVFpQaklJS28yVGl2bWpYL2lycm1vVE45bWQ0MUl4bk9EK2xlS0RUYmxzbHlNKzdacXdOTHVGWElLKzN6VXVXSzh6ejZtTXhFOUZvaUs1bXZMeVF5VHl0SXhPY3NjMW1YRVRSbFd4eFhZdzZmT1ZJQ3JrRCs4T2FzdHBqdkdReUE1d01aSEZKUzFPTzAzcnJmdWRab0hpYlRaOUduMG02Z0c2Y2JWbVpzSWg3RTFuV0F1OUx1N2l3bnh2aGJqREFxVlBJSVBmTmVkU2FIcUNTTUZqM0FIcUNLdVEyR3FMSWorV3hJRzNsczhVU2hCcHE2c3owYU9OcnhxUmswK2FPbDExUjExemJ4WFJtd2dVdWM0cGRFdW5nM3hFbjVTZUtkcFVOeEhjQXpMdEJISlBQRlZOWDh1MzFEeklTZHJqbi9lRmN0V0hORnhPL0FZdVZIRXVwdGM5R2oxWXBjMmpQSEZMNU1xa0xJb2NiU2NFWU5lb2ZFZlJyWHh2cFQ2MW9zSU9vNktndHRWc0l3VEo5blQvQUZkMUd2VXB6aDhkSytXNHJvK1lDVGtFMTkxNkY0NCtGa05wcDk1ZWFaTFo2NWF4QUpxTmp2Qmt3TUR6Rkp3VDJKNkdyVktwR0VIRjJjZCt6OHJITmpjVTY5V3JKeDV1YTNxZm1obXZ1YjRUZkFEV2ZFSnM5VHYyRnZaaDFrRVpVbDVWSEkrZ05lVVdHaXA0aCtJVnJOTmVSWFAyelVROHFKRVk4cVRrL0tCZ2ZTdjJ4MHpVRnNiRHlsamRJZHhDaEFBQW80d1RVWW5FZXpsQ043TjZ2cWVUVHBUZk1rdGVqT2hoOE93SnA2TEhjNU1KRzJJQUFLUjIvS3ZYZEcwK0dDTlc0TWtuSTNIR0I2QVZ6V21QSERBbHhaeE15U2RRNXp5Ui9DVFcxYVM2b1o5eitXc2VjYlhHVCtkZVZVeFNTdGM3S1dFOHRqbzd5RzRZMjY4cks3RUlEem4zTlptbjM2V3N0d2piNVczNE9CMFlkY1ZMcUZ4Y2k3am5SMXpHTWpqNVFCNlZWc0JBMDg5eEljb3k3dWVEdjlSWEJVeGtuSzBYWTlpT0dpcWQzcnBzYjBWL0JCY1JMS3JMTE0yMUVKNUE2NU5OdnJ1RVc4OGwyV2RDU0Z3TnpLdzZBQVZ4TnZNSjdyekpZM21rREhiMkkvQ3U0U3plNzh0UEtNWVE1S0FjNVBRMWpUeGRWdTF3bmhhZTdYcXprZE1ubWRBU2pSbzY1SmM0Slh0eDYrMWRJdHJiVHhidHJaT1I4cCtUNmtWMUVHbVF6LzZPVmJLZ2t1dnluOWE1aWF4dU5QVkRFcG1BWUNXUG9TdmZIdlhST3BaSnQ5Z1ZPTHVqV3M5S2cxU09WWno1Y2tSQ3h1Qng5SzhLOFErQ05KMWg1SUxpejhpU0tUYkhleHBoZzY5QXc3ZzE5SHdhdlpRV2tza0RxZ3lRcTR3UVBRNTcxNTdyL2pyUzdmVFhRdjhBNlE3OEtTTTg5eml2V3crS2lrb1NhYVo1TmJDeWZNNHgxUHozOFUrRWRVMEM2ayszSXJ3VEg5MU9nKzh3NlpJNmZTdUFzTFpmbjM3MmRtempkaklyOUc1TG5SdFcwU2V4MUYxa1dWU1ZiSStVc09vejBJcjg5TlJ2YkhTcnk0czVidFFZM0txKzM1bUhib0s3NXhnOVlPNk9LbDdSNlNqN3kzdDFNeTRGM3RkRXR0cXIvRWVmMXEzcCtoeFhVcnpUVHZHMFlVcWlqSWZIWG50VGJmeExvaWVhbjJ4U3VNWks1L0hGZHpvTjdZM3NER01DUm84bHBCOHE3ZlRudlhNMjB0VXkrVzBrY3RMWVR6T1VqSDNtQXhuYm5QdWVsVUw5TlEwK1V3K1U1YU1qTUdjcm5wdTQ5cTZ2VkV1Wm96OW1USXdkdzZuSHRXSEJwMXhKRk5KTkxKYlNJaElaamxTUFE5NjBpMEp1ektseEUvMmJ6U1IwemxlRFdqRGF4eTJzZnpiZ1VPNVQwcWdrbm1RU0pJRndwQ2xsSDZqUGF1aVdLZG9VU0tiYW1Ca3FnZmRWU2pwY2krclp6L2gvUjlSdVo1UDNpRGE1V05UZ0RiL3RIc2ZTdTAreVJSWFRLanR0allxd0ozRnZYQjlLNmZTZE9lM1VoMkF5UHZZQXAzOWw1eVRjNXc0d1F1T08rZjhBR3NPZThpa2tRdEY5cXNsa01ES0I4cXNTQU9QcjNxaGJRWWFSQjVBMnNEZ2ZleWU1cnZyNnppanRZb3Q2T2h3ZVYzRDIvR3JVRnRIc0xiT2ZWY0tDZjYwNVIyTGFUYXNlUlh1bHJKS1dVN0NYK1lqK2xlYytLNFVlNzA1QmdzRWJxTTVBTmU2enc0bGZESVFUd3Vja0d1QjF6VEZtMVhTOE1OeGpjL1VnOUthYlRzeUhibFp5RnRwZm1RcUNxcmwrTURQNjF6dC9vNlJ6eVBuSlk5UWZ3TmUyTllrRURJR1B3ckR2ZEt2R2laU1ZmY09DUnd2b1I2R3BUbFlpVnVYYlU0STJpeTZQRU5wd0NSd2M5UFhQUVZGcGVqcGJ5ZVo1Zm1MSWgrUnVPdnFQNVYwMXpwanhSUm9DY29NYzk4OWZyaXJPbFEzRXl5SThqTXlrRGZ0NmV3OWFMdElpeTBSenh0V0ZzZGdCTE1UdVBZK24wcTVwY1dvUnd1MlRsMnllZzZWMkVtbnhSb3UxMURxVGxpT2hQZkhyWFdhZHBDendaY2s0UFVEcjcxbzcyTGNXZlE4T25aWlN5SzVHN2dqZ250elRiT0dlSU1rbHVGTEU1MmowOXhVYVRIeVVZU1lESm5yVHJDN1Jjczl5ZU1zV0REQUE2NXowRmVNbTN1ZTA0Nm9xNnA1VVlaVmc4eFRobWlWVGxmY1k2WjlLODh1NFdrWGViV1I0bWZpRWpBWEh2WHFPcFhNZmxJWThzSHhpVkQxSFlqMUZjbmUzOXUwT3lPNThsK01oamtISGM1cE54dnAwRTlFOURwZEtpUVdJUVJEQkEycHZ5Vit1ZXRkT0k3Q0NlU01Xbm1Md2NsY25rZGlPb3JuZEtOcUpaRkVtNlR5UTdEQlhjRDFLK29GZHQ1YklWbHR3WkNZd1dIVlFQWDJyZFhsQmFGSm9JckhUZ2tUZVZJRHlWeHdjKzlhbDR0Z2JXUXU4Z0lJNFBRR3ZIZFg4YmFOWXU2VGF2WXhTd241b21sQVpXUFFISFN2T2JiNG82UGRhaThNbC9iSUhZYlgzZ3F4UFVFbXBVS2w5S2NuNTJNSFVoZTNPcitwNkRxUWlFaGRVRFl6ZzQ1clV0MnVKYmRDZ1ZVazRZc2VnSHBpcVRYdzNGbGhEQmdjSElZTVBVVnQyclJpMDJvaEM0eWM5aWZTdW15NVFqZE02dTB1TFM1bVJWaElhSWJjZGpXM0pCSEpNOFVlRmx6OHlZT0Y5RDlLNDdUNUcrMEZuajh4VytWK2NjRDNycFRlcUpRRVoxQUlWU3pidnlyRnVMZXAwSnNlOExvNkZpWWdoNy94SDJOYlFrMC83UXY3NTFsMmh1VnlXK2g5SzUyNVpVQldPV1M1TDRiWkl3VlFmYk5hUmRvNTdkOTRYQUJjSG5BL3VnaWxweXNlN1JibEZwNU1yUnlCR0RZdzNUSnFTTFQ0bmdiTXFnbFNRQTNKUHJ6VHMrWVE2RlZqZm5KRzVTZnhxYTVWZkxXTXFoQUlPUm5tczBsc081NXhjV2x1czZ5dnR5ZUd5T1dBOWE3clM1WmR4bWlkaGhlVkJ4d2ZRSHFLNDJWV2Q1WStXOWovalhRdzNRc3JHRUpieTNMRmdyZVdRQ0FlL1BwVFNqSFVsMlBSWVpablErYXFiMys1a2NrQ29MaU9IeTJFNGRCNmdBNS9yVmkwUVNaSG1FamtqZnhqOGFyd3hHOHZOamdiVVhBeWVXUHFEN1ZzazNheG0ydFR6dTZ0N2RHa1dNSytEbk9PZWZmMXF0QkhFYlVDVnlDRzRIVEZkTkxhVzl2UE9yTXh5d1VTTndQb2F6SlVuVVB2S1lQUWpubW5KYkZwNkFJSUdVQUhJejZmclZvSmFJQ0FDSHp0QXhuT09meXF2Y1JtT0ZHUzRCeUJrTU1FSDJ4NlZXSmFaRkQ1M3EzWG9lUHBTaUpxOWpUK3pDSlZrakc3SERyMUhOZEdxbnlKRytVQXB0VlNPR0o5YTVLSU5INWorY3d5M1RPUVAvcjEwOXNWWmwzZ0hucDJ6NjRxbWh0M0xLdTZHUEpDS3VCdFFjWjlxNkNBcVVuQlhjVzZrRG42MWczVVlSWkdSOE5nbko1QU5YYlVzc2I0bElPVk84RC9IdFNWa3lUVHQ0WlYyNURqYjA2WWI2MXBCRmtZQkk5anQxT001QTdHbGQ4UmhqSm5jZWNqK3RQTzlsUmdxdGs0R1c1SDVVbm9Qb1NJN05jTWkrWCs1YjV1UG1CeDI5cXNtYUlTN0hPUWM5aWNZNjVyRGltV1M1S0NYNWw0S2hzbjYrOVgzRWJURnZOWU12VUQrZFFwTjI5U2JFY3NNQ1JzNHlWWmVLOHUxRWx5UkdVVitNQmgxSDRkSzloa0VZUU1VSkFIVVY1VmZPaERCOTdaWTdXQUFJOXVLMXNtYVFiUjRuNHB1SjAwZThtdUxjd3VJaXZsWkRnRThBZzE4MS9Falduc2ZBK2wydzIvdnl1N1BYNVJuaXZvM3gvTjVXbHZFSFdUelNpSzJTU01ucFg1MGZHdldpOS9ZMmlIQ1c4TEhHYzhuaXZzTW1qeVlTclArYVRSK2VaOUwybU5wVTkwa3IvbWEvZ2k0dVJad0o5bXpCTHZacENRUG1KNEFCNm12cXp3bkhMTTBodC9sZE9CNW9LalB2aitsZUE2UGFrYU5wc2JORDhzVVpWaWM3V0hhdnFqd1dqeVhDbllBcEFHM08wdDZrR3ZtTVMrYm5kdXA5cGhvdUtoRyt5UG9BUVFpMmozUlpiZzdseUNUM3hYVTZUY3krWTZFN2xaUVkyR003dlNzaXdzYmFKWkVONU5uZVNCSWZOSTNlaFA4UHRWelRMYVMxdUxnUE1KUkt3WlRqb2ZWY2Z5cmhqZHJVOUZ2WTdZbks0R2R3ems5TVY1Y0pwSk5XaGVPVm1oTzVXMjhBbjN6M3pYZlBOQ1laVVdRbDl1ZWhHNFZ3MW5hb05VQlppdUljdGpuQnp3UHJTVVZxSnZVNFB4cDlvaDhPYXRJcGRDTE9ZN3M5UGxPYzRyOEtmaU40bXVaZEswclN5ZzJ3eEkyOEhydTVyOTdmaVhacEI0YTE1dlBZazJNckZWT1J3dkgvd0JjVitFM3hNMG15dHRNMGk1MkJaYmlHSVozWnlvNzQ3VnZoSlI5bzAxMVZqbnhDazZicytpKzQrcS9nT2lwYjRhVjJmS25iajd5bnFmd3I5RC9BQ0YreE9rYThrNUlQSEhjZERYNTkvQlZHVkVBa1ZNRlNTNXdCeHhYMzE1NWJUcFJmNEl5UnVVYmd3ei9BQStvckd2eXV0STFvL3dZbVo1bW5Sa1NmWjdnR0hJOHhrSlU1OU1aNHI4aC9qdmZ4WFh4UDFEekpNZVhCRXFNeDZnRFBGZnJSRkxIY01aSTJTQ003Z3FPcGpiSDk3YU9NZTFmbEY4ZmJJMlB4RERQUEhNWmJLTjJLREFYSEF6bnZYbzVZNExFMlNYd3M4bk0yM2g0cisvK2g4YzM3bzAwZmxFUElYR01ldWVLL29XOEdhM0czaDdUVmJ5MWtOdkVaVTQzQnRvQnpqdlg0RGVIN1k2bjR2MHlGSTl3YTZqSkFHZmxVNVBBOWhYN3cyR3YrR2JyUXBHczlPY0dFZ0xjSkE4YWxodzIvSXIwc2JLTFpoZ1U0MG41dEd1bC9ETGZYWWoxS1M0Q0ZUSW1WekNNNHdNQWNIM3EvYzNvVncxdE1GQitVTWZYdURYazEzcmtBdEg4elRSSXJrQnJtTmdrZ1BiSkhKV3JmaHdhcEpaZzNOeXR6SExjTTBMREdZMEhyNzE0M0xaMzZIcTh6ZWg3N0ZxdHdzSWFTMUp5TUJ3QXdQc1BXdWpzYjJkN1praVVSNy80aW1PZlRIclhKWE1pQXh0Qk9GeGdLVnhrWjc4OEgzck9udE5XZ2VLNmhrZTUyWjgzeTFVczJlNjV4ajhLNW1yeWJOMW9sYzYwVGVUY1NBT1M0VUE3a3doejJ5YTVSWWRLdS9GT2pSWERxU2tyR1J3U3lCVkdjZ2RqWEdUYXJmTzB2MnVhOWdqZmxVZU1LUUI2TU8zczFhdncvd0JJZlZ0VDFlWkhWTGUwUWJKSjJFZTFtN0RIV3VPdEtVYWM3UnU3T3lPL0RLTXE5Tk4yVjFkbjJ2cDNpenc3cHl5UnkzTFNxVk9ka1pJT1QxNXI1cjhVNmpiMyt0VzBzU2hyWDV6R3hYYXlzZXBOZXVhUDhPNTlUdDB1WnIveWtjSENxbTQ0NmRTYTgxOFYrR1pkTW1sMlRQSkJFUXBZWVIySTV3TzNOZksxNVkxVUljOUtNS2FmdTkvelB1TU1zdStzVkZUclNsVXQ3eWUybnlSdzhOeXVqNjVhMzhjUU8rTm9qR3ppT0tOejBjRTlLNDN4WmZ4bXhSYmxsa3VETjVZYU50NE83bk80Y1lydDViUmZFT2dHTjRnZ2VJdkdwUHpMSW4zUXg5ZXhyZjBpWFViclFiSU5iV290bG1FRXVGMmxOdlJqdXpYTFp0UlhucWp2ak5LN1c2MHVmTHZ4ZHViRFI3SHd6cGNXMGVUWWViTGc5WkplYzQ5YTlsOEJRaHZBRnRleVRYRHZxTFIya0NLTjUzTWVXQTc0SFgycjR4K000bnZ2aUZxd2lmTVVRU05UemhWUVl4WDJuOEQ0bnNmQmxsZnozVFRSV2F5dERHVDhzYkhoanozOUs5MnVxU3B3Y251MHZ3UE5UbjdPVnQxZCt1cDdQNGo4TDNkMkwvUWJmV1puaUtSUnV6cmhkK01rNFgrVmJHa3JiYVhQYjZaSmVxYld6Z1ZHa3h0eTZqbjZDdTlzcERMcGk2blBFWTVaWXhzUWNESjZNYStmdFEzTmUzN1M1S2lJeUFEc0NjZk43bnRVU2RPSEx5OVh0MlJ6VVZPbzVSazlJcXpmZG5tNDhaMm1qZUpydTRzNDNlMGlrY0NLTnVIejA1UGJOZFQ4TVBFVncxbDRrdUxtNnVYKzJTbU5VbGJ6Q3VlU0Z4MEhQU3ZDL0U3VzhFYk5ISHRYK0lEcno2R3ZwbjRSYVBaeCtEbDFHZEJocDNZTTM4STZVUlVuSDNYWjM2OUYxT2lxb3hUNTFkSkphZFgwUGM0dENsMVh3MFUreHdRVzdCdVhYZElkbzRJQTZWOGoyR2p6UjYweHVwbmxaYmR3akVISEp4d2Y2VjdMTjhVdFZFYzl0cFZ0YXRaSXpvWkpBUzZrY0hqSTYxNTNvVjZkUnVubTI3NGxrMnM0NkZ1dUI3VmpXY0hLbHlOdDJ0Sm1WQ25WakdxNmlzbTd4UjBkaGJhWG9HbFhONVBFMHJUWEFBMnhsM0k2QUJSay9sWHJ2dzV1Ym5XTFdmVVlqY1dRTWpvcXpRQlRKdDR5RkpPQit0UlErSDlRMVcrc3JpTnZKdDlPM1N1VDBrY3JnSmp1UFduWGZoUXBPN1IrSU5lc280a01yUlF6cVl3eDVPME1wd0NlMWV2aGFLVTFLWFJhTThYRzRqbXBTaEhkNzliSS9GLzRrYXRxRnA0dzFIZGVpSnZ0TWd5MFlJQkpQVVY0cHFQalR4REpidEdIZ1pjNGJFZUs5SitJeFM5OFEzanZ2a0xTa21SL3ZrNS9peDNOZUdYOW8wVHFjRERkRDNQdFgyOVJKeDZOV1B6V1VGejdiTTR6eEUvaUsrUkhra1NPTkVBQWpHMG42KzljVll3T1UvZlRPM1BBelhmVHgzTElVNUF6emsxenB0U3BPMXVuYzF5UmdsSGxTU1hTeU5OTnoxbExpU0hTNDJRYm0yWVVZOUs4VDEremt1VU03TDg0VW5qbXZVZEl2ekhDMGNwVmhqb1RWYlZMV0dSSFpYQVhHU3A1QjlQenJuaEgyYzcrZTQ5MGVWYVRJSkxOUVd4Z2tWMGNNcmJ0Z1liU3B3SzVMUm8xTXR5cE9GRDlQU3VxZEl6d0JnanBYb08xMkpQUXc5VlF5eHlMMFpSMHpXMTRKK2I3U041R0V6anNhcnpXc2tvM0U1Sk9DUjNOUmFVdDVwTjI3RVlSc2xXUFFqMHB6czRPTjlRaHVmUXVpdmJ5UTJ1MlBJRGJXSTdtdG5YdEFqbnVSNVRuYUZCSHBuMnJ6WFNQRVFFY1VNVnE3TnV6OG5jMTZGYTZ2TE5LWXo4ckQvV2J1b0ZZeFRUTGs0bmx1cTJBc3JtQldSaDh4SUk5SzlJMDJCemJ3eVB2d29KQ24yOXhYbjJ2WHB1ZFJSaTN5THdPM1N2U2ZEeXgzRnE0Q0dYQUdBR3dSNzVyUnZWR2RyN0hSeGFoRGN4YWluRzFZR0FWeGdna2R1YStPSjg3VzlRU1B5cjY2T2dJV3ZMMmFSd3dBVlVKL1E0Nml2bGZVYmNKZVRvRklHNXNDdXFuYlVMV1NPWkREeVh6MTdWelUwN0ZzR3R1VmhHbUNhNVoyM01UV2pJY21lamFGYk8xak5jc0JoRHRYNm11WTFUaHlQZXZvQ2ZUNHJMdzNISEdBY3hJeCtyREpOZk45OUw1azV4MEhGY2tIek52ek9xcXVTS1hXeG5qT01kczFKdE9EaHZ3OWEydE8wdSt2Wk5zS0hiM1k5QlhxVVBnd3BHaEw3c25rNXJkczViYUhsTnZJNHRwSWhDaDNrRXVWK2Jqc0QycS9FalIyOGlmWkFYT0NzbVNDZ0hYam9jKzllMVNhREZaMnBsZkNxcWdsaVJ5ZnBYaXVxNnEwMGpMRjhxSDA3MU5rOWlrMXltTk5jTUc5d01WME9oM1F0WFp5TTdxOXU4SC9BN3hkcnR2YlhSdENzTTY3NHZuVmR5K3BKNkN2cE94K0EraGxRTGlSWW1BK1pVWXVCOUQzcnpNVmljTXFiaTVwOTB0ZnlQWHdDclU4UkNvb084ZFY2bndscVdzeVNLY05qamdWNXd4TE1TZXByOUc5YitCdmh1MUt1azB6eHNQbE9jQ3VMWDRWYUF2QlI4ZXA1cXNIS2g3TzlQWm0yYVlqRllpc25VdnB0cWZESVZqMk5YbzdXNURxVEE1QUlPTUhrVjl4cDhLdkRpc3JORTdEMDNFQTExV3UrQlBDVnA0YUJnZ2tpdVpDVVYvTkp3dVB2QWRxOUJ6czFvencxRHVmQ0xhWHZjdnNrd3h5QUY0SHRtcmtOdkxGSUFrVFpYc2VlUGVzelZMUFVkT3ZaYldXNEpLbnFya3FjOUNLeGMzQmJQbU1mZkpxcjM2aXV1eDNXMjVmL2xtZVRTQkpRMk5uMTVyaHlMb0RHOXZ6Tk44dTYvMnZ6b1hxaXVkZG1kOTV6TGo5Mk9SMExkNmVMbVp3UUlJajlXcno0Vzl3Y24rWnFNd3pEc2FWbDNGekxzZG00bVpqOGtJeDJCcW85dk1UZ21MbkF6a2RhNVR5NUQyTkhsUzQrNmFWdk5ENS83cHJ5V3poaXBkT0QxenhTQzNrSFNWUWY4QWV4V1I1VW5wUVluSGFuYis4TG0xdnlzNlNHNjFHSGxMc3IrTmI4WGlUWFlseDlwVWdldmY2VjV6dFlkalNZTkhMNWxxcTF0Zjd6MkcxOGQ2NWJsZ3JnRXFWSlZqeXA2ajZHclk4ZTNIQWtpSkFJNkgwcnhNYnFPYVhJalJZbW90ajIrNDhaMk55Vk1zTTN5K2hCL25XbEI4UkJCQ0VqamtBSFRubXZuN0pwMjVxdytxMHVibTF2Nm1yeDFkeFMwKzQ5NnV2aVZQTklqaTEyN1ZDNDNIQngzK3RZVno4UWRUa1B5UmhBRG5xVHo2bXZKUkt3cFJNNDlLM1ZPSzZHRHhGVi9hL0E5RG44YWVJSmwyL2FpcStnRllGeHJXc1hSWHpyMlo4REEzTVRnZWc5cXdoZE9Pd3B3dkpBZWdxck1qMjAzdTJLZDdjbDJQMXpVaXFRT25XajdmSjZDbkMvZlBLaW5aa3FTdVdvZ3BiQllxTWRhdWp5OEQ1eldWOXY4QTltayszY1lLVm55c3YyaU41V2pCKytlYXViN2RRUDNwT2Vvcm1SZm9QK1dkT2JVSXp6NVFIMHBPRHZ1VjdWZGpyVmx0eXdIbkVlOUgyaUJYWUdSeVBVZERYSnJjZzVQbGs4WjZWTUxnc3U0UnNRT1NkcHhVOHZtV3F6N0hiVzk3cHpTS3NseElnN21wNTd2VDBrMngzTE9QWElGZVp5U1FQbnJXZTZwL0MyYUZUMXZkaTl1N1c1VWV4dzNGaEkrRGNFSEg4VEFEODZ6OVhrc3pFb0VnTGdaR0NEL0t2SmFrVVZYcy9NdU9KZjhBTCtKMHNjaDY5cTlCc25zSnJYZGNYYlFsZUZBVGNQeHJ5Y1NFQ2xOek84TFJBa2hpQ1FPK0swanNST3BhVno3cCtDT2lXbDM0NnQ1b3JocEZ0NDNibGNZWmhnYyt2TmZxbnBtbHlRR2UydVk4cE00Q2h3UTVZZCtPQUsvSm40QVhOM2JYMTRCTHd2bGtBZGdUem12MmgwTFZIMUd6YUM5dUhrSlhDdW1NeGcvM3UrYStVekhTdks3dFpKSTlYQ2UvVGxKZEhxYTJuTEpGQjVBSWFKZnU1NmoycnFKZnMwVm41c2dETU9GK2JKSXJpcDdPZlIxM0djejJwWUh6YzdzZXhBNzFwVDM4Y1ZqNXJuTzVDeWdZSy9Tdm42a3BKcEh0d2ltazB5OWNhM2IyMXNIZmNWUFpCdWJJOUs1YUh4RWsxaVZVQXN6N3VmNVY1Tk5xZDVLRWtNTExFejh1T0IrVlgvTnQ1cmlTSlJ2UEEzRmVCeDF5SzQ2azJwYUdqY1ZhM1Zuc3VqNnJBZFRTMmx1RmpsSjNLTWNrZWhKcnV4cWtvdVZLcXpQR1NSczdnOFpyNXVXeDFobVdXMmRMdlp5ZHlZMm4vZTlhOTMwR1dTYUJwUE1mN1FxbkJTUEFHT3hOYlVwdEphaWJUNmREdXB0V21ndDVKNDRDV0M1WUgrVmVXejNxM3Nrc2s5eXlJQVRzQUlWZmJOWk9yYS9MY2t4eVFwdEhMQXNRM0hldm4veEJyWGlhZEhTTjVuZ0p5UkdBT1IwQnJkMUpTOTFzcjNZUnZiVm5RNng0cnVZMSt4c1NJd3d6THlDUjJBcngvd0FTNnU5dGNSSHlUaHdXVnQyNE4vaFZPRFM5aUpjWGw5RXBWcy9QTHVKUGNjbmlzSHhMNGkwMFdzeWVXak14RzVsSEFDOUNwOWE2cWNJKzNwMlY5ZFRobFVkcGEyMEd4YTdjb1JJNUpjL3dPY0Q4RDZWMTJqL0NiVWZIY3I2aW1yMmRuRkh0am04d01XejErVlY3ZSthK1U3V2MzZDAwejIyNklOKzczc1NmeXFqNGw4YitNWUpZVThQYWs5b29RaWZaOTFtSFRHZXVLK3Z3bnNvMWJUVGNMYXBIeitKbFg1WDdLYWpMdTFmUSsvTFA5bEh3akhkeFNYSGlpYVhyNWdSQWdPZXc1SnIyM1QvZ2I0RTB5eWFHMjFpZEltYkxLQ3VjajFQV3Z4WXN2R1B4cHY3aFlJL0Vjd2RqeXd4aFIzSlBZVjZQZitPUEVHbTZYTGFXMnAzT3JYeFg5L2ZUdCs1UTl4RWc2NDlUWDBmdDh0dFowWDh6eTZXQXh0V1RsVXhjb3J1djBTc2ZaL3hLMFRTUEJtdCtGcDROV054cG1vYWlsbmVSdXErWkg1bjNYamNkZ2VvTmZSMm9mQ253a3pRdkY0Zyt6eFp3NGx3UWZUSHZYODZ1ditLL0dWMEZTK3ZIbFJKbGRjOW5Ya0VWOUFuNGszR3N3UlJheExxV21PbTFsdXJOekpGdUE0WjRtL21EUXErWHBYK3JMeXRaZzh1clZLa2xUeDhsYUMrTmN0M2Q3V2J0OHo5dzdQNFRmRHNsemNhdTkyUmpCUmxVRDhCWFEyM3d4K0dWdmpaYzNDK3dtQUIvQ3Z3NHM3WHhQTWpUV1hqVzZudDVHM2ViRE1lVC90cjFVL1dwcm13OFl4eVJJM2l5L2N5NU8xWkNUeDcxazhkbHZYRHY3a1p5eTNIcVh2VjVXOWYrQ2Z1dzNnTDRjc29EWE56L0FOLzZiQjRJK0g4VTJXdVdrVWZkRy9EQS9XdndvZzBMeHROTDgzaU8rS2psU0oyeCtOYW4vQ08rSml3WStJTlRPZU54blpSeDZlMVpmMmhsMGRzTCtDL3lKV0F4Vi84QWVaTDV2L00vYlNUd3A4TnZ0a2tKMVBhQXU3N1B2NUMrdWV1SzE0L0Qvd0FPSmRNait6M2pGQ2Zsa2prNEk3OEd2d2R2ZkJ1czdReWExZnl5RWQ1bUhIZnYwcVMyOEg2bEFCRzJxWHprQWtxazcvSVB3b2xtV0FzclliYnlYK1JLeTdFOHp2aXBmZS84ejlzSi9EbndsR250SStwc1FrbTFwZk5IWE9OdUtMN3cxOEhJci9UN2lhZllWUGxvaGw0Y3RYNHFYSGdXUVdxdkpxRjJxRWdoV2xia24ycmdibnd4cUQzdHNuMjI0ZGNuZG1WamdEME9ldEtHYVlPWC9NTW52MFgrUVR5NnRaZjdUUDczL21mdTlkNkQ4SDMxQXA1N0J5QTRqV2ZJQ2c4MTBOem8vd0FIbjI3bzBDaitGYmdnSDY4MStEeDhGT3I0RjFjRTRQOEF5MWJPUFhyV0ovd2hHcFR5RkJjejR5ZG9hWnUzNDFYOXA0Ty8rN0w4UDhqUCt6OFJaLzdSSityZitaKy9FbGo4R1hpYUo3VzJaRDAvZjhqOGMxa3RiZkJiVFlUSWx0YmhtWlZMdEx2WWpQQTYxK0V6K0JwSVVVUzNVb2JHZG9tWW5IdHpUYlh3VEpOTW9NMHZsbi9wbzMrTlM4MHdpMndxL0QvSVN5dWYvUDhBa2YwQlBGOEhIRGsyOXBramsrYnovT3NIU3B2ZzlBczhaYUp3c2h3MHN2VWVnd2VncjhQWnZBVWNicXpyTnNQUCt0WWcvclNId1ZaTVR0U1ZjZGk3ZjQwZjJ0aFVyZlZWK0grUnU4dG56Ui9meTA4OXo5THpmMnQ5YkZra1VvemdiVklPQ2Y1Q2tZeFFXSnRFZ0VzZDAreGl3ejVZUFVuSGIwcjVtOFA2em9aOE4zVXB2RlVrRXNvZkIrbnRWcnd4NDYwK05qSUxsdG1QS2pUZHVKWnVCajJyR1dRMWJ4VWFzR21ycFhOWTU3UmZQZWxPTGc3UDNmeVByeldMeXdndHJlMWlCT3hGVUxqQ2dZeHdhODN2dE92SnpKS0psdytGVkdQVEhYSCtOZVNlSWRPdXRSdjQ3aU9jRXd4QVkzNEc3MStvck9uMTNYWUZpTTBpRllaQWhLdHlmWlI2MWxMSU13cHR0MC9WOURXbm51WFRTL2VKWDJYVSt5ZkQ3Mnl2R2JnN3ZMZ0tJUms0STlEMnpXWnEydnpXdHU1c01zMGpiUEszYm1PZUR4WHpiZStQNTEwcG4reTdWUVpFam5ZZnJ4WGhrUGpyN1ZkUngyOXhMY3lKS3NxK1NDWFZoMTVGZU84RGpGVmpHVktVVW5mYm9lblBHNFdkR1RoVlQ2TnA3TThQaW1rbjF2eHJKUGwzRndBV2ZsczU5NjR6VUNxd3ZqZ2tjY2NWMzlocHQrRThVejNVTXdsdUx3TXU1U0hJWTV5UWV0ZVlhMDBzVVV1UTJjWXdSWDJscEtrcnJvZkZ4NVhVU1R2c2o5Y3ZDNzNzSGhqVGdJRmFTR3lqS294d0dKQS9URmV1Zlo4UkRJd3piYzVQcU0vaml2Q3ZCbXYyOHZoYlRUSWQ4Nnd4SUFEdFBUQXo3VjdIYnpNeXJMTEtyL0tjN09RQVA4SytKcXBwdS9WbjZCRnBwSGYyVmlRdTRTSEFRZ2ozN1Z6RUVSV1lreWVaNWI4WjY1OVFQU2pScnFhR2RsaGtBUnpsSGNuSFBmbXBKSG1qdTh6ZnZjRWdrQUR2N1Z5VFNWckhUQ3hwWGNyUGpjcXRpUUVaR1BsUFVBOTY3ZjdTSWlzaUIyTzBBTHh5RFhrczE2OHN4UVJrd2dnNTY0STdpdlFyR1h6SlVjUmtyczRKKzZUNllyS04zcXU1ZWgwVTZCclJsTEdNWkIrZy9Dc3JiZVFqY1hKSEpHeHM4ZS90Vy9jSTh5RUNYeTJPTVlIQSt2dFZLLzhBSmhqQ2hGRGhNaGdEdDU3Zi9XcW1uWnNWOWxZNEZvNXl4eVZZT01ubnA5UlhwbWl4M1Vkb1FERnQyOVNUblBxTWRxOHJGNUVKMVdTTGtoanVBNEJIcVBldlQ3RzBnbHRJbTVqVWpLS0dJejcxYVdpWW5ZM2k3Q04yY3EyMEhKKzd3UFdxWWxOeXJUeEx1SXhnNXhnZW5GV1doVll5cDh3ODhkR09UMlBxS1MzdUlFall4TGphZm0yakF6NllxazlUT3hWbG5HU3VDb0lPNDU2bjhhb1FHTm9NdGhtSDRsZ2ZwVDU3Mk9SU3lrRERmY2NaeDJxemF5MlhrRTV6SWpnTU01QUI5aFZMVmcvSXlaV3QxenZpa2NNTXFJMHljZXRjdytwdGJPNThsMmpDN2d5OHllNHhXcHFGdmREVURiV3VwRzBrZU15TE5JQXlvdWVoSEdRYWE3N1VoaEUwTWt5NFovTEh5TmowL3dBSzFXaVQ3a2Mxblk0NWI0M0NUM0VUeVFxc2djUnV1MGdwemhnTTlSWHJHa2FnbDRGbGhaU0hqM0tTTUt4UFN1SWt1VW5jdUk0c0RnbEZBNUhVR3QrMXZJQXNVYXFvSndCdHdNZmdLcDJkaTFzYnNjMnBtMFZic0xISXhPWTFPNVJnOVZKcm9iVFkwUktsdUQ5MGRQcldMTmVOSVZRWUpMY0h2VnEyZkRxaTVMTjZkaDlmV3NuWlM4ckR2cDJMMTdkdzIwSmVkeEZFemhTem5nRThDdE9GSVN3aFYyQTJaM0RsY0gwUHJUWkRBeVlZS3d4ODI4Wkg2MXpXb2EzYWFWRUpKM2k4a0FscFYvNVpEMVplNHJKKzg5aE5wTGV4MlVDV2tDTjVoUlc2Z2o1YysvMXEwczF1VEc4WjZqYjgzK0ZmT0UzeGIrSDV0Wko0TmFzN2hkMndzckVuZUJuYmpIV3VSMDc0M2VDcmlUYkxyTnJHMjRCZCtRQm5vTS8xcHhwMVU3ZXpsLzRDeGMxSnIrSkcvcWo2eWt1WlRJNnNQWWRsSDRWeUdyUVJyRVpEa0hISkhQOEFrMUpCcWNGd3dhUEVnWkF3a1U1WEI2WU5jTjRxMUdLUFRKM2xZR09QQjJsc0VIT2VQV3RvcHk5MUxWNldCeWpHTGszWkpYWjgzZVB0UVg3UkRFU0Y4c3ROSmo5Sy9OTFU3ZytKUEgwY1Njb1psWFBVQkkrU1RYdG54SjhZUEhGZHltUStaT3h6ajM2RDhLNGo0UGFKR3RycU91WGVBb0hsd3N4eG5QVS9uWDJVMnNMaElVazlVdFg1cytCb3dlTHg4NnpYdXQ2ZWlQZlJFRGVHTlVWbFYrQUIwNDRBOXErb3ZBOENOR2ZNY0VvdWNaeGl2bG16RWsrc1dpd29kd0dTdU1aVStocjdOOE9tSmtrampFVXpJQXNzYWxkeXNlempyajYxOGJYcUpSc3VwOXpRVGNtejNDMGpFaUFxTnk3ZWNIOWFiYmFmREZkUGN3NUR5RUZobm5LOGNmV3BOT1FyYnNRallJR0NwQUNrZHNlbFFvdHZ1azNnaVhPVU9jREhjNDdWenArNnROVHJrdFRSdTc1dG1DU200SGNEMXovalhJMjhtbnhSdTdScUpGZkltM0ZTYzltSFFpb05XdnpIRzN6UnNVYjkyRk81aU1jN3Zlc0R3eGZ2TmVtSjRtSDdzc0F4M0hnOUswNXQrOXV4aTBtMFp2eEdubms4STZ6ajVXZXlsQk9PUU50Zno3L0VDL251TlgwNkp5UWtFTVVhak9lQjFOZnZuOFVMbWFMd3JxNnBDN2I3YVVCaDIzRCtWZmhEOFFyS3pXKzAyZUdVTVd0NG5rQVlINWlPZW5TcndFbDdTZCs1bGkxKzcrNCsrZmhIRkpNRlpMWXl4Z0RkS1pBaktDT3VPOWZmcGNQYW9xbi9BRlpYSlZzbjJIdURYNTIvQ2ZVYmVLR05abE8xOEFZNHlNZE9LK3pXdkxjd0JWbE1DWkJ5ZmszRWZ6eFhEam0xVzhtdERvdzluU094dUVjU1QvYWRPTVh5RHlwR2NFeWp2aGUySy9JWDQvM1VFM2o4eGhBRmdzb2tQKzF1NXI5VUo3dWVhM0R5cXpJZURJU2VvOXEvR3o0eGFuY3Q0ODFzVFJCZ3dpQy9LQ2RxcndWUFlWNkdVTlBGU2I2UWY1bms1cEJxakRYZVp4WHd6a2hqK0pHaGZaeHRKdU1FOWNaSGF2Mm4welZCQkJMRTBVckJuTzVrSks1NmZOWDVGZkFPeldieGpjM0hrN3piMmpzRC9kTEhHNnYxazA2U3kvc3dpT0I1c1J0bFl4enUvdkVHdTdHenZVU1M2V0RDeHRSV3ZVTmIwanczdEVxd2hXQ2t0R2hJUi9abDdHcmVtU1JtMjh5QzJRbGRvd3VPUHBpdk5ZV1dPSnhMSkswak1lU0R3T3d4MnJzZE5zN3RMVXRhcW9sWlNVakpPMXZja2RLNDVTNzdIWWt1eEJyL0FJbjhNNkZKYlFYa0QvYWIyVEVXNk15SmtIa2tMeUFCWG9jbmlKTFhTb3BZVSswSktBVUtOd1JudDZDdkQ5SitHMHVsYWhKZjZoZnlUU1RPWExNeGthTXR3ZHU0OWE3SyswZDlHZG83YWNMRWZuSXdUdUpIWG5PQ2U0cmhxVklSMjNPbWxlUzFTc2RGcm1yNmhjMk1QbFJxR2xUSkRZemdlcFBwWDA5OEwvQ1RYM3c0a0x1c0QzdHcwcnk3ZDI1SXpnWjlqaXZoSFVieHJ0WW9UdmlrQ2dBRmVDV09Celg2eDZvVDRZK0Z3VGhaWXJPT01BZjMzSE9LNTVPTXFWU1UvaFVXMzBPMmxkVmFhaHBLVTRwZk12OEFnbTZzenBDV3Nlb1EzVWx2dURtUEl3Q2VPRHlLK2FmalZwbC9ld1NHQ1o0amJYVWJLU2NKSnZISStvOWE1TDRZK0xXc0xqVzR2czVlNFpZNUM1YkFDZzlNVjU5NCsrTWxqNGhza3NvN0M1amEydWlaaU1GSEtIZ0lldVByWG16cndyWVNtdHBSMXR1dXg5T3NCVW81aE5xN2hMZDZKOTNzZW1hRnAzMkd5Z2lhZHA1QW9NakVZd3g1d1BVVms2ZFl4MzJvNm5GRmZzMGNNOGM4a1NOakJ4MFA0OWE0clRQRmt1dTZCTkxhMnpMZTI2LzZSYVoyeXRGMDgyTDFJRmRwNEtzbnRHdVo3UDVaTGtKNWhrWGNYMjlEWGp2U1VWYnFldnkyVW5mZGRUemJ4VHBrTm5aVFhXcDJ0dGN4RnlIYy9Ld0JQQURMem12WXZoaC9Zc1BocE5OdEk0cmlLK2thUU52WnBJMXprcXdZRGozcmsvRVduMit1ZUpOSzAyK3RwVHBza2plZkt2eUtabUdGSDRlbGVxZUQvQjEvNFphOGx1QSt5MlZvNHlCOHZsTDBJejNycmhGeFY3WHZvY2RXckdVZVdUczdYWFRVOUE4VGF6RGJwYW84cXdRbGlHWWpoVlVaSitnRmVIWEhpTFQvQUJGNFUxSy8weU1HMU4zSGJ4WEdmbW5FZkxNZTRIcG1xdmlDN3Y4QVVQRnVuUjNEd3ZDSDJ2QW8rVklwQjFPZXBQZXZwSFF2RCtsMnVoWGRyYVF3d3d0RytJMFFLcElIWEE3MWRPbTYwNU45RnA1SEpPb3FFSWFiMmY0bjV0K0x5VGJxcWdMeXAzZDhqbXZwWHdWY20wK0dSczF0NXMzWno1ckg5MnJ2MVhKNmZTdmw3eFpLSDFOWUNHVlRnRUVjWXpYMzZMTC9BSXRwRmJhZlpTT3NrYVB0QjNaSy93QWVEeitWYXFFL1p5VVpXOTJUZm1kRmF0VDU0OHl2NzhWdmEzVTVIdzc4TnJTNzA5WjlWMW1HQzBjNThpQTVsZkI2TWNjZmhYUlJKNE5zZFpnMHpTVlZZMVlzVTNaSkk2azVybXZEdG5xUDlveG1NQVFMaGJnT1BuREVaNEJ4aXZSVzBUUXJlOWEvaWhLenBHUjg1emdIcmcrL2Vpbnl1bkZLbWxiZDN1MlkxNVRkYVRuVmxLL3dwYUpYS212K08vRGVqUnJiWE4rZ2xlVExSS0NTZy8yc1Y1VHJsbHAwdHFiaXhkcGJqVUhDeE5GZlRLdXpITzVja0QyRmVWZU9OWml2MkVOdkdza3J5eW1hNWtVb014amJzSGNBZHZXdEpmRzJyK0hiSFFiWFROQmJVcm01VlQ4cmpZbmw4c1hQWVYxeHExRzJscGZ6NkhMUEQwbFR1OVg5K3ArYy93QVFMYit6TmN1WTdoY1N4dUVrVE9jTU9wejNJcndYVkw2YVYwa1FqR2Z3elhyM2p6VVp0ZDF2VU5SbXdwdUxxU1Fybk8wNTVIMEZlRFhsd1k1QU9vNTRyN3BmQkh2Wkg1aFVmN3lWdTdKVk1yQ1NUWXpNUi9LdUt1Z3pSdGdnN2p3SzZTMW1ra0JXUGNTMmNBbmdnZGEzbTBHUzVFWlNBSWNaem5qL0FBTlk4OFl5MUlQTnRPc2JyN1NqeUhLRGovOEFYWGFYc0VzY1N5SzZzTWdiVHptdWcvc3FXM2lBbGRFSlBHR0ZaMnN3VzFycGpUUzNDRWdaVlN3eitHS2ljMUpycVhva2p4MngzTnJONm93TW5PQndLN2E0dDFpMnNBY0VjanJraXZKN1hWSW9yaDUzakxPejVJSEF4NlYzMXZyK25UTWlTeW1KU3VlQmtBK2hyU2FrbW5ib0pOV0ZrbUViS2NoUWVub1ByWFMzaU5lNlN0d1kzRWFnbUxhUHZFY2ZrYTViVjcvU1Rwc3NVRXlzemtmWGl0N3dqckVpeGkwbWsrUkNIaUovaEk2L2hVYXVLbGExbjE3RzBlWHFlcVMydHJvR2tXMXZIdEdwWEtpU1pzOHdvZVFQcjYxaEpQQkhCY3V4RzkrakE4bXZPdFd1Ynk3dnBKUklaRHZQemR4WGFXMWpweHRrYVZzdVZ5RlhyK0lxb3BwWGJ1M3VaeGpkV2J1K3JNdnkybGxqUTRJR1RrK2g3MTdkcGtGcFphZDVoVDV3T0NNakk5alhrRjNaVzAwY0pqbUtNRktrSGdjZWhxekI0dmFDMXRkUGx0dUFRb2ZkbjVmZW9hazVLM3pIc3owM1VMMjdHalJicEdZM0VtNEt3d1FCMHI1djFtNVpycWVYQVVIampucFhwbXJhcHVET2s1S3F2eW8zUUFWODQzOTk1ak5HcHp1Yms1NDVycnBYMUtxSkpJekRIUGNPeFFFZ0dwRFlzbUN4eFhxVmpvVnJid1JGcitCR2ZHU3pBalA0VkZQbzhUa2orMHJZaFQwM0NoMUZmY0kwdFBNN25YTHN4K0c3VmlmK1hkTWUvSFN2Qk5NamhlOWg4NUF5N3NzTTR6N1Y2bjRoV1M1c2ROdG9wbGtFVWVIS25qSXJpazhPNnVwVjQwQngwNXFhTVh5ZXJacmlHdmErU1NQWTE4VEpieEJFczdWVkF3RjJkcW92NDB2NUUyeDI4STJuZ2hlbGVjcDRlOFR5UGxiTW52Z3NLdkw0YThXRUZSWThkOE1LM3ZLMW16alVvM1pYOFUrSTdpL2lnVmxDWUhLcWVDZld2TmJhUHpKNGxJNGFSUVQ5VGl2VWs4RmE1TTIrNGkyNEdBTTVvbjBTV3laRzhwdmtZRWNkeFM2RWN5NXJINm9mRGFXZU96dWxET0VoaFJGWE9WSEhiME5YMDFtM0Y2Ylo0WFdSZzJIQjRyelQ0VS9FSHdsRjRhMUFYdHlZWmhMbHR3eGhjWUZkQnFuaXZ3M2VPaHRaNC9LUFJnd0p6M1B0WDVwVXBZaFltdGVsSzEwcjIwMFI5L1RsUTloRDM0M3RzYld0ZVV2bFFLVGxWM01EMHkzZXZQMUFWOXVjak9EbnJYSTZ6NHQwbXhjeUdlQ1NJTHRHMlVieVI2ZzF5VWZ4VDhMU0tmbVpTdlVrZ2ZsNjE5VGhPZjJNZEg1bmpZaHhsVWVxUG9hMEVHNVEwTzhjY1o2WnJ5SDRqNm5wOXBlUnhQTUF4UVpVSEpHZXdGZVFhcDhYNXB0MEdseDdXNUFtT09CNmdWNEZMZnRjWFRQTTg5eE94eXpZSjUrdGV0VDUzckxROCtyS21vMlgzblArSmJwYnZXcmlRTHdNRDhxNXRFSkl4a1YyOGZoelZidTRlUVJNQXh6akZkUmErRWRRQitaSzZlYUNTVnp6R201SG1Lb1J3U2F2ZnZBZ1hPUU9nOTY5ZkhoU2ZnZVVjZytuTmJxZUVwQWhJakI0N2pGWVNxUlJxcWJaNEFJUHhxUTI4aC9ncjNqL0FJUmVSUnpIakh0VGw4UE1vR0ZIZmpGWU92RTJWQnM4QkZwTGsvSmorbFNyYTRHZWZ5NlY3NUxvRXo3Vjh2aE9ueWdIbnNmV29GOE1xQVEyNFo3ZWxUN2VJL1lTdm9lSXJGR0NlS1F3aHY0Y0htdlpYOE1RcjFicGc1eFdjL2g5VlB0amcxYXJRZlVmc0tuWThuYTJqUEh0VUJzNCtlSzlaT2l4OEFzUC9yVS8reHJRWUljL2xWKzFqNWg3Q2ZZOGsrd0hqNWVPOVJOcDJlb3hYc3gwaTNLL0xNUHAwcXV1andoU2ZRWnhucFUrMlhtRG9UVnJIalowOVFhck5ZREl4bXZhQnBXbjdTVElWLzhBcjFxVy9oL1EyaEpmVkJHL1pXakxaL0VjVmFyeDMxKzRoMEplUjRNTk9HS2tPbGdqSWJuNlY2NUpwRWNjbUZsVjFCNnIwT0tVYVRJNDl1MksxOXBIdVQ3S1NXeDVML1pXUmpQUDg2a0dpdWVtZWxleVJhREtTTVpxNy9ZRnlCeHlUMnBlMDdNamxmWThMR2pTNUFDNXpVaDBXWXJrcUJqMEZlOExvZDVrREMxZE9oWFJBeUFPT2VldnZWcVZ6Tm8rZGhvMGg3ZlNuTG9Wd1R3dkh2WDBNUEQ4d1Vrbm4ycVVhQkoyeVNLcTc4eEpMeVBuWnZEOTBveVFNZXhxci9ZZDFqSUZmVG8wQmxVRmxIcDFxUmZENGJvMk05c1U3dnVTM0ZIemFMSFdRZ1VTUGdEZ1o0cGh0ZFlFWlF5UHNQOEFEbml2cDArRzN3UDNpalBPRHhUQjRkSndUTW85Z0tPUy9iN2l1ZExyK0o4c2pSN29nTnNQWHBqaXJxZUhiK1dLYVhZb0NZTERJSFgwSGV2cDFmRGNoQkltVWR1dEtQREdja3k5T3VBS2JVaWJyc2ZKN2FaS0FEajlLcE5aeXFlbGZXNThQd3EvektYOXNDbkhTYk5RTTI0eDNwOHN5SFVoZmMrUXZzZHl4KzZjMDlkUHZqMGhmOHErdTQ3TzFqSkgyWlI2WkZWYmwxalZkMFF4bXJ0THlGS2F0b2p6MzRXZUpKL0RQaVFTM0Z1V3Q1MTh1WEkrNzZOK0ZmcWsycmFKSEhISll5eWVhNmg0M2haaVNEempnNC9PdnpDdXIrMEdDWWlUem5pczlQR0dyMmF4aTFubWpFWnlnVThETmVQak12OEFielVsSnBwV2E2TTlEQ1lsMHJxMTB6OVovRHZpK1ZyNlczdWJvUlJ0OHJ4U05rRUQrTFA5NnZTcjI5RndKRUZ3UE1Sc2VVY2tGQno5Sy9HVFQvaVRLWnBXdjU1QzdmeEJlUHlyNlI4T2ZFMFN4TzBXdHdyc1FBaVk3U3krZ3oxcjU2cmw5U0d1djZIdjA4WkIvd0JhbjZETk5hbXhNU2htUDNveXVUZy9oWGI2VnF1bVdzRnJFUkZ1QUpmY3VQbUpyNDYwSDRtVzAxM0hhMjcyWVoxSjN5M0lqVmlPZXA0L0N1STF6eEJKY1IzTWd1SkFvNWVRdUJ5T3dJN2VsZUo5VnJlMTFWbDNOM1ZwdTNVL1NXYnhmb1VVVGhOcXNBZUVHUVQ5UFQzcnltVHgwSkxvUldzYzQyTi9Cd3BQKzBhL09XVDRqNlFMVGI5c21hVkR3SFRnKys0ZGg2Vmt0OFVMR1RUUlp2Y1M3R2ZkS1VCRHQ3ZlN1K09Fcnllc0h2MnNjLzFtbXR0TmU5ejZROFdlS3JXNTFLNDhvdUo0MnhsbnludUJqdFhsVjM0a3Z6TnRhOGVDUGQwRWhBeGpvTzlmTitwZUtiR1ZIVzNrOHNCampMWlkvd0NGZWFTNjVBOXdWa2xKNXprdFhvVThGUGZYN2pubmlYYytyNzI0aVkyOFh5SjU1RFphVEpBUGR2VE5WdFUxcTMwMHhRS0kyQ2o3dlZTVDNQdFhoTVdxYUtiY2tUWjI0SjVBT1QySGMxdVdVZHJmemI0YnBvMlZjQUdQZXY2MTIwc0xOdTdUc2puZFpkOXpwckhTOWExZThranQxWm8yT1hLQTdQb08xZW1YbWxXZW1XY2F2Y1J5ekVGVmdneEkzMFlqaGZyWEg2YWtzcXJGZlhWMWdmS1VMZVhHUjZoVnh3ZmV2U0xhMHRJN2NSSXF4b3k5VVRHUHFhOVpPS1ZyTnNsT0hadG5KS210ZllQS1MzaGhnWTh3eC9LVDd1NTViK1ZhWDlrUi93Qm51VExHakZTU3VjZm42VjFBbEF1SWthSnlwNExoZUJqdnpXanFGaHA3MjhoUEIybmJ6alB0WEhOeWNsYzFjN3Jmb2ZGUGk3VG9rVzBHMERmZEloSVlFRUUxOVZTK0hMRCt6SEpURWNhQUU4Ym1KNllIZXZuL0FNYjNFRVVtbFd4VTd6ZXhPRGpLbFI3L0FOSytxWTJqdWIwNGphUUxHTUJlZ1Awcm9xSnVOUHl1Y1VKcFRuOGo1Nmk4SVRReVBkNmZOUEJMbkNnZkxuNmp1SzJyVHh6ZTZkTDltMW13QVVFZjZSR3VRTWR5TzFmUWNOcEpkUWVaRkhzU0xPL2NEeWZRWTZWeFdxNkZHNEJrWmNTODdDdVNCM3o5YWhhdHBxNTJScjh1bWpYVk03N1ROWTBxK3NmTXRaWW5WdW14Z1BxVDZWZXVwUkkwUUxEY1dBVmNaM0EraDZWOHJUZUVYdGJrM0duWGpXY3dKMm1Oc2dnZHlQU3RTeThhZUlkSlpXMWF4RnltTm9uZ0h6S0QzMmppbkdNV3RqVzFLYjkyWEsrei93QXo2T2toaWVZL0kzblpBKzloZlQ5SzIyczN0STVHTTZJb1FFaFdCM0VWNXRwZXQ2YnJVNnlXTjJrN1krWkdKRHFmZGV1YTlNWFRabVJUS3FrTnR5R0dGSzlNWjlmYXBuVGpiUXhuR1VXMDBRWHV0YVk5cGFKZXZscFZKakJHU0Q3WTZDdko3eU9PMzFtemxCR0dPMDhmTDgzYzRyMDNVOUV0N3k0TTBrOGNRZ1VMRW9YSVZ1MWVGV2w5cU04dHl1b3BMRkhCTmhMcUdMellYSzlCN1VvVTFiUkhISjYyKzQ5UzFIV2JLdzA3NUxKWHVHZGp4eXpBZXVlZzlLNXF4djdlNFI1N3BOakhrYkJuQjlNQ3VkbTFtMGttWC9SSnBMaVFIREtQK1dhOTg5TWV0ZXV5NlI0VHRkQSswVzA1aW5rUWJKdHhVaHp5ZVA2VlRwdXkwSTU3dXlPTlMramxIbEdCVkRBdUM2NzNHT2d4NzFvYVhIcGs0WXBpS1laeXpBN2Nqc1JWclQyMFcxMG01dkpaN2k0MUJmdXptUFpqNkFkUlVPalhsczhwRzJUY3g4MXpqSnczY0R2VSt5ZG03R3FscXJtM1p3eHlLRmVhT2RnU1FVNEQrdzlLNkI3YXc0QWxqaElIS05nRVVhanJPaWlZUnh6SzRJR01SZ2RmWEhwM3JyYlZkRUZoYkRCM2dIZVRzWlQvQUx1ZVJXRW91NnVpbEt6N241eGFqNE92N0dJTEJkeVlrSEt1ZXYwcm12N0c4VVdkdkc2eng3VEtOb3lRZDNyWDNEckZvOXhZZ21GUUl5TUg2OVB5cnppWFQ0SHRGWWtsMGZrWitYbnZYUERNYXlhVjcyWnZMQlVuSjZIaDZlSi9HTm5LVlB6bGg4d0RaeldQSjQ0MU1DQU9KbE1Vak1DUm5KSnIzMkRUN2U0djJDN1ZQa050R09yZHE4ZjFPM2lhM3RVeUdhSmlDZTRPZWhyMGFlYllsdXpiKzg0NnVXWWRhOHErNDUzeHg0MGoxYXlnUkRKRnNURHFNZ08zcVJYclh3aytKR21hRjRmMUZaSW9VdURncTVBM0hQcjY0cnptL3dCTHRuaVZwbFViMkkzQmM4aXVSLzRSSzJ1SXJuWUNOaU13UGZnWnIxS0diMVZWOXBkOHpWcjJPQ3JsdEgyRXFYS3VSN28rMzVQaXZvdDlxSzNFa2FiNDBDcjBJeDNQMXIwRFhmRS93KzFUVmRFczJndDBzNUZacm1RS0FXYkhHVFg1S1E2Wk9kTWhuVm5VdEt5NXoyRlRKQnJESVRGSktVajZ0MUFyNk5aeFhVWHpLTFY5YnJjK2RXVFlUbVhLbkcxN1c2SDY3NmxyWGdudzVHeTJreVRwNVc2UExaWnM5RkdPZ0ZWOVA4UTJkeG91blNycURXelhsMnlMREUrMVlWWGtzM3JtdnltaXVyNlFiV3ZISkE0elhReDNtdlc2QlZ1bkM1eUJqUE5jMDgwcFNsNzFDbmJvckkzaGxOV0tmTGlhdDI5M0pzL1RiWGZGZW9hT0lmSjE4VFJURElVcUdJSHY2VjZGNE84VzZ0ckNPSkwyUFlvMkpoQU56RVo1UHRYNVFyYytKcnNaV1pYMkR1dUs2clR0WjhiNmFvZUh5d29QVUU5NjVmcnVXdWZ2NGFuYnRzenNqZzh4aEgzY1hVYjd2YjdqOU85QzE3VUxtRzludWIrRDdQQktVM1kyNytjYlJpdTkxRHhscUhoMitzN1dTMmp1QkpHSFdKWmRweS9Ua2pyWDQ5LzhKaDRwU0thMDhvK1d6aHdnYmdObk9SWFVhbDhUdkVlb1gxbE5jMnMwbHpiSWllK0krbjFxbkxKM0JXdzFuNU1VbzV6RnJseExhdnJlSzBQMnYxVFg5WGcwc3ZjMmNhRFlIWStaL3F4NzE1VlovRWV3MStmN0ZZeFhDeklvSnd1VmJIVW5QUVYrYjJxL0hEWGJ2VHBMUzdpblF5RlNkeW5jY2YwbzhEL0dXTHc1ZVhralJNNW5oS2ZPbU5wem5JcVhoOG9uT05sS01lcnVKWW5PNFJuek9FcGZaMDArWitqTm40b2diVXhibFdNck1RU0R1SEhYanRYcVE4WVdFa2FJTDFFMmtoQTR3ckVjY01QU3Z5cFg0ejJvOFFhanFIeUZic0VORjkwQUhyakhTcFBEdnhWMDJIV2JHVzR1QTl0YnVTc2JIT0Ixd1B4cUhnY3NsWktyT0t2NUd5eCthUmpkMFlQUy93QXo5V3JqWDNqVzI4N1diVzNrSnp0YktxNEh1YTZhMzhWK0duVlQvYkZzTThzUklDTjMrRmZtSjR6K0t2aC9XSllKTFlKdVFFTVpDR0REc0FPMWNWcHZqU3hiVTdGWlV0L0tFeWVZZG8rN25tc3Y3TndIUGFPSmxidlkwaG1tT2NWellhSzhybjY5YWpxV21OYnRKRk1qaHNrbE85WWpwR3VuUmFqR3BEdWhWNUZmNWRvNkszb2ErSFBGL3dBVU5KbTFIVExXMldNMnBrVnBTUGs0M1l4eDZEdFc0UEdYaGJWL0VlclEzRXpXOXZGQTR0TmpsVWNyMEJBNDU5NnQ1TGgyMm80eUwxNnhJV2M0cFJUbmdwSmF2NGwwUG9ocEZudkd1SHUxZFNpN1BNYlBma0VqMHIwS0dUZkFNQ05RUnh0Nkd2Q3J6Vi9BVUhndlYyaWtqVzVnalJJa1I4czVPTXNLK1pyZnhiSkNxcWw5ZHhqZ0VMTHhUcVpOeTJqOVpneHd6dFR1M2hhaVh5UDBCdFVoaVZvOTVEaGdTblllNHJySUk3WW9oK1RjckVxY1lPZlFHdno4di9GTXRuZlBHZkVFamdJcDh5Tnd5bmVNL3AzcEl2aUpkR2RKUDdkWnlwQ2pLakJIdldFc25xZEsxUDd6b2puZEc5dlkxRjhqOUFyaklCZnpXVnM1Q2dWb1hWdnFYMk4yZzN3dTBaMlNJTjJ4ajNBTmZORjlyZmlpMThGMjJ1emFsYmhMcTQ4cUdJeEFLeWYzanpYcE9uWEhqeVBSUHR0eGY2V3NLUkl3VWh0MlpCOHFjZTFaenlYR0tPbkkrL3ZIVXM1d2Q5WE5mOXVzOTF0QmNpeUR6VENmQ0tHNCs5eHljZGlhOHc4YVRXNmVIOVE4dU1oWGk0ejFCOXE4bTFmNGc2OW9kdXR4Y05wcnJ0M1NKNWhVNCtoNjVyNGorSS94MThXdHJGdlo2VnFPbDNTM0NveDhpRXVJM2IvbG1XZkdXSGV1TlpWaktjb1RhaW84eWZ4ZVpsVnpIQzE2VTZjSEp1VVpSK0YyV25WbmlYd3d1UFA4UjZ6Q0N3SWFXVlZIVDVRUVRYbkY1S3dFMkNjWmJuOGE5NjhBK0ZQR1hoN1hyalUxdWJPSnIyMm5odUlpTjI0VGRldkFJOXE3T3krRVdoZlpyZTUxTFhNUVhOeUlJdkxBVUZzL01TVDBWZld2c1lZZXRLRFRqWjY3dXg4YThUaDFXWExQbVZvclJYMVI5MitBTmV0NFBDT2tTWFpCaFMyUldaamc5TWZLZld2bm40bCtQN1NYeldpa1pJWThoRVBVNC9pTmVNZUt2RyttNkpCUHB0dGM3cmUzY29tWDNBN09NZytocjRzMURXZFo4VFgvQUpFQlBsczN6TjBBSHY3VjROSEQwc00zTnlVcW10dXlQb2NWaUt1T1hKRk9GSjc5MmJMVFhuaXZ4SEhib3pDSHpNeVAyUmU1K3A3VjkxbSswL1M5Q1dDenMxZU9KVlZWMmJoZ2QzRmVDZUhOTnM5THNrdDdlSWwyd1pKQ01sMjlmcDZWN2JwMmdYOXhDOGdpY3F3NmdZQkhyWG5ZcXRmV1Q2bnNZV2p5UjVZbzNmQmwvd0NkclVEQ09WbGRWQkE2SWZyWDNqNGMwenc3RFBQSkZaK1E2cVEwaEdHWWRTV2JxUWErVy9COXVMRlpGYXpPN29BMkdUZDJ6aitkZlNsdHFWdkNMazNBbFJKVUlKUlJJVktEa0QvQ3ZuSjFGS2JzZlEwYWRvSnM5cDBxWFRyZ09rZHlyQlJ4czVBSjZEbW9WdEp2dHJQdCs0TUFqbHNtbHNiR01XYVBicVdWbFZpd1hhU3BIb09ocXpMS0lvMkNQSXJ0Z0E1eWZiTlZmNFM3YXM4ZzFZcmJYOC96S2trMG0zYXc2a0RvUGVwdEd2NS83UmxpYUJWaE1hbFNmdmIrblE5c1ZGcmx1cXp3cGVXeGVReWhvM3lDQ2ZYSTZWUnRXalMrWU0zblNFY0RucU96Ti9LdFpQbFZqQ0tUa2JmaUtRRFI5UmlNZm1QTEM2UkJ1QUdZRVYvUHA0cDhNeDZkNGV0N3lXVXROSk84YXJqRzNZVG5Kcjk5TmRtbDhxUWMvS0R4MTU5Sy9KenhwYitIN2p3LzR0MDZja1h0cGVmYUxKQWNrcktjc0IvV3M4SFVrcTBsYmR4dmIrdk1NVkJjbC9Ka1h3dTFRUWkybjh5M2RRdk1ETXhhUStnQTlQV3Z2Nnd2TERVTFNJenhMbmtnRThKbnArVmZqVjRFMXk1dHIyRlFvWm95UXVjL0xYNk5hRjRzc3hiUjI4c2lyS2paZGl3WlNEMjV4VzJPcE55VmxyK2huaEtrWEZwczkxOFRhbHAybDJvdVpib0NGZ3FCbUorWW4rNkJYNU1mR0svczlSOGJ6elJ5STBadG9RaklNQmxBNzQ2bXZ0SHhqY1FYeU41M3p4UlNvOEVVY2hBejJKVW5PMzFyeG1Qd1BvRi9CcVZ6ZldtK1dOUDNiUnVWMmowR09NQ3VqTFlKVlhMVzltckhuWm5VL2Q2N0tTc2VWL0JGOVRUVmRYazA2V0tIOTFFa2l1Z2ZlTjJjRFAzYzErZ0IxSVR6MlJOM0padERreldrSURPeEhiUDkzNlY4TC9DYTEwM1Q5ZDFSL0tMQ0tVS29MWkFBOWUzNDE5ZVM2eGIzZXB2Y0pBWVpGdHlGWlY0SVgzSGV0Y1ZKcXUzNUd1RVNkR09yT3l1Tldpbmp1WnBYZ2o4cHhrRk5yeUszcG52VzlwR3ZhQWJwWVZ1SjJqQ2pjblVqUDkwanBqdFh6cmVYTVdzUXhrQ2J6WXZ2S2VWWUR2bnNLOUVqMW0zV0czdExXNDh5TW9IS2VXcUVPT0Nxc09UanRtdVdVbHluUW0rZmJjK2xmN0s4SFN4M2Q3YmVKOVFhVmh0anRIWU1xSC9hUnh3UHhyaXRYbW5rL2ZsOFlqVlNWQUlPT1BsQnJrN0RVNFZtVlpsQ2xNQTd1dTcwUHJtdk9OUkduVytyM1F0bzdvU3lneStZOGpHSG5zdWVBUjZWNWszenkrRzFsOTUzMDRxRUhyZTc2czlnOEVhYW1zZVBOQ3NFdU4zbTNTVFBHNi9OdGgrWWh4MnI3KytQWGlBVyttMmxqRTQzYi9ObEE1d01ZWE5mRzM3T0RJbmlueEZybDQyK1BUTElEZVQ5NlNYb0IrVmV3M3kzUGlUVVdpbGpFajMwdVpBZjRRZXcrZ3JteHRXTU1Nb0pYbFVhVFhrdjh6M01wdzduaVZWbHBDa20xZnUvOGp5SHcvYWF2Yi9hYnRrSU0xcXdPU01uUElybGROK0h0OWVtTkhEdytiSVdmQitaczhuR1A1MTlxYWw0YXM5T3RsdHBwWVdoRVJCTExoMUdNWXlLNEk2cGFhVHBwZUZRcEs3SVIzeDYxODA1U2hlTGRtZmJSbkdwN3kxVFdqUGxiVXZEY3ZodnhmWmYyVGV6Z1FSdDVtOXQzbHNmNFMzY04zRmZXZWh6ejZucGpYbGhIbTRSbFNXMkRBYlhKNVArNmVvTmZMbXM2c2ZzYzhDeTdiaHd6dGtoanZZOEUxOUMvQmpSYmkvMExYSkxPNk1PcFJoWVk1Q3ZHZHU3ZGc5Um11cWxTbE9FVzczV3o2czRNVFAyY1c5RmI3ajZLOEkrRjVYOFNhci9BR2phRC9SNUlyaUhQekptUmVTRDZpdnBTZXl0cDRKRWNCMWRTcEI1R0R3ZUs4RStHWGluVnIvUjVyWFU1L012ck9ab3BYMjdTNEhSaUt0ZUx2aVBaNlNwdHJPMWUvdkc0OHVOc0pIL0FMVWo5Z1BRYzE5QlIrcTA2RjczVDdueHVJaGk2dUo1V3RWYmJiMVBuS2F5dHRJdXJyL1JrYWFHOFdJUElDZjNZNXlwUHRYdkthaEJaNlplekdaVmpWRytZbkFIeTE4cCtNUEdGNWNhWkhQZHprUEI1aGRJRitSeklNWWNucHQ3ZDY2aSt1YmZWZkJDejVaWXA3T05uejI0NVAxcmdvY3NJeWNiN05uczRoU255S2R0N00rZE5CMExWL0Z1dTR0MWhhQ0NaWG5uTFlLcm5KRzN2bXYxQU9vRFIvRHM5d3NLaG8wOHUyUThibkF3b3J5ajRQZUZ6YWVHelA4QVp3azJwUythZjltRmVFL01jbXVpOFl2L0FHbTl4YjJpbVFXY0VoUkY1M01PTTE2dE9Qc3NOelBlUzBQSXFUVmZFcW0zN3NYN3pQbDdUOVo4V3dlSkJKTkNKbzdvZjZXdTdvNTUzS2ZRVjZkWTNYaUdTMHVibUsxaXZiUzNsWnBTOG5sdE0zWGJIL3NwWGhWeExyZC9CWTZkQTZ5WGs3ckU3cU9GM0hrREhwM3I2aDhRVzQwN1FiVFJOUG1DL1owVVNPZWN0M3o3azE1R0hpNU9jbjhNVjk3WjlIaTNHSHM0SkxtbGI1Skh5RjQ5MVZieUo5VGVON1JaTVJQQ0NISjQ1RFkvbldQTDRsMC9SUGhycVdvK2VnbGcwdVZiY0g1VzNPTWZMOU04MTZOYVdrZHlidURVbkRGRmQ0aXUwS1g3R3ZsUDlwNjhzTER3UkRiSklVbFlxdUZBMlNBakpHUnprVjIwSVJxVm94ZXpsMFBMeGs1VXNOT1Vla2REODFMTHhmRkxvVWNjcUYzaWtPNWQyQ3dKem1vNC9FdWp5ZExLYVdZNStSUnVIc09LOFYweTJOeGN4d2pkdWtkVkdQOEFhT0svZkRUdmhyNFk4TmVCb3BVc1lVa2pzOHUrd2JpNVhxVDY1cjd2MmJhazByMjEzUHl5clZVT1RTN2s3SS9EYlVidlhkV3V6c3RIUUp3c2FLUnRGWitQRXR1b2ozM0NBOXR4RmZwRHB2Z1hWYnZVWWpiV3hqVXJ2bmtiQ3FRVDZuclhzczN3UTBpZUdhUXp1OHJBRUJnTUFHdUdyV2xDU1hJdFRxakdMVHRKNkg0enkyK3JPVDVqU01TZTdFMUgvWjJvU2JRUVQ2QW5OZnJ1bjdQRUVycU1zUWM0NDcvaDJyZ3ZHUHdjc1BEMmtpZU81M1hCa0NyRzJCa2R6K0ZaUEdwTkpyWDBLOWt0TmJuNW9IUU5RR09GL09waDRaMVVybFkxYjZITmZWdHZwTGkxbmtWWTVTT3NZT0dHUGFxbG5ZM2tvSVdBb1FSd1NCalBlajYzTFcxdERUMkVYM1BsWStIdFZCQThnODkrMVRXK25hdmF6QjFpNVhQR2VEWDExZWFUSmJvVmpDU0huSVE1RlZKTkRRdzI1Qk1yUEd6TkVneTBlRHpuSDUwdnJjMnRrTlVQTStlb2JpK2lYekRhT1BVZzhacllYeEk2UnR1MDFtYkdBUTNldlMxczlMRVRoa1ptN0RISDFOSkZGQkVRVmdWd2VvS0Q1YVBiL3dCMHIyZGx1ZUxOcldwaGNpek9DZU10bXN0NzdWWlpRd3RmbjY1eG12b0o0WUhMQmJiYXJZSkFYMHJzOUdqc3JjaVNTMFJ3RGdoa3pXaXJ2K1FuMlNiK0krWnJmUmZFdXF4N1ZqS3FUempqODY2eTErRkdzVDRHR0RmU3ZweTN1dEtRdUFtekxaSUM0QVBiclh0V25hMzRWTVNtN2VhMytVYkhSTjN6ajFQdlI5WXFKYVFNNVVtL3RIdzVIOEVkZFpGYytZVlA4U3JrVjBObjhCZGV1SFh5WVpwY25oUW96K0FyN0J0L0ZsbEMwcXJkSFlXRGJTcEM1OWZZMTFrSGk3U3JkUE1OeElyT2NvUXBHMzZHczNpSzM4dW9sUjErTDhqNVcwLzRYYW5aTTBMV0Voa2o0WlN2UDVWNkhINFAxRkUrWFNzWUhVaXZmWWZpUHBMeEtra20vQk8xeW5JejFKTmFiK0t0Qzg1VEpxSVpYRzQ3RkpLK3g5S2g0cXNtdmMvTXRZZUxscXp4ZTE4STYya1c3K3luQTJnN3NEb2U5YVZsNFkxUWdqK3lwWmNkU3FnbjhxOWJ0L0hIaGp6WEVlb3lSb1Z3NUNINXgyK2dwVzhXYUxETkpKYjZpNGJqSERIOVJXbjFpcTFyRDhHSjBrbTB2a3p5MCtHcERLV2ZUNU1jZ0x0eHpUWnZDaVRyeHBCSUl4eU1qSXJ0bjhSeHpicFcxQlVVTURnQW5jZXRQMDNYTkV0N3VXVzZ2NVd0MnlYS1JsaVdQWWVsWnVyTjlFSjBsRjN0Zjh6eU81K0dNZHdKRkdoQm1HTncyY1k5eG1zbi9oVWdFWU1PZ0FjOVZRait0ZlJDZU45T1J5VnVBWXNqRGJUbkE2Wjk2MHJING1XRFRZa0tzUE0rVitRVndLeVZXbzcrNnREcmhUdnUyajVTUHdnMCtXUW1UdzhGSVBMSE5USjhIdEZEeEZ0RlVJMmNEbkorbWU5ZlQrcGZFQ3g4bDB0YjA3WkhEU2t4bmRrZTljOHZqRFRrTnZKTmVTU3BHK1ZRcGtNM3BVdXJVN1A4Uk9rdVkrY2JuNFZhTmJJcGowMHFTMlBtQTNWdTIzdzVqampETnBjZ0E3cU9QenIzeUh4Vm96eXZLNmN1Ky9ETHVDbnQrRmF0MTR0MCs4RVNRTklXQi81WXJ0QngwSkJvVmVyY2FvUTVsZHV4OCsyWGhHM2N1RXNiaGdQdkJXd1IrSnE5RDRQRHVUSGEzTzBIbGNnNEZlZzN2akd3T29TUElBakRDTHNYYW9DOWNqdVRXdEQ0cjBzTDVndVNvWDVsUnMvTitWVk9wVWJ2eWtUZ2tsWTRpNjhJK1E4WS9zeTRqNHlDekRtcEovQjl5eWJvN2FjNVVjVmZsOFdabG1rRXdMdUFSa0VsQjZqTmRWWStLTk9OaTduWElZbmpBNFpXOHhzK2hxSEtiVjJrWEZOTlhQS204SzZveEJObkxqUGZ2VjIzOEp6eXlGZnNVaGZ1dTdtdlg1UGlCNFdXT0ZIbWFSc0RlMlNDRDdldGRuL3dzdndpdHFJb05PZ3pqNXBKRllNY2prNTlUVXhjdXRNNkhvcnAzOGo1cHV2QkR1Lzd1MVlEUFB6RE5aeWZEeThsenN0WlNlZUdPTTE5QW54UjRhODRiYmlGRUM3amhqajF4NzEyOXI4UlBCOTVZUzI4bHl0dVFNb3hCemtkaDM1cDNuWjJwc2JsWlh1ZkcvOEF3cnEva0RMOWxjWSs5N1U5UGhaZnRHcEZ0SXdKd1N2TmZWMGZqendzbW5rU2xaR2xMamJ0TzVlMjhWeXNQalBSSG1oamdtS3FrZ2Jjd081Z09nR08xYVUwMm5kVytabktVN3YzajU0YjRaSkhrTmFURWoxQjRxWmZoa3pxM2xXRHNPNTY0cjZ0aytJdmg2TW9oWm1LTmtncGtzVDYrZ3JLbThkYVBPcnlpYnl4M1ZVSXpqNlUvZnY4Qmw3U291cDhyUDhBQ1BVbkhGakxqSUF4MXo3VTAvQ0s4S05tMWxERHFDY0VDdnJhMitKR25mYTdYWkl5ckVSeHN6a2V0VXRRK0lXbFNUU0xOY1NIZElHSHlaSTlnZlExMkpRYTh6RDJtSWN0ZEYzUGtzZkNPUW96ZllaeUYrOGM1QXJwN1g0SDNjdG41NHRRaWsvS0pKQUNmVEFyNkt2UEgyaENLUkxTNWtoMzQ4d09mdjU5UjdVc2ZpTFRKa2lFdXJLck1RQVh5UnovQUVySnlkbDdvS05TNy9lYWVoODJwOEk3dU5nR3NtSDBJTlNTZkMrN2pjSWJkd1QwR0FLOTh2TmUwbnpwUkRxYkFxMjBxQVN2L0FUNlZhUGlyVHlrSW5randtTTd5U1dIMTdVMVV0WnFLRk9uZjdiKzgrZjQvaHBjNU9iU1Q2N2dNL25WaytBTHhGWmhaeWJPQnU2ak5lK1A0aDBpVnZLRjNFcU45M2N4SkZTV1BqQzFnbEVLWHNaUWJnVkozQTl1aHFsV2RuN3FNVlJsL05KK3JQbkkrQUxvL3dETHRLT3c0NjVvaytHK284SHlaVi9EcFgwc212V1FaV2sxSlNxdm5DazhmUTFYUGlDSnB6SkhxU09oendYeVZIdm1oWWwyZnVJVXFEdjhUUG5FL0RpOEhTRzRQcmxmNVVyZkQ2NldUQ1cxeTJmOWp2WDF4YitMTlBheldKcnlKZHBKRzdyays5V3B2RmRpTFZtaHU3Y3RqZytaZzUvd3B4eFU3L0NoU29xNjFaOGpENGYzYnB4YnpGZ2NIQ2RDS25YNGU2bUFQOUV1R3o5M0NjNXI2WHR0ZGxudVhlNHZJUnVUaHM3Y2tkc0N1c3R2RWxwNXFoTHlKT0J2SmZnQWRxY3NSSlBXS1pySERKMzFQaitUNGI2cnNVbXl1c25yOG5GVi93RGhYVitnR2JTVU1lZ3h5ZndyN0trOFdySE9ZSXRTUmxCenUzOEJ2N3B6MnAxeDRwMGhvbUVxQVRjYlNyamFUNjVxbGlwMitGQ2VIVjlYb2ZJY2Z3ejFQNVNiQ2NnOXlLbVg0Y2FoR3BZMmMyM1A5M05mWXkrTHROK3d4ZWJmN0NHQmJhZHpaSDhQSGFxbzhXV2pTc3kzaStTOFl3dWNFRVZmMXQ4dCtReDloTG96NUZpOENsMjJyWXlzZTV4amtWZFB3K2RYSU9reWpBNm50WDFBbXY2U3JMc20yT2VTQ3d4V3BONHRzRWpYWk1KY2o1c25vYWg0dDZ1eFAxYTdWMmZLTUhnQjVHd21teVB0SjNZSGVvcFBob3pOait6VGtrOFlIUHRYMWhENDR0UnA0RGdnTVNWYU1BQWtkbXh6aXVTdGZFOFprWUJjSGtna2Q2M3A0bU50WXBHZFREdUxkbWZOTC9CeVc2UmtYU2Nramc1eGlzOVAyZko3aHlJOU5KMjhNTjFmUjlucTgzbk1HdUhVTXdPNVR3Rjc5VFhvRmg0bHM3ZTN1dkp1R1F1Qnp1M0VrZHlmV29sWHM5RW1pbGg1dGZIWStON2I5bHRyaU41WHNvdGdQSk1vR1ByVkRVdjJUN0tCbEVvRnVYd1ZIbjljOU1WOW15K01XUzEySklGbGR0eGZybFIzeDJyT2s4YVFMRERMSmNzeFU0TE91UmcwS3JmVnEydmMxOWxOTDRybytLZitHUzBXUk51b3lEY2VBc296L0t1aFA3TE56Y0tZZjdZdUgyOVVhNHdEK0dPdGZYK3JlTjdhYjdMSWwycWVXNE94UUNTdnJtb2YrRTUweVJKZCtvS2hVOEFjWi84QXIxVWEwSmRHekhrcnBhU1ZqNHAvNFpnVkgyeVhzdU00eVpRUVB5RmFFbjdMdWlSRlZrMVFPV0djQ1VqZ2V1QlgxMlBGbWsrVzIrK3lvN3FjOG4vR29KUEZHaS9ZblJKUnZZNFZtNHdEMXlhMVRpdWdjbFQrZVI4eDIvN0wvaGdSN3pMRXkvN1V6VmJnL1p6OEx4bi9BSmN6dHhuY1cvbWErbFArRXIwRWFUNWMyb2dYQ044bzJmbGpGY2pKNG4wMDJzaG4xZkVTak1oSE9RT3g5SzNpNDIyWHpPWnFyelAzcEhEYWY4RGZEQ3g3MWdzUnRQcnptdTNzL2hSbzBKeWoyMGUwOWx5UitWVkxIeFFzMGIzVnZiU0MyQkFqM3NCbGZVQ3Q3L2hKNEFydXMvbHlFbkNkZTJhemxWakYvQ3Z1SVZHVGw4VHY2bk9hOThOZEhKQWZVWUJKdDY3RGcvbFhuMm9lQTlRME9LMW5XWkh0cER0amwrK2pNZWRwOUNLNkRWdGRXOGppMnNXbEQvZVU0d2ZRanJYS2Fqck41L1pqUVhOMUtsdkUyNEJqaEkzUGNlaE5jOVJxWHZjdG1laFNWU1BLdWE2NnBuTnpXTWhtZFpBWXQzOTBiZ3Z2Zzlxd3RRanRiYXhabGlhNWN0amRHNHlEN3FlSzZ0TDlIaGllUzhqbGNyMFVqQnEvZVJJcUlEYkNNTjh5c0VVcmp2OEFNT3RjVWRaSnRIcWRENDMrSWpNYlhSc2hReTM2WlJRUGx6MDU5VFgxMXB0ckdOUGpkUTZBSURJekE5K20wL3pyNUIrSU04OXlkSVV4WWhYVVVYY3ZKWWs5cSt6ZE8xQkkyU0JvSnBSR29BMnFmdmR2dzlSWFRWWHVRK1p5eHR6eTlFWkVVazlxOXdscVhFTXI3UVFjb1d4endheDNobmJlUHM4MGhjZ2VadUJ4OVY5SzYyOC9zd1d5Ukc4U0Z0NVlNN0toRHQvZTNjWXJsZEhMWFY4Nk1mTktsazgyRmp0SUhjZXA5K2xSeTJWeDJTZHdtMHkwaEtpT05mTUpJa1FrTDlPdlg2VmUxenc5cGl4d0pCSElMallobGlZRGNTd3p1T09nTlMza0dwSmFYRWpSaDdjT2lzeFZaSFhucXBISUk3MVBxMDNoN1RyYURmcVptdTd2RE5jWjJQR3E4WUk3cjdWRFRiU1FwVHRyMlBrWHhONFcxdTF2eGMydGkwVC9BUExONEpRSEh1Y2RxNzdTL0d1dlc4VVZyNGhzNUx1S05RUmMyellsaSt2WmpYcEY1WTZwZGVYNU9uTmNRUThOY0kzbHRJT28zQTllUFN1a1RTV3U5SldXUFFaMDhoMkVqN2x3eSs0Nm5GTzBrbDFPcW5YdEZwNnA3b1kwMm0rSmRMUzIwUFdiZHdTQnRtYkRybnJsUmc1K3RjejRvMEc5MDViYXhzcDVJNW9zQ2VPS1hkSElHNkU3c0JXOXE4LzFudzFwcGhlYTBoRnV5a2JabzhoOXc1T0NPVFhQUWVOdkZlbm9iZThqVFZiVUFjU2piTXZwaGh6bjYxdENjYk1xVU1QTlhUY1plZXFPNjFIUzdqejdTYlQ1WjdRUngvNnNoU1ZjZmVHN29WUFdxTmplYXBxc1lzSDh1NkVUbVNSRmpCVGoxYjFxVlBHM2d1KzAyZU5tbjB1NWFQYXEzS0ZvZ2ZYY3RlZ2FSWkxMQmJ5MldxMnhWZ0ZtTUdHNEhmYjZtdE5IMU1QWVZFcnBYWGRhbU5ZYVZQck53Tkx0THcyMGNpdDVrckVzc09PdjRHdVhMYTFaUlRhYk1qM0xSRmxTNWpPVUlCKzhoSElQdFh0bWxSYXRwRjBHc3JTSlE3YmkwemhWWWU0N0UrbFplc2VMTHVQVUMwbHBEKzlHRERHb0s4Y1pCR0tqb2M4bExtZDlqeWpWcis4U0dLVzMwaTR1N2RVRFNYRFJsZG9IQkE5VFhCNm5yRjlkR0o0SlRCSGc3WTF5TUQvYXozcjZOc05lMWd5RFRwTEpERklkL2x5TmdKanVNZEs3bTQwdUNkWTVJSnJkdzJTWXhqTWZzM3JtaGJyUWh5YVBtZFBIc0N3YldCWTR4dDdjY1o1NzFsRHhVcHQ3eUdTRUpKNVpiQkhYMDU5YXpMYlZ2Qk9vM2R2SEloTVFqTHl5dDhybGdQdXJqb00xRWJQUXBZNXJyN1FWWXRzUkdJZmNQZjZWRXNsajhVSndsZHZyMk1ZWnRVdmFkS3BGcTMyZTUwVnRjQklrMUNHYkNxeUFrbm1Oai9lOWo2MUg0MTFkclhWUEl2N0cybDh5R0tlTzRpQVI4U0RQSkhEVjBtZ2VJWWtzYnl5dUxPMmxqbmdhTkdTTUt5a2RDMmVvelhuWGlLYlVkUTB2UllycXhVUzJKYUVTUUwxaEp5Q1IzeFhuL3dCbTRpTlM3cHZsMTFUditSNmYxK2cxWlZGZnN6cnROMDZTOHRra01JU0lUZ2trWkFVam9mZXZPTFM3Vk5WMU8yQXlDcjgreS8wcjJmU05XanR0SDFRUCs2RDdCQ3ArYmxSeVFEMHpYejdjNm1qNm5OZE5FWTQ1SUhpTEt2RzQvd0E2eHBVcWthalVvdGFHczZrSjA0OHNrKzV0M2VrMkdsYUZwNHU1STVXZG1rV09Gc2pEY2dNZTFlYmFkcjAwZmluUzloU09FemlOb2dQazJTZktRUjNyWnVWYVhUTEtLUGRJNFFzRjduSjlLNmNmRDJHRFFtMVdlK0p2SW1WbzdhSmR3VUhuYzU5dTRGZXpWbEJRdEovRnA5NTVsS0VuVmNvclozKzQ4MjFhMFN6MWU4dHlvQ3d6dW80N0E4ZmhYbzF1YmVXT0VNeXFNWnlmU3MvNGlvbzEyMXVRZzJYMWxielpCejgyM0RmcUt4VUJsdDE4c2dCaGhnVHhnZWxlZE5YcHdiWjMzVVp5WFpudmVnMlVMdktsbk1wTHFWSjY1eDZWMXR0b3RuOW1na2t2UXdrVnkwWkJ5REgxQngzUGF2RzlOamxYN0xGWk9VbFg1c2x1T09hTlJ2YnFYVVpZSjdJN21BS3RDeEEzZXByd1p5Y3B0S1ZyZmVkcXF4NWI4djhBa2VzUjZCcGR4ZUs4VVB5dGhsM2dnajFyMDFmQkpua0RJbHRGR051V1poa2ZpT3hyaE5BMTBhWGhwOHlKRkdTVlBKT0JYcU9qNi9weHY3TllrZ2EwdVlDNUlYbFpEeWMxak9yT3pzM2Eyak82UHNtbHRkOURtcjN3SkMweGttazgySmVVT3dObkhZWTZWeWZpdndScHFEVFRIQ0lYbFlCa0svTWQzUWdlbGZTNjZqWlJ5Qm9ZL05ibllGSTY5T1IwcnlueGxZYXE4ME41T3NTbVRiaTRWd1RsZW55OWpXZExFVGJTY3JDbENtb1AzVTJmTmx4OE56QnFXMXJWZ21RU1dIWEo3ZjRWNmJlZkNlMFNCTHlPRzM4dFl5elJzMndrbjB6MXIzelFkUHVic1d6M0VMRVF4NUFMWjN0MWJQMXIyTFVtU0xUUWZKajJzaDJ4dGhqbkhHUGY2MDYyTnJKeFNtOU45UmZWb0tEazE1N0g1MXdmRHpTN3VCbmUyUlNjbmFueW5Bcms3ajRmUUxjd0dPQ1RZeCs2Q1FSWDBocFVsM2NtN01NSThwR1pTVHhnazEyZ2loT28yOEtaQks4NGZidVBmclhYSEYxMWYzMmNTcFVwSlBsUjhlTDhQbHVvejltYThhVkNkeWhzN2NkdnJVVi80QTFtMnRsdUV2N2dQczNDTmoxQTYvU3YwbHR2Q2VuUWVlOXRETExjTkpDaGxqd2NBOHNDdnI3MWFYNGFXaDFUVVpyblVKWnpLdVlJV1hESU1kTWQ4R2tzenJMZVdpKy8wTmxnb05mQ2ZqNlpQRU1UT1RkU2dEajJyWXRwZkVzZ3d0NldKNkRadXI3czFqd2RiV1YvSkN5Sktrc2JNeU1NTjhvOU94cmxiYndMZUcxZkZvSXNxckoyM0w3SHBYcXh6S1VvcDNPTjRLS2JUU2Z5UGoxWS9GVWdJODJNWlBBSzR6VzFiV1hqWmlpUlJ4U0VuR0J4K3RmVHVoZUVKM3ZReXhlZU1Nd1FzTUZVNi9qWHVIaHpTYktlN204MktLMnhKbE53NFA4QXNZOWF1cG1GU0NiVm5aRXd3Tk9WazBmRDkzcm54TG0weTMwbWUyL2MycE95TWs0RmRuYitPdmlaYlFSUjNOcGNOQ3BpYjVaTUFHTVlValB0WDNkRjRjMDFCY1NtQkk5cFpwQ1FHMmtkVHpYTTNPbjZMcU1PQUpQSmY1bGRGNFB2V1A4QWJPSzNjZE5MdlU2RmxkSzN4V1orZm5qalcvRSt0UWVkTGIzMGtVUy9QOW9rRWhUUDkzSGF2bFN4MUNTMTFDT1owZHRyWkJZbjg2L1pEVXZER2xQb01yS3l4RkViZEl4NUE2Y2p1UFN2bTY5OExhYWZDZG9vdGtmN1A1MEpabHp1VWplcFB2NzFwUXpoemtrNHUvTlpXT2V0bDZwd2JUMFVicytiSlBpYVdBQ3E3K3h5YXlOWCtLV3UzdW0yOWtvMlFXN3UwYTlNRit0Y3I0SHM0Wi9FVTBUeHF5K1JQZ0gySGFzL1ViT0tOWHdPbWErcTlwVS9tZXA4NnFkRk5KUlM2bXRZNmRmNm9ZcEpmTWwzbmhSd0sraC9EL2d6VXl3a2lSVmlpd0dUN3U3ZDI5NjZ6NFc2T2x3bW5Ca1hHQXhZanA3MTlhM3VpUmFPbHhjQ0o1STJaY0FIa0ErdnRYeVZmTUpLcnlwYTMwUHFLV0NpNEtUMk9SOFArSDdDSXhyTVQ1ak9FMnNPUG9DT3RmVWtHbTJFU1J3Yml4Vk9ZOFl3UHJYR1dhMlQya0VzU2xBcHc2dGdNUjdldGZUTUVObGRhY2s3UWdEWjhvSTVJeDBOZVpPYzUzYmJQWGhUaENOa2tlVmFjbGt1b3BGYnFwRGN2eGtWMkhpVnZKaXRZWXZOUnBaUnpDUXVBT3BPZXg3MWdhREhZeFgzbWhWRHJJM3lwa24yeUs2N1dJWVk3aTJ2QmNGb3dHeXJIQUpQZkI0R0s1MU5idmUrd1RVdVd5UFJkTm11WW80L1BjaFJHUUZCK2JuM0ZObTgrUk53M1pac2RQbXpVdHRxMXEwWWtSbEcwRGtqZzhjY0NzUzR2NzE0bktlWUFUbks4QS9oWFNwYmJzTE04cjhRMjVFNlpuZEZYSUtIczNjMXl1amFocHNHb29ubmtKTWgyZzVBWXFleDZHdW44UjJVMDBRMm8rVEVTUm5CQjc1OWFwNlJyT05Kc3RNa2lpTnZISVhDdkdDVmIxVmpYWEp4ZEYzZGppdEpWTHBMYzZEVTdtR0p6RVdZc3d5ZHh3RXpYNU9lUDlKa3RmaUJEY1c5M0hjSk5PSW0zTU1MdjRCWTlPSy9ScnhEcUdyNmpjSFRMcUdKWkpGYU9PWEJFVFJuN3Z6RDlhK09mSEhoMElMcTNrbnM1SnZMRWFwYmpBVUwwNTd0WEpocW5zOFEycFhYUXZFS1U2YWR0ajRPOFVhWGZlRnZGOXhESVFwOHpPVU9WWUhuSUk2aXZvTFI5YmU3dG9YbDh1Wk51TWJRR0g0OTY4ejhRM0Z6NG50SnhkamJxVmtGaVlZeGxVR0ZPSzgxMFBYN3ExRWNFMk5rWkl4amtWOVhWcHVkT01ySnlzZUZUa3FkUnJXejJQcUs1dUk1WGQ4WUlIRGQ4ZW1hNzZ5dUduOE4zanN2N3lPTUJQWWZoWGxzZDNaVDZaRXZ6QUQ1anRPM2c5OFY3SkZGcDl0NFUxQnJTUnBZekd1R2I3eFBmOHFNdWkvYlQvd3M0czBuYWpIemtqNWo4RDNIbDZqcWJzUWR6dHVUT0FjK3ByMjY0bVZMV0dXTjJKS0Vjc2NmN3B4WGpQaERTcmx0TnZyK1MzZVczYTVlSUdOZ3VINjRZOWdhNkdhNEZzQXNaa1hjNHdIT1VpUFk4ZFJYSGliT3MxNkhwWWQyb3hSMDY2bktJMEt5aUdGczdnRUpiSTZCZmF0M1NoQ1oxWmJ4cEhZa21NamFrT2VnR2VUbXVXOFZhRHF1aHJwMzJtL3RibzNVQWxYeVpCOG1UMFlkaldaWWFicWwzRGMzcXpvdmtPc2JvMGdENWJwdEhjZTlaU2o3ck5ZemZQYTF6NlIvdE82MUNCUWJmZTl1Q3ZtUnBoMjI5QTJPdFpPdjZwY2lPMmpkL0prZEJzallINWU1NFBOWVdueTM4S3dsTHBGd01Oa2NrSHJuSGYwckI4VWFqYUxlUkNCNUhDUXF1OWp1YmNQclhudS9NZWp6V1I5Zi9DQlhmU05SZ2ptajh5ZVJXTVpiYnZLOS9jQ3ZwNzRYM291Sk5aMSs1ay8wZlQ1MnM3Uk1qOTVPUHZOZ2RsNkN2bHY0ZlRhWlllRnJ1ZFVCdmZLWlZmR0RHN3JrRSsxWi93QUs3blN0RWsxQ3p2cEpFdmJtY3l5U0VrcEw2RmZTdm5xcVh0YTA5NVJ0eXI5ZmtmYzRmbTloUXBYU2pKZTgvd0JQbWZhdXNhZzB0cmN6eXk3bUdYZGljQURyem5vQlhoeGorMzJjOXhKTThzVjJ4YURIQlNOUmo1ZlkxbytNOUs4U2F6YTZiYjZOQVowdUdjeUZTUExWRS9pa1k4QVZRMHZ3MTRrdHRFc2RRMURVTE1SVzhqMjBVRnFEdFpSMUxrOS9URmVWR2kvWjg3bHE5WDMwUGJWYW1xdktsb3JMeTFQTmJrMmNPb1FSQ0RDSzNQcWZmUFUxOVEvQ2ZWNTdmVnRZdGd6UnBMQ2pqSFVsZURnMTg3ZUlaSUJyTm1XVlRGSkYxQnh0STdtdXY4Q2EyVjhZMnFrcWtUSzhlNEhsczlNMTJVM0swSkx0M0pycU02TldMNjdhZGpYOFErUHRlc2ZHYmFmYnkvWllydHo1Z1JTMGx5VTRBQkhQUDhRcnpmeFByT3ZTYXRwZGpxRjlGYnZIZEF1c1MrUWpxUjBZbjhqWDN2cHZoM3d1TlVPdHhLSjUwWjBqWWtNRjNEYXpEME5lRmVLL0FmZzVZci9WOVFXUjB0d1psUnBDdzNMeUR6K2dycWhIM1kzWDJUd0ZVOTZWdTYzMDJOM1JMZlRIbGJSWGozU1RSaVZodHlpcjA1OS9TdTZ0TklzSDBnYVMxdCs0VzQ4Z3AvZWlKeUNQYXZFdkEvaWF3dW4xTzhudWxobXVtaWhoZmJ1TWF1TUFnZTFkdjRhOGE2M29tdlhkdnFsbmFhaUdLaTN2TFZzRmxYdXl0ME9lb3JwdzZwOHl2S3kyZHlNVno2OHFiZGswdk0rMnRTa1RUOUxpZ2llT0thZmJid0RvRkdNZmtCWHl6NG44UzJ0akpOcEdtbkx1b1M4dkFjT2M5UW5wWG0rcStPZFI4WitQcmFLMXN5dW1hWTZOTGNOSVVIbWpxaXIzOUsxclh3NXFENnBkMzg0V0tNeXNkeEhCNTRDNTZtdTdHWWxTdW9kTkUvSTh6QVlSUTFxTzdlclhuZlQxT3k4QVcvaHhBWTlOVldTM2xiRXNuRCthUnl3RGM0OTYxZkYrdDZmb2RoY3ZIR3MwN3F3YVYrUUN3NmoxeFhPMzV0dFBhNHZwYmVPSkZoeTBwUEtyM1BGZVQzM2pid3Q0dHRJOUVzYjlIdXpJcHRuWlNqRUFaT1FlM2F1S01wZXpTNWYxUFJuQzlWenUyand2VkkvR3J0YlJKZVdVeUZma1I3Wm93TTlkeEI2MThPL3RRNmpNa2ZoelQ1L3M0blNCMmtXQXNVQUo0enU1elgzYnJFTjVwSmx0SklMaUh6ZGdGMEpRNERnNU9BZVFLL0h6NDJhNU5xdmp1OFl5TTZRcXNVZTRnOEx3VHg2bXZXeTJEbFd1MHJSMTJ0K1I0R2ExRkhETkp5dkpyZDMvQURQTXZDNTI2enA1UEFGeEh6NkhOZnM5ZS9GZTRQaDJiVFdzbzVKeVNnWjFKVFlSMUk5ZlN2eFAwL2Nza0pERlNYWGtkdWV0ZnFiZDJrRnRaNmZIOXJFclN4cXpsK0NTUjFGZlJWSnppL2RrMWMrUGNZTlE1b3B0UFR5UFJ2RGVwWDhkaElMMjlrUlVqVXhwNWVTMmVoejJGZXczWHhMME9QUzJzdC9sem9paEhqNWFUQTU2OUsrZjIwZWVaR2FiZDltaktMSXlFbmFPMjRWeXNHaW1TL2xlUUZJMWJZckJjNHp5UHhyamNyMmNqUlJWcFd0dnJZK20vREh4YjhQMlZoSWs2WEhtS1NWeVJrZzljVjg1K0wvR0UvaW54QkRORHA4WWl0QTdLcmNrcjB5L1kxeTl6WmVWZGhCRXovN2JER0I2bW9KUjVhdUxaQ3puTzhBY2c5K0JXY2xDOTdibFdpcFh0cWVjejJYbFhETWpCV2JPQ09PVDYxQUV1QTVVTGtrY24xK2hyMHkzOFB5M2NFc2swMGNTUXhseVpEeXgvdXFPNXJMMC9TNWJ1WHk0Yk9lV1JteEdJK1R4MnhXS2pkczNVMXJyc1lTTExBUzhpcXlrREFQM2NlOVhMT2VSTlRXNGpZeHZqNWR2R0JqRmRoZGFOUGIvQUxxOHRYZ21CNWlsSHpESHI3VkhjUVBjUEdrTmxHa3JiVmoyTnRVNTQ1SjZlOVpjcTVyV0w1bGF5MVRSeGMya1d6Qm0yL1B1WWx4L3ErZW5BNlZuanc4ODhKMm9oeUFkNm5wOWE5d3NmQ09wVzExTGFYOFNSekNQZXJoOG8zK3p4K2xWM2oreVFTRXhBTXFsUW5RTWUrVFRmeE5KaHBLS2Q3cG5tMXo0ZWl0STBXZWRXWlQwWG9RZWd6VExmUzFLRmdqQlJrbnFjRHRYZHZwY2d0cmFabFpmTmozSURrakk0T0Q2VnMyMXBxUVdLTkxjb3BHM2NlTSt2QjYxVjJsdVpLM1E4bGJ6ZkxqaWtnVnRuQ2tZRFlQcjY0cnZkQjhDYXpyRnBQUGJXWWxpdFN6U3NYMktPTWpQcFQ3bExLR2FmekFaV0pPTnlZS2dkd2E5OTBmeFBlYXJwdGxvR2cyRVZnOHk1djJMWjg3WU9wSjZBMXZCTjMxc1p5YmpIM1V0OVc5a3VwOGh6d05CSXdrdE54d1FpN3VNK3A5Y1Z6c2x6cnd1Q0E4UmhrR3h0NkE0N2ZMWDFicjNoclZOSlVQY1drTGVZZXBPN2I5TWREWEZlSVRvN2FWWldOclorVGNxcGE0WjIzQTU2WTlNVlYxZEsxeS9kMGFkMHp5U3cwMTRZbVJGU1RPQXBiT1JqMHJvSU5LZG81QVpjSEl3bUQwK3RkWERaYWRCWUFMSXp6eUFCaWVSK0hvYWd0MXVrSGxHVGdIcXd4ajI1cUc5MlZHN1p3N2FaTUpKQjVaUUE0ejIvRDFyME8xSDJYUkx1eVd6R2Joa2RIYzlNZHdmUTFQSkZJMEVqcSs4SUR5T1NvOTZrbGpWdFBnTVVubU1wd1NBYzgvV3NaVGxkZXB2eXA3bm1vMHk1am1QbnNRZjRTcll3UFNyRXlTVzIwTDVoUngzQndUWHAxMW8xN2JQR3Mva3poa0R6TkF4UGxaN01mV3MyNjB0TGVSVDlvTXFzb0trRW5BOU1IMHBLZXFWeVV1WlhXeHk2YVhxOTNiVFMydHFUYlFoVEk3SDdyTjcrOVJRR1h5d2oyK1NPUWZwNjE2aDRiMVVhZXQvR1Nzc0VpQVBHVkxLeDl3T2hIYXMrNmhaYmNlVVJ0ZHNuQUJ3ZXg5aFZPWFR1VXViWDhEbmtoVUx6Ym9NbjVXSjU1cXRxbGdVdFEzbUFiRHVMWnlTQjJycVV0bWtPellkeFhPRjV6NzgxbFg5aXZsb2lzWDN1QmpIWWRlUldmTTdyVWFKTk1zcDJ0SWlSbG5CTzNnZktmWFBTcThjTXB1d3NUTWpQOG9PZUZKOVRYVDI2M0VqUUczREkyY0hldnlqc2MrMWFVOWhoaWp5S2pSc05vNEdXN25QY1ZDbHI2bWlWMGVkM2VrTWtqSktOMDNQRzdJK3RVbDBwNUgrYVFBS3ZUbnIycjAyUzNzdktsOCtQTTNCallOa1lIMHJLZXh1SGZKS3FOdVN1Y0UvblZjelc3TXBwYW5EemFWdS9mdWRwNkVMOTA0N21zUVFoWnBIS0JsUFRqSUhwaXZRNDRyb3d5UnM2RVM4Y25sY2RxclNXWVZZNGhjYlFBY29jaFIrWDZWZDNzU2tjZWlXclc0Q29Ha1kvTXhHU01WME1HbngzTjFBbHdXWVlBVmVvMitwRlpzMGNlZHVXVTRBREE4RWU5ZXMrSHJxT0cybVlXb1o1SXdqeU9NNEhZcDZHcWNta3JkeDliSEFhdDRTdTdDNXVWVzE4bUZFM2JuWWJpcDc0OUs1bXowbTZtaG5sVzJMUnhZM3ZqaGM5TTRyN0Iwend4UHJtbW1PZU03Q2Rpejd1VkJQUTU3VjQxNG84UGFqNGZlNnQ3ZTlaNHZsV1VJd0hIb2R1UWNWY2F0MXk5YjI4ak9TY2R0YldQSm9yYVMxc0xobGtKa0xEYVNlaW50WGRmMkxwbHY0ZHNyOXJtRXp5blo5blZmbVFqcXpHdVJzNDRnak1Zemx3Y3QxeFhSMmNkckV2NzFYa01pakNIN3BIcngwTmFOMisvVVVEbjBleXp1TnRJVkJIbUJmNHlPZVQyclBsanQ3eUtVeFRTUXlGeXdVQUdQYjJVOTgxNjZ0N2Jpemh0SWRMYU5WMythd3lmTUxkQ1Q3VnhSMG1hVy9naG5sV08zY0VlWkcySHovQUhjVlVhbDA3cTFyaW5IVGM2R3kwTDdJa01jMGdFcFJYVVpCSVU4anA2MXBDMGg4NTQ1TFV5U25nREJCWXQweC9qVWxsNGR1TEZ5ZkpsS3hBQWlRZk1oSE83UHZXNXEwYzE1ZVF1WkMwakFEWUc5cXhVLzNpMTBGelBsVjJucHVhL2liNGZXZW5hYm9BanZyZHJpN1FtNGdXUU9Zc2NqSkhyMCt0ZUgzVmlyczZHUWlOVHRXSlNEdEkvclhXeTJzc0tPWWxJbFU4Z2NiYytocUxTZElVd3l6c3BPNXpnazg1OTYzbEpMVytnb0o4cVY3dnVZc09qb3hjUlJzSmRvSVZjNTNmeXg3VmlTNlhjeDNBRXFzQ2Z1Zy93QXE5VThpUzJuV2RIMms0WlFUanBWUzludmRUdW5ra3k4ckhMbFFBRyt1S3c5NXZ5SWU5bWNoRnBNUjVkanU3a2RoNllyWFRTTFNKTndtTFpISUlIRmFBaHVZeXliRkFBQko1UE5ia3kyaGFQYVZMZ2Z2TnFuQTlnVFVTdlpLNXNuYXh4ODJuM0lWSWx1bzlnRzRSbms4K3A3VlJhMWdpRHN6SXVTQmhSblBzSzdPNGVPU2JDd0x0S0JSbnFmcm1vUk1td0JZbEtxY2JlNXhUaTJrVGU3T1ZYVG5NYkZDU2NjbmpJSDBQZXNlSFRXbE1zZTNjUUFBeEhROWpYU1hoWHlKSENqSXg4bzY4LzNha1ZBSWM0SmM0Sko0Tlhkb0hiWkdKUFpYc3J4cUpNQUFLVzZjKzFWMTBhYU5nSkxyR1R5eEdjajFQMHJxb0c4eDFVeUx0UDhBRjJERHNjMDFqYnVGWnZtdytTQ00wcnU1cHBheGx6YUkrN1BtREJ4ak9RUHJXTzJueVIzWGx5eU04YWtZS2MvVG4wcnNMNlJXTE1Cc1J1RmozSEFIdG1zLzVvMWVTUGF2UTdXUEhGYVJjckdFcGRETnViVVc4eGFMN2pKM2JCSjlxeXhhenlEYWtvVURuR2VEL3dEWHExY1NOTk1HYnFRUGx4Z0FVOXdrYmJlaXQyemtENkVWcEdUdU43RlJMTzVjU25CQ0tkdTd0bjJxMUhEa3NvY2hWUWM1UHp0bnRWcEpyallrUklXRVpPM2tBdCtGYWNDb1ZqTXlGUUc2ZndrSDNvbEp0R1BRNTlvNzZLWnhDNkVCTThIcm4rdFpVa1RDTlhOMHhabXd5ak9GSHFTSzdzMlFsaktLdWZtQUhxVDlhbnhIYmd4ckhnTjkvYWNrN1IxZjJyTk4yU0ZyWXd4WkxKYlNDTzVra0d6NVMzQjl4aW13NmNVVHlraWNIYjJ6OHVQYjNycHJlUHozYVFmSnRVWllqajhLbnZKZHJ4dkJQdktLU3dVNDJIdjlUV2tkRVVtOWprcmUzY1M0bWN4NVJnY0hCUHRXeHN0bUxSRmQ2c2cyc3pCZHVCMEk3MWZOeWx6SGtSZ0ZnR3o2L24wckZtaUFEcXlnb1Z5cEF4aHU0elR1eVhKM0s5dUMxMklOdTRoY1pUb3ErclZXMktXRWZsRUhKSEhRajFOYWF5eVFzTm9WV0NqZXdJUDBGYlZnNGZ6SGNnWnp6bjByT01wSmhkOWpEaDA2NUt6cUdYaFNRb09DY2R1ZXRhQ0tGc2xWbnhLVG5ZUjJIcFdqUE5JbG1XS2dBQUhMWTV5ZU1WbFNSeU84ZHhQdUlZWUFycDVteUc3WFpXamdqdXQvbW5ENUpSdDNIME5jWGJhWC9hZW9Ja2pBeHhuTEtCNmNjMXM2a1doVjBNZTFtQUlDamc1N2l1MDBEU2paNmY1OHNMR1dVQWxTY0FIUFVpdFhKcGJtUFBvL011dERMdDh1QkJzakJHUDhQY1ZuQzJZeks1R2Y5ck9UajZWME1YMjVwR0N6cEdqSEc0OU9lMVVSYlN4dExGNW03Snh1UFJjZWhGYzdZUlRUUmgzVnRIOW9pSnpFakhIbVk1VWQ4WTcxejl3MGEyenBORm1IZmdieWRwR2VDMWVwdGFQSXU4c1BMQ1lLbms1SGFuVEpiUldSa2tCMkVFRUVaQkFIVG10SXp1ckc4VStiZm9lVFhxYUpJb0UreTNJVHkwV05lUVQvQUJISGYzcndDL24xK3k4S05QRmZGMFIzL2R1Zm1DNXhrQ3ZaazE3UUxTMnZwYjJ3WUFzZkxXTWd2N1pIVWZXdkhiN3hDZFVtV3kwK3drU0tTRWlXTzdLaDFJUEJpWUR2NlZwRldscXRDMjlOSDBQT2RlczdEL2hHZEN2SWJwbkRYOEpiYTJSa25rN2V1UlgxeEZJTGlhMnNOUHVZN2t1ci9hU3ptSnllMjNPT25ldmlueEJwZHBiV1Z0SXR2TGJ6L2JJY3FUOHArYnJpdjBNMDJ6MDdXVHR2dFBqTnhBdTNkTUNvSXgxQlRCSnBWUGhqOHhRVGMzYnNqa29mQ3NNdWJlNzFDM3VZaWRrNjQ4d293NmJSL1d1eE9tYWpwbDBzZW4yTUpTR0hZSlpYRWNZM2NCZ0J5Y1ZNbWxhWEhiU1IyY0VjQkRjakJJQkI3OVNCWFQzVHZGc2VaWThLQnRKWU1kdjRkcW02dWxxVTQ2dGRXZVZSblN0SzFPR3cxQjlrem9aNHBoSXpSM0I3b0dYcDlEWHBGcGMyOE9seVhQOEFaYWNFc3pOQ0diWjJ4bk5UYXRZMnVvUjJrOXFZdlBoSkgzc0RhZjd2VUNydWkzTnhDOHdra1NWdUE1ejkwZWdBNjBXaTJyMzAzSjVaZEZxZWFYTjliM0VOdGNSWFNMSHorNWlKQkovdXNEeGo2VnZYRmxKSlpHT0NTU3krVU00QjNoZzNiSHY3VjNiMkdqUTJjN1d0dEdZNVpnWFVvR0N0M0FQWVZqM2NWc3FJd2xRTW9PM3VNRHRuMnJPVXRralhrdGQrUjVOcmRzd1ErVkVGK1VENWU0SHI2VjVUSmFXKzVKRElSY3F5N1ZLZ2dxZUNDYStodFpqM1c2R0JFVjNPQm5PRG52eFhscyttbEo1cG52UEpNS3FXMklHM1o0d005NmNJNkdEbTduamVvMnRoUDV6UEdwZFRoa1ZlR0g0MWdKNElzVWpTUkxxVzB1cFBtUVF1VlVEMDRyMERWOXBnbG1XUXNtZHVHQUxNZld0ZUxUTGVQUjRiazNFN3l4RU5zTzBxUDluMXErU1d0bWFxcnlOTzcrUnhGaHJIeEowekVVVi9IZVFxU0JIY3hpVElIdjFxWmZpU3NWeHQxSHd5OGJFNGFhMWNzQ1BaVzRyMzMrMVV2dE9TUzJzQWNLTUVLT1NleHhYbTJsVzluUGNTQzZYYzhzaEEyRVJnRHNNMUVYSkozUjJmV0pPMTdTOVZjbHRQSFBneSsyeHZxeVdhbklaSjdkbzJZSHFwWmMxNmRvdXBlRk5OaGsvc2Q5TmRKaUdrWnJrTWNqb1BuNkNxRC9EblNwTGN4bUtJQTVPYzdnbzl6WEN3L0NqdzY0WjdtR0pXWmp0OXdPL0ZQMnpUMkpsS2c5NmY0bnhGY1c5L3FUeVR4cERiVzl1U0drKzZQejdrK2xaR24rZGNUQ0dHNmRtNUlHTURpdllrajgrMnRvWnJjbXhtM0toVWZOQzM5OWNkVDZnMTQ3ckdsMzJqYXlFSklLc0dTUlFRSEhZaXFwemVzVTdOWHNjMDR4VFQzN2tFUGlqVTdXVmszTjhyRWU0cjBtejhhYW5Ec0xveFZnT085V3RVOElTYXFGdjdhMmVQZENza3FrWStidVI2aXU5MFh3eGNHUzJCMDJFRXFwa2xabVp3cDc3VDArbGJyR3loRk5OcDlUbm5oYWNtMUtLYTZhSFNlR3ZFMXRmTkswc0JWWVZKT1Z6a2tmZHhUN3ZWL0NtcVFGSXJPR0hiOTlSbm4zNTZINlZCNHdiU3hIYVd1bnlTTXRxV3d5L0lKQ2VyRUwzcjU3c2pOWnl6bDdRbG5QQmJnRFBPUlV4eHNwKzgwbSt6T1NlRnB3ZG90eDlHZXF5NkpwY3R4QjVWMUxHUmtSc3ZJVDByMHM2SjRodDlQU0MwWkRKR2QwaXlPUVNINms1OWE4SjBMVDcyU1M0dkFYbFZmbndEZ0tSMEgwcjZDOGNYa2tXdTJNelJYSSsxV01Fbyt6Z01WQ3J0UFBRL1NxOXZoNVRTbkZOZGs5aTFHc29lNU96N3ZXNTVwNHIwVzl2OUd0dGtYbDNWcWhYYURsWEdlZzk2OEdTNTFHempLdkJNa2dCSEtrQ3ZwelNOZmgxS2U1aFdhVjUwK2ZFa1lqY2dkZ0FlbzlxOVF2cjdTcjJPeGFPS00vNk1CTis3d1RJcDV6bnZVdjZ0Zmx1MHI5Zk11MkpmdldVdlQ5RDVWOEozOXp2bnZya2xZSVkyQXp3WGJIQ3JXeGJlS2ZQdVhsTExzYjVjZDFyMks3MHZUYnY5MExVRW9BMkFNWVZqZ2tZcmt0VThFYUVrbHd5VHJDZ2tLcTI3NzJQUVZ4U3kyRlM4bEtMNWxwYlRRMCt0eXA2U2hKSlBYcVk4V3F0UEhObHlFUHl0ayt2OHFkQnF3MDlOMGMyRlRnYmlPYzlxclJlRWJ5VzJ1b0xLN2prRXpJY3R4amI2a1Z6bW9lRXZFMXZaZ3RZdExGbmlSZm1HZmJOZWZQTHBwMmQ3WE4xaTRTV2t0a2V5K0hmRVVsd3MwaUtjZzQrVSt2Y1lycGg0amp1SGJ6WnNOQzNDdTNHZm9lOWZPdWlXK28yV3hZMVpQTUtNMjRZdzZIK29ycDRkRmcxRFg3dTBGMFlvcFE1am5QVHpWR2RoUG9UeG12TmxnSEdvN1hTNkhWREVXaXRtejZRMHJ4N3FWcmNicmQvM2czYlNPQjh3OU9sV2J2NGczTGFXeVR5azNHWDN0akhKNkVZcjVUSDl2V1RUclBadkUwWTJPbU9tUm5jRDN6Mklyak5SMUM3dW5qS293QlVCZlVuMjk2NC9xVXBUV3FWbmU1dFV4Yy9aMnZ1ZldHbGVJbWh0NWtWOXl5RU5KOWF2THJzelhsc010dFVsaXdQM1IvU3ZsWFNMMjQ4eFVXUWh2TVZHTGRPVGl1LzFpNzFYU05aYTB2SWRqUm5CQjZFbnVQWTA2bEdzbTRwM09lRlJxQytSK2p2Z2pXcExoWnJzekRjcTQzTHdXQTdIMUpydk5JOFk2ZnFFdHlVdC9MVzFiRWJzY3V4YnJ5ZTlmbnpwUGk4Unc3RnVOcFRHNWZUMk5kcEg0eU9KWFY1TGQzT1c0QkRub0NmWTE1TXFOZE96UG82RlpPRWJ2UzJwN3ZxbXN3MmV1cTByek5hM0laSlpYUU15NTQ0UFE4Vm9hM3I5L0ZhR3lzcDRwSUJCdGhESU42K2pLQjJyNUUxSFg1NDRHaTgvZHVmZVVKeU54L3JWaUhXN082c0dralIvdFVKRzEyYzVUL2R4MjlxOU9MU2hHL1E1NTFFK1pYUFJORm11VGJzZlBTM25RNUxTRENxUWVsZDdiM1U2SjV0eHEwRnpNV0J3VjJnanBrWTdpdmsrWFhvNUpIQXZUc2NFemIxQklZZGNWdjZSNHZXeDFHMXU3WlltTWZCUmhsWDdaSVBjaXVtcFVlOXQvSTVvMUlKMnZzZm9qRGFlSHBYaEM2Z2plWWdEcHV6bmpxMks0dHBQRE9reVNRdzNCS1NPUXlkVmpKN3FmUStsZk5XcitMYnkyOFNRQ3psVVJYc0VVc0cwWUNxL0pISDkwakJyekh4cjRwU3l2NHByR1NiN1BmQU1peHVRb2JPRHdlY2J1bGNNRlVxcFIxdEpIWFV4Rk9LdmJaMlBxUFc1ZFBHbGdHZGxqSUt0a1pEWS93Qms5elhoOXZmMm90dFMwMHl1d1lDU0RQVDVRY2oyNHJ6Mlc3MVEzbDNiWE00bWxnczJtRFJrdUNWR2R1VFUzZzNVYlRVTGhzNVdab2lGUWpPNEhqY1BRKzFkT0dwTlZZdlZxNlo1VmZFYzBaSmFYVFg2SHk5NEFYUGpHNUE0L2NYV1B5cUhVNFVOcStCbklJejcxNnhGNGV0L0QveE12clJBKzM3REl6QitvTWk1TmVjZUkvTHQ0cEk0MjdaL092MFNFNHpwS1MyYXVqNWlTYXFwZGtrejcrK0Rta3dUNlBaeFJFbVlRS1MyY1p4MUgxcjZrMWVLM3VZaEM3N1E3SUdJUDRjVjhnL0JYeFBaMnVtMis2M0N1MFcxbkovWEhhdnFLTFY3S2EvVnR6U0JGSk9DTnBKOS9hdnp1dFRxS3ZOeVQwYloraVllVUpVSVdhMnNkRmNXaVd6UlJ4SE1XVVVzM0RCVDF3ZTJLOW12b1FiR2RJYm1kVEhDckl3WUVQeHdNOTY4RTg2NFl5N0gzaGlGSWJrRG5qQkhldWxoM1JXYk05d3d3U1hUY1JnbnNCL09tNnFTYXRxeStWdG5PZUg3ZUc4ZTZra3Q1b3J5MW5FaVNyTHhJYzhxUjYrMWVvYTU0amtSamJRWEtPNmtMTkdWeUZMajVRUWY1MTVWcCtzV0Qza0tJNEI1YnlpY045Yzkvd0FhMzlhdnZEMDExQWpCdk1rMmx5aDZrRGpuMnB5VjZpYjAwMk01ZTdUZG10ejNQUkw2QllMU04yOHFWazNPZkwzUmtyMTVIUSsxZFZmYWdrbW9RdGJJMGpLcFU1RzFjKzQvbFhsR2czTFhGM0RDVTJDS0U3bmY3akFlNS9pUHRYWGF2cWFDV00rUWtaSkFWa1lnSEZkZE5wMzdveXUzRzV3T3NhZHFzZW90SmNodHNpbkJKeHRQc09sZU1OcnFtRjdlT0V5ekc3Y0IxTzR0bmdBanR6WHEvaXpYVm50Wkg4emU1R0FDZnVnRG12bERROWFUVDlRbXVsa2xOd1JtSDVWS3FmN3g3NU5kSE56S3pXbXh5UFNUN250ZXBSYTNOYW0wdTVycUpsQWZaa2JNajBJcndMV0lSRlBDZkxkVlU3RmtZWUNuKzhmVVY5RVgzaTF0YjBtMWFhRXgzQ2xqSVl6dFU0SFgxNTlLOFMxLzdQZHdTTXNpeXNDT04yQ0I3ajFyenFsUGt4RWxHVjRkR2FYazZLYlZwZFQ0YzhaYVBlYWI0Z2U4c3o1ckl4M3RrRVREcWYwcnpUV2RLWFVVL3REVDR4eUI1c2E5UVIzeFgwaHE5b0puZEdLcS9JMm41UXg5YThBdjdPNzBlN0YzWXRqL0FKNlFzZmxmMXI2VEJZcGNxcHlmb2VUVnBkYkhKNmJxbDlaTkY5cWdrV0o4bENWSUJ4NkU5YSt3bzdvajRmdTRPRmx5MmF4UEZsMTRVOFdlR1BBbWw2YTNsWFlqWTNnNllta2ZHQjY0SFN0WHhwYkpvbmhPWFRra0xlUTd4QnoxTzNpdnE2RktFWE9jWGRjdHIrWjh6aVp5YWpDYXMrZDI4MG5hNTRWNE9tdUk3T2NCdjNVa2pFcVNkckVlM3JXN2QzR003SHlSWG0vaGZXYmVHRXhTNUczSlU5aG10bWEraGRqdGNuT2VhK1lxMDVPckoyNm4wVktjVlNpcjlDOUZkbHk1ZVJWT0Q5NVEyZndQZXQrenVTUWdESExBRGN5NEhIcGlzVFRtMFpTNXV0enFGNFVFcVN4OUR6MHFPT1JQTnhFQ1NPVkdlM3JXTXR0aW9hTk81N3RIZlFKcHNvbFJuWmsvMWdiYVJnNS9Hc0h3NWJ5Njk0bHNMVHkyOHFhNFNOcGl1RG5yajI0RlVMSzZSNFVFaTdpckRjbzZZSEpyNm4rQ3Rob3VyL0UvVWRUalUyZGxZMk80NXpJaXl2OEFLRCtGZWZVMHAxSDFVWGIxUFhwUjU4UlNqYlJ0WDlFZldIaGZ3RXF5U3lTTG1HUndCR1d3RzI4WlBldlNiL3dENEEwZStnMVBVNFpMbVlBQzFzNGNsblBZWUhYOGVLbDFYVXhaMmlwcEY4c3M3ZklzcWdNVlpqMVVISXpYYzY3ckk4UDZWWnViZjdkY3d3cVpaRGpKTGRXWTlmd0ZmTDhqU2NtN3lXbS9mMFB1cFhkU0NTYVQ2TFQ4emsvR0Y5YXpXR25wZkxKWXh5WEtDMnNMVE9aVDJFd1Rxbzc5cTFQaXJwM21mRFIzc1pVWnJTV09SMVFqQkNuNWg4dmNlbGZNbmlmeFBIZXZIZTNPdFF4YjVGRVZ1eitUa24zUU1TUjZWOUx5aWFMd0hIcDgwS1J0S2pNdTMrSU56aytwTk9pMm9TY2wwMzZYVE5jVFI1VlNVWkpQblYwdXpQekY4UzMxOWRhblpwRTd4TEpDcGtYT0NNOWo3VjduNGFNY2VqYXRwa2tBTnpIRWdTUW5HMHlucUc2NXJ5WFg1YlgrM285c1M3WVl4K0xMWFdmQzI2dU5aMTY0Z2VaRWx1N2xWRzdrQUlNOGUrSzFsek9tckxSV0d1V001SnU5N3I1SDJoOE9mQ3Q5b21sM1RUWDg4NlhMeGlDTm1MQk52WGFUNm1yZnhzdVd0ZkEwc2FFaVc2bFNQSFlnY24rVmUyc1VpRnZiUmdsTGFNZEJ6bnNLK1ovaXpxRTArc2FQWXBFSlZqM1BLdTRBakhjWjY0OUszaHpKU2N0VzdmZ2VkTDNwd1VWWThQOEFDWmh0YmZTVmtSMzNTbVZRQmpMRmVoUG9Ldy9oenFrVWV2alFiRTNsMG91SjVXbGxpMktoWTVPM1A4SHVhK3lmaG5hQzZpdGxhSlo3VTJydXNwUmNlWnYybFJnWjQ5YTQvUU5BV3grSlhpajVDRmd0NDBpWWtmTUpUdUpHT3c2VnJSaE5wODIwbXdxMW91V2xyd2orQjNHbmFMbzJnUjZyZlc4SkRPR3VKd0dKRHVvN0E5TTF3UXVOYTF5ZURWWGsrZUNFdWx2NW15R0ZUeno3NDZtdmVMelRvNXRLbVdFSXJ1Tmk3bXd1VDZuMHI0WjFieHRwOW9zMm4zZXlCa25jeXhpVHpOL2w4TGpiL0Q2Q2xpNHVNbzJqcDVCaEpKeG4zdnBmb1ErTy9GOXhkYUs4RnQ5cGFPNm5KdUhkU0JoZUFvSkgzZlN1RStHbmh2U3J2eFhCY2FoZjNFRVVFTHlSU3dxcDJ5RHB1TGRCanAzcmgvRW5pcWJXb2hoNWxqTEJZb1FNWlA4QWVOZTQvRGE0aHNMZlhiUzh0NExtR014U3JqSmtMd0x1UDRjNHhUcDh5dktYYlk2NmpqeThxMHUveVBRTlcyZUlORHVadFZna1dDMk03c3dYWVowaXp0Y2YzYzEvUFo0aHVsdU5hdTVFR0ZNamJSbk9CbmdacjlVdjJqZkYzaVI5TXN3ek5iMnMxcVhlR003VUR1ZUZZanJnVitSZ0R5Rm5QcnlUWDFPV1VtcWJxT1YrYnAyUGdNNHEzcXdwMjFpdFgzT24weU9XYTR0bzBCWXM2Zy9uWDdGYTZrVnU5akdZQUF0ckZza2RjNHlveUFhL05INFphY2sydjZXSmsvZFNYY0lmUDkwTU1pdjEvbWwwKzg4WEphYXBjb21rV3N4ZllPTnh4OTNJNXJ0cVdjby9NOEdVcExsZHJwS1RmeXRzZVQ2aGRhVGJUck9xM1AyTjJpRGhqdWZIOFhzUjZDdmFiM1RQQzhjTWNscnFyVDJWMUg4NWROc3NiWTRMTC9oWEtYOXo0UWw4VFhFTVZqYzNObTV6QkdoRU96UEErL25JcGx4TWcxQnBZb2pBa1kyb3B3U2dIR00xelZPWGtTdHIzdWFybW1vMmNsN3ZsMTcrWndZc0hhWkRFbzJKaU1BRGN6SDJ6MXJWMWJ3L1lXY01Vc0Y5Yk03QStZa1oyeUQySVBldlFkVGlSVmp1b1poTDhpK1l3QVhheEhiSGV2TzB0WnJoWk5RS3U4a1o2aGZTdWFOM0V2azFVdWEza2VlYXBCTTBRR0I4aFVoZXVBUFd2ZHZDZHRvT202WExxRnBmK1plQkNra0Ryd3hia2xEMnhYbmQxZlJYQXZIOGpDVEZYZmN2OFNqZ0QyOWFrdHJ5MnNkS1c3U3l0L21abzlneVBtUFhQOUtxTXBSZHJhMzBGVWluQzE5OTEzOGpROFFlSUcxeFRKY0xIOW9qalBKenVJWG9Qd0ZjcnAraHRkc2kzRHRERk1ENVVveHRZK3c2L1dzVzQ1dWt3d1h6bCtZQTUybjBGZGZwZHJkYWpyT24yaXBIRkkySTFJSkcwQWQvU200eWNyOVJ0S0VkUGRTWDNJeGZ0ZDNZenZhUEs3TEdkcjR5eEtyMEFQcFZlOHNUY2VhWTNsZ1IwT04zekJDZjR1ZXVhOUQwbXp2N0R4Tk8zbExJa0FrU1YzUEIrbFZKVHAwMmszMG4yV2Y3U2JnTEhJb094SXh5eTQ3bXMycnowc3RFMmJjM3VKN25DVzYzRWNDSksyK05WS3huT1FQWGFPeE5mYVd1Ni80R3ZQaGZvNzJvaU4vYmJWOGtnaGxaaGh0eDdtdmpON2RFbFdTUlpCRmo1Vys2Qy80MGlYUVFlWGhTQzRMRHJ1SjR5UGV1aU51V1NhM1JuS01HNDMreTdyMUsxOW8xK0ZjbGNIamMzQnpubnI2MWoyRnkxbGQ1ajNKbmhteVJqOGExTFpIYWFlTjVwTWJqKzdQVWUzTlR0S0lWUVl6dXpuUFQwNXJPTjFvTlBRdGFwZFh6cGtYanluYVMzYm4ycmgxZ3Rwd2hpRTdQdHpLem5QelovaDlxNkM4QkZtdmtBTXBZbkI1TkpETzFqR3FtWW9YSHo4Y2JmU3RMR0x1V05QaHNrQWFlT1VsUWZsUWpKeWVoelcreVhEWERtMUtGZG9CYVJneEc3c0IxejcxWHRoY1RSeC9aWTJkeVRoUW00azl2eHFucGNHclBxTHRBUEtuR2Nsc0syZmJkeFhPazNKNm5RNUpMcHQxTERUVy9rSkZCR3lOR3A4NXM1OHhnZVQ3ZlNzKzJSSnI2S013eXBGSklvREVFRXFldTNQQk5kRFBvOTdZWDhpWGRzMFVtd09WYkh6YnVRd3gyTlpRbnZudVQ1c2hESWdNUzU0SHNLeFNYYzBUMHVtdFRzUEVjR242WHFFa0dqd1hNcUJGRXF6c0RsbTc1NzBrdGpyNnZEQmVhYUk1SGozd1J1VlhLams5U08zYXZNbHViNjVWbTgxdk1WanU1emdacWhxSzZ0cU9vd3kzRVV0NDBUcXF5bVE3VkI2RnhudDJyUndWN05yUmJrcVVveGlrL3YxWjZ4NGY4T1h1b2EwbG5wRWFadUVNakZ2bFZTT295ZWdyTDEzdy9yT2k2aTlyZnhHQnczVmNFUG51Q08xYSttYXNOUHY3YWFKcE1RbGZNMmtqZGc1SStsYm5qYnhkZStLdFdkL3NLd3d3UnI1SWRoa2p2MDZtc1ltcWJXbmtjaGJhY0lKWjJFdTdZdkRIQU9HSHAzcmxkT2lOenFEeVNrQ0tNbmJzSFVqZzVwSjVoREJJN0hMQVlCemtqdGpOYkdsUkdPMUNrY3NlVzlDYWRtb3Y3aFJkNUh2bGhwbGxmYWZMUFpRckNscEVwbUR0dWR3VDFIcFhFMjA5aWRSbGlXeE53WkE4YURCWmhubzMxRmNmRnFWelpLK0pXUU5oVzJuQk9UME5lcStFdFJzcmUxdUpwTHFLS2N5NENzaEpLOTl2dldTaFpkZnZIZVNqSzd2cm91eDVqZHd4eHhxa3NMWUVtMTBCMnNUMDcxZFMwdHZNUmZJWXFHdzR6MEhwdU5ibmlTN3RkUTFScGJiZDVmZkl3U2ZYRlprR3FUUXZ0a3lOd3d4MmdoOGRLMTVHMGdkM1p0Zkl4WjdKb1BOWmRwSE8wQTVPTzM0MWkyU05Qdjgxc0hIM1NBTTEyODA5bkprZ0Vsam5BSEErbFdJYld6TThHT3JIRy9IUWpuOUtpN1NhdHIzSFp0SGtONUV5T3JpUEIzY0RHZW5UTmQ1Wk5OR0VpdkpSQ0hUY1dUQkhzT1BXbTN0dEM5eTJRcFZXT1d6Z2tIcHdLNkRSdE50Ym1mZmNUTENpcngzYkk2RG5pdDIxeXBHZHJiczZmVDlkdlA3Q3ViSnJzeVFPUVl3Rnd5bFR5TStsVXRBOEwzT3QybDRxbU8zdGtWbmxtbFlxckVjaFZKNnNhemRSOFo2ZERISGF4UWlPNmlKWUVKaVJzL3dBVzFjOGVsTjhLZUN2SHV2M1RUaTA4aTJCTGlTNmxaVUtuL1k2bjhLcWhGeXZ6SnJYUWl0SlFVclRTdnJkbk0zZXAybHhidlovWjB4RXFxajdjTU52cGpyV1BwOEhtRFlIVlZML2ViakgxTmRaZWVHTDIwMUsvUjJUZENUdTRJQjkrZXg3VmpLMHJENTEzaEJnb0JqSHBpcWxEbGRrWkxaTmJQVW5pRnZiUk9yVE1XeVFPdlNvNW1NN1JzYllwR3ZDdmpnazEyR202V0RjMnozZ0VjYnV1NWlRU2llcC9wWFErSkUwcHAzVFNaTTI0Nm94UEpQWEdmV25wWnZUY3JtZk1vdUwxVjcyMDBPUzA2OTFDMUtCb25jRTRiYXdkZ0QwNjlmcFdQUGJ5dGNtU08zYU1EakhkVzlmYXVvbHNyaXdXRkx1M2xna2tYZEVHR0NmVEdlMVo4OTFxRnh1akNxeW9wTEVZVnZtNys5UWxadlN3azA5Vlpvd29aRUR6UjNGdUMrY3JJZVdIdGlyaXlqYXBYc01NcCtVOFZTYUJvWkU4eWFNQXIweVNmcHpWeVczbjI1ZmdNUGxCeGpIYXRKSk94Y0xhMkV1UnYySkc0a0JYQnoySjY0cXphMmtkdkVXVmlTMzhOVTFlUzM1WkI2K25UdnpYVVNUZmFZb1c4M2M1WHB0MjgvaDFGRm1ySmJFUFdSU3VIUlhqRVVSQUkrWlhiY1MzdFZDN2FTYUxZWThZSXoyejlhNmFHR0VpU1RZV01mQ0VIQXoxNUZRTFpMUGJ2S3JsRHp1TEh1ZXdOWk5hb05lYTlqa1hYOXl4REtNZS9PS3dtUVI3VHVQR0JuUEp6N1Z1R1ZZYmpZUUhJeDM0eFdoTEZDWnBXS2xjQU91UmdFZTNyV2kwM00yOVRsMGtqYy93bkI1UFhGWjkxY0FEYkVOMlQrSUhldHkwV1EzaEVNZm1Gamdyd051ZVIxNlZzUXdRYnlXaVRidUJJUEJCL0NwYlNuM0hIYzR5M01janFNL0tWT0V4bkQ5aWZTdEdDSEVNelNFS3lwaEZJNGRzOUswM3Q0aVpNZzd2NFNwNC9Tc3NoNTNDZ241Q2VRTWs0L3BXOXJtdDBrUFNBM2NMcGovVnFIWmh5UXZXcUtxWkxiQVU3SDVERTRKeDlhdHlXNGNwc2tNWmJxQWNEclZhOWN4eExHWmNodXJFOEFEc0t4VGZNY3lhY2loZlc4c3FSdWtmM2NIQTR6N1ZtMjBxYjJXNHQyalhQeUhzV0ZiME1zYlBHRGQ3MVB5c3BHUVBUQXFhVHo1QUl4Q0F1ZWd4a2oxQnJScjNpdGtrWnFXSWxuM0diY3ZRSWZYMnhYU05HL2xraytXZG9WaUJrWlBvRFhPV1ZzdHBka004aHdlaDdld3JzWGp0NWJWNUdtQ3NEa0l6ZEI2azFMYlRTNkNzYzA4VThvRVl3TURKYnB2L0FCN1ZjdlpGdFdhUmJmS2hCOGg5ZlQzcTVENVVtRVkvS2VRd0EvUTFtNnZOYnpSdkdva0NCbEFkams4VlRUdWkwMVpqSlpMdTVzMFdOY0Vya0hvQUtpdGJPS0czV0tZTTRQTEhxVDlEVmkxeHRDNzJBR2NjWi96OUszN0d4VHlKSkRPY0JzbmNwL0lWZDNheGp6Vys4NVQ3TUZ2Rk1TU1J4RS9MdjYvbDZWTGRxT0ZCVmtIelpCMm5tdDJUbVJzTTNBd2VjQWoyclBqczVKdjNhaFc2NWtjWXdLcXpKazFlNVF0NDRreEh0SElCWTljajNOYjFqYnlpMkdHMmJtWWtjYlN2dDZtczIrdGtpWFBuSGRnQUFkUFN0eVhDd1E1QklYQlFyMk9PaEZKeHMwWGZUMUtCaGlsY21hTm13T2c3Z1ZGZW41WTJUYXk3TUFna2tFbjdwQnF3OTBkKzRBcUZ4bkpIekUrbE52QklzQ3YrN0FJempIRFpyVk5YUnp5dWprR3R6YzZqYlJNY2taWitlbU9nRmVqVG1WRWpSUTNHQ1QySHZYRFdGcEF0M2J5aVg5NUlXTGsvd2dmdzVyMkRTdEwxQzhRU3JHV1FzdzlQdzU3VU82MUlpazJjdFoyZHhmM1BrQmp0WGxpTWNlMWRwZGVHYm0wQ01RR1U4czM4WEhiRmQzZGFIcGRqYTJQMlRVdDhyeE0xeStBb2pjSDdnUGNZcmtiMjhhTzFKamxNeDNoU2M1R0RYRzZudmJXMXNqZUtsYzVLN3ZBUXNFRWVINnlBamtLZXJWYXU0cmUzdFZtYmhNcUFyanFQV2tqZVYzZHdDR0MvTU5vUEgxN0N2UGZHZXJKYjZIdWVaaXF5S1NDZUIrZGJRVjVKRnQybDZsTHhURnB1cEtXMCt6dG9wUjVZa256dGtPNDRBWmVtMzNyQ3UvQWtHazZXMXhjeXpQZEIrR1RHRUhVQVo2Q3ZMYkdDN3ZkWW51TFRWNDlrZXd6d2o1bEliN3VHNlpyMHpXVzFlN3Q1N2VIZmVNZzJ2QVFWRGU1T2E5Qy9NM2QyRTA3ZVI1VjhaZFB0aDRadEx5V3pNTjMrNllGSDNLeUEvZWIvQU90WHVkdHJNSzZWYVQrZDhqeFJzSkRuRGNmZEFQOEFPdm5qeHg0VWx0L2gvYzNWeGJwYXpvby9jQ1F5RUp1N1pQQTlxOS84RjMybEh3cHBpUHAxdFBLbHRHSXpLRGxTUjFVKzlOd1NoRlg2c2RPVFUzMXZFZEg0aTBxOURPbDNiMjhrWXl1ODdjZ25rSDFxbU5aaWp1V1dmeUxtSTh4SFBsbGdlNXgxQTlhNmE5MXkydURzbTBuVEFRQXBMUTVJWDEvK3ZYYWVHZE8rMTRndDdTd1h5VjNScEpFSGpkRzY5ODU5S3hjVzNiek5yOVhvZWNIeEhZd3hxbGtvdHNaZVNWVjh3T09oVmR2OWE2aHRWOFZ2cGNMVzlvWDNuS3ZzVUVMMmJJNXo5YTVML2hFYnZTTDY4a2kwd2VkUEs2eVJyTG1BbzNjYnVRUjZWN1JhUVNUYWRhV2R6ZFRlZmJMdGhrV1JRQ0IvQ2NEQlg2ODA2bE8zcVJHYmJabHBMWXRhaUo1cmdHVEhVREN1T3BBNDYwNjZ2TEt3dDRQdER3dkZrZk9SMHo2bjNyZGswclY1bzdpSy90STQxaVFTQndRUXhISXh0NUh2aXVLZ2swblVaSWtTNmpFUWZkS0FwYmRqK0RhM0lOWVNqZTJtaHBmY2draUYza3BuRzRsUG15Q01kUU8xWTB2aGJWYmlONXBySzNoUkN2NzRTc0Y5QjhvNm12b2RsOFB5UnlQR3pLVVFCVlpjNWJIZnVQcFhJYXhxZWdXK2htQzRnRFA5cDNBaVFxVlVyMUdLdEtWakpXdWZKZW9lRzcrZlVGdGtzNUpnN0hjMGFuYXA3a3NlZ3JxTk4wV3owMjlnc0wreU53T0dqbVZzUm5kMmJudFV1cGFqcERYaVBHc3lEY0F4RWh3UVBwMUZic2V2YWRhS2YzZWQzSkorYmoyQjZVNXAzRTdMcjFQVE5GOE0ybW14eWx4bU9RNUtodXA5dlRqdldQcVhocndySklzbjJaMktObG9rYllDcDc1N1lycFA3UTA2N3RiZVF5ZktjRUJqakJIYW55WG1uU2tqSW1aVk9ZMUlKSTl4M3FJcDIxYkNUZWxrWktXbHBhMjZ5RGZGR2taOHdGdC95RDZkVFZPeXZ0TXZZak5icEtVenRCWlFwT1BidFc1WjNrTjRrbUpvUkRHQ0JFWXlIQkhVSFBURllid2FSSzdNeUlyRTg3V01lZnFCVThxVDFOYkg1MVhGeExwZWp6MjBNNEF1NU53VnVXakNkQ1BRbnZYUHBIYVRYUzNDSzEyL2xqRE8zM0hQc2ZTb3IrMzFZVHVIbnQ3aVdWOEtzUXlTUFVEMHFQVDlCMVNPWSthcjJ6WkJ5L3dBb1lIdGozckd5VUc3Ny9pY3QyNWFIcE9uWFdveDcvdEJSMUtIYmcvcGlvaHJsNWN3SnZjVzhpa2dzVzJnZzlCN21zQzYxYTF0TElpM2t4T3JuekdjYmw5T0FlbFY3Ry9udTBpdGJ5NFh5Sk9kb1VEazkvV3VaS1NpMjFiVTE5bzlGY2toTW4yMlVSM0tTdDVSWnpuY0Juc1NQV3VRaG1ueFBLYmpaNVpQeU1jbHNkaDdWMGN1c1dtbjZIZjIxbFp4a1MzQURTc1R1d3ZUNmcxd0M2WGUzVmo1MXV6T2lobW1PZUVBUGYycmVuRGUraXVrcmc3dlMxelpmVUJmd0xhUTNRVlMyV2hiS014UG9SWDFINFA4QURkdi9BTUluZUM4ZVdLNHRFZDAzc1N4WC9ua0FlM2V2bHZRTkVXMzFtQTNVZ1NPUlJzd0J5VzZOazloWDE1clhpbUdUVDJqbG1qUzc4dGJmTzM1YmtMd0NTdlRQcldXS1drWVFkcnU5emVoVGphVGZub2ZMMFZucWg4UjJsNWJ3NWxlUUtzWVBKQTlhKzFuV3ovdFNHS1cxdHJnRlFKWkk0L0xGdXpMMEQ5R2IxRmZLc2ZqdTVXZDlPWTIxdGFwbnpqQkVONUNqcHVPVG12T3RNaTFqVUdFc2JYYlc4Vnp1VkZZbGVEbmtrOWNVblJxeitKcUtTMGZkTXVFNHhTUzExUGQ5YzFHNnNyUVhWb29FcTNJamRUOXhsSi9VR3VaOFhYT2kzTjNCYXdBeHM0VmlvYktJVzY0OTgxVThjUzNhMm1ub2p5ZVhMRVpIUWRBYzRDaysxZVVXdWx6WDhGMUx6QkdnR1pIT1YrZ1ByVzFOV3BKdVZyRVZHdWRxMXpyclBXZFQwcnhOSHBNTXkzRFBPc2NqcjN5T0ZVL3pyNkwxUFdMN1F0VTBheG1adkoxR0VySXBPUXJrNEJ3ZSthK1lkS2cwbTFab21uQmtIS1RqUHl0MklQWGl1NDhRWDFwZFcxaTd6WFBuUUlQczEyVnpFNWpPU1RuQkdmV3FkYXQ3YWk0eWRvcDMwM2R0eUZHazZVNDh1cnRxdXgwVmw0b2lYVUw2R1cwYVkyejRrWEhPUWNEcDYxNlBybGpaYVRiMlV0d2tMWFY3R2JoclZPREJHMzNRVC9mUFhGZWZlSC9HVUg5b2E3ZnhXYWg5UnQwaW5PemNRVUkrZE0veEU4MTB0em8xMDZyUE9KUzhpa3dtUWZQSnU1d3BQRlRpY2RXazR4bG9sdnBkdlFpbGhzTkJ0cFgrYjBQcGk3MFNEVmZBMm16VzhEVFgrbEpDMGpLZHp5MjByZENPcDhzbjhxK2FmaUo0Y3NyU1NTZXlraWdVM0x3eEtxNEkrVUV0bjZtdW4wYnhKcS9oM1ZMSnBOMGJ5N1lwRUQ0YkVnNVEvVVYxZnhXdjlMMUhUZkMxdGEyOGFKZEdScmg0MXlSSkdjSEpQOFdLOCtsT0xyS1VsZU4zb2ExWTgxQ1RnN1NUWDVueTZQQUd0UWVIckRXb0Mwc1VrcndUNHdRc2c1WDhHSFROZXAvRktmVHBKZENqbWI5Ly9aTm81a0lPZDZqblB1YTZud0JlWEdnalY3T2E4V1cxdkVTT1N4bmpJUWtINVpFZm5hNjE1NzhYZGVPbCtPNTdSN2NtT0szZ1ZHSSs4Tmc1RmVyU3A0YXRWYTUydDJ0RGxrNjBLVjFEbXZaTmVaNEpiWEFlNmVOVmRuY2trQnNacnNvZFN1WW9ZSWhjOEtmdW5hVGc5czExbW5YZWxYSXNia1cwYmx6MVZlVXdjRU5XaHFmaHJRcmZVWm5lQVJOSU1xRzZnTjNBUDg2Nlo1ZlRtMG8xWVB5WnlyTUpVL2lwVFhvZVU2enJTcGZUcHYzSElBNDlxMmZEMXpmUlgwN1J4akl0L01WR3hqUGJyVzYvaGEybW1XVVRoOXVQbHhna0QzcnBCcHZpN1VkU3hwZHZiSzNsL09xcXZ6cWcvaTNjVnkxTXByeGdvcW5lL3dBL3lObzVoaDJuSjFMTHowL000endocGR2ckYzZW5VNEpZWWlqdUpRTnVXSFphM0xqUllkT3NMMllSZWNiSjBNVXpaR1F3M0RJcnBiSzlhenNGa3U0akxlbWJhWXdNSkVxbitFclhFK01QRlY5ZXRld1c4TXhXNFZTc2VNL01PQ01HdkxsUnJ1dlp3Y1k2YWRORDBJMUtQSW1tbXp0WmZHTm5yM2gzVDd3YWNOTnZkTVNXT1R5aGlDWlpPUTZEK0ErbzZWNW5jQzh2STlDOHRYZnlWbUFWVjNZS3R2WEdPdldwOUMwdTZuOE5hbDV4YnlJdE5aZ0EyRDUyZnV1blVmV3V3K0dHcFNXK3A2ZGVSWlNlek1zcndad2hReDdlZmYwcHpvUnBLYmpIYTlsOGc1M054VW5hOXJzN2Z3bnBjVjFIZmFyZDNHM0ZtNlRJR3dWRXB3eFk0NDlxNGpSL0VjZW0rSTdWTktzSWt0ek1JNHA1VTNQSXNaNVBQWTF1SnJIN3k2UzNrRWp1d1NhSUpoSmxjNU9mcFdUNHdzNXROOFNlR3BOaXJiRldFY2lIY0J0SXlweC9GVVVJSlNWOW5leTlOUlM5MVE1ZWoxZnFkLzhBRk9lR2Y0MWFqS0FnTGFRTXAzWENkYStLZFprUjdUZm5MSElOZlhIeE1hTWZGWFVOUjh4VWcvc21OR2Rqakx0SHdPYStjL0NObG9HdGE3cDlocUV6TEROdlV1amdiR1BRdG4rSDFyNkxCeVVjQlM4b0k0c1ZCeXh0U3kzbTdmZWRUOE5MaUdLSXlNU1N2QkdTZnB4WHVkcnJWM2JNWGprS1NGMjVKeURucHhYenhxMmdYZmhMeEpmYUpOSTI5WkFGbEFJVjR6eUdBUFhpdlRmRUY1SnBQMkl5K1ZLanhSbDNEYzdXNk1BUDFyd2FzZWFzMnRWTFZIcVllcTRVK1Y2Y3IxUGI5RThiUEN6MjF4STVZTG5QVEIvRHBYb1Yvd0NMNzhMYlJSMmJUUlNKL3JJemx1UFVkNitXZFlqbXQ5V0xBdXFQYXhTNUk1SVlmdzU2ajNycjlCMVptemJDUUtKVitXVGRnakF6d0s1bkNEa25ib2Q2cnRPMS9JOWEwbnhEQWRVamtaMWpaZmwzRmlPTzRIdlhzSGlSN0NPTFNiMUp3eXl6czBnalVmSmdkU0srRXJhKzIzckFTamc1d1A4QVBXdlFIMTU0L0lmN1NVWk00N2pIcGcwT2kzVVVrOWxzWlRyMnB0UHFmWGxqNG5zSTNVd1h2bUE4aE01WUw2NVBRKzFhZDc0cXVHZDJTNElSMVZUQnVCR0IzWDNyNHR0OWEwcFpTd2FOTThzRXo5NnRqVHZFYTNFektEdVRKQ2x1dForeGQ3M2FNNk9JYmFqNTlENlExYStXNFdKMmxLckdwRXNRR0MyZW1HN1o3aXZDMUNDK2tsV1NNWkhDY244QWZXc204MTRLSkVlUThuNWhucVA2VnpPb3pXVVdxTEphM0RHeTNBbDVPV1hJKzdnZFNLN0k4cVN0MU41U3UzYzl2czcvQUZDOW5oc3JhM1puaytWUWd5Vzkvd0FLbytMdjdHME9XTzBYVTRyelVHUDcyM3R4dVdMSDk5K21hNEtmeG9zOWt0bG83TlpwdEt6VGs1bmw5Y2tmZFgyRmNmYmFldHFzZHlyQjQ1ZHczamtsdmYzcmpyWDVXOXQ3THVaVnE2alRhajd6dHYwK1J1Uno2VnFGcEc3aVFaa0RDUmNaQjlEbnRYakd2eDJzbC81VWNpeXdoOW9jakRBbXJQaDUydUlydUhiTUk0SjNEU1Jwdnh6a1pIVEZiN1hOdnAybnptOTA2RVNTTmlOMU9BeDlXcFU0T0ZWNnQ5bDZrUm56MDR1MjZQREk5THRFMXlCSkJPaEVnTVR4Zktkd1BCR2UxZXRmRlRVaW1sdzI1YkxiUms1eVNUMU5WOUJmN1JlTk5zVm80RzNuUFFON1Y0LzQyMUp0VjFsWW9nemM5QnpYMitGbEtHR2JmVi9rZk5ZaU1hbUpqRkw0ZGZ2UFZ2aHA0bCtITmxaNnErcHdsYm9hWktsdGxBNk5PZUZKejBydC9EZW5mRFMvOE82VkZjYWpDdDdxR3IvWjU3aHZsK3p3NHlXeDJ5ZUJYeUJGb3R0THZVbDRuVTRPVnlPS1QvaEc3Z1c4c3FUb1BMbFVFYnVtZWpWdERId2paU2pGcFhWbXU1dkxDcVRiczAzYTdUdDhKK3AvaUw0SmZESzMwbTluc1BFU243UGJ1NmhaZ3hrY2RNNVBUMXI0V2dzTlNTWHlJcmkxWTVDdU53eXc5ai9Xdm4xNzdXU0dqTjFMaHM1RzQ4MW5JdCtyNVYzRFk2NU5YWHFVS2trMVNoRDBNc05SblJjdjN0U2FkcmN6dTE4ejdHMW13MWExdlkvSXRralFLb1lpVVNaOVRrWXI5UmZBdmd1SHdKNEV2THQ3dUdWdFdsdEpZWGNZVW93NEJIWUd2d1JqYlhwQnNGektkM0FHNDhrOXEvYnJ3aGJFZkRIUWRCbXVYZTVzMFM3bWFZbGNNb0xiQXh6a2VsZlBabFBETER6VVlwU2s5TGRPNTlibE5Ldkt1cDZ0UVh2WDJkejY3OE9UYUt1bVN6eFJ3ckhMYzduY0FmOEFMTWJqZysxZUVhNXEwL2pON2lQUlpBMGpnK1p2eUZRTHhuSTZDdUtmeFBjV1h3NXNHdHJXUzR2THBtVkxlTUU1a21iSFAwSFd2WWZocEJwZWhXOCtpVzBRbXZUR0p0Vm53UnVrazVXRlBZZDYrSFZPOXJ2WnEzeVB2Sno1YnRLN2NmdXVmbnplZUMvRWtYaUcxdHJ0M2lRemJ4SWZtUmdoM2ZLZmZGZnFuNGsxZXpHamFKZTVLd3RIam5wOXpqOGNpdkZ2aWxyMmpRbit5UE1WTG94N3JsMVhjTFpXSHlyN01mMHJOMTIrbW4rQVZyY1FuN1RjNmZHclpPZm1FYmJTVCtCcnNWNmtha0pXK0hUN3ppbE96cFRzOUo2L05XUGpYeFA0ZzA2NDFDOG10Vk1VYktRVnpuQjc4bW9mZzFCcU12eEVzUElqTXF3cVozY044c1l4Z01TTy90WHlUNGsxUFVXRG9IS0NWaGxkdVNjbkl4M3J0dkNGcHE4VjR5RzVsdDVIaFBLTTZGdlJUdHgrdGVqOVg5blFidXRVSllsU3JwY3IwWi9RbnBEdTEwaXVBRG5jNVk0YmdWK2J2alR4VExjL0V2WElveWZNaXQ5Z1lrQUwzNmV2TmVXZUxvaG8zZ2czbHhjWDF4ckU0U0RUMDgxOTBRWDcwaDU2RHNLOEs4RkpxdXE2dEZjelN5ejNzc2pMSUhQenRzR1NUK0FybGhTVXFVcE42SzlqWlBreEVlN3RwNWY1bjduZkNuVDAwZndWbzhETVE2Vys1aTNHZDUzRS9yWGxmaDJlKzFieGI0cDFWUWZzODl5SUlUMkt3RGJrZmpYejc0VS9hTzBUVlV2Tkt1TEdXeXU3ZXo4dURMQjFtZGZseHgwOWErdlBEbGxEcDNoUFRvbGxIRVc5blBkM080bjlhOURrbEJKU1ZuYTU1a2JPcEthczA1TkhTNnF0eStpeTI4TWlwTzhUaEhJeXFFQS9NZnBYNUsyZWt4YWg0bmxWQ3JoWTNYZU9qdWcrOGM5aWErNGZpRnJzaWVCTlllM3ZHamwrenl4cE1wd3lPL3lnOGU1cjh3cnVXKzBhMXRyRzZ1SmZ0a01hbWVSQjhpRmhuQmZ1Mk9TSzVxa09lTHRMVzFsL21kVk9hcFNhYTgvK0FkVG9kM0ZONHIwK0dhUlUyT1djazRBVlRYcDNnVHhISHArdTM1dXA3ZElmdE55VEpLa2piMGw0MmdvRCtGZkZkelA5b2VXN2lrOHdzVmlSc0hIQjY0cjdNOEM2eGQ2aHFpYWZCYllJRE8yWXdFQkM0VUJqeUNUelcwb1I5bitub1l1cTVWRTcydHQ2TThtL2FPMXpUNXZEZWxwRGYyMXc4ODVHMklzREdpRGpLc0FSbXZ6VFRjMkZ6OUsrMWYyaWRVVi9HZWwyc3FNWHM3T01YSlk1TFNPZHpmcFhoQjFMdzdMb3Q0d2hTTzVGd29pQVhyRVIvT3ZxTXZvcFlTUHZXM2RuNW53ZWFZaVU4Yk44dDdXV25rZDc0UDhBRkZoRGNlRzdPQ3pQbVJYMEptWnNmTmhzL0w5YS9TL1c5QzFHODFlNG10RHVpbS9lREhCQ250WDVRelczaDJ5MTdURzB5OWt1QUV0M2xWZ0JtVTRMS3ZzT2xmdXhwTnJQSm9kbEtrV3hpb0xCanlwUGJQY1VxOU5SMXZxWXhxT1NqODBmTUVPbi9iTHlNTHZFNjRBWlRncUYvd0E4MTc1NEowL1I3M1VMbDlhbTh1TzFRUEVFYmNaQ0QzRlorcTIxMGozQ1c4Y1lrbUE4eGxISStsYVZsZTN1aXdTV3NWcmJFem9IRXJKdWNIMTNWNTlPYXZyc2RFaytXU1hraWJWOUdzN3E3bnViR0Jvb0VrVTdaRVpkd2JvU09tYThlMWlhNHNyNHRDMkN2M2dNZ2NkaUs5TnU5UjFTZGQwOGwxTXhLaGhuSXdlTW5IR0JXSnFlbUd4djVZM1JpWWdQbis4cEo1NDdZcVZLUE1GdEZyc2p5R1NTVytoWlhZSTdNVytYaGVUNlZjMVRSNVlOTDBpUXFCNXNwMkpuNVNxL3hIL2FKcjBDNTByVHJtNUVpTFBHU2dMS01ESkhmNlY1L2RCNDcyM0xiM2hoa2JhdkoybXFkbXpKTjh5djh5aGIzT2twcUpOMVp0SWR4TFJ4dVVLKzZuK2xkdlorSTdheldYN0xwNkNhVnp0bHVQbmRVUEFBeDM5Nm82UjRrbnRZNzhTNlhheWZheVFKNUZ5d0k3ajB4WEg3NFd1QTJHVEJQUDNzbi82OWEyMFhrdTR2aWxLOFhaV1MxMGZ5T29iWHZzdHRjV3FSZ3ROTXJQSTNKWFBiM0ZhTmw0ZHU0Mm5XU1lXOGt1WGh1Q1NZMlhIM1ZiM3J6V1ZGbHVuY29XTzRIYU9BY1YxdmlIVkJkd1JiQ1lvMENnUWdrZ0h2eDYxbTR0dGZpVkp5bGV4a285d0luaHVOUUxSS3hkWXo4NnEzcU1kRFRkT21FTjRKWTEzblp4bGVoN0g2MURKWUphcUJ1Ry9HNXNISUlQUWMxVnVNQzJEbENJMmNoV1BHU1BRaW1rdmtadDYvTXMzVnhISmNGdG9pTFpMNVBWdlUvV29JSlowS3hOQ3NpbzVZOXh6NkgwckppbHRZeVNxRjl3SVpXRzVlZnJVU0pNcGtkWENoUUQxSU9QUVZhU05VOWpxQmJ0Y2k1bVdOVWo2NDJsakg3Wkhhc28yZHZlV3pUYmtSNDJVTG5KM1k2akZmVFBnVFU0LytFUTFDM3ZJYmFPTjFMSk4veTBsSTZManVLK1dkUXM1b0xxU1JGZFkyWXR0WE9BcC9Tb210VTFJelUyNVNYTGF6Vm4zUFRyblZ0SU9pMlVGakcxdGZDWEpjTVNaRDI0SFRIYXVTdXIrNER2QmN4Qm1ENWJma01EM0dmZXNTMEtMZnJ0bHh0eGh1aFBjWXJyZGIxWTZ2TXNqeElYd3NaWWZLU0YvaWIxTlpwSmE5YjNOTHl1ckpXczd1K3R4eFRmQ3NnTDcxWEphUnNyMTRDa25vSzVHVldubkp5TTkyQjRHZTlQaGQwSmpIS2c5Q2NnVjBWdkJHbHRLL2w3bzl1V0k3ZWdGWlMwc2J3dVlVVnBMYlRUS3poRUFYY09wYlBmM3JaK1g3Q3NTbG9tbWZQVDd4SFRqMHE5cDNoZlhMN1NyaTl0N0ozZ2lmL1hBNWI4QjFJOWF1YUJETFphdmJLOHp0TW8zcHYybFZic0JXYzNvK3JYNkZVNUp1MmphTXA0WW8zUnJzT1FSODVCNUlBNEZab21RUnlKS0dXUW41VHUvaEhRWXIySHhMWnc3cDNkbEVqZk8vTzdlZSszRmVFVHN1N3pGeWV3SjVxS1VsSkxRSnZWRFpFV1o0NGxRbFY1Y25wbjIrbGQ0c1VjVnRINVlZdHQ1SFUxenFXN3gyZURCSXNxZ21TVWNjTjBHUFQzcmRoVmhhcVpKSExzbzh0Z2NFKy8xclpxNWFhUzh5TDdIbVJON0QxK2JzVC9PdXVNa2UxUXFKSktPVE4yR092MHJsVExPcllaTXQ2Z2piejM0cXdqNG1SbVJzQlNEazRINVZtNGQyVEdlcFBCNVprY3RJeWxtTzA1NkdxM2xPSlZMeWlVUzVLZ1l5Zzc1eDNxY3JHVmtHUVFCd000d1QvaFdQRExCQkxnRjk4aHhucmpQdjJGV3ZJcVVyTkhVckNzbTVJcGdDQ09TdVNmNlY3RDRUMGFXNGxRU1JsbzQwa0xjWTV4ajlhOFdNY2E3V2laZDVYNXdUMTk2OUcwTFh0UnN2TXRsWWtYQ2c0SFlMM1gwck9NYnlKcVNsN0tYTGE5anlSTlUwdTV2cnFHTzZqTXNjeFJoaklCSFkrNHJRZXkxaExZM0NQdXQxWUJuRVJZRFBxYStpUERmaGZ3M1o2dnBiVHJicmJ6VEZ2SlVETWp2L0FCU2s5czlxKzRkYlhUTFNBMnJXdHN0cEpBeVBHQUZDOGNGUU90ZWpUdzhwM2JhUnhUeFZsQzBiMzEzN0g1SVdrdG5wY3B2TjdDNDNBaVppQ2ZZWTlQYXZXZEI4UitNdFcxTXh4YWdzcnVWQ1F2OEFJcmY4Q0hlc2J4Um83Vzkwd1RUekxCTVVFVW1BRkJ6L0FCWjZHckd0K0hOUzhOTmJUMmtqWEVUQU9HaE9URTNjY1o0OURXS2NvVFZ0THY4QUkwazZVdXpiVHMycm0zcWwvclVmalA4QXM3eERETERaTENra2pRWWZjeCs2QTNYSHFLOU5rOEllRDdyVEx1WFN0ejdZOXdtTEhPNys2UWV0ZktFTmpkYXo0Z0w2bHFGeThheGhrVGVRUzMrMGErdDcreXVQRFhnVTNGdGRTRDkyQXFTQVlCYzlpUFN2WnA4a295bHl4czcrcDR0ZVVvMUtjSTFIR1M1ZEZwRm55MWY2dHAxalorVExiU0c0M3NkNEpiQUhjL1NzalFwYisvdExpNG5ReHh4VEFJZHd6MHlHQkZYdFg4TytJSFF2ZTJvVjVJdHdaWkJsZy9JempzYTRDMGdtMDYya1dhNElqVmd6QmVRTTE1Q2lyMmVqUFc5cTNGdE03dlZ0UjFEV3I5SXBwcEpabGpWVko1d2c2SDJOVlV1Z2IzeTN4QW9VNHdDeEpBOWZlc3JTSnJkV2xtam1iZEkyUTVINUQycXpKZXpOY3NxUnhrZ2dCeU9TUDVWbFVMakpKV1NzYkVOdTA0WmhJT0VMRGQzeFZxUDdWSzl2YjdJMmxtKzR6bmFxajFZbnRWaTBBdGtWQ1NQbTV3TTRCOUs2TzdqVnBDcEJYeXp0Um1JNERldUttTGNpbzMxT0FrVGU2cExncUNjUG5xUjdWMUVLUU41Yk1QS0E0SjY5T20zNjFweGFGQk9MbFd1a1JnQjVLNXlIeDFHZmVxU1JTeVFTeFJiVElwTzJNc0FNRHJ6NjAwL01TMzNOMjlsMGxiZUpsZnlpRUpKYm83RDZVTnB5cnA4d2t1ZG02RlpJd21HRE1leHJnTHpVNVFpS2tFTFNraGR1L0tBRGpuM3FSbnZHa3pNcVpWZmxFZUFCV2RwWE5YSmJlUnl0N3FjVnJLUVlXYkhERlZ6dCtuMXFuTjRodG1oWHk0NThrRUIzVGFnK21hN3F3bjBZWEZ1TDFHWkpIRzlkdS9PT21NVjBuaWVmU1h1bGl0VUFnVUQ1QW5jZE9DT0s2K1c4Zm1jY3A4dFJMbGUxNzlEeCt3Z2podDVKNUoyUXlIY3hBNDIrK2E3ZXdpamt0WTJta0tReU1RamhDYzQ3WjlhcVJrb2hLSnV4L0VlMmZhdW5pMUNUN0pFa1NwaU0rWkVyREs3eDNBOWF6Y1RWU2J0WXJTMjBUTWpKTVVDNHgySit2cFhNUEhjUlhVNFRyeU40T2V2SjU5SzZHNHZOUTFIVVpKYmw0OTc0eVFnakhIMHJZbFJVaG5qQkJqMjUrVWRUNi9oV2liVVRYZTV5bHRIRzhMbkl6aks0UHBXYkpITnZhUldWZ0IwMmh0dnZXMUZFa1VZNVVnbjVobnFQNlZqSlBDR3VDVWNJZUFWT1Bwa2VsWmRXYzFqTjgrY08wTVNxUXd5emJCbkZXSHVHaWtSeEVaVjRPMEhINjFkZ21sajNrVEdPYmtFcjNVOWlheVpJcENKUEtrUm1VYmp4Z1lwM3N5MlpoZ2U3bDgyT1RZeTVZZ2tZSjlCbnJUSjFra2FOR09YeUMyT2dOYStuaUo0Q1hPSm00LzhBMUQrdFFSUnltWjNSZ1NyQU1DUFQwclZDYWJMNTN4V3VGSzdSMXh3QmlzUzFkN2hKb1pZOW05Z1ZrUEE0NmNHdWl1N2xDak1vVGtZd2VlUjdWSGFwWnlXNDNQR3pINVN1ZWNudmowcFNWNVIxRFhYUW93TE5EL3kwVm0zYzhad0IwUEhyV2tsek9vbmlBSVZpT1d6d2ZZVnN2YlRXOFZ2SktZeTR4dFVIZ0wyelVGNUF6Sk5PU2dhUWZMR3ZiM3JSV3VZTjZMMU1obUNNUXpBZ3FOMlRrNDlENlZwd1hFYXFWNUdRZW5QRlkwVXNiUWdTTG5JQTZZb2VKQzhqb3h6akFBNUFQcCtORGxhU0hLelZpSzhnU2RoR09UMUpCN1YwOS9PRGFxanlGaUl3b0NSOGdLUDRzZnpxa2JXYU8yVmpHbzNKeTNHUWZXcmR2SE10dUhrT1c3SG9XSDFGYVRTdWhLVjQvTXJYTm0ycHJiQmlGM0g5NDZqRzBZNDZkNjZEVnJOb29Zb1FWWUtvQWIzOWVPOVVXMUJUNWNSVVJPaC9oR04vKzk2a1ZCTGR6eVJ4d3lXN09BekhQUUQ4UjJyRGxkMHhQV0puV21nYTdjTXNsdUYyb3czU2RGR2Y2MTlDUzJJc0lMVjQ1eXpNcEVnRFlBT08rSzhxMGkrMWEyWUlaRkVUdHlCemdkT2E5VDFPS0NTQzBsM2laMVB6b3B4djc5YTBsZHg5RFA0V3RUQm5lSzhqbWpraE85MUlJQUF5UFUrOVp1b1FTMlZsYXdmWmxDcW9ML05najBCK2xLYnk0VzRlTVJ3eDVrM0ZONExNUnp5Um5pdXExbVV5V3FzOEtSeVNZTHhFazl1bzlxNEZGeWxic3pyVXJXdGF6UjQyU2lieS9PL3NlaC9LcUhpL1M3Q0d5MGZ5WnJlWlROSExPemplb0I2cXdQcFhhTnBibDBuV0ppRlRHMVZ6ZytwcmtQRm43dnc3NUFSTjhrb3pJT0NWNjgrOWVyQ01GcDFzWWI4cjh6bXA3YndJTlRkcmF4aXM3dmJ2U1pCdWhPQjAyamdIMEZZbWx5aExwcHhOSklVYkRPUGtMYnZibkFybXJXL2dnbmlHMVdDRUhPQXgzZHVLMWJqV3Mza3F6dW5tRURPMVFuWCtkUkpTUjNLeld4c2FrTFcva3VvenAxdHNmRE03bnpHZFIySTZWSkRvY3JmWlpiVi9KZ0lQbVpBK1FqcHNDblBOVjdhZTJRaUpJd1dZOUNjbkJvbjFHY1FLSVc4czd5aFFnOUIzcHZkYTlCS01leHZTYU5mUTRtTCtaR1A5VzUrN3RJKzZSMXpYUmFXbGhBUTV1ekZKRWdhTGFjQUgzOXE0dlNiMjdLL1p2T01od0FNNE83ZDB6VnlLd0NTTzBqTDV1Y2VXRGtxRDEvQ3J2WnF4TWt1MjU2c3VyWDkwalNTM1lFWkpVOExnL2gxcW5iTFlGbjJ6c2NLUmxBQVZidHdlSzh6ampuTWdYYU1oOEJRYzEyOXBwMTE5cGxScmVSSDJCbDV4dUIvaXgzRlZLYnRxek5SWFEwcHBybUt4a2xMU01ZaDFCT1NlM0E2ZTlXOUsxSFdQc2tZVVJLN0hMS0V5ZWZRamttdWh1TEsxczdPQllaL09aOXhNaFFrSTNvd1BZVmo2WmNXVVRPc3dsY3BuTXFBS04zcXYrRlRmUkZKR09zR3JTdFBJczRVOXBIQVZSNmxzL3BYaSt0VzJxbVY1NXA0SkZrWUtTbnQ3WXI2bG0xU0ZiWllZeGxObTc1d054YlBmbXZPTlgxYlNXdHBKWjU0amNEYXIyeUVLY1o2N1IvT3RMTkl3dTc3bnpNdWxSTmVIYTJEa0hDamRrZSthN05OQVg3Ukc4YXliZ01qY1J0d1ByVE5TMURUL0FMYWR0bVlnNlpUSFFIMXpYVDJtdjJrbG5EQ3NUU09xRlNWNUJQcmpyV2J2YnVYSGxTS21reVdVMHMwSlIvTmpjNWM5RkJQOE9QU3VpdUxRMkpWMTFKcnh5NU9mSUVaVmY5NWVwcm5ZTlh2bzFKWFRralZSODYrWmduSGM5RFcwdXVKSlpoZk5kV1Z0MjB1TWtlM1NzN3ZzQzI4ektzcjdWNzNXTGkyVFNYWk5nTDNCWUtBZlFnMTF2OW1hclpJcVBhK2NXeXdLdjBCN1ZOYmVLNC9zYzF1MFpQR1N5TUR0ei9lelZML2hJQ25FY2piUjNDNXpVNnRiRzZTdGR2VS9ObTFqdHpwdS9hWXNzUWt2WDhNbm9hcnlyZERpU2VXZFZYT1MyU285ZndyUmt1SkZCc1VOc0lKSEVzWVk3aXJZNmtkajYxanlMNGxsdTRtbDhnQzNCQ0ZkcUFxM0hOUnE3NnBkZFdZZTZySFU2RHBtbTZ0SmMyUUhrek92N21jdnVHUjJjZGxQcjJyem0vOEFEdC9hWGswVndURk5FK0RrNUdPK0dIR0s3M1RyQzhSVnU0U2lQSEtRN0tjS2lqcU05eWFYVmZEMm8zeXJKSHFETXBKSlNSVHVRZW4vQU5ldFl0S2U2c3hYU1d4eG1yMnUyS0VSWERzckwvcTlwVlJqdms5VFhxZWlXZXA2SnAxdkRQWWh4TVBOTEUvS3BQSURnZFJWQ3owdUdPMEVodG1hYTNjWmNNWFJoMjNBOUt2UStKZDhSZ3Q3QmJQT2ZQdUdiZVc1L2hVOEN1YXBKdFdTdXI2OUM2YzRweWQ5ZWgxY1hoVzQxdWFPV1dkWkhFaFpraGpJOHRjWjR6amlxR3JlRm5uYTBodEx6ZTBaTHl0SWNGVno3ZWxhbGpxMDhkdEp0dTVFTWhBQTUzWS92TUIxeldUQmRUMjgwMEVyZWJETVBrazNiZHhKNUFIWFB0WEtuSzcxMjJSY3BxM3J1ZVFhbFoyamFsTmJXYU8wWk8wa0RKa1lkVzU2VnNTUVd0cnBVQWdSeGNwS0ZtVk93VTV6a2RjMTBXdjJzV215U0x2TUtsUXpNVitiNXU0UHY2Vm02WGRSUGNKSlA1Y2R2RUJreUhhMGc3Y2Q2N09adUVXazdMOFRuaExYVXl0U3VyaEx5TkpaNVZTWlc4bU52bXdwN0hQZXZVTkh2dE0wdndscU5oY1dMU3lYWUhsRFB6Ujl5eDl6MnJ6RFZ0WTB0THVTZTFSSGtWaHNkeGtSL3dDNnA3MVEwalVMcTdGMDBzL216RWtqdHg2NW9sVGJwSnRXV2wrbXBmT3RUWHN0TzBtS0h6NzZ6bmxEbmlLT1hZVVVmM2lRYStyL0FBNTRVOE9hcG9FcjNlb1R4V29JUDJPZFVjQmZXSmxPVkkvV3ZBZkRaVTJOM05meWd0djJ4QmdDN0grNkQzSDFydjczV1liUFI0a2x0OXR3MGhjeC93QURBRDVXK2c3MXcxK2QyaW03dDdyOURyb2NpMWFUVnRqdWRZOE0vRDNUdFBobDBmVlpMMldQZHVqWUdQSHBoZlgxckwwdlg5WHVkRkRTSXErUTJCNXB4dVFub21lNm12bml5OFNhbTF4TWt1ekEzU01NQWdmVCtsUlcrcTNFOEc1TjhkdUhJSzhrdG5ub2VCV1hzWnBXYnUvNW1YS1ZMZGRlaDd2ZHRySWxzN21hV0tVbDkza0ZBekJGR0F4UFg2VjZiNGc4WDZCUHBGbEUxdThqV2JHU0VJZ1RZN0RCM2UxZkpkcERyT3I2a3JKWkNlUmlGZ1ZjcVFvN2xpYTdTLzBqVlZ0L250ejlzamxVc3BmNUFnNmNnODA1VUl2bFRscjVHYXF0TGxTV3BoYVZwMnJYRjQwenVvaGx5eVN0bmFjbXZSMTBmL2hJcFhqdXRSQ3pwSVkvUEs3Z0IyUW5xQjcxajZSNGhrdTduVGRPaFNKVDV6R1ViY2dObmRnWTdmV3JNMTFjSFZieFgwNTQ0WVRJOXd4VTdTU09DcDlQU3RIR290WDd0bG9OeGlvcFh1bTlUcy9FSHc3OFRhSm9GamRXa1FsV05pOHpZNVRjY2JteHdWUHRYSGZFVFRvYm5TZE12YnE0bEYyNTJxdzZZQTVVNDZqME5McmZ4WjFnWHNGamJYODZXNndyRzBhdGhQTHhncVJqbXVibjFhMHVOSnViT0dVZ3h5cTF2S2NNRmliN3lBZW83VmxENng3ams3UGNLbEtrNHRSZC9YeVBLcktiWElwUExnbmtDQS9PeFFQbGY5bjFOZHJaeStKWWJvdGEzY2R6RVJsWkl6c2ZIZFNwNUI5cTQ2MFdNM0FjU1hEUVJPZHk1Q2w4ZlRwWFhQcVlrMCs3bWhzSWJReHNzZUFkeGNOMkpQSlByWHFPdmlJMnRKMi96UE9uUXB5aFpwR3ErdTJjVTVNbDV3Q04wYklRMlIyeDJwbXY2L0JyRjFCY1FHMHRoR2lvc2FodTNjOTkzcWE4NThYVGd6V08xUnVrZ1ZkNXhnRWYxcnF2Q2ZnZlU3cUs0bm0rYnpRQkdxbkxFWndTbzlhdDFaT21uS1h5Wk1hTVZKcUsxSmRQdnRNTjlQNTE4WkRJdXhtZ0pYT2ZYUFd2VFlkTjB4SlpmN09pa1dOVTJOS2Nrc2NjblBwV1RGOE45VnNQRWtsaXRwTHdpeU9YVUFLblVNVDI5NjdEeDhYOEw2ZERZelNTSkRlQlpZbmhjZVprOG5yeHR6eFdVYTlQMnNZdUNuZm9EcFZKVTVQbTViUGNvbnc0OTVacmRXYmo3UkdySks2NUh6cHlEZ2R5T3RjZGIyMnEyelhObmRSckpaM01pdXlsdm5obEhTVlBmMUhjVjZmOEdvOWFYVzdaSW9UZFdqcy8yaVp1bVhIeWx1MlIwcmx0WHY3MS9GdDVwMXZ0elpYTW91bUl5STF6a3NUNkR0VzBIZzVWcHdsRjZKTlc2YWx6aldqU3B6akxYWjM2bkplSU5NMVRXZkZOd2wzcE0xK29zMUVCU2Z5aGxGeVFPRG5Qb2E4VGJUOUIvcytTN1UzVm5PenRGRkdWRzNldlZXWWRCNkd2dmo3VnJPa05kMjl5dHVXbHN3NGREdkt4U2NxeFljS1QycmdrdHRIdTcxbzVnalJKYitkS1NNZ2VoUHZXc1hTVUVvenRheXQ1RzAzVTVtM0R1L002Qzg4YXZxK20rRjRia3BJaldQbFhNVnhFa3U3eXZsM0tTTnkvVUd2T2ZGSGhpVFZMbTBhMmpqalR5aGJJR08wS005UGV1dDhYTjRDaG0wdlQ3UHpoZENFUEx1T0VLeURLN08vMXJ2cnBOTXNOTnN5YnRaTG5jc2l3a0ZpZ0dBUGxIWE5lYkxCenB0VGkxcnJ2M042ZUloVmkrYUVscjI2bzY3WC9BQTdIZCtHL0JzRjJJWXBJVm0wMHk1eUdZcUNoT09nR0srSjNpdk5PaW1lWnZudEdaR3djZ0VuYUNENkd2cEhYZFU4UUM0bjhtNEN2TmRlZXNjc2V4b1pYVERBS2Z1OGRLK2JyYnd0cVVDNjdaWG9ZaTdrVjgvZVpHQnp6N1Z2VHdOZVVicUxhZHRsOTVqaWNWUlVyWHMxM01pTTI4Y2Q1SUpXRFFzbTVoME83bmpOWlYzcVQzZVpZWkgySVZVbGh0NVAwOWF0ZUlORTEyMTBxRzB0dEpNdHNKREpKY3hodDhqOU1FTjJBcTdwTTFuRk5kMjhzRHJESWtEL09NYlRDTnhQUGMwU296cDZ5aS84QWdHTG1xbGxmU3hQcTlyZVdPaVdONDEwRE5jTTJFNmtiZTVxNTRWdko3bTV0bzF1WVZuTWlrRnZsVUxublByajBybS9GTjE5dDhHZUg3OC9lTTE2SElHQ3FseHR6N0N1eCtFV2syRjU5czg2TVNYVXNialR1NUVzSTNGdm9SeFdFb3YyRW05MUpyYnN6U211V3RGSjZhZmtmWS9paTU4S3ZvVTl2WWFWYlMzWlVTM0FCSWFOSEcxcEZ6M3p5RTdDdmtEd1RleFRTYTVZWFJMdG1NcUQwR0R0UDB6WFZhbGM2L0hQSGMzU01scEdvRXJjTGt0MEdSNzlxM2ZDMmxhWHFtamE1ZFJTdUowbWlsblVydy9rOGtCeDkwKzNldk1qSDJWT1hOZDN0cjJkejFxa1hWcVI1YmFKNmQxWXptMHlEUzc2M3RTSExPNVdSaGdsV3huQngwNHIxL3dBTVdNK3FlRkpJSTRFZUZOU2I3VEwvQUhFVmM4TU8vb0s4RXVQRmZoNmJ4TGZKRkRjUzNXcUVSTVBPQ29Ob3dDQjFCTmUrdmY4QS9DUGVDNzd3N0M4c0VyS3JPenJ0WGM1RE0vcnlPQWFkWlM5bWswK2FWdW4zc3lwVTR5bEs3OTFKMy95T0YrMFd2aDN4ZWxoQmNsdE5tbVFpT0pDQThrZzU4eGgxSTlPbGVHZkVHYlhMenhFTFNWZDAwOHA4cFZRQWVXcHdwd3VBSzdLMThTYWZlYTNCYTJscDlwakZ3ak9RZHJNNEl5NFBZQ3V3OFkzVnRvdXEzczdsR2RKVzhvRmNGUTNKQXIwTURocjE0T2NiZTdxMzVmcVRpYWtZNFo4bXZ2V3NqelBXSGc4T2VIbHRneW1WdVhQZk9PYSthclZIa1o3bHlkOGh5bzZjVlByT3IzZXU2b0E3NFV0alBhcDdsMHNrampYTzh0ajV1U0FQV3ZvYThvdHFNZHVub2VQaDROZTlMZDZ0K1owaVIzUGtNeGlVUkVBNXp6bjByV05qYzZiWVEzVnpiazIycHd5ckY4M0pLSEc3SHNhOUsxL3duRGJhUnB0M2EzREFYOWtKb0lwT0pDMGYrc1RIc2VucUtiOFJiYUNTNzBuVHJPNkd6VE5JdGc0WTRZUEtON3NQeE5lUGVMZHU5Ny9JOVJxMS9rZk9iSTI1Z0F1UndjSHZXeGJXbTUxWGs1L2xXNmRPWm9iWmxlTncrVnl2eTdtWHJ6NjFBcUNPVG41UWh3ZWVwcmFVcnJReTViSGU2Tlp6VGZaYk5vMDhxUzRWMWJBM0RCNXlmU3ZyVFVQRWw5YjM1Z1VZamxpV01LQmtjOERhT3VUWHpGNElEWE9zR1ZXQjhoQzVPZUFPbU1HdnRYNFB5UWFqNGl2TDY4aWhtYTBLSkVyZ2JWY25JWUErbnJYejJMc203OVAxUHVjcjB3MG10NVMwODFFKzUvQitreDZOcE5wUExBVHFCdGdJWWlNaTFqSTVadjhBYmF2TUxueFJaZUJOQTFmVzdtTVNhaHFWejVlbndrOHUvUU8zK3l2WE5mUzFnOXNZMmFVNUVwSmtrNnRJM29QWVYrVi94bGt2TmQ4WFROSnhiSUN0c3diSVdOUmo3dmJKcnk2Y1lxckc3VnJNOU9YTzRUN3UzL0RIbCt2NnpxY2QzZXlOY1BJMTdLSHVKMitZczNYQTlNMTlrZkQyOHVMMzRjNjlwN0tXUjRaZ25zR1RPMGZqWGlIaC9RZEYvd0NFTnNybTRTZWU0ZTRlTmlEOHBWZWhBOXZXbTIwdml0RzFIU2RJMUJZNFo1QUNod3B3Qmo3M1VlOWE4MFpTY1Uwbkc5NURsQnFtcnEvTmF5UGx2d3hiMnB2cGJpNlVOSkF1SWxia0JsL2lJN212ZFBCOHNsazkvcWw3SUVqMzVhWmpoaXZwejBKOXE1WHcwbWhlRjlRMU81MS9UN3E3amgzcEdJUUNpeWRuYkpHUm5wWG5QaXI0Z3ByRmpaMmtWdTBWckhQNXNpOURJd1A4aFhvMUlWYXRYbFVIeTJWNWRMYjZIRkNyUXBRNW5OYyt2dStmbWZiZDFJdmludy84amMrYnZSSEFMTGorNHc1NTdpdlBQQTJoeWVGOVcxL1VOUmxWbGl0U0xSZU1reThGdWZUb2FkOEQvRUoxVkw2Q1RidnRTWGlVbkRQRWV2NHJYdmQzTm9rTXQxSlBKWU1JMU1nZTVVTXFyL0YxNlY0dFNkV2xWcVV1WFIyOVQwS2JqTlU2eWVxdlkvSmkzMTJYU1BIQXU0NFJJRXVDSFFjNURua2ZYbXYzNXY4QVZvcmJ3WmIzRFJsV2ExVGF1ZWhLNXhYNTBlSy9oSHAydmVLTGZYdE04VmVIemFUcEU4dHZhN3R5YmVQdVlHZDNjOXE5aStMUHhRMG1Md3RGWjJGaDlsMUNBcEVaWXA5OFJHTnArUnU5ZlJWcTBLc0tTajhmTGFTZDlQSThqQzA2bE5WT1pOeGMyMDlQdlBBdkZQeFp1WUk5UnNKVVNXMGRsVXdiZVN5SGQ5N3FCbnJYQStHVC93QUpWZVgycGVJNWdrTG82MmR0dTJvUjNaUjZqMTZtdk1OTzBhNjFYVVVpSjN4cCsrdUhQYkp6Zy9XdnBpdzBxQzY4MUJHaWZ1bUNFOGRQU3VXdEtuVHBXV2p0OFMzU09oUXFWYXFsTFZMWmQzNW5nV3I2eDRkME9PeHRwSUhLdk1HVGFNbFkxUFg2c2Erai9oenJML2I5U0ZodSt6dWtNa3l6SDV0eW5JS0VkUHBYd3o0NXNQdFBqUzJzSUpENWdXS003MjRERTl2UUN2MG8xRFR0SDhDZkRlNnVJNzRpZElOelNia2NTVE91T2c1SHRYUlVqQlVxRVU3enFKdi9BSUo1MUdjcFZzUk9TdENtMHJyMDJQeXErS1BpRTY3NDQxcTl3UUpicDhBOWd2eWdmcFhqdk5UelN2Tk04akhMT3hZbjFKT2F2eFJSRkN4emtkcStyaWxDQ1haSHdrMjUxSlB1MnpwdkJrWG1lTE5HWHkvTXplUkRiNi9OWDcrMlVtcHhOZHRITVM2c3V4Rys2b1VjNUh2WDRMZUZMNU5QOFNhUGRsQUZodW8yYlBQQU5mdE5Qck45cXQ3SmEya2IvdTRSTTd4dHdWYnVSWEpYMXM5RlkzaW1veHQzZC93T2sxYnhYcFViRHpvMWE2STZ3dG5CUHJqcUs2YlFycVRWTkxKbXROdXhnRkpjY0FkOGpybjBOZUZhZjRSbThrbGx6RXhZeHlNL3pNMmVuSFBIclhiNmJmUmFTSVlXbFppWlNGUmU1YmdrMTU4dVZ4c25kblJCTG1hdWVrWG1tUlhUU21OaXFiTnBSVGpKOWZwV0dMYlV3VmhqdWd5T0NDcDUyRlIwNXJyZENlSVJYRWJTbmRHMi9ucHoxWG1rdXJ5emsrMHVaV2ltVTRWTm56RURuTll4ajd6VnpXVm85TlB2UEw0cm0rc0d1a2tnWjhvVVJTZmxCUFE1cmoyYjdLck5OQ3JxVk9Wd1RuTmRQTDRqdFpycEQ1dm1TSWpiaHR3RDlSNjF4TjNxTXFLUks3b2paK1haa1lidHpYUktMVmtjN2pIbWIyMElqcGMxN2EyOFVFaVJ3OGt1NXljbnJrZHE1KyswcHJHVmtrK2NyZ0t3NURkNjZDM2ppaml4TDVxN3Z1c3ZiMng2R3NpOWtlNnVJa1ZYU01mZDlUampJL0d0VXBXTTlVOU5qS3VicU5VZ1pVVldPY0tCakdQWE5NMCs5bXQ1OTZUK1ZJTWxtWlF4NSt2ZjBxcGYyc3I3UzBoWm95TThnbjYxM2VnNmQ0WHY3dU1heEtZSXNOSXpnOHVxOUZBOWZTclVWWklVbXVWdnlPSHVYdUxxYVY1cHQ1Ym5jd0F5UHdxakJwOXpmcTBNYnJpM2phVWhuQ2dLT3VNbmsvclc3ZngyTFhsNHVuUnlOQUdQa2h1WkFPMmE1ZExhU050b3R3c2prOE1Nc0NPcHgycFJWaVlxNkwwY0RJcGNmTnhnWTZjOTZ1eDIwYlN2dmR3MjNBVUQ1VDdNZTFSWFVnRnZIc0Rra0hJWGphUjNyYjBpZVJOT2VPU0VGb3lKTUU0WWducUJXTXJsM3NkZmFhbGNXeUNDV1QvUkVWZjNlRkI1NXdQVWU5ZHpyUGpUd3BmNm5wMHY5aWt4VzhSU1dKVytWd0J4OU1WNGk4c2IzRWpKRVpWT2RyT09NOVNENlZpczhzU3FXUUJqa0VnOUEzVG4ycFF1a3lmWnFWbTczU2R0YmJselZJcmU3MU80bHNvQkZGSXhNY1FPU29IOFBxS3kwZVFScm1QYVkyMmtIcitGVExFeWZJcTVtTFpDcVBtUDQxZXNmbmtEU3htVUVrTjh3emtkdlhtaG0wRXRpZTBqZVV1R3lNY2pqSFR2VnE4anViZTFjdmRvNGJsQXBCVDhhejc4cTA4aFNNd0tRTnFGdVZIcG1xOXNFTEpHM0pBeWU0ejdWbTByWE5ibmNycmZpYlI5UFpZSG5oU2FNYmxLN1ZQb0JtcXZoL1hiT1RWWUh2OEFUREtxdCs5d2R2Qi9pVSt2dFZteDhWZjJsWjNsZ1pFbGhSQVEwaDVSbE9QbHoxckJ0bTNYUWlpKzZmYm9CM05FNHdzMWJkYTlES256M2sya3RkMTFSNno0b09rUnlKL1pWNGs4RXFHU05XWE11N29VOXMxNGJiYVhjM0ZzYnFaV3R4R1Q4aFhERUhzUjYxM3VxMkVMNlpiRzF0L0xDQW1lZEdMRitlamYzZmFxYVh5ckIrNnNwQ2dVb0dPWFVkaWNuK2RZcUtVZEN1YVR0dm8rcHowYzFpVDVrcnUzYkEvUW4vQ3RjbkpqOHZhM2NrNUdBZTFWTk90b3BZUVpaSXRoUGZsdnlyMFRUOUxpdVpWaWl1RlY4RnNFNHdCenh1cXJxTGR6b2F1Y28xdnRWeXpaNkhianBWQjJIREVmZTR4NmZTck4xY0xzS3hwdUM3aVR2NU9Pd3B0aGFsN0dKcEhHVlBBOWo3MU1pRWtScXl4eFNSdHQvZkFnU012VDBJOTZndElyV082YTNtZGdXWE80ZGMvV3VobFd4UUJYaGFVTWNZQXlQYjhxNmUyMTg2ZkY5bWlzcldkQmh2MzZic1o5RzY4VmUraTB1Uk5ON0k1R0dHYVdYWmFydlluQUxnRGozeldsbzZpeDFLZVM5QlZSR1ZESnp0ei9BQmZTdnBKYnZ3VGNhUUxpOHNJdk1iaFJDZHJQNmtmU3ZEOWYwM1JHdGx1Yk80bFdQY1Y4cVFaS2UyUjFyb2pHMWpHcGRwclZiSTVPMDArOHY3NjZtUzV1cjVZbVhPMDRBQjVHTVY2RjRiOFZUNmI0bGt0OVJodW93NmZ1bm1kaUZ6M0c3UEZlUVdldjMrbDNrRnBaRlE4emxzbkl5Znc3MXY2N3F1c2FqZlN6M2R5SnBsUlVDUDhBTHQyakhXdXhUZ29wcHZtN2RERzFWeWNaS1BKYlR1ZW8rTTd6KzA5YWUwRjN1aGpVT29WdlVkYzk2NGZSdFl1OU8rMFJRM0pWSFhHOWdma1k4QXFPY2oycW1aZEZlM2laM0VFa2NBRHRra1NTZXg3VlkxZUxUNFBES1MyWlNlOXVmdXNDY1JxRDFJcm1kNXQ2V3RycWFMa2hGUjVXN3RMYjhUelcxOFJYbGhjWGx2ZldiRnM3Zk1mOTI1TEhyR1A2VjFkL2RhNWRRUTIxM2NUdmJvbS9BZmNxS2VtZjlvZWxZTVdoWGt5ZWZkM3J5U1JqY0MzS3I2WXp6VjY0czU0TEp4RE16TEtQbXkzSjlqVjNhdGF5TFhMZDZhM09tdS9GQjFpeFl2Y3hoN08zV09MWmpjd1hnQWc5U2E4U1czMXU4QldTSHlvM2JoMjRJK21hOUpzTkpudG9vdk1oamo0REs0VUV0ajM5NjBaZDl4Q3hjTVY0d0FlaDlxeTV2ZWIzMUlVSTh0bG92STVPejBxODgxWXZ0Wmt3ZnVoUndQclhWV3VtekFvSWhpV052blIrUWNkRFN4WHpMRnNhQ0VGR1hETGtrc2FtRnpkMnpsVEcvbkZzK1p1NTUvcFVTVjc2Q2l0TFg2SFEzTnJlamU4U2o3dWM3dUQ2NHoxcUNSWlBJakxnQXFBelpPYy8vV3JTaXZibTlNSG1GRkNqYWZRbjMrdE12bzNEcUZWQkd3SnlDVGdpb2lySTZJcjNWM1BPYitIV3IyNEJGd0lGQkJWaC9FUFlkcXYzV255ckRHVXVXMzU1UFpoK05kb2pJSW9zSzJYUEE0SkpIcDZDbTZqcmVseTIwMEI4dFpESVN5QmVwSDNWQUhiTmFMWXdmT25IVFE1ZXdEd21ObGlBSkozZkprWkhyVXVyUTIwelNOSzhzV1JrTWdCT2ZjZWxhV25TYXlKcFpyaTJoaFVqY0VYZ0VkTTRQU3BrdExtN3VvVUlCTG5CUFRHVDNxWTlSSnlUYlp5OWt2MmE3aWVPUlhZQldLa2RoN25qTmVnUEphM2MxeE5NRjgxeUNGSVBQNWVsVTdyU2J5d056WlhGc1VsWERrNTZyN1Z6RUdzUVFTc2lSN1NvMjRZZFFhcHJtVHNYS3oxUFFwRmFiekpZclJBb0FEa1lIQjQ0RlU0YmVPNExoSTFKaUh6QXRqQTY4VTZ6dVBNZzgwcUFuVUFjWXJtTlYxWllrS2VYc1JwUG1ZTHpnMW43T1hMWmRCd2toUlkybHlaSmt4aEJodm13Q1J5QmcrbFZJcmw0ODhBdnZYb2ZsSzl3ZmV1Y3Raclg3Uk1RYzdUdEk2RWs5Q0tsdTdoUExESUYrUnVWNmtrK3RMbGJXOXg4M3ZNMTVaNFdGemhSdS9nVVp6ayt3N1V4TFZHQ0FzZVZ5d3djakhjNXJBczcwd3piMUlXUUVFRS93bnJVMnJUeVM3UEl1cFpaSERTVE9SZ0tEMTU3MCtWM0swc3pNODI4VzdmOTR2bGc1ZGY0bUZVSUx1NmZ6ays3R0dZSXVRR1lHc2VCSjNsODRzUjVaNTc1K3RiNmxydTZrTU5xVllqQzQ3K3A1cTFIdjBNdHlHQ3piZWhWTWpHVGc1d2FFWm9TK0pRTWdrRURJSjdEbjlhMEw1YmdpQ0JvMHR3cWdFb01iL2RqNjFsU3Exdkt1Y2dEbnJudFd5MU1YSnBFRDNGNUxiK3pIUENqQU5WZHBqdWxsaWtVbmNwT3pnQWoxRmFrTFJNQnM5Y01NNEFwMGd0VWFQUFRHU0FPaDZacUhxeXVmUTJZYm01dTNCallNb2JMQStudFd1c1VibEM4N3c1T0d3TjNUcDA2VnlVRzFaejVaS2c0ejc1RmRyWmlYRWFOOTBrOXY2MWRyQnVoelF4dUZiSkNxZmx5T1Q5Y1ZTbGpReStZalpKR0R0TzA4VmExTzhWcmNXNk1BaXNTeklPYy9XcXl4V3EybTZPYU03bE9Ca2xsQTY1OXpWSkp2WXhtMHZtWEVrdEhBUXVvVWpIbHVlYWRhWElXWVJ2RXJBNTI1NCttSzQ4UnlNc1RCVkE1NFlaUDFCcTlhSmNyaC9NSlpUbENlMmEyYXZZSTJVWHFkKzBPbkxHQUhjM1BKMjhFS3Z1YXk3eVB6WElhVTRHRnprQWtmU3MyM3ZMaUI1RUJqRFNqRHlBRE8zUFRtbjNVcENaQTZkQ1R3ZmNldFp6aXpGWDdpbUdPM1dUZStPd2JPRFNMcU15eEx0WnlxdHdEamcrdnZXWkJCOXBpY3VHWXhzTWs5SzE0NFdJS3JFTUhJeVJXc0tmTWh5bWxiVVphWFpFb1lSZ1pKK1lEbXU4c044d25hU2RpbzVVczJBUGF2TzdHM2xlL2EyaGpPOVJrL05qSUhYRmRSSDVxUkVGR1pjZ2ZVNTcxaTZkcEZLU2EzTjRYTXNUc2tXT1FCa0U4L3dDRmVNL0ZIVlk3VHdzMG9iYVVuUlpPQmtFOGdnanNhOWZkN1dNamN4VTQ1d1A1WjcxOHcvR3U0dHg0Q3VwRmphVEYzRXVjWTRQZjYxMFFoKzhUTkl0Y3E5VDVadGZHc1N6M0RCVmRtQUlWaGpwM0dPOVZuOFMzRnpxa2x6RVBtQ0R6Vkp6OHA3alBwWGpWcllpNXRibWFHWUR5MUJWT2grYmpqMXJmRUZ6RHBTWEVOczI2SlZTWWs4bmVNNStsT2F1WENiVjlkRDIyeDhWU3hYclQ3dHdLYlZiR1NNOWo3ZTllNVduakZKTkhTWkNvZUY4U01NYytoUDE5YS9Pb3lYczFubU4yMksveWM5U2VvcTViZUliNjNrZU9JdEdzdTFYUW5LOFZEcDN0NUdpcTJQdnk3OFNlWXNGeUZoM1NQc0JCd1FRUHZVbGg0bG5NOXdyeUpJakJjZ25rWVA4QURYeVpaemF6cTZ0YnhIYW1XS25zR1VkeFhTNkZvdXUza2dranlubGticEF4eHdld05LNlVmTkQ1N3RXVno2dlh4S2JXM2JNaUk3a2hTeHh0SHFlNHJXMFg0bGFwWlhkdEJjWEMzY2J2c2laQWNvZW9HZlN2SnAvQzUxRFNqR1ovTWxFcE1jZ080NUk1QjlxODc4TTIydHlhcExaU2N6V3preEtvK1k3Ums5T3ZIU3VkVHZCdHZZcHBxUzAzUHRmVWZpSmMzRi9iV2M4M2ttWm1DS0R3U0IzcnVkUDFiUjVyQmxlNWhRQWdPSGsya0VIQkczMU5mQWVxYVZmWFd1YVZKRmNHT1R5Mm0yeUhKVWdkQ2Y2VmJ0ZFRuQzJFMTFkd3czRnpLM2xxdzdLY0EvVTlxVXBKcUx2OXdKdm1rbXRGc2ZvSnFYaHlEN1JHSXJxUGNzZktidm5LOWppdkcvRWNkNUNrcW9tOVdsUlBOSVV5WlVaeHgvRFhJeWEzSlo2Z3lNNERZSHpic3MyUjFKL3BXNWQzMFZ6YnBlTnVWVTJwS0diN3pkamdkSzFwenZCUGN6bWtwSEFYS1gwdHdQTEtTUjQzRXVUblBvQjJ4VXNNS3RlQXhRQ0NSVHk0SkdHOWF5YjNWOU5pdXhHak1qT2NCTTUzWjc4Vm5IVjRZRmFLQlBOSlBKVnNzdUt0UFZDanFqMEs4czdkdHpHWjVKUXBaMnlUaysvTlZMVzBoazh1T1NMZUhQemJ1bU91YTRPKzhWMnFGV053ZVZBYkl3YytoeFdmRDQyMDlYMm9vZDJQRHQ4MzZkcWJab2tqMHlIU2JRdkZMWXhUMjBmbUR6RWJCVi9Vcm5zYTdxWFNVOHh2S3UxQTdqZVA1OTY4ZnV2RnFUMkNIZUJLRGdSQnNmZ0NPbjByemkvOFUyenlLTG1Ob3BGRzBxdVIwOWF6VGJlaGZMWkk4MjFLOTA2Nit5WEVkdUZramZhWThENXdmZnZXYW1veHl4K1ZOQXVZNUN5LzNndllaUGF2TklvZFI4MU14RUp1R2ZtQlA0Q3RxL21rbGlFb1ZRSW53UXd3MlIwSDBxZVJhSzV3cHlidlk3Tk5ibmdsaXpiTGdOeUNPT2Y4OFZxM2VzVHJjU3pRelNMSXk0VVp3QUIyRmVYSlBLMXZJZktrQ2c3c3R6ejZmU3Fza01keGlXT1lybGVRU2V0SElyNmxYdmM3Nlh4QmRRUnM0a1lQSVNKSTR6eGpwa2lzMjExU0s2UkxVaHpIZ2dGU0ZZRStvNzFrMlZ1SHM1U29aUUNON01mVDBOWTgwUmpjdkF4a0NuY1dYUDhBUHB4Vk9FRzMzSnN6MFRURjBwRnVSTmZ5bVNJZ0l5bjV2K0JEcGl1cHNMbEwrMm1Sb21mYW9HNERsZHZSZ2UxZVhXZDVaeEF5U1c2a3VEODNiOGFyMlY5cUtUUEpieU5GbmpBUERENlZoS25mbTFmUzF3NXRVZXEyOS9ZK1pkQzREeU9nWHl5eWJnWDdzK2E1OWRDMHljdGRhalBNc3JuOTJxZ2s0N04vOWFwa2tJaWFTV1JKWlpRVmtVZktUN2p0Vi9UZFZsWFVmSVZKbVNTSWtxY0VxRkhHS3pVNUs5aTdSNmhMNGMwaVNCbWp0cG1RTU1zVDgrTzU5cW9SNkRhNldCUEZNend6L2NJSTZkd2ZSaFdyQjRtdUdmeTVJb1Nja2NQbHNlNS9wV3BiVExlV2sxb1E3U3VROFJ6dklLOUNvSGIxRlh6enRac3pPZzBiU2JLYThoU1dHWm8wUVNseU03RVBWamowN1ZiOFN3NlpOZHdJa3dSTGlNZVRKS2hHMVZPQVdBNUdhODJsdWJxMGFTTXVXWFlDd0Q0S25QT09lS3JMcnB2TFoxZUp0eXlBUlBuSksvM1dKNzFMcHR0U3ZzYVJuRzF2SXV5K0Z0UnNKSjVoUHA4OFk1QmdsV1E5TzZua0N0K3l0c2FaRkxmRnhhaDJZdEFESUhJKzZpc09CNzk2eHRMdHJaN3RqdDNUSXBaRVJGT2ZVRWtqSTlxOUl1cjJTK1VlUk5jMjdvU1hTS01KQ3BBeG5ZT00rdFlUbGExMzg5aGMyL2tjOHRwZVg3U1hWOTVGbmFSSVBJU0NSc1NEc0dJNUpyRzFhTzB2ZEppSzNEQmwvZHNpZ3JoUWNoaVJWZjhBdEs3TEk0V082aEQ0RDQyNGYvYVVkYTZqVWJOTDJlRXc2YjVFalJBU3FzZ1JQTTdPY25paHR0cHJTMjFoS3BLMjF6ejdUN0NPSStYQmVNSW5aVmx1VlB6S0QxeGptdHdRYTVOY1R3V1pEMmlyc1Z6TnlWUDhYSjVKcnB0Q2wwM1I0THUzbmhaNUo1QjU0SzR6anBnOWNWd1VHcTJOcnF0Mlo3T2FkV0xMQ3NaNVhkMDIxZk5PWE5wZTIxK3AwODN1SytoMDl2b2pEVXJlSFU5T01wa2lZUmVXMnh1T04yL3BpcTEvNGFrK3plWnBxUE1JSGFHU0FwKytSbis2VGo3eSs5UlNlTmtndklCNWJ6WGtQN3VPR1JjcUZQSlZoL1N2VXAvaU40emxnM0xGYjJ3VmtaZGtLb1ZJNlkyOG1vWHRVMDdXOVNrMDF1ZUdSK0hOZjArMWsvdFRScitBUzVramtkREVwTWY4SkpvbHM5Y1BoMjNYWjVVenpCMVFnQWxEd0Q5Ulh0a3Z4QjFEVVFXMW1lVzVZU0FvMjRGY1k2TUQycm43KzQxSy9rKzFtSlhTUTdRUzQ0MmRBQjJyYjJrbTlZcTkva1lWR285Ym5ucTZESS9rclBjaTVkWlA5WWNSeEt4NTI1UDNpTzllNzJYaXJUOUJqZ3NaRWlhNFV1WGRHTEZJNWNIT0IwMjlhODk4T3kydDk0aGUzMUpWOGd3ek04U3Q2cndSN2pyWE13MjJrNlE5d0dpdXJscFZJZVgrOHJjWUJIZWx5T2NtcFgwVjdMVGNVSk5hcnJvZlJPaTI3M2NMUzd3YmN5ZWFaNHBXelBHaDVadDU1LzNhNDd4cjRyOEFhenJFTXVwYWZkWHN0akY1SVNKZ255ZzhaeWNjZDhWeTdhL0xCNGZEeHhMYlJRT2lRQkNXUEp4ZzU3NXJsRjhNMkY1ZVR3eDJsM2NYazB2TEJ0c1FKNXkyM25IcjJyblZPMVJ5azVLemFWbWR5bG9sbzE1bjJ4OE92RTArcmVIYis4MHUzdDRHc0pGdDRiZHg4cXJKMHdGNExlOWVkK04vQ210WEdyUldNbG9YYS9samwxQVJZZ09XNUlrY1p3ZzcxNnQ0QThQSjRiOEMzTnRheVJpNmxsV1ZwV0dRR0J5aFFmM2ZUUFd0aUNlYTE4SjNYaUNLK0Z5SnZPZ2szcWQvbTU1VUE5VFhEVW1sTnlndHBhYUhwZXhVb1I1bm9sZG5MK0xraTFSYkxUTEM3dFRCWlc0UnJlTmQ4a29UZ3MwbmZaMjlxNFR3OTRkMGJVWm1iemRrYmtRRHkyQjNoRDB3ZXVEMXJSK0VGNTRiR3VTM0dyeVBHOXhhc3RxaXFFRWZCTXBmdmtkQUs4ZjhKM2QxWmFqcThuazNGc2kzRThscEhJaktGaU9jc0NSeDYxVFVrcFdiVFNXdnpORTROeGNvcDN1Y0o4US9FOFZscWNpNkRaaUdTVGZIUGZTWWtuWm9qdEtveDRWUjdVdG41YitDckhWNTlTbFdaSVpFS3VlTjZINVRucVNhcjJIZ3c2cFlXWlc5aTgxN21lU2VWdWZMako0NEhkcTkyZzhJL0R1NnM3ZlJMenhOZFhFOFVKQ1c5ckNyRjhmTmtzZUJqMXIwNVZJeG94VjVhUFZwWGRrZVhHazA1T3lzOXJ2cWZPT2grSmJsOUtrMUJ6Y1N5dzNBZFkyWWtzMjNIM2puSzU2VnByNGsxKy9qMGVZTW4yeVNVcmVNZUpNU1BoWEs5MUhxSzc3d3JmV3NPclI2WHBrRWx6SEU3UkNDUWdtVWQ4OFkvR3NuWDlIajB2eGZiM1Zna2FXTnZ1a2E0alBtYlN2TElUMUdPbnBYVlJ4azR6Y1ZlTjlWcjBPV2RHTTR4YmluZDJlaDlFK0xmaVBxbmh0ckhTWnZDOXBkaTJWMGtsRVpZeWpvUU52SVBmSXJ3V2Z4YjRjUnJhNG1nRHdUZ2xjOVFSMVZ2Y1Y3eDQ5MVhUOVgwYlFiN0JUN1JFdXlYYnRjeTRCVWpIclh5RHFGM2JhaHFrdHBxTnM4WXQ5eDJNdTN6RGpya0RyV3VIekd0ZTdWMnRKZWR2SW12Z3FNYnh0cGU2dDNaOUcrRUwzNGU2cmZKWVNXVVU0MUhmYXhSbkk4dDVCbFdYdGtHdDN3L3dEQ3U0Z3NHdTdKR3M3K3h1cDRZK3hCQUlmcjFIdlh6eDhPZkNWdXNWanF1cTNNbGhEYk0wc0xxRGxwdjRGK3A3VjlmNko0NUtYTjFlWDgwczF4S01FWStWYzlUZ2V2V294bVBqRk54aEZ1NnZaZGk4Tmdvdmw1cE5LM1Y5eUR4RDREbjFiNGZYY01zaGlIMnUwSldOU1hESXVHYyt1YThrMHp3enFuaHZTUEV1azJOMDB0dnFVYXZJMG9DdW5sY3NjZm9hN2pWdkhCdk5TazArMXZXdDVabGFRZ0lWUXFEZ1pQOFBIY1Z5RjE0YjhSNnI0dXRaSUpuWldPeVJRMk42TXVIQ08zeXNlOWNrS3RHWE1wd1NUOTc4aldkQ3RCM2hOOWtlRWFiNEd1N0hYSTlRRnpBN1J0dkJCM0xrOUNmY1Y5cW1YVHZGOTFydW9hc0JGRGI2ZXJ5SkRKaG0yRUtxaGowQjcxOGErS3RDMXp3M0pkMnd1UHRjelQ3Z2lPSGVLMlhvWmNkRzlxNTN3M3JPcldPcGlPN2d1VlY1QUpGQ2J2TWhZWkt1aHhuNml2VzlyZzIxUDJLbFplN2VSd3FsaXJjanJPTjNyYVBVN3E4OFIrR2RFUnhwc0tDUXRsVlVFOUQzUFd2TlBFR3B2cTBsemVhdGJuYktRMFFTZmJNd0E1d3ZJeDlhOVVzdmhoRS9pSFRyL1Q3dHBiWCswTWs0QklnZmtFQW41Z3A0TmVJNnRhdkRybW95Q0EzWGs2bXJpSkFXVjBKSUtqSHFLNVByTUtsUzBla2ZTMTNzYmV3blRWcExkK3AyVnA4TklOWjBpeHVORzFXMmxXNTh3MnNGd3dndUEwWDM0bS9oWWpxQ0s5VDByNFU2MURmcGNhdHBURnJZeG0zRERNVW04ZmZQOEFlVlR6anZYMEI4RnZDMmp0cWV2V2hzUDlDWkV2WUVuWEwyak9BdlRyZzV3UlhwbmpDL2cwa0xjM044VllJSWtqYjUyZVZEOTFSMlVEdlhrVmNSVlUwazk3MnZ2cjZIcVU4SkhsNW4wc2VPM3VqYXZxR2hSV2FhUEpxZDVwMDV2RWxaaEV0eEU3YlpsVS93QUdCeUFlbGVMZU0vRDJqMmZ4STFpTDdRUzVzWW50VlhEaGxlUE8zZDBZanNSNlY3UnJIajI0dUxXNGphMmdTeVdORExid2xnOHlTL0k0ZHgxM1o2ZHE4VnU5VjhNWFBpUFFwSmJoN0J0T1NHeWlVeCthaFdMT3dTdU81QjVOVlRVM2ZmWjdlZW9UaEc2MTE1bHY5eDRWYjJjUC9DTVg4YzB5R2UwdWttMlp3ZGpqa2oycm10ZEJ0cjBSeEx2aW5TT1NQMzNqUEZlbXplRXJpWHhKY3drbGJTNEVzYlNCaGdwbmNyQTl3SzFORDhKTnJYakcwc2pQbUMxdFh4TTN5TnNnR1F4SDZWMjg2VGJiMHMyenpsQ281S050ZGl6NEtzZFFzbzVybWEzSWpJSVVrZGR2VUd2V3ZBMTNmUmE2WkxlWFlYWXN3SDNTbzVPUjNybTlOZlU3cTB1TFhreVJnb3FzM0NoamxtTmRKNFowNlhTN2laNUpRQ3cyN2h5RkhmTmVIaUczenQydjBzZm9lQWlvMEtNZGJJKzRmRW54QmwwdndpMHpUeGk4dUl4QkJDdjhIbS9lY2p0Z1YrWEZucnQvYitMNzNURzN6R1Z6RUhjNTJnOUR6NkN1dDhWZUxyZS84UVdzRVQ1akFLbVRzM0hYbnBYdmZnend2NGM4UWlmVzdhQUxxVWNXMS9NZjkyMjBZejdIanJUaEdHR3djcDFZdDh5KzV2WXpyU3FWc1ZGVVpwY3JzL05MYzlDMUhYOVAwancxcG1taEZEV3NMR1NRRGNTN0hQVHNhOGwrR21yV3EzMnZYMXc1YVpiWnpIazhKbmtuNjFQcWx5MXo1Nk5aZ3FWS3lsajB4MXlmNjE1OWFhVkZwUGhUeFJlTzdIekdXS0U1emtNUFdzc0xTaEtNNHZlVFIwNG10TldrcldpdnVLZXY2cHBkeDRhdEROTW9sdjVwSk1NMmVuQXJ5Nno4TVEzU1JDMzFReXZHQ3oyK3pJVmM4NUk2WnJoTlJ1cGJ5MTB4dG9QMk5Dd3dNNU9lTTE2YjRSMTZRV0V0bWlCWG5sTXQxTGpCSTdKbXZlcndsQ2w3cjFUUG5NTzR6cXZtV2pXaDJsczM5ajNhWE5uKzRsQUdESHhuc2E3OTdTZnhWZVdVTXNieHd5dWlDRlcrYVJqd3hQb0s4dDFTYVNlOHQ0VjREU0twQUhiMXIwVXpRMmR4Wm9aMU1rc2dTRmtiYXFLT3JzZU1BQ3ZBcVJuZURYeGEyZlUrbXBxbStaUytGVzA2SDZtNmRwbmdEd0Q0TDJ6eDJkcS9sRkRJUUdkeVI5eE01Si9Ddnl0K0pkeGE2enIxbkZwZW5MYS9hSEJSV2I3N2RBeitoTlJheHEycDZwcmlUM1YyWjRyY0NPQXN4T1ZVOVZIdUs5TDhFYVZvM2lMeHVrVnlpU1FRMjdaREhqY2VuNDFtclVFNXl1Mm8zZlUyYlZSOHNWWk9XaDU1NGRnYlNvcm15dU5qU1NiVEl5am9SMUFQZXZTdFBOc2pTajVpMjBGQUJrc2M5SzdyeDNZUVdtbFcwTnZBa1R4U2xmbEhPMzM5YStXdkVPdDNXbTI0bWhsOHRsVWxYQitaU09RUlhQVHZpWTNXbk15NmpWQ0xUMVVVZUxXa01kMThWTDk1TGI3U0lidGdJMkhCUFFCdm9hN0g0dVhtbnRwSG1XOWpGYnF6aUJHakJYem1YNzVJSlBBN1Z4L2dTYTZTMTFyVTVISm11cE1LNTZrbmxtRmVlL0VUVzVidVd4dE4zN3VDUGNGOUdmcWZxYSt2aEJ2RXhYOGtWSDdrZkMxWmN1QmxMWnprNWJhNnM4U1hyVzFiU2lOMVlnSEg4SkhCckhqKzlXZ1RnZzdlSzlpV3VoOHpGMk8xc0dFbW8yWUVTa05QR1BMWHZrMSs3TXRuYWFSbys2eHRSRTF3c1BteWRXNEE3OWdQU3Z3czhNVGFjTmYwdzNWeEpCRUxpTXZJaTdtQUI2Z1YrMytsUm54S2JleVo1N2ZhU1JOSXZEQURQM1I2MXl6amZsVmpyYnRCUG9tMnlpa3Q2dDlOY3A1ZTlobFMzM09lK1BlcnZoclJwMHZacDJoaW04eGczbU01SnlPY0JlbVBlcWtkeGQyRS93QmpVd1hRamNuY3hDZ0lUZy9uWG9PbDNOdEJMTXBoM1F0bllBZHBCUGNZN1Z3eWp5cC9jZEM3cGIyTkxVb1lJcEVNWHlQTVBuT2Nqam5IMDlLNVNkNW1SNHlGTEVaemtqT2UyZld0aTZ0VnVkWGVTSzFMaUNBZVVjbkRNZXVCNjFONUZ3SVEwcTdaT1A4QWdQMXJKSmR6VytoNXBxMW5KSGJKSzFrVm1iQ2xrR2NiZS9IcldNdHJxV3NOYXdXMG5uRlkyYVZKbUFWVkhjR3ZkRXU5UXM3TXZEZFJ4eWIvQU4wVEh1NmRTYzhHdm5uVkcxSzFubW1qTnRMNTBoTWhSQ2hQcjA2WjlLNjRPRXB3dTcyM1BQcXhtMDdjdC9zdDY2K2gzdWsrSGx0ZkVGbnArcUVzamhYVXhFTXJLZWd6Nkh2V0Q4V0UwNCtJRVhUN2NXNGloVkRHblFFOXhYT2FmUGNXMm8yczExSE9ERzRaWTN5UGw3YmM5QlZmVm1FMm9YOXhKSVpUTm5hdTdEQW5wOVFLNkpTaW5aSTUxR2Q0dVR1MUhwb244amw5RXR0TFM0bS90THpnZHVZekdjWUk3SDYxUGZTMmF5c0Z0aThHY0tYUHpCZndxL2JhVk5mZWJJc0JhS0JWTHE4Z3lENmc5NjFORTBTMjFYVVVTWGZhMjRSOTB5Z3V1VjU1ckZYY3RqV1Zrbks3MFdwdzFsUDVjMisza01SRGtvYzVJSGJPYTM3aTRsaXVZNXdSSzVCSkxyemtqbk9PeHFwTlppQkYzcEd3ZVJ2TGxCeXhVZW9IUVZjczVDejdUY3JHckhrTU4zVHBVeWZVYVd4VzFHZVFxa213UnMvOElPQ1I5T3dybllMSzRsa2t1STVuVUlWVlFjWk9lMzByZXVVVjVjZVh2M0tmbS9waitWYzVFVkw3R1pBUWNlNHBLM0thOHUza2R6RG9lc0NUZkpQQmFSelpaRFBLcXEyUFFESnJqMlNhZWZleTd3cElHMDRYamdmaFZvMlp1cjVBaks3S01LU2V1TzNOYmJRWGkyYjNyeFJpSlpSR0RrYmd3NXh0SE5ROU9xQlhUMWt0WHBwWWl1YlQrelowbGtHM2Vwd1NmdWoyOXUxTGMzR255eUNXT0hFNUtDUGF3Q0JlKzZrdkxnWDhhUnNpeXlESVZNWUlKNmdWaVRSejZhMHNGeGJGSk1xU0N2ekl2cFM1ZEZkNm0zUkZTN2l2dFQxREN3aU1nQUhCd0NSOWFtT25YRUlZNEpDNUdRT2hIWEI3NHIxRFJ0Zld4OFBhaGFmMlV0ejlwT1liaHpqeVNlTWdldGNwRGZ6MmhFTXE3bFVzVk9jako2NXFIcXJKYkU2ZTlkV3R0cnVjUHBtbmFiWjJaY1Q3WmQyVHZRRGRrODRycDd6U1BFMDhFUzJXMk9HVmdvY3VFM045ZTRyRnY0cGJzU1NDTWRNdXdRNUhwanRtdC9TOWtVZHZiR2YvQUY1L2VJNUlDa2V2L3dCYWpsZDA3M2ZtS1U3UVI3WHBWdkRwL2hRNmRycVMyRTBTRXlTZVlHRWtqY3EyQi9EN1Y1VmE2bE9iV1czRnlGaFFqYmpHWDU0NHE1ZmFmYlJaTjFkbVZSbmJFcmx0M29CbnRYQ3ZKcCsveW1TTkhPR0FIREQ4K3dyV3BGdEpOYTlURER0TlNrbnpKdS9sOHJuZkxZNHdDb1Z1cGZBQUE5YTZDZlRyWllYTnhPMERKYm1TTUFFK2Rub1BZZTlZajZuTkpwc2NVVmxGY0pCSXBhUXNjc091RFhvUGlHKzA3V3ZMbkZ1c1pXTlFBSmNrQWNZT09sY0s1NDczMzZIZGR5bGEybXVwOC95eHl6Tkh0UjhiMUtqK3VhOWptc3JSOU9pTVVuTVlKZEJ3VDlEV09MYXlpaEVheFIrZkcrNXB4SVR2QjZLQWZUMXJtciszV2U4aG1WTUJXNUlZam4rdGF5dksybGpMa2xGN21vR01jU0dNc1NRY2htNlo5YVNPVmk4YkNOWGNjRlF1UWY4QWVvU2N4WlZpSEIrY0RIVDYxekU5OUtaR2UzWXhqb2UyUHJTNVh1TnpzanJkTUQvYVZrZVVNQXpZSDE3WTlCVzlxOWk4VnJiemlWREhJU0NvR0dEZWpWNU5hSWdrU1RmTDVnZnRuREErM1N1NE0zMmxTR0xoMU9DV09WSHBXcjBNazNLZnhhZFVZZG5ad3JxcG0zQVNiZHFEblB2aXUzOE8yTi9yMTVQRkJaWExGRHRkcEUyQlNlaE9lY1Y2TG8zaU8wMDNSSGlqaGhseUFXbGVJRnQzK3llMWVld2VNdGIwM1c3aStrMHVjQzRPRm5Wc0IvWWc5S3FEVGV0elNYTjcyaTIwZHpaOFFlQTlWMDdVckMzbmt0WkF5K1lRc21kcEg4T0s1S2E3ZVh6RThpTmN2dExoY2JjZCtPdFozaUdQVk5kdm9KNXI2U0xiSUhiYmdrci9BSGMxZW10L0wrVkNTTTlXNFkvV25PVWViUWxOcU5tN3UzWWE3RlhrVTVDRUFNNVVrSC9kTmJNRVZpSTVaREd6aFZ3QXJjRStwRlVaSjRnWVYvNWFqakFKeGozeHhpcU56QzhHeHd3T1RnRk9SbjM5S25kZGh4YTNKQ2p5RVJ2aUhIUEp4MTlxMXJhQzBpa0gyamJORmdrS2piZWNjWk5aeTNNckp1bXh2QTJsanlXTldkZ0pUY1ZJeGxBeHh5T3hORnRSdHBwazl0YVhNODBoaWl5RkJZUnFlY0QrZFFMZFFKSTBtNXN5UjdHRW1OdytnN1ZXdFJkeDNobWpkL1B6OTVPY0E5UW9IYWxjeG1iTXlzR1luY1NNWWIvYXAyamJyYzVtbnpQYTF2bVg3VzZ0SkpKRXVDWVFWSWpLanJ4akIrdFNRbDVZMWhYN3U3R2M4cmp0VG81TEU3Q0VPRVFodm16dWJ0ajJxSDdYdGNGVGtrWkp5TSt2ZW9TMWVockZ5T2p1bzJ0REpGOWpFazZFTGtzU0ZCR2M1SEJOWTFwcDcyMDhkNHFoWkVKTzVodXdmUVpxU2JWbG1kSGlZbHNaSzR3QWF6NXI0U2xSSTVBYm9TZU1uMXE3ZGpubTVmTHFkbHE5enFGN2JRelhEUTdDdTBzT0dZZStLcXgvYUxWSTVBQVl5dVF5OWlQNjE1dkhmdEk3SXJNeUl4VXNSL0t0VTN0eUI1YXlNSXljaU1IQzhkelVXZC9tYlFkb3BKS3gxVjljWE55Ti9uaVJpTW9TK2NleHp6WG4weXJkVCtYTUVqY0FrUHVHTXJWNmFhTVhDbDFBa0RaNWJJUHAwcUc1dGRDTTBzbHhPOEdSbEVJM0t6OXo5SzFUUzEvSWNkZnVMeFpZL3dEVnlOSU5tTWRCay80VmkzTnhkcEl5TElzbWVNc3ZBOXlhY25seGdvYmxWQkFJQjZuUGZGV3BqSHcrTndQUURuOGFVcFhLakZJNVpFWmRSbVZpcHlWT1FPQlNYaXFKR1ZFSUpZQTl5VC9qVHpiUzNNcVN3WkxubGlmdWdqK2RQTjVQUE1rWnh2WGplcTRISHJYUEJ1TGFDU1psTGJ0RXBkZ2Q1UFRPZWZlbG1UVUxuNVZtT2R2em9jQUFlMVMzclBiM1czNVZYYU9OM3pNeDZuQjlhWllSTmRTVHlsL0s4cGNxVHhuMk5kTCtHOXpIbnRZcHpRU1FxMGNjYlpaUmdaT1RqcWVlMWJFUnVJN1hLelBISVZPY0RsUjYxRmJ6SjVibFkyMzlON0hQeSsyZTFaOTVlUnNkck1PZUZJeit0Rm1icHF4bkdTZVpJM2E3WlR1N2drbjNxZVdKZDZCbTh6ampKeHoyclZaSUhoUUt3YmFNa1NkejZjZnBWS0ZRSkdNa1liSTRHZUJSRnBNeGxyYzFMTzJ1bk80UXhoY25PVGpPQjFGWjhSakRyNXNoTGJqdEd6T0IyNXJxN1MwVHltTEVGUjZIR0QvaUtsT21SWE1oWVNNbVJnaGV2NjFhMWJNb3h1bVp6V3NKTy96c1BqQVVrRFB2N1ZwUVhkdFp4cnZZY0VZWXVEejZpc3lUdzVwWG54VEVUUGduQkRjRW5qa0N0eGZEbWdPQ0JESVhHZmxZNVhOTDhTMmxicUxjYXRvbzNtYWRXSitiYXZPQ2E1VStKdERpREZibENBZm1HRCtWZDdEcEdqMlRSdjhBWllsZmI4ekU1SkhvUUt0NmhGQTltcWlLRkVjbFdqRVM0SS9ubW9VMzJJVVkrZTU1a1BHT2tTRWt5bHdSeHNqSng2Vmp5ZUk0MlpSRlozVHN6SC9sbVF1TzJQZXZVSXZKc1lBa05rbU9OellIUHZWdiswWmlqbzF2eVZPM0dPYy9UcGlxNTVKQ2NVM3MvdlBNclcrbWFmZDlndVN5cVJqeStDRDYxZGtXNE1jVEMzbVFiaUczNTRQb0IycnViZlUydC91ek1wWWdiU09wcm5kUjFPOG5sY0dkMlFIcDFBT2UxZEVaTjIwT2Q2UFFpdGN4eVkzWkpPV1R0ajNycVZmcHNZaytvTmNqYnVpc0hiSjR3YTM0MG5lTVB1NE9NRHB4NzFUYlMwSmNPWjZqWXBoRkk3eVBzSWZPNWVEK0JydGRPMU8wbmdsU09Rc0l1QmxjWVBYOGZyWElNMGNkMkhWVlpSOTRNT0RYWjI4Y1Z4RUdVN2R4enM2bkg0VmxHVHYrWnExSGt0NkVsdzl2ZFFxbmtKR3lna2tNU0NUOWVsZURmRmpUUHRId3llM0VqRW0raGVRcXVUdFhPUlgwTHFFTUtJVVZRVTJEYVNmNHZ3cno3eFBiUkw0UHZHZU1BbDBHOHR6anVNZHMxMlJrbHN1Z1JpM3lxLzJrZm01Y1cxM28xemF4Vzh4YUVvSkF5S0FHejZFam11cWFHM2VHM3ZXdGlzZDNHeU5nYmVRZVZaT2dQcGl2VEdPbDM0ak1jY2FRUUFiUm5KQjduODZ1YTFGRjlpbGhBSk1rYXRnRDVZejZuMzk2NEhWNk5hOXp1VkpyVytoODgyZmgzUllyM2E4c2hRL01xZ2Y2cy8xcjBleDBEUVhoY2lOSlpmTjhzcnQ0QVB6WjU5YTB0QThPMmwwOXRLMXlYSVo4eVkyNDI4RUdyRStqejZicmxyY3d1VGJYQklkSEdXREwwSi9wU2M0dTZiMUxVTkw4dWh1TEhIRGJ1SUxhT053dUdWVndmbEdPM1hJcnB0S3ZMaG9JQ25rcXdBRUpDY3NQUTQ2TVBXc3I3U2RMMUsydTJTUjB2Sk5weGc0Mm51cDZDblhkdTVFcjJjalJxYm5kZ0xqQWZxUHBXVm8yTm9xelBUZFh0cmVmVEpUYlNpMm5YbVZJemtiOGZlNDdIMnJsdEQxRlJQNTBzYUM3amlLSzZnRExIamNlOWViYW5xeHRycTJRUkFMSEcyNlFOeTM5ZWFxUytNclY1a1lCVmtZQ05sSzRMSHMyUlZ4WDd0NkJmM3ZRN3JXdE90VjFhMnV6bDJnaElHRDEzRG5QOUs4UDhWVzl2ZFJXc3k1M1dTNFlmeFlYbmQrSGV2WDU5V1J0T2p1V0c0b3ZsdnQ1NXoyRmVFYTNiWEw2K1Q1Z1Fnb3haZWlqcWQzcm4wcWFhZDd2b1oxTGEyNm5UVzJ2MmkzVVRtMmQybVZTV2M5QXc0eCtOZHA0aThRekRTeThiZk9peFJyQ3ZKTEU5ZmVzZlVJdE1sbHQ3bUlwSkd1MEgvcGt5OGR1eHJXdDFobGdrZjdNc1YxSDhzTnlEdlJobm5pdGVlS1MwTTNHYlBKTlEwZlZDSUx1TzdMSGZoMEl3VmZHZnhCckZrMUI3eTJuaGxYN1A4d0FLWlZpdy9ubXZXTlN0TFM5aHRaWkh6c2tQbXFKQWtia2R3ZTNQYXNTN244TnFZekpKNXBCSkQ0R1ZJNFBJNjBjejBMaW1qNTNBMUNLNG5IbHlORkZ5NTVPelBRaytsVkxhK3UxdlJJL0hCQ2pzTTk2OVp2TDIwR3ZXNVJmTXQ3bTNDVGM0RGdjVlQxKzBzT0pMU0VHUGNFQUhBUHYrRmRDbGV5YTNSelNpMWQzMlpXMDVicElwYm0yakU0ak9KaS9TTit4TmRCRlltNUJlN3ZJMGtQcDMvR3I3Mm1tMzl2YjJWdmMvWnJoY3RzVlR0a0lISWYrbWErZmJpUzVobmtReXQ4ckZmWHBTakhtVHM3TTF1NHBYMU92c2JCMFJvbXVnL3A4dTM1czhBazlxMG90TjFWTldrdEpZTjIwaDlybjd4WG5INDlxMVFkSG1naU5yZWJHM0R6RWxYR0Q2ZzQ2Q3RLOU9wMmx4REkxMldSbEE4M2FINEhUa2RhNW5OM2R0MzNSa2s3ZWhwSnBON05wUU4weDN5WExDTlJ3QXJEQlhIb0t6L0MwbW1hSHFaV2EyZTRZN2d1Y2JjOXV0ZEJjTWsrbnBLUEUzS0VzWVRBVk9mclhtbDJSQnRBdXpPVzVmSzdjRStsWkxtYmFiMzZJeHZ5eXVqMkxWTEx3MWIzNlRyRWx6SktBeGc4M0NBbnRKdC9wWGwxM3F0eGNURkUyUWtaQ3d4S0ZUSG9xOURXTGJMR3hieVVDdHQ1VTk2ejJzTGlTY01qTVZpSTNFY2pKNkFHbkNGbTd5djZqY3JzakZ4YXBJNG1IbEt4eHMyNXo5TTlLdkpiV0szS3RGY0V4bm9qTGsvUTRyUnVkRnY3NG1Wb290MmR2RWd5U08zUGVwb0xLU0JKSVpvTmhWZVdmaGx6M0h0V2prcmFQVzJxRnk2c3BTQzhualdLS05JOWg0VWJzL3JTeldUV1hrenJJMjlsRE5JVHdENkw2MTBmOXFYVUZsREJIUHZRdG5LbkpCK3RKSmMyYnpTT1k0SDJuRzFnUXgvRWNWbXI5dENHaUt3YUw3TURjSkNxT3hrTW93RzQ2cnh6VkhaTWJsVGJxRmhsQnhJcHdWUDhBTVk5S2d1N1pXMDFDdHZuTE02b0c1R2ZRZHhXVloyTjg4RGkzODN5U2NzTTdRR0h1ZTFXb3JWM3NOSFd3YUw1VjJJN3FXMldhWVlRTmtHUWtmM3V4cm1MZlRkWXRiNUxZUkdJZVpsWExBeHQrUElxL0pwdC9CSllYRjdNcXFNbEdEaGdDdklCcXZlNm5xVU9wTlBhWjhtY2h5aFhLSFB0L1dxanozK0pTdXZsZEVXYWtkUTMyeWVZaVN6QjJaVW1Nam4rUnB1bUxPWjVQS21NRW03Q3NISzRQdUQxcWpMcWNOMGdkclFSdUV4SWQyQ2ZvUGV1VmVhNWdoVjFiWU4yVjUrYjhLeWNHN3Exalc2T3ltMDVMV081bVM0M3Z2dyt6S3BuMUMrdFhMSFhMblVrVzJ2MFYxSCtxbVB5eUszYkJIVW4zckcwcGY3UllrdUVWZ3hhV1ZnQ1NPcHJBZVNTS1dJT2lsUjBjY1p4NmY0MFJnOVUzcUxhM1krZ0pMcndxTE8waUtYTFNRRXJJVitabTNjODU1L3dyaW52L0FBN2EzRWtpMjF4YXFDZkxjRXV3ejNJUFUxaWhKN2lGMTArNCtZQU5OSkp4alBHUzU3Q3NTUFJkVHVmdEpBZTVqaVFGM2pVeVlIOTRBZHZlbjdPTm5kdnpLZk1wSGEyR2lSaTRsbGh0L09lNklNVXM3S2hBUFBQcG52UnFIMlUyOXhZS3JyZTd3R2xqWW9nSTZERGR2Y1Z3OEduei9hRWhqY3p1cEJFTy9CR09jZlN0RVgrb0dXVHpiVVNHUDV4R3dPQjI3VTBtNWIzMEdtWjBVNmFkY3BCZFJiNUZrSG1zNTRJUDhLLzQxUXZwcm0xMUtRUXpzZG5NWUl3Q3ZVZEs3ZTRnVFdwdE1FV25TRzVmS1Nxbks1VG5qZjZEM3JyWVBDbWxYeGl0WmI1b1pveVEwZ2pMaEFleEM5UlI3U0VXcnJYcVJaL0l4TFB4TkZKRGJvc2NEeUlyQjJPRkxHVHFvOWgyckxudXBHbmk4dU9QWXFsZGtyRVp4OUs1ZlV0TXRJSlpMZFo0M2tqZkc4cmhUanB4MUJyMXp3Vm8ya05idmY2cElHaWkvd0JUYnF3SmxkZXg5UHBVeWxDUHZhK2hyVHZPU1dpT28wendYSkQ0WWZVTCtCYkhTN2lUY3NyU2xqTElnNDhwRHllZXByazlPOFdIUzRKYmFHekUwbXBTaUJuTE1HMmRnQ3ZJRGQ2NmI0aGVMZkdXdGFScHJYRm5IWTI4Y3VMR0RJWXhXNmpCSkF6eXhyai9BQTdkM1VlNFcza2xZZ1pQTXVIR1F4L3VIMXJuano4amxPemJleWUzek9xWEtwKzQ3cExkcmMrcTlmOEFpQm9QaGFiVDdDenRmN1ExS2FDRVRicG1hQzNNWS8xZU9yc3AvQ3ZFN2o0amVPcG9MdVBVNTVFUzhrSldBUWhRMFk2QkZHTnYxcmlQRE9pMitxK0x0T1EzVVZ6ZVRYa1NSZVc1S3dBbkxGeGdaNHAveGI4UzNOejR2MVdTMW1JdDRpSUY0QnlzZnkvSjdIdldmc291cW9LTjI0M2NuNjlEb2xXcU9MZndybXNrdlE2dlJOVTAyeDFDNWxGMEo5VEVQN3ZZTXcyNC91Z0g3OG5yMnJGOFNlTWRYR2ozMEQ2ckxLbHhJVUtsc2pJNUl4Mk5lTjZUTGN4eFdFOXZhcXM4Vnh3emd0bjNxM2U2Y2tzdDRIdUdETVdkWVFNUGs4bHNlbGRISkJTMTFzSHRYeTZIbk50ckdxeVBIYlI3bVZuQVZGSlhQUGNpdmNaZkdvMFRUcnV3MDJGRGYzaEMzZDJvenNUSE1VWjk2K2I0L1BobXdDMjB2dEpIRFk5UGF1c2h2NHJjeVIyOE0wVzRrRUJ3MjRkeVFSMXIwWjBvVHRlS2EzdDM5VGxoVmF2NzJ2ZnQ2SHF0anE3YVg0ZGhRWEJqdWJoWGpERGlRUnVlUitQU3ZVUGhkWWFlcjM4R3BMZVFnNE85WkZWWTB4ODI5WEJCQjcxODZ3YUZiWFVrTTAxL0l4bEI4dURnUHgvZWJvb3IyeldkYzFLMTA1WTVtOGlhVzFDcDhwUDdwUmdiUzMzampyWEZXZ25GeGk5WlBWN1dOSTFFcEp2b3RFZXIrSmRUOE02dG9VTm5iYmJWYllGcmE0VnM0amdiT0ZUdHV6MHJ6M3hKRkRLYlFXMHlUU2JRWlM1TzVnUndCbmppdWFzUEQxMG5odTExS1VSS3JUTHMzRm8zbFRIemJWUEpBN25wWG0xejRsYlZOVFMyWUVXa1RNRWpSVHU1NzhkYTRhZEdYTTdOdFJiYk5aVnJxOGx2YTN5UHBQUTlmMGFhVXd6Vy9uSHlSQzhMU0UyeVJwNkRqNXZlc1h4UGRQRFk2aEpaM2ZsSmNUSXFCU0NRb0dDZzllSzgzWm9ackY0WW9saFVETWpNQ1pCamp0WE9hemZXcTZUYjJzS0dNS0NTN2s4NTl2VTFjY1B6VGk5ZDFvVjdWY2p2YmJjN282MWIybGlHdDFacGZMQ1BJM0Q0OXZhbjIveFh2ZEh2WEVVcmlOOW5tQlFwWTRIKzFuSDRjMTVWcDl6OWduc1psTy9vekxuNUNQUmdlb05lcFgyZ2VFZFJqbHVSYkdDVzRiRnNRM2x4eFNBY3h5WjZnbm8zNTExK3lweGZ2UmJUNm1TcTFMZTY5anRkTjhkNmRxbDVNMTFBRE51VjJjS0E3N2h3R0o2ZzFtK0lOQXR0UmhzcjI4djVFU1Rlb0tnaGdzWkkyNTZFL3dCSzRXMDIyc1VlbTZycGpSaGkyMjVBMlNuYjkwQmwrOGdOVTd5Mk52Q0lXdTNpV1V0c0labVFNT200ZTlja2FhaFZ2RnRkdXB0N2E4YlNWejZYMERVcmZUYlN3U0cxVWVYYXh2RUdPZGlic2o4VDNyejNWUEZ0cTJwZjhTbU9PeG1sbkVjbHlveUI4MjRNSXlPRDJyUDByUmRhR2dTU1hVd2dSZ29XOHVBeW1OU2Z1eDkzSEhGY2ZxTDZYSnJRTnZESUlXampNMHpOdGVhUlRna0FmZDZWaFNweDlyTjN2cjAvVXVyTzhZcTJoK2pQdys4VGFacFhpaFpIaGtsRjNHYlNjS044Z2xjWlYyeC9DU1B3cncvNHhmUHJXbWFsY3BzMkdVU3dodmxVcU9NWjlhOGtuOFhRdytMb3hveU1pcm5LeUFyajVNdHVPY2xzOURUL0FJbTJ2aUhWL0RuaDI5am5CaWs4enpHa2ZieXZHU0QyOTZ6VUp2RVU3dXkxKzVtN3JSOWhPKzZhL0E4NTFQWGJvYUxiUTIwTHRjYWlIeXNhbHBGQU9BQmoxcm92RFBncnhGYmFOYk5keEJJN25jMGtVcktIVjE1V1FBbkk5NnlmQk5ucHc4UWFSTDl2M0czbENrSzV4dVBHQ2V5MWJ2dkdUNmJMUEQ1UWt0NDU1QWhZN2p2WnVRcHIwNXFjWVdndXB5cWFsTzdleEpyTmpkRFVYbnMza01iUnFDcXQ4c2NwR0cyOXNHdXA4TGhMSzAxSnhjUU5xTnhDcWJXYmNxUmc1SVQxWTRybVh1NFlMcFl2N2JETzZEN1RadGJuNWcvSTJ0eUM0N1Z3L2hpSjd2eHd0c2x4STl0YWw1RHVBVXNvN0hGRnIwbnpkSTMrNGNHM2lJcGJ1UjY5ZExxRU50TThERmJpZVFjbm5BUFdyR3YzczFob3pCeVdkOElyZC9ldStNYU5mT1d3VkxGVi9ueFhsVm5iUmE5NCswKzB1WmdsbXMySFluaFkwK1p2eE9LOHVObmR5MmluSi9JKzFpcldTZXJ0RkhqVjdZMlMyVnZLSGtOMDBqRXFSaFZUdDlUWGZlRGRRdmJXOGozWHJ3V2p4dWt3R2ZteHlGT08xWC9HRjh2aUR4SHFOM2J3YllUS1JHcWdLcVJyOHFnZmdLNFA3WGNXY1hsSWlzV2tIWGtxUnh4WHF4NXAwa3BMVnJWUFd4NHNyUXJ0cDZKN3JxZlkwdmlQU3JIdysrcFdkbnZXQmdyUlN2dVdXUnV2UHBYbmZqRHhtdW8rQUxpYVcxaWhlZTVWSTBUN29BSE9QV3N6eFJIUHB2Z1hTN0FRNzdtL2tMQkFNdCtYclhtWGkzd2I0MzAzd3hweHZyQmJhMWhKY0Y1bExPemRnb09jKzFjT0RwVVZKU2JTYnFOUmJlclNPbkdWYXZMS01VMmxGWHN0cm5OK0c5T2sxQ3puU04rVklaMTdoQlhaYU5wNjJON2RPM1IrQU9tTWZ6cnovd0FIM2FSWGpFN3NGQ0RnZFNlbGVzM0Y1R3JPckFncjA3MTE0cHo5cktLMmFKd2FwK3lqSjdwbHl6djlNdHRUTDNPNlNWVVAyZU5mNG5iajV2WVZsNjRiUTNBdVo1Y3lpTXBIQ1BmbmtWekZyZTdkVXlrWU16cmhaVzVDZzlRUGVxbW9LeTNNaEtocEpCZ1pPSzVGVFNxUmQydmRPN21jcWN0RmJtT3MwNlc2dlpZM1ZDa1M0UWsvbng5Szl5OExhbnAralhMc0lwTjhoQjN4REpPM25yWGtPa3kzSzZXSGxSUVZmYnVYb2ZVVjBOaE9aSmxVTURqTEgyRmNWU0hQS2NXdmQyME82TTNDbkZwNitaOUErSk5ZT3Q2VXQ5QkpJRkV2N3dPQnVHUGw1eDB6WDUrK083aTVuMVNTSnBpVkJDZ0E4RFBXdnB6UVYxSzc4TStNVlZ3SW80a0tzZUczSzI3Zy93QksrWHRjMHk5RnBGTlAwZHVIemxpZmV1M0FVNFVxa28zWHV1eVhxcm5tWStwT3BSVHMvZVYzOG5ZOWloV3lzdEh0b1l0cGpTTWJmY25xVFh4ZnJWeDUrcDNMNXlONUErZ3IxYnpydGRLbXhlU0JZa2I1U1J6N1Y1dnBYaDNWdFRuU09HTERTSVhVeUhZR1VIQklKNjRyMjhQVFZQbmJrbnJ1Zk1aaFg5cEdsRlE1VmE1eTZFaGdSMk5YTGhqNWh6MzVyNkNuK0dtbjZaRkJKZjY5RXpTWlpSYXh0S0ZDOEV2dUM0NTRycnZESGhMUno0WDhXWGx6Y0lyMjl0dHQ1Mlg1YmplMzNRcmZkY1k2aXQzV2h1cnY1ZHp3M0dTV3A4dFdzalNYdHVBMjArWWd6NmM5YS9iL0FQdC9WdEx0dE5lMlpHa2xoV0x6ejB6dEFKUHZYNWVhZHErZ05aNlpwOXZvMzJoVWN2SnZPMWpPMzhSNlpBSFFaeFg2MDI4MmxTNk5wTUVMaVdWMFJtaEkrVlNCOTQraDlxeHFTZDFwYTF6ZW1uSld0ZE42aG9PZ3pQY085eEVzaG1IelovdkwwSjlLOXRmVDdSSWwyU0tIQ0E3VjU1Ny9BSTF6T2h5enlTdWpMblB5aDErNmVQNlYxU1E3Sml2RDhaSHFjZlN1Uk83Zm1keTJYa1ZwN0o3aVBhc2pxcWdFYlNGSEhVNTlhcTNGMHJ4SUcyeUFkTng1UHMySzdVV3R2UGJwRVVLaG1CZGQzK0ZjeFlRYVhITmN4R1BZNFpoR1dPY2ozRllTU2pJMWFmTGM1aStuYWVFUzI4SVlxeWphR3lvUGNqUHBYbDNpR0tUWmIzT25RU1hWK3R5a2tzWkFTSlVVNVluUFVZcjJLNHRRc1VrU2NNL1FkQUQ5SzhsdmZCdXUyYXZlSmVtTXpySkc2ZGVENytoRmRWRng1bTdkRGdycTF2ZTIrNStwNnByUGl2dzVxbjlsV0psZ2thNG1IbTNMREF0b3dNdDgzcjJBcnlueGtQRGlhbzQwNjRFMFhaMjZ0Z1k0OXE4S3ZMTjRiMk8yUmd3R2VlUU0rbWErcy9EL0FNUDlEdnZDOFdveTNFV25wR3JCOTRNckVyMWNFK3ZwWG9LQ3FMM1lxL2M0M0tuVHRKeWx5NnEzUzdQbTM3VHF5Z3d4UUkwWmJKN04rZnBURTFIVzdhM2V4aHZHaVJuL0FIa2FrWU83cWMxNnJINFQxRFZyVzZ1dEpzYnVTMFRjRWxrVURkdDZrWS9Tdkw0MVJJa2lrdGo1aXY4QVBMM0EvdWdEcldWcFJlcXQrcHB6SnRxNmRucXV4a3lzTGViYmpKVTdXWUQ3M3ZnMXMyMm1Xa2tUWEQzTzA5VnlweTFObnREY1NMTnRFYUtDQU03dHhIY2lyMXpkd3RhV3FPNVVKdzZoZVdQWE9mU3NtbTFjMGs3V01qVXRhdW80Q1VRVGphQVJFb0RiZTJQUTFYMHhiUzZqaWxTMmNNdytaTWJtSnoxUHZXbkJJc2l6ZVhFcXB5Q0ZYR1FmV3Rqd3JkVzlucThLVEJ4REx1UjJVZ0VLUmpQTmM5cnV5Vmh0dFJiN0k1UzZnc3JLNUVna0FKa1g5eXgrWUFkVHhUb250MzFEem9aSlkxTEJoSHUrWmNldnJtdTNqaHNiUzZ2NHBvWXA0WlF3SmZHU0IwWUhzUlhQd0RReXFRMlFDbmtTVEVsaTJmYXJhZm5zTlMwMjBaZ2FucThLYXExMFpuWTdoKzl4Z0FnZDhWSTl6WWFsRzB6aDdpZVNUYkdVa0xCZ08zSGYrVmV2eW0wbHRiWFRKTlJFTnJ2TExJVVFaWWprT3hIU3VidEYwalRFdTR4RE01OHZOcEpHbXlNblBMSGptcFVXMzZFS2I1TkkyMnN2eU9PbGp2cmNRaUoxaWorL3cyZW5VSFBYM3FJbGZNRzJVTms1eU9EK0FxbmNYVUkrY2h6Z0g1ajE1OUJVc1UxcEhiR1ZtaUxNTVlQTEFkc1lxV2piUTNZeGQrWEtQTVlvK0ZZYlF1ZnlxamU2WmJYbW9Xc0tHWDVVQ3NNajVpZW1QVG1yMmtUMkQyRnhMTElzVWdLK1N1NzlhbHZ0SjA2d3ZJcmlIVTQ1NUpVVmlNbmRHM3RXYnVtM3RZcjNicGFudlVmd1N1SDA4U1cycngzVjZpSTA5bUd3UUR6dERlb3J1dkVsbDhPdE04SFRXVXRsREZlU3hBK1hKR1RLc245N2QxSE5lUGZEL1Y1ZEcxRzd1emNnbGt5eG1KdytPdzlDYTlPOFdhejRPOFpXTThkODMyR2J5dmt1Q3VDU280VU1Pb3pWeHJQWDdqT2RDOFlYY21rNzZIemxiMk1MYVpGY1cwNGNwbFpJa2Z5MkpYKzk2KzFYTGUzalV4eXhsWFpseTZqcUFQVTk2eTlDc3JHM3MzdFRjcnUzTm1WbHlGVS81NjFTa3RCQ1dNTHlTUnFSaCtnT2ZTc2xLN2E4em8xWFUxVGRXczFtcXBaN3BtbUx0S1hJWW9PTmdIVGoxclhndGJhU0FwOW5tM3RsZ2NnakE5QlhPM3R0SXV4dktPNEtDZHJjNHJTdDQvdEVLckZPMFVqYy9QeGpIOURSSnRSdmNiOHpJbDB1U1p3VllCVDFicGpIZWsvc1dFUnlCbmNuc2VnL1Axcm9iTzdsc2svZmZPV3lBQjFQNTFpQzdrYVhlVUlBNkgzck9EazIreGxOSytwSkFnUlZVdDIrVUU1eFZlMXRqTmV5bVJnRUl3dzUrYjhQV3E4ZDVLOHpGNEZ3NTRJT0Q5Y1U4dUZWeEF6QWpETWR1NWx4Ny96cnExc0tNRW5kSGRSNmRJTFMza2lqUlZWdVZVNE9CNkExdGFQWTZmcXR0ZXgzZXJTdzJxU2Y2c1lMRm03cUQySGV2UGJ2V2IxbzdXSjdlWHkwNnVnSSs5Mk9LMVo5Qmx0dFBmVTFYYXNhL0x0YkxrK3dvZ3BXUTVheGFjcmE2R25hV21sMkh5eFhHK0pXSTNTWkJjTDZaOWFpWjdHNHV3Nk1XVGFkMFlPZHArdFAwL1g5WDFmUjVQdEduVzcyeVpYenorN2xSc2RqME5ZVm9zdG5FNlBidThrcHlKTWJjb1BVRGpQdlJVaFp2VzdNK2E4bmV5YWR0N25hWGgwSk5QakVkbHNtNithc21RdzlDSzVHR05JSVQ1anFGays2Z1BKejBOY3pmWFZoYk5FWkhLcDNWVHdEMTVxTkxwaG1RSUNpZ2JIeHhnOXZlaUt2RVVWcTFxZXFXOHR2RFp3UUpuek1PWGNxQ0J1NDYxaVN2QWhVSWQ4Y2FGaWNiVCt2WEZZZGl5RmpMSXpMdEErWHFwL0NxT29TYWsxbE1scmJOY3p0OTJKR0FMRHZpbFpMcVRiM3JMcWF0aXhpTFhVRThxRjJ5UVJqYm4rN1diTkxzUXN6RmlHenVJNjVyRDBmV2RVZ1ZMYlVOSFNNSzI0R1NUY1NEeHQrV3RZMjZUVGpEbFVZNUFMZEI2MVNzbmRpYTEvVTJvNEYyQm85MjNHY25pcTdveEcwS2VUa0RwajhhbWpodVoxeW1YSU8waGNuQUhGU1A1eVNHSWpCeGc1T1RpaE5PNXFsb1p6U2hleWdMZ1l4anIvT3BoYXRndHp3ZnVFWjYwOUpIam5WZko4eFZPVDBQQTlLZERCT0hrYnpGYUVuSUlKQlgyT2ZTdFZZNXBiNmpabnVCRis2alE4RmNNTWZqOWZlc3EwMER4UmV4eU5aMkJuU0pRWnZMYjVrWDJGWG1sUjJSQklNTVFBNVBRSDFxaGZTSnBtb1NKYVhrc3NzZ0h6UnNWRGo4RDJybmtyU3VkTWIvQ3JKdmE2YlJrM0Z0Y0MrdGtqaHVZbmFQSldSU3BSdStUM0h2WG9rL2huWHpvY2wzTkVxMjI1V0R1NmtIUDhBZDdnMXdhNnBxTU45RmV5M0U3ckZ3Uko4NHlPM1BZVkJxL2lHL25Wb250QTlsTzI2TVJFN0FlNUMrdWF1bTRPTHZycHBaOVRPVUt2UEZKcExTOS8wSkxlVzNtak1JaGpQbHV3OHpiOHpONkgxeDJycW8vbWlqakVTNGpCM3YxeVc0eWE1cTd0Ym5TWm9RcTIreWRGWUZHejFISDBxaGJ2ZCtheDNFSVFReEo2K2xUYTZIOE94MHQxZkpER0VqakFaMEtnZ2NESGNlOVphVzJvU29zeXhJeGpZRmlXQ3NCNkVWYjh0QXFCMkpLSDVobml0S1ZBWld1V2pFVzZQYnVVOUFvOVA1MWpKYTZHcWZ1bkZ5UW02MUZHY2NyOTduSEgxcXc5eGIrVmNSaEZRbGhnRDV0M3J6V0NiMVdsekZtU05XQVp5dU4xYUxNaWs0VlJuNWlCeXVQZXQxb2tZU1YyWjNseWlOdVR0R2V0VTRvNTMyUk1rYTg5VzY0cmFtTjFKZkdFQkRHK0dRRGdmU2traHRXdUZWcFdoSzhEZDh3UDBJcWxzSzlrdENNMnR0RXJHSzRSeVNDd1U1SDQxb1JwRjVpZ01GVGJ5eTg0UDQxdFFhWk5KWUUyOEs3RitjeURCK1FkVGpyWEpiR1Z5Z084UG5hYzdRYVNXZ09UYkZ2R2UyYUV4UlNUR1JpcXIzYjZBVjJJazFDSzBTV1N3V3pRS0FJMllzekU5eUR5Szg4dWpjUlJoa2svZm9mdjVPNEQyUFlWM1ExZTV2TE9CN2txL2xBRU5nWkhzVDNGYnhnbkZPNHBPZDQydGJyM0pZN2hZa1prUjJMcWQ0QXdNVjB0cGZ3TEdIOHBNOEJ4akordnVhODZhUzRsbUVvYkF6OHlqUEk3VjNHbXBjU2pKVU1pY2tBY24yTldySmt6a3pWMUNPeGt2MWEya0oyZ1lrOHZCQTY1eDYwNTRIbENPMHh5L0lIUW1xcGVMNXlHMmcvZHdPY2VsT2E3aXVKN2Y1UXJvdTBTQVlBOXo3ME9OdFNMeXNsZjVtcW1ZNUM1WldWUU53eGtHc2VTNTh2VVRjTEVxTGhnc1NuaGM5L3BXSkxxTFNYRXV5UXREQ2NTSEdDVDZDdEM1WlYwMDNDU3hNd1VaVXJ5d2J1UHBYSEpwcjVtdHBYc1pPcWk2dXB3V1lBN1FNSEFINTFqd1JsRkNTRVpCSVVxUWVuclZtQjRaRVdRcVR5UVEyY0UvMHF4YlMyZHZjSzZXenh1RHRBNHg5VFhkQi91N2RqbmE5OGplYVZIU04xYU54bGx3dU1nOGQ2MkJMQVJDM0tsQVF4OVFPbnlpckVyM0Z3NGt1R0xxUWZtVmNIQTdDdEd5TnV3a2tVaU1jN1MzTEVlbFk4Mmk3bWozTXZFYmtzekhucU1mbFcvQnZ0WFFQSWNOamhSeUJXYkxjMmF2dERzV3p5VlVkUFlVbHhxZW5iZ1lqS3hBeG1UZ2svOEExcXBKOXR5RnVkUmNYSWx3RmhCQ3JoU1R5YThsK0lkeHFkdjREMUxmSXdpZVdNcUJnNUkvV3ZRYlBVVWdLbWREaCt2citGZVNmRlM4Z2J3VHFFa1I1YVdNRGR4d0RqUDRWdlRTL0FhY2xKYWFYV3A4TzZCUE0wenVrM2xpT010ajFIYzF2TjRnblc0YU9TNmFlRjhNTnZIR1B1MTVkYStJYmEzVzlHeFZ4QnNSc2NzVHdUbXMyQ3l1cFdXYTFMU3hnYmk2Y2dBLzM4OUtod1YyMmp0VTdKV1o3Q2RlVmJSclJJM1NQek4vSitablByN1ZhVHhGZTNNeWduSlB5c1c2Y2NEQjlhODN1cisza2hqZVNSWTVJb3loWWR6MlBGY2ZwbXFUR0s2ek0yWVYzcUNCNjljMW02VjliRiswU1I5Rm0vdVcxZTRta2xVeCtVZ1BYNWl2WUEvclhxOGQ5YnphVEpjZWVSSkFQTmJCNWFNOXNlb05mRlNheGNUUWp6UzJYYlBUb2UzTmRycm11TmF3MktwSXJnMndWM3oyN2dZcVpVVzNGQkNzbGZRdVhHcXpYMnB2S0loY2JuS0ZCbktEcmtZOUs2QlBEMW5OZFEzTVV6SXNVbnp4eUhEa0RrOGVsY2xCNG9uYUpJb2JndkVWM2lNSXNZVUR0eHlUVmUzMWEydlpVODFtRXNYS0hkd1BRY2RqWFJ5UFpHRG1tejJ6dzNyZHE5MVA1OE9iZFJ5aThNYzlDdmJjSzV6eEhxbGk5MExhSm1sNUlIRzF1ZWdhdk1kVjF1VnJmZEhJZ21CSVlJQW94N0QyckUwYWU5djcxSFJHa202RlhZY2tEcm1zK1JSVEs1cm50Vm5jeXBoR2xTT2FVc29HMFlYakhJN2tWMU5sTmJTVzRTVzY4cG93UE1ueGdGUnp6MkFyek8ya2h1Q0pKRWFQeUQ4ejlTR0hIZnJYSWFqZWVaSENYWXRDNUlCNmJ5T3hybVVIS1J2R2RrZXdUNnJwQTB1VzFpakYyTmpzbmw4QTkrUWZldkM3dTNtVzFpbFNOMmtZWjhsbElLajFIdFhwdmg0TU5QbnVvRVhmYmpPd1lKMjljSE5jeDRwYlVMbXloMUlYRFBLallMWjVCUHJpdElYNXJlWkV0VmZzY0ZhM2Zud0dJT0lwNGxaWTFKNGZQb1QwUHRYc2RocVZrM2hlMUUxdEJIY1dzb3hGMExnOThkL2V2RWZzc043RmlLTmx1QmdsY2NFOXpXNHpMOWlabnVjejdOb0RqNWdvNHlmNlYwU2plM3FZS2J1ZHRaNnNzRjNjblpGUER6NXdYbzNtY0FCdXVSMnJsTHpUdFBuZGNJNEtqYnYzRExnZE00N2pvYXBhWk9MU3ltVXlFR2NoVHQ2Zzl2eHJIUzIxNGJqYnM1UWtqcG5rZTlLTzcxc0RlaXVlaFhPbjJ3aWJ5THUzakxMa3N4NUkvb2E1MUxhNVRha3R3QWpuNVhibGZxRDZVNjgwdTViVTNpdDBMeEVENWp3Rk9PUWZjVnQySGg2OWszcGNTcVl4MEVrbUFQcFhJcktQeFgvTWxyVm5QVHhYUWxhT3puTXJ0OHZIOFdPd0hhczlyeStqU0lUdHVkSDJDQjBCSzQ3bjFyWXZkSVN4dW9wSTd0WkNXK1pWM0RnKzVISXB0eEFMdVpZYmRSaUZTek94SDRqSjdWb210T3E3Mk1aRWw3cUxlUXNVTUNLeElMN2NnZmxUckMvdXhGR2h0ME1KSlVxRklEdDduMXFLM25pdDVrY1JaQzg1enVHNzFycWRRdnIwM050QmRiY0tWWlZSQU54YnB5UDFxSGExcmVZUldwaEdWN3N3d2JEa1BnS1IzUHJpcHRiMG55THEwc1d2R2xkb2d6Q01sZ3JQMFVrLzBySTFDeTFXRy9aeTRoUlQ4ckJndTRleC9yVVZwRGUzMTZqMmRwTUhVNVp5M0F4MVl0MEFIclNTMmFhc2FwcmxmVjNJYldSb1l6YmlENXZNQUR0eXVhMmJwM3RJNVFaSWsyc000aEJ5ZTV6WFEybDE0ZWpuZjdTNG1sallzMDhiWVhqc0FQdkg5S29YaXhUNnM4TW04UkZBK05tMXBBd3lPUFUrdFNwUG0xaTdiZzR1eTEzWnh0NWZ4ekxIR3o3dVF5c09DSzZ6VHRSdHRyUnlScmwwd3FPeFZmcmtkNnliRFEyTjY5dW9YY0YzRnljaU5mVWtlbmVyVHc2RURLWmIyVWxQdU9rSVpTZW5Ra1ZyZURkdGZrTlJkL1UzdE9zNUxxK2d0Slh0NG9kdUFaVGdFdDB3QldYYWEvZjJkNllvNHhJc0xPcklRTUFLZWNjVm15eTZZdGk3Ulh0eE5OdDUzUmJFSDBJSi9XdW10cnN3cXNsL2M3M01LbUtOZ09mWTQ2NXB0SmRMK1FyV2QwY2JxT3FtOHVQT1BscVpHKzVqQno3MXpjQW1tdTJFL3dCN0pHd25IUGJGZW5UK0hiV2FLNWtNVzB3cUhublhHeFMvUlZCNjQ3MXowY2R1RmFJUHZqd055c0FXNDdxUlYzU1dpTVh2ZG5LM2RwTlBNa01ES3F3eDVJTGpIUEp3UjFyV1ZaYnVlM3ROalB0T0ZLOHQ3ajZWZXRwTEtOSlZrdFlsaERBS2VkNS9FVjEzaCs5UzNua3VZcmNTbmRqTEhKUlQ3K3BwT2J0dHRzWEZYYVZ5amE2UGZSMmM0bUJXRm44c2pmdDJzRG5rOTY5QzBLN2kwdHBWdGIrT0NSbzlzbStRN1NwNFpRUjYxcEh4VDl0dEo3TzlzN2VZazVqVU9GYlBxZXhOZUpQS2tGMnNhVzdPenY4QUtpTGtnSGdxYzFoZVU3cG1zclI2blNYajM2WHFSSmJKQTBod3NzWXo1aUgrSVAzRmQvcCtyd0cvaHRwcFE1Q25MT2R2QTkrNTlxcFFUeWl4K3p3MlU2ZVhKa1NTRUhieHlBQjByeVM5WEFKbGVNeHE1dytSODJlMkt5c3BPMXJHRjJqM0xYOUp2a3RyZTUxSFVFa3RYWm10cExhWUFCUjJBNkJ2VUhtdk5VdnIxMGloaXRaMGprSlRjaWc3d3B6bHNjNUhyWFgrQkw3V2JPOGEwbGEzbXRycm1TeXVSbUdWUjA0UDNXL3VzT1JXeExZUXd0cWR0cDdTeEtXY3hwSWQ3b0g1SURMd2NldFRLeTB1bitTTmVWdDM4anpiVTlNdDdJU0VtNXQ1NUVES1pFQlY4OWVmU3ZONE5YbWdtSUtxenFlREo5M1ByanVhOVZ0cGRVMUpaWUpMbHBoYXB1ajNqZGdEallDZTllY21PUzNhVzVXRmR5UHRWajgyV1BYcjZWMDB1cWxxOUNXblpOSHJXaCtPOVlhZTJ0cjY0VnJmZG55d2dCeGpzZXRZdXRhN1pQckdrdUNzTVFnSWRsVVlMbGlSdnJldExYVGpwNlgycFR6bVpZQ1BLamlHMk5DUGxMRTl6NjF4K25YT25wR2pMWnhreC92TXY4d0pmamEzb0IxckpScHVUYWh0cHBzVTNLeXVlczJ2aWE0czRJcFk3d0l5c3lFckNnZUhjTVpCWGtnOWpYQzMrbXgyTzZReU5jcEpnNVpjbkI2a0UrdFlVTnhlMzJvUmJKbzQwaGtCYVJFK1hiM0hQV3ZkTG5UcmJTWVpieXlsYTVzWll3U2hJQVZoMStVa2dIOWFjcFJnMHRtemZleDVtMTNEYXhQRnBrY3kyN3FDeGRjRU1SMDlldGRkSkhwZGpwYnRQYnlYTXMwQTgyOFZobE04N1FTRFdaYjNWeGRSS1k0NG8ybUx4Rk9wVnNaQnlQYXViRmc3UTNGbkROSzBVUnpNckFNSkQwejk3NWZidldFb3B2ZnJxWXQyVHN6bXRSMEpiaVcyL3M5OXlUN2Q4aEk0eC9lUFFWenNtaEpEcU10cU5VaTN4amlRNU1aWTlRR0hlbjJNTjVhWEVubHhTRlZKM2hzaFFPeEpyV21ONjdwR2tUT2NaOHNNcEJJNzl1YTdZeWt0TDZXTVVkTHBXcGpSOU51ZDF0dmtLbU9QOTN1WmllcCtncnR2QytsYWhxMm16eDZwY3BGYldxTlBFOGo3bnRBLyt6MUliKzZPOWNSbzE1RDg2M3NGMHJxVHNrSXdBUDdwejI5S24vdGViVmRXamlpdUdqc3dwamZiaEdFWi92ZjNxeGNMdVdsbTllWXVFdnY3RnJWOVZ2WlpKVEs3QzNXMWFLR2Q4dVN4R0F1ZWNld3JsUENlbnlqVHByaTR0SGVUelFJSlFNR051aFB1RFhhcmE2Yll3d2kyeGNDWWxMaDFZOGVnSTZFK2xjbnFPbzNWeGFBVzA1TUlZeHlMR3dES1IvZU5Xb3R3NVVyTFRVMlRiZXB1M3NBMCtLU1ozOHNLNVFNcHk1ejF6WEt4WG9XZVMxbmhtdTQ1U0NyUWpjK0NNZ2pJN2R4V3dMZXp1SUxXRzh2R3RuS2d4NVRLT0FmNG56d2ZlcldwNnRMcHF2WjI4a0gzOE5ISEo4emh1NUlIekNuR01rdHJ2N2lwV04yS3poTURRM0R4TmJiQnZQbHJHNkE5eTNyN1ZXc0V0TlNrTmxGY0xKRUpOc1VqZklCZ2NjazR4NzF6MmkybDFxZW9sWklKSlYzQUdPUTVSQUJ5U0IxQTlUVm54SnJzVjdwdGxaMlVFUWUwa1pacElJdHBrWGRrTWNEbkE2VmsxTnpVYnZ6ZlJEanByME5ueG5Gby93QnJodGIzV25TYTNnalFDRkROSGpxQUgrWG4xcmc3Syt0SUpiZHBMaVh5R2Y1MktndGxlaEhXdW1sR2xTdkZIcWR0SmMzRjVLcFJFSkRSSjBCNDZFK2xXYnRJYkhVcFliTzNoTUZxeEIzRU9XSkhVK29IZXRMSlJVZGZ3c0Rmdk0zdFQxL1U5VXRvdjlJdUxpUGJzaUVqaytXQjIrYmdEMEFxam9sak5lMmswYm9IY01TUnVHOG4wVUhGWDdLTFJyalFuaXVMU0w1QXhEaHNrc1RuSzlNRDFxS1RWTkdqdUxTN3NXVjRZazhzazVCV1RHTnVUMUhvMWMyaVRTWFZtM00rYTdaVjAvU3JHMnVtZDVYV2FQY1dWeVEzKzdudWE1M3hOcnQvZnNzY2tFOGNDeGVYQW1mbDh0VG5qMnpXeStwVFdKZS9FdUdsWDkwbWQ1STZFL1Q2MW9YbmlXYlU0aUxtQ05JZGdXSW9naUFWanlXQTk2SVg1K2EzTjA5RE42eHNuWlhNcTExVzBpMG9NbHF4WkdWdHNBV09PSmNjbHgxWmo2bml1QWx2L092RmhpdElmTEkvZGhuRzVlNUovclZIVnJSN2k3bVdPU0ozaEcweGlUYXpqMVVjQmg5SzVLRkwvVEg4OWJRcXpaVVBLaElVKzNiTmVsR0VXcjlleGg3UnB0SG9jbHBMTE01TnpzdXpHZG5tUGhjSGdNQ2UvcFhvbmdsSTlKdXJ1NHVBUE5saVZDd2NFSDFQSEFyejJ6OEdhMWRReVhzbW93aHlvZDk1SnlDTWdzVDB6MkZZbC9vVjFhUUxNYnVPZUxBT3lQT1R1NzQ5QjYxbE5Sa25Ebld1NTBVcXJwelUxSFZiSDA1cC9pRnIzVmtodDBWdzg2S1NEbmtucUQ5S3B5M1doYVZxTjRrb1R6bU1xS2lrc3pMbmt0bmhSWGh2Z1hVenBYaW5UYnp6bE1kcEo1aktWSkM3dVBtcCtyYW9icWZVQ1pHVXZKSTZ1RjRiSnlBM3I3R3VkMEVwY3ZTM1E5Slk2cTROdTE3bnBEYTJseVk0clN6aldNY3NTVDI2bm5BRmRBZFI4RmFiNWN0eklaSi9NV1FSSmh5QjFBSjk2K1ZMYlNOVXUwU1NPSHpNdDhvZDhaOU9EaXRIL2hGZGRlUkdsdEpZMWM0ZGpnQWUzLzFxMG5ScFdTZFN5NjZuSjlkcXAzNVUzNTdIMjgzeFk4RzNGMmwyMkRQQ2dTM2pBeStTZVFEMEJQVE5lWWVMUEVNbXZhcWcxS1o0NHd2N3RWemhGUFFBZnpOZUVXL2hhNHQ1VEtOMGF4RWtNNEc3SUhwL0t2UXJhNThXZjJkYjNTMzd1SU53QWxYekRFcDR6eUR4NmRxNTQwS0VKSjA1ZExhdmIwTzcrMGFzNHRUUzM2TGYxTlB3YnByblVMc1djSnZHVlNZYzRWUWV4Y3NRT1BTdlVwTkJ0V0VyM055Uk5HUTF3RWNjWjZrZFJYRTNtc1dGNUNBVVpRUExIbHJoZk5sQXdaR0l4alBwWE5uVlZqbkxtQ1VESVVMbmR5T3h4VVRjblVic3h4eFVZMDdKSFB6MzFyYWFpQ2p1NERjRmhnNHp4bkZkN1l4ZmJMbEhZaktmTXdQWWVuMXJ4alZ3djJpYTRDc3l5UzRXTTV3QU81SVBHUFN0bUxXYnRiZGpEYnNseUZBeUR1UjBIVnVlOWJ1bHpSVFcrd3FPWXVDbEZyUytoOUIzZDRKTFNleVVxcXhGWk1BWXd4ckV0TCsyc0libHl3YVFSazgrL1FWOCtyNG0xeHJpUmZMU1F5OGRPcHJWMUM0dllEQkFiSWk0TVJNMGJNVzV6a0FZL2xVUnczTEpKdGFuYTh6cHlob25jL1E3NFRUYVhlZUE5WFdTRmxiZEtzNWR3VmtkaGtGZlQ2VjhpNjYwOEU4Y1VFVVR3Mi9CRXBQTE55ZW5wWERhSmVhM1o2YmRYMDFoY3lXTEFDUkVmQ0s0UDNtSHNLNTEvRkU5OU04Y2NNYXJJNUlMdmdnSGpIcHhVMGNFNFY2MDFKTlRsZTNZaXJtRk9wUnB4dlp4VnZVNGE5dnJpVXl3cHQvZXZzQUI5NjlNMGp3L2UzTWtLSmM0bXRyWGdQeUVWV3kyMGUzVSsxY05McDF0YU5ITjlvVnpHemRGT0ZiMTU2NHJxYlM3dTdjQzdXYVVURmlmTUdjakl4K1JyMUtqMFhMc2ZOU2szSzdkN0hhd2EzcXlMcVgrblFYZHZBakZuWlZERUE0UGxISEdmU242NzRpdDd6d3ZhSVRDc3FTK1hKYlJMc1lxT1E3c09wNXJocmMzd3NmUFMzM1cwamVUS1ZBWUVrNUdRUDBOVzlaMFc1MHRvMXUwaWphTWd5b2poejViajVkeFRJREVkanlLeVVZOHkyVDhqSnpsYnVoc2tWdVd0N0tMYXlFUnNHWGx0MmM1UDhxL2JqdzlwbHMybjZiYU5JcXpMYnI4NFhqcDBKcjhYOUcwUzFtMURUakc4alA5c2o4b1orL0UzSUk3NTlSWDdraUdhU0MxeUdRUmhDM2JnRDFxWERtc3RkRFdrOU8yckhMYnc2ZG1HU2NmS1NTNmdrTVQ2bnRVOW1uMm5EQ2Rtd2M3a1B6Y2RCOUsxcDVFbE9kdzhwaGdiZVNENzFiMHpURXRGWEJIWHBqQUdheGw3cDJ4YjZqTGk5dDdaY1NTcUdJd3ZZay80MXp0OWNocEVtakdXeGhteDFOZERjVzZMTGlVSkl5dHd4VUhIMDlLeTdsYnN3eU5FZDZBZk42aW9kckc5MXBxY0ZyQ1hVc3liYmpESEJMaFNQdzQ2VnpYaW5WcnV4OE5TRlo5M2xrWnljay9TdTRlVXhKRGx3N01TQW5vUGNkYStQUGlYNHZ1TExYYlMyYTJ6RXpLQ2dYS2tzZTRyZWltNUpJOC9FTDNmeFBucTk4WjYxYzYxY3Y1enM1VUNHTXRnTGoycjZXOEhhbnJUMjBjR3MvYW1oaUhFRzRvV1Z1Y2pQQnJ4M3cxSjRZaDhUU1QzQ0VYS3M1VUZQM2FIdGdIT2E5OWk4UnhYMHFMTEMwb1JzdTdOODJQN29IWWVsZWhKT01McjdqamhLOGtyYVcvcXg5SVdIai9BRm02Z0dqNmRiMjlyYkdGd0E3WTR4MHoweWErZXpZWEtsM2ZjUG5JWTVMQUgzeDJxN2NadWJreFFzc2JrWlVNY0tCMXhrZDY5RTBYd2g0cGc4UHk2azEzQkZieUl4VlpINWxBOUY1L1dzNXluT1B5RmFsQzdWbzh6K2JaNVY5azFjUkgvVkhienV5UVIzNCt0WThjMFVzN0NZcXJaNUI2QWovR3RxMmVXZlU3YUtkdkxpYVpBMHEvd0E4WnhTK0k5RVRUTmN1cmFOMnVsUnlCS0NHM0FqSWJpczBwYk0wbTFkUmIxYXVZMWswMENTdVNtMGx0dmZINVZNMFZqZHVpaVpvbmsyL05nRUgrbFo5MWlDS1NKUUN4VlFTUVFSVU84UnJGdVRDbGNESzVCSjdWbTQydlkxYjJMOXpGYnh5VFd6eHRjUm5BOHdqQWI4TzFkQjRmbDhQVzk5SDV5aUZPY1lCd01kaUs1VnZPbWtaVVlLd1VFSFBYMS9Hc3V3RWYybTQzdXJFWTY1d3RLRHR1VE9QTkZybWUzVGMzdFl1YkthOGVQY0RGdU96YnprSDFyU3N2RUdvVzhadFluZDRXQmpTUEdmdmRoNzFsM3J3clpvaXg3bUlMS1F2UDByWmt1ZEhsdUxUN0hETERzUkF5T3dKTW5jZ2pzVFJ6TkoyTDkyeVRqZnpaemt0dHFFYXNzOEFVWndHSStZWjdHczlkRzBHMWxFOTVCSktwYk8xWkNpQnZVanZYckd2WE45UEdWdUJ2Yll1NEp4OU1udVJYazF2Y3lOcUVGck5PaUpLQ1VlUmR3VURzUjYxbkZPUzArZlFoVHRGdDZkN0hxYWVHNUk0NEpyVzBpdklER1NYVS93Q3JadWdCUFd1STA2MzF5ZTlSb3RLVGVMallZNUNGVmovdmQ2NnJUL2lUYTZWWTNWdEJwcnlTcWpLbTFjREovaXdlbGR0cDEzWnllQzU1ZnNXOWtoTXM5eXpjeGx6OHFqSGYyclNVWTJXblF4aFVxeFV1WlhWN0p2ekw5cDRSS3pzYi9VSWJTS1ZpU003aU9Pd0hUbXZJZFJ0SGp2cGJaTHhKSW93ZGpMa3J4N0h1YTVxTFdWa2xSdHJ5T01EYTNJT085YlN6djVkdzhjSlNUY0N4SEF4OUQxcms1RWtkOFpPMjk5UFJGbTJoa2FhQlBOK1ppRnl3QXdUNisxTGR6bXkzd1RUQm4zWXlwQUJPZTJlOVpEWE53a2dXUzNPWkZ5cnEzeUFEcWVlNDlLenBUL2FFNmdPcWdrYldZWnpqdms5ODBSaTczNldIZTd2YzlRMTNWOUN0cm14bnNMT2VaVXRGOHlPUkdLSktlRHlPNDY4MWp3L1pvTFA3WTg4LzJnNGFGU09HOW05QU8xWkY5OXQwNjdVM3p5VFJncnVoWWtLNXgxeDA0cXBxbHJiN1k1Mm1rdFI4cEVVbVR1enprSG9BTzFYR3lnbHVaeWw3eTMxdHI2ZERkdXIyNHU3eU9XUmd1NEx1VUFEYmlsdWQ3dHVSVDVmSTh6SXdUL0t1TzA2RkwrOVZKN243TkVYQjg3RzRBZlQwcjAvVk5NMFpkSnVZSU5mbGtLcmtvc0FTTmdPcEdlbFRHRHRvVk9yQzltbmQrVFo1Nmx2Sk14TUNtWXJnSGFPU2ZRR3ZmdEYwcnc3YitDTlRudTdlN1M1aU1qTWVRTjZqSUcwOXZXdkQ0TE8rMHdSdlp0RWtqRlRFR2J6R3oySUE2R3ZxclVIOFI2QmFXMHVxNmpEYzN0ekVqaTJlUGtrOVM1NkFZcnRwTFZ0cE5XT0d2ZVNpb3lhZk1tdGJYdDBQbi93LzR5bHZtdm1YVEdoc1REczh6a25kamdjakp6WFk2TmV6V2RsT29nYVh6V1UvTVNBby9Ic2U0cjdPSGhQd3Y0ZzBPRjRQc3F6dkhuekxkVCs3a3hrOGR4WHhqcmRucmRycUxXRTdvMGl0aENwQ0xKdTZIUDhBU29uVG5CN3EzUTBwVllWSlNUanl2cW0reHp2aWZXRnZZUHMvbXlLNHlOa1JDS2dQWUFEdFhuVnJveDhtV1I5VG5rd28ySWZrWmo2RHJ6WDBWZCtCVjFUUjRZN2VCMHZJV3dSQ2NrdGorTHQrTllBOEcrS05PdFlwZFN0UW5salB5QUVGVjV5Mk81cTBwSkxyZlV0VGhzbnk2N2FIT2Y4QUNyOVNtc1d1akJibTdqNEVFalpLS2VmbTdHcC9DdHJwVnhPYkh4TElJWXd4YTNXM2tWWXNyMUVuOFF6MjdWMTNpclV0UTFTeWwxR0MyTnJiektpTWR4NDJyZ25IVTVyNVZ0Yksxa3VwTnBkNUZ3RVVaYmN4NkdpY3VXeTVOVStwbW9UbkdVblVXdjhBTHZGOWoxZGJQU20xK1lXOTV2akFjS3BKUEFQQ2tkeGp2WFhQNE4xSkxKNzIwTHE2NE1JQ01XSVBVajNybDdYVC9FRmhlUVRRaVNHVlVQbWJrQmJIZkh0WDBEUDhSTHBMQ0tTd21na2NSZ1NMSmtOdlhxdTBjQ2oyY1cvZXV0Tmh0MUx3Y0dudHEzMlBrbDdlNmJWSEYwcnhPRTNPSDlQWWRzMW95M2x0djJ2eEhDcEFZS1FNOWNFK3RlbzZyNGdzdkVNNEF0eGEzY2tXMjdkWTh4cUNlQ0Q2MTUvcTNobTNzNUhqaDFodFFpRFJzWXdOaW44ZmFzWlU3UGZSYkM1M3pPNnMreGxIV2xnaVJsdVdXSjF3ektoR005Z1QxUHJYYTIybVNYc0xYRml0eE9Gd0RnQTdUMUlOZWQzRUZ2ZVhsc2pJenFCbEFvT053L1N0KzAxN1d0Q3VuYXprQ3ZKM0hwK05URnhUMWZxYTgwM0QzZml0MTIvQWZMZU5IY3NWM2drYzQ5dTMxcXRjZmJydUFBbmJDQ01qek52bURQVElyTmJ6OVNGekpQZUxHT0dsSXdDTng1d0JXMzRlOE0zMTlISTlyWlhGOHlzSTR3cW5hb1A4V0JXYmsrWjJ1N1BUUTB0Rks3YVRzRTkrNFcyUVJva2JIWUl5dUFNZEN4L3JXQnFIbGVhc3FSTEV5a3JoYzdRZlVHdTExZE5SMGlZUVRRckpKQ3h6MDJLZnhyem02MUFtUVBKRUhWc2JodHgxOUtVcjNzMFZUZDFwdDBaNmQ0ZDFLT3pnbnRybXkrMkNWc29TK0F2Zk5ZdXFTUEpPenlPY3haTWNhSU92dmpnQVYxUGgvVTdXMjFLM0R3aUtJd2xCbE1vTjQ0M1Z4RjRqdzYzY1R3Ym1pUml1RGpKSTZnRFBTbDdOVTRYNzlDazd6bGZleWR4RVN6dVRHMXlyL1BqQUJ3UTNwOUtwYWplK1RjcGJRUmc4bjNKejBxL3FGbnFRc29yMGhoYjNKSVJsNUt0M0dPMWMvRGY3WmdKTnVFSERNdVR4MnlPL3ZTVDhqSnVNcnROUGRmTmFFbGxGcXIzWGxSUW1TYVFjS29MTm4wNDcxYXVmRGZpRllkK3FOTlpESlVLNEtzMzBIWEhyV2l0NGtkdE5MRmR5Uk9DT0FTaEI5NlpkMnd1Tk5TN3V0UmtMSElqalltUmlSNjVQQU5WYVcvNkJlYVMxU1hwcWNmY3dBeXRGRkxtR0pCOVByenpWUFRCZDNzMHFSeG1LS0ZBWm1RRXR0OXZyU2d1N2hReFVGY016REp3ZmIwcjNUd1ROTHA4bW9XY2FKS2JxMkFYTFlBWlRrWlByVnZaTHFadTltMTBQSUxlVkV1VWUzV1RDRmlTL3pBRTlQeHJQdTJJdTQwTWU4RVpJeHhrOXF2ZUpkSjFpeTFsMHVtUkpuSmJiQzN5QWZRVm5ydTh6NWtKSlhnZzlLbTJxT2hjdms3bXpIZVRReU41WUl6R2ZsVWtFRHBqNlUyM05pL3lUSThZSTR3UDYrdFVmT25oblIwUml5a0RIWE9ldUtzdDVzN3lDUkRoUndSMStoclhxRWtoV1NOUWltVjJSZ1FXNjR4MnJycExFL1k0OWpSRXhwa3YweUQ2RHZpc1RVNTlsM0JHdG9ZLzNjWTVVa054eTMwTmJON0orNnMxUTdQbkNzaVpaU25yejNGWnltN1dSbTRPNjh6RHRwNXJaSG1pa1JndUFXUEliOEQvS3VvaXQ3M3lCUEZPeVNNQ2NjQWM5aDZWejg2Umk5a1Z5cm91Q3AyNEdEM3gyTlhMV2E1KzFRVEpDQTBiYmxVdDh2eW5qY1BUMnJTTDBWekZwS1RadTIxaGRCRVc3ZGhNYzdoam5ucGdWZVMyU080UnVOb0dDTzV4N1YwV3E2OU5xZCtsM2NhY3NNcmtKdVNRRmVuSng2ZTFjcGR1WTNhNElZSUgya2pPUDhtcmRUVjY2Q1Y5TzdHTGovU0kwUkFvQkp6eWVlOVpCdVRKYXl4aVV5UmJRRklYQlgxeUtTNHVRVkxMd2hQVWRjL2pXSkpxRjlic1lvU21BNnN3WlJ5UnlLWEtrUTNMY3AyMytqRjFrTXBWeVBtSTNGQjdEMHJyWVlwQVlpMEoyT2M3dDJUeDNBL3hySmlBbmtubG4yck95RXFnUHY2RDFwTGhMdzU4b2xNQUl3UEdRUGYzcStaNkpGcEp1N090dVhsZnpGZTZiYWh5T2hBSjlNZnFLcld5cTBlM3FjbkFCd2FweHJJYlA3TzdsY3RuSHYvVW1yZGpDd080cDh4SkIzSFBBcUpwSXkrMHV3UVJJdHhJdUFUa0RPYzR6MnJwb29iUzNoS1RRSTdPeDJ5NFBIZnIzcmxsbFBtSElJSWJJUFhqM3JvNE5RZEFVbEhEQTg0enU5aDZWMWU4b0loL0VhODV0UkhLaGhMbkFPTS9LUFRwWGdIeFdjUDhBRFBVeUxVZVlKNHlyZzUycm5HM212WUx1ZFk3VnRoSVZodElIOFh0WGsvakNlM3VQQU91d3lueVpCQXJScndkeFZxVVhlU0t2cXRIdWo4eDVMU05GUXRESUpSOHpoaGdNRDA0UDg2aGpsdXJjTkpCYzdNY0dOVDFCNmozRmJseGNJOWtubjNHNXdtMU1IZHQ3NHllMVpzMWdCSEhJamdPeTd5UFFqdFd2VFUwYXRwY3lvMWxuSllsSWh2QjJrbnFhZGMyNzI4OXdGRFJHUUFEY09ENi9oV3VCc1ptWmdvYmF4eHhrK2xkSmZXbHhkVzZSeG9Edkc3SmNBYy9YdlJ6cTZ2c0k4L3M5VXUzSnQyY0JHQTNFRGo1ZWhyYzByVGhxOTJiYzNhcXFmZE1uYlBZVmVzclczMCtTME1rSWtrYmZHeTV6dHp4K2RadDNiVzlxSXByY3VraXNmbEhPTUhnaW56UjV0aUw2YmhxMmkzK25XY2lNeWtDYkpiR09VSFFmenJaMEpVaXNKNzUzQUxST3F5SGdJMmNEcjNyb3JMVlk5UThQWE5uZmpjNG0zeFNFWWNFamtIMnJoV2tqaXNEYVozeGI5M1BUUHIrRkRuMDh3MHVLMWhieXczREpNV08xTU4xRFA3SHRXYlpJMW5kdW5tbFhIY0hxZTRyUnNJNG9XY2VZeGpQR0NNRFBYR085UXkyaUM0L2VUaGQvejVJUHk0L25VWDFab21raDArczNjNDhvSHFTV0E5ZmV0RFRidlVDNnF0bUc4d0JBbU9HUHJnOGZqWEtTeEZuM0RsbVBZWU9hOVdpdUxTdzB2VHhFUk5jbGlaL21HNEtldy9yUzAwVml1YTczTkR3NXFDSmI2akZKQzRhZE5uQjZINlZCWmFxME1FOGNvMmxsSVVzT0NSMUhQZXVmMDYxaXROTG12ZC83NmFWZ3NmVUtucWZSdlNzd3pDNWdrM01YOHZMTGs1QUpweWlyZ3A2V096MGF5bCsxRzZLS1lrVm1SY2JjbkhJOXhXTHJCTDNMUzdvd1gyaGtVNXdQVDhLem90YmFGYmVFeTRDcTJlZTdmMHFva0RDWkpsMmxHWnR5NTZNT3grdmFzZFUzZjVEY2tsWXQ2ekRnV01GdEFjdklHM0RxM0dNbjBxMXFFTjYwaXBKY3lXcklNTWl4c2NuMU8zb1RVLzhBYUZ2YlJzNnU3UzVHTzZvUFErOVRRYXJMSThzak5sbklMYmlldnRUaTNiWXBLK3BvNmhxMFZ0R3lUM0o4eG55eklNRWUySzVVK0xJbE1ZQ05JaU5uSk8wL2dLOHl2NTVaNTJrZHl4YmsxQkJGR3lTRjMyNEhIR2NrMTA4bE5MNFRuVW1lOXorSjlOdUxHZEVZcXpLTm9KejlmcCtGZVZOckdiVXdtMnlFSklPNDhacm1Ra2c2Ti84QVhycDF0M1cxVndOek5rWnhrRUR0U2FndWhuWWRiYTIwYWxFUmtCNXoxNUg5S3VycjdBYnBHYVdRSDVmcDcxWU52Q21tdTdBbG5BRWFqc2UrYTQrT3psSVdRSmdBOSsvNFZGcWJiZGlrMmpwMG51dFNpOGcvTXpFdnRCL25tdDIxT3ZmWmZzTnE1TVR2bVJTUW5UKzhUMkZZY1VqeG1CbzRvekd6YlN3SHpmUnExdGFodUxrSXlSU0JVQVV2a0wvMzE2L1dzbnVscFlhVDNDSlprdjhBWk1BVkEyalluREd1MnZ0TTFXM250cGtsRTRFYkhZcWtOQ0IwRFo2bXErazNFRUtxWkwwRU1Cdlp1MlA4S24xUzVqVWJvWmhjUjdzdWlOeU05d2ZRMXl5Y25KSkw4QnliME1pODgyRkpJNGwzU1NxRE5JT0FGL3VLZlQxcm1ia0NjeG84b0IyNERqbkJIWTFxM3VxVzRzNEZDbVNaZ1FEMENqMFBxYXhyZXpHNVdrendjbE04bjZZclNLYTFlZ3J2bUpOTnZyZTFpdW9wUVo4Z2JVVmZsM0E5Q2ZTdlQ0N25TYjIyam12aWtXeGRxYkI4d0FISEhjVmxybzhOd3BFY0tFTUZLbHpzZFNlaDQrOVdyZFdNZHZhWFVVME1iektWS1liZHN4M1hQWTl4V1ZTY0cxYTkyK2c0eWVwejkvcU4weVhFcW1GaHNDRkFDTjBmOTdIOCs5Y1hwOXJjUEtzbmxsU29MYnVSOHZzUFN1Zyt5WHhWcFlZQyt4eHZUcXdPTTlPNE5lc1cwMm1heHB3V1lwRFBDTnliVnh3bzVVZ1ZUcThzZHI5MkpYYlBMbHNuZVIxWGNVTWU0RWZMa3QvT28wc2xzb2pCZFhLZ1hTbktSUDhBUEdSMExBZnlxLzhBMmd6TGROdERMSWdSQjJVcDB4WEhXTnpGRzBrc2tSTGRNNXpqUG9EVGk1V0o1ckcvWjJtbTJ4UnBKY01neWlaeVh5ZVNTZjVWMjl4cVVsMWVvYktDUFp2Vlgybm9SM09mWDFya0xYVHJLNDNTaU1tVTRBM1NZd0QzeFcvTm9rRm41RHgrWWQ2a0VaSTVIWWlzNVZJODJ0NytZK1Z2Vm5zMm5teHU0TGkwOHhJcGJ1ZFRKTzZ0OGlqK0JmWEo2MXlrSGhheFRWNytNUngzSXREdWFJNFdSaC9lVUUvTW9yek9iVnJ5UmhiU1hlQVdCWWhzbFBjVjAwRjNjbUpKa21qdVdqeVVlUjlyZ0QwUFVnK2xZeWhKTFIydWJjMTJ0TmlHQ3h2ZFF1SFdBYjQ0WHdFSXlVOWw3ajZWNk5wWWtzTG1SREcwYnFtQTV5dTR0d0dCUDYxNVJmNi9mUTNOdmV4QllwSGJFeUFmSyszKzltdlZkRjFBMzE4MXNzalhFVjJoZUdFL002Uy8zQWZUMHJPY1pjaXZ0WWFlK3B5RFN6V1Y5SWJrcjk0U1BzRzRrNHdBRkhhdEdXSFNwNHl2MlJSSVd6R3FuYWhCNXpqdTFaM2luU2RUdVFnNGp1SVBsMkViR09UeVBXdUx0UnFPblhOdTl6dVpRNEJVSGdkaUQ2MXBHemltcGE5ak5UMWE2SFRhbDl0MlhLUjduczVqR0dPZTZEb2M5Z2F6TGJ3MzltdG11aGVveGJJOHBTUG0vSHNCM3JXOFNDNzh5QnJWSENISXlEaklQUUgzckt0dFR1b1lidEhzbFZzK1crNEhjaDlmUVZwRnZsMGExTSthNjBPNDBwSXJTZUNHOXNMY3JOaVZXRGNCdlFBY01LNVRVTlN2YmU3MU95TE9xRS9PZzZidW9JcmpYMXk4TmhKQzNuU1FwSjkvZ2JUMTJnK2xjN2VhdkxjUlFLUklaSTg1a0p5U3A2QTQ2MWNLYmNyc3BWWDFQWGZDTHlReTNXNGVha1Z1NGpKUHkrYkozejdDcTFoWlNyZHdRd1NSczZ3UExka0UvS29QM2M5MnJrOUw4VEphMlQyY2R1ckZnd2FSY2grZlgxeFdmYXkzSmFTQTNCalRZV0lBeGs5czFUakxtZlF2blQ2YVdQVTR0R211TVBEZE1MVnp1SHlFTWNmWFBOT09rMjRhV1ZJR2ZDLzZwVXlvSi9pR09RSzUvUnRVdnJCYmhKV0gyZVNQQVpuSlZXSGRRdlUxck5QUHRqS0tZdzYvTGhqdTQ1eUFPZ3JOcDNlcGx6ZFVlZFhkcnFXb1F4anpYaGFCaUJHMlFyanIrN0o2bjJOWmxqWXpURjNlVHlYUWxOcmdLTS9VOGZoWDBaWVFhemZDeHQya3M0VEtyK1U4Nk1SdUF6bDI3RW1yR215d1RRdEZxTWx2SEk2TUhXUzN5aGRlRDh5bmpwa2NWY3Frb3BxeUpUZDlybmhkamE2cERlQjRMdUpIUVpBSkJVNDZnMWZ1OUxUVlpmdEkxUzF0TG1jZk5HaUZFWXJ4azRBR2ZwVi9VdEJnTnZOZHgyYnlvWk1DYUE3MUI2WVlkZ2E1aVM2MGxyVHlNVG1UZGtnbkN3c09NaFIzUGVtcE5wT043K2lPaE5yYzJMRHdsNGlsMDY0VVhrTTFzWlBuQzVKVngzRzdHRCtsYitudytFYkNOSHVyZjdSZFE1VjRaRDhneDNCWHRYRmFmckVJdGtpUlRLV3l1V2xJQVlucGowcVRWNHpEZW1DYU5YbUVRRXBYbjczSUJ4M0ZVM1VscEoyOU5Db3M3RFROZVRUNzIzdWJjc3NyVFBoNFN4MmorNmZWUitWZWtYZmpHNG4wRzZ0cG9iTjVSTjV5ekJCSElBZXE3bHhrZTFlSlhOMWI2VFoyOE04YVQzSHlza2F2Z1JnOU4rM3FmWTAyek9xNmtubFNSL3UyTzd6V1FMNWVmVDFIdFdFb0oyZHRFOTMraGNtcmJhbWJKcVMzTjNjM1VzWXRValg5Mm9jbHlmUmUrYVhTbXVwM1NHemplVXVTdnpZTEV0emdIUFd0Szg4TVdKYVFQZnRHSTN4bklKWUhvY2R2cFhWNmZZYUZwZmtYMHBsZUNOOGlKRUt0TVIxRzhkdld0MjRjcnRyNVdJakxXOXpyTEh3WmIrV1picVZvd29ZU1JvMlZSaC9lZitncXZxRnhwVFR4d2FmOW1GdjVZVmhzK1ZuNkhyM05ZbXBlTEw2L3NIamlFTU1Fc3VkcHdyb2c2RDNGYzNvdW96eXhYZG5IWm8wZ0paYmduYUVVZFZ4M3pYRzRUZDNKN2RMbHptcjZiR2RxTWs5dmNCR3R0c2lFTGxBZmxHZjRndkFxejRxdXJTOHZvb3JObWVKWWxSaUJ0VW5ITzBIM3IxRFNnTHkwVXZiaVFORThUQUU3bVk5TUZlbTBldGVlWFdsYWUwV3lDM2RMcUZ5b2lhWUtzb0hVcWZYMk5iUW1ycTYxUkY3SmE3bmw0MFpaSTk3WEVhcEg5M0xEZVBiQnJwYktTM3M3YVJCcWQzQXhHNEVFTkUvb05wNkgzcnZORzhPNm5mZVJPdG5Ha1Z1V2E0UURjVlFmeE16ZDYxSmRMdGRhMU9TS0MzWjRWQk1QN2dCNVBwdDRGYnVzdXIwVy9rUytXNTQrbC9kelB4Y0dRU1ozQnVBY2YzaFhaMm9NNTJXY0svYVJBTnhsYmNGSTdwNzF0d2VBbzdxMmE0anUwODZNU045aVVrTUFod1FQN3hIY0N1bGdqc3RLMTdUMUwyOWp2dGZuV1ZTMmQzSUxBRHVmV3NxbFNMMlYzcjBHcEpHWkI0VXV0TzArOWU4bldDNW5VT1ZLcXdiL0FHUjMzVnlPbHp4M0t5RzR1NTRVZ08yUGJGdnl4L3ZaL2hIZXZYNTlaZlZZUnAwOWpBREhjYjVMNk11Nnk3Undxay9LQjNOZVVYa2Rva0YxSkhORGRiWEFIbGt4YlJudUQxSDByT201dS9NdFRWeVNXaDdYNFlsdHBwSGtaSVhTRmxVdVNGREgrNzVZSFN1WlR4RnBUK0tVYS90bU5xSmNzUVc0Q25xRkZVTEhVNHJ6UjdTd2lzN2VDZFEwa2JnRXRjQWZlVXVwQjNlZ0k1cnl1NlZsdVdVbVJCdUpDaFNvUDRuazBvMGs1eXVaU3JiSGJ6NjJOVmsxZ3JISEVyRm5oQXp1WEJ3TUgrN2pyU1hhNnhzMHk1c1VkQVZCVlZPMDRIeW5qdmsrdGVlQzhuV0NIekF5RlpTNktNQTU2RFBvUFd1a1h4SnJsMCsyTUtyWnlaRTVZZS9zSzM5bHl1NlNTUmtxdDkyZEplV0d0VFg3eFMyOEZ2SUk5N0FEQ252azQ0M0gwcnJ4NFB0dFVUeXJPNU55RnR6TTF3TVJLWFhxbmJCRmVCWEY5ZjNHcHVIdVNEdEh6dExsc2p1ZmYwcjBDMm5uaThGeVFXVnpjQjVMd0dWMlhhdTBET1d4MEh2VVRweXNyU1NadkNwZStsOURwYkx3NG1xNmZBWlo3aytYS1VWQUVVbGY3elNOOTdINTArKzhLdkhCQ3RnUkVVT0NUSUpIWlNmbXdPZytsYmxyRE0vaHNRcHFNVWh0MVdSR1ZWQmxEbkJDRWR4NzFtNlZOcTJzWFN4V2dFUXRVWVRUeUV2SEdyZFN6ZDI5TzljMFhVMTFWazJkU2hCMnZmVkdCWTJCMDlyZ05iMjBHSnZrbm1mZklRT2NxbzQvSEZXbzdYN1RxMDE5RXJYQlpzeW56QnRCSTduZ2dmU3V5bDhNTGRySmN3dlBJTGRWQmx4dGpSaWNBSDFVMWg2OWE2N0Rwd0JzaUpFa2JadEFPVVgrSUFFY1ZYdE9hUzExZWpIeWN0OTdGYngxWjZuZFFhWlpmWmRvYUxlc2thYmtVS09tUjFHT3BOZUZ6VzBFRUVGMmxuQTZTbGtSUnVWZHljRW5uSno2VjlFdzZkcTJ0TkhERE9HdTQwalBsbzIxNUkySEl6d0FSMHhYTGVMTkltVFI5RVpMUzVFYVN6aVRlTWJEdStVTnQ0ejlLNktOVzNMQnlWK3BoTks5MGVIYWxleTNTYm5pQ3l4OEZRaFJTQnhuRmF1bFhkN0ZOYlhGM2R5ckFPTnBUY3BRZWdIYXZvN1IvRGVsNnA0YTF5Nzh5VXoyUWlaL3RLOE1zaDJrTUJobElQUnF3TmQ4TG1lNTBDMWkyWU5naDkySlluSngzclZWb051TnJXMys2NGV6bXRUZ21TQzVYRUpkTFpKM2JCR000NUJHUDUxZnNOUDBIVUw5VWlzN3FLZmFjeFJ1SklDMzkvc1FmV3ZYTlMwcldOTWgwK0s2c1Z1TGVRTjU4Y0RZY3FSOTlUMHlCMEZiY1hoZlNQRDBJdG9yaDJlNmhlZnpDTU1xT3VVRWc3TjdWZzZpU3VudnRaajltMjl0anlid2pid3orTnRMdGpFVmNYYUE3R3lFR2VRSy9jTFlrRVNEekNRRUJZZFYvQ3Z5RitHMmlha1BHZHJkV3FXdXlFNzVKeXhkcENSamFGT01FVituZW02MXFCdkVqTm95UVJvVmtjTHd6SG5uZDJydHB6VGp1U295NWw1SGZxYldPRWVXUHZESXo2OTYwWnBtVzNSb2tKTzBISEhXby9PZjVTSTBZTU9Dd3lNZW5IZXF0eU43S2hpQ3U0SEMvZElIUFB2V1U0Sm5SRnU1enR4ZFhVakw5blNJU2tIZVpDVkc3Mit0YU5yUFBHakpLNm82Z0JnRDFQMTlLaldLNG1hNGRtRG9RZHFZd1JqMXJpUkhwbDU1UldXU1Y0cGVqNUJHRHlNVmh5Nkc3ZWhvWGtCTFNUeHlKSGNJY25JenhYeUg4Uk5LazFKWGJjdnpPR1Z4amNIN1Y5ZTZvbG1sdVZIbUF2bk9XeWNIMVBwWG11c2FFcmFidWlNY2p4WmZlTS9LZTFWVG5hUzdwbk8ybXZVK0VORTAzVlp0WHVJYm5kNThVVGtnNDUyOWE5MzB0WjRiUlZXSUVGaVdKWGtuMEo5S29hWEJOYWVJNTU3eVJKTjF2SUNpZzVZTjYrOWV2MkxXSjBvbEp3ek0vd0FzU2pvQjNiUGF2U2I1azEwT0NhNVY5eHhFSWQzK1diTDcvbUI3ZlN2cVg0ZE40UGJUdFJoMXJWMmpsbHpIREN6a0pqR2NudDFyNW92YnVDeXYwZDRSc2tHNWRoeWMrK09sY3lsN2NOdlpiZG1BY2s4WndEMytsS0xjTmJYMEMzTlR0ek9OK3FlcDNWM1BJdjJwWWR2bEYzWHpDY0RBNllKcmlySyt2RmpJQkpBSkFiT1AxcW5kNmlIdHpGNXI5OXFBOERQY2c5Nm11YjltdEl4SEVnVkZDdWVtVDY4OVNhaTdzOURXVXJ0TGRGMmErZjhBY0Y1QTdLTmdETHUzWjlhWURLMERxNDJya09vNEdEWExyZk5nU2JDVkxoVkJYZ242bmppdXhUWHJ5eER4TlpRbVl0bHk2cklDdmJCN0dvYWVobTN2WkZhMmxqamtXUm8yaksrdjhYLzY2ZkpkNmUxMjd4VzZXNWNiaUYrWVovR3NHOHY1aTZ5WlY4Z0hDbm9UMnJwWUlJeEJGY3l3UU9IM2ZLelpKeDZnY2lodzB2Ym9PNlRUYjEyV3BZczdLNm1rZHBia291MWlneHl4SDhxdUN3WUJBdUhKWGR1SEJ6Ny9BRXJvOUgxclRMVFNwaGZRTUJ5WXBRdWNNMzhJOXE1eXdudUgxSTNTOG9XTzVBY1pCOUtUcHZsdmRGcWJrNUxsYXM3Sjl6WGtqY3pocER4SUJ0QXpqQTZuNjF6OXdsdkxxU0U3Y3huNWNEMTlUWFl2YW02dVdLU1lLREdNOUYrbnBYT1hQOWtxaGlXNEpaMkFPQWZ4elhHcE5hQzVBVFNiK2FTNG1pV0dKWTBKZDJZQTRIb081TlF5YXJkZjJJK25wTW4yU1lnek45eHZsNkRGZEhxMm5hWEdMZExXNGtLdkNKT3Y4ZmZjUFN1ZGhDaVlLOGNiUXRrYlc2Wkl4azFTZTJwbEp2dGRkRmF4ekMycTI5MUdJNVBNUndNTUFRTWV0ZHY1NHM3eFI1aTdYWURjbUc0OUJudldOcDl2ZVhFVHNZVllCdGtTTC9FTTQ0UHJUNVBMTTVWSWZzNWk0S0U1d2U1L0dsb3p0VnVXeDBHdVJ3WGlzSUZieWdBZG1mbS9PdVYwOW9JYnVCekFIQy9kVnM4RWR4VzFjYWZlMlU4VThpdE5FV1JoMUNrRG5CL3JXaHFtcGFiZVhiWGNWc0xhUlR1TVlIeUg2QTBvdHE2RWtra2xxcmJuTmVJcnk2MU9lV1dWWEJqVW5BSFVnY0Qycm1sdk5hMXFOeGUzOGhSRVZGak1mTzFlZ0J4MEZheXg2alBkWENXa0cxYmpMWmxiQ3FUMHpqdFdscE1OL2F3SlkzVWF0Tzh1U3g0REVlbWVsVTlGcDl4bW5yc3RQTGE1ajJRV1dKYmVWVldOUnhJQmxpZmV1cGt1VlhSVXRyZGx5MGdWbjI4bjN5YXFhbHByV1pYYkhzWXVEMTVIclNTNnJMYzNTN0xGSTBqeGtJY0FBY1pHYzhtdHFUdmV6NldJcXhVdVh5ZDBkVjRhZ3NWdW9mdHUrSkVtQkVvQmNFcnpraXRENGxXbmlLUzdodkxDOFRVWlpwQVMvUENmM2NIcGdWeFY1YnExeVd0N3E2Q2NZUjJHZmV0SnJMV1FSUERkTWdSZ2RxbkxBZDgrOVl5ZHJHOUZXYWszMDJhN25zdWc2ajRqc0xjTGNQY3czQXRnbmxSdUYyb2VRY2U5ZWNhNHBLVE5lUVNHQXNydEpKSVdjc0Q2RG1uM04zUEt3dURJN2ZJRU9jZzRIVEpGTXMwdWJtU1NYekZ4R0NjTjg0SkhRYzFLY25iVWZ1eDEwVGZ5UG8zNGZlT3RDaXNwWXJpTjRTV1ZvWEE0SUF3Unp6VVBqbnh3azhsckZha1NXMGd3enZ4dWIrNmZTdklkTlN4MC9TWVpycWRKTlFuRWtubHFnWkkxSFFIMEpyeTViNUhmekgzYjkrTnBHQUFlNHJxNXBxUExwL3c1akJVNVNjdFhyK0tQUmRlMWhaN0tPelJjS0NmTTJrWVVIcWNtdVlPb1cybXBGOWxOdnNBVUpLMFEza2Y4QjdqdFcxTHBsMXF3a2d0TFo3bEkwTHU4YVpBOUFSL1d2Tzlhc1pyZXlqVFlJbWhaUVZjWUovT3NZcHV6YlpVb3djZVcyamQydlU3RFJaTCs5dUxtZHJtY3FzYm1hVXVWM0J1TnYwOXE5SWk4SXdYWGhocnhiaUpKdHpoeTJDTm82RGpuUHZYamR0RDRndmRNdi9zZ1l4eElKSnhGd0RnOGNWek5ycjB6UXZDREpFUWNTbk9NZyszOWEyOXJIckcrais4NWZaMTIvZG1vMmt0RjI3TTA3WFIwYU82amx1MWhELzdSeTNzQ090ZGpvbWplRzdIRFhNMDgyWVd3aUhEQ1FmZHpuT1JYTDN0eUxTd3RKcmEwY2Izd3F6QXR1eDFJejI5RFRiWFYxdVRJc2poSmZNNGZBQjIrbkhGUmFUU2ZjNjNacDZ2NUZZMmw0ZVltSDd0OXpMdjI0enowSGF2VWJhLzhEdFp4UVhzRWNzN3huZExBN0l5RTlqbXNDeTA2U1dDNnU0SGJaalo2L043aXVhdnBMRlo3ZExLMVdOb3h0bW5kQ1RJeDY0QjRBSGFrbEdMZlVoMjVrdGZrN0hMYWhhYVRCcUUwV21yS0lWSTNlY1FRQ2Y4QWFQYXZvN1N0UjhZZURQQzhvMDEwTFRvWkhVa2NESFVIMTlxOG4wUzN0Skx5V1c3dDBudG9WTzZKMjI3dlRIcmlzL1Y3d1BianlwR0t3bjVVREZnQWVnQTlxM3BPS2JldCtsdWh5MVZLcDdxdFpOTjNWN25LMk1sOXFUeVhOM2NicEdZa3FXNUpQcDYxdVdkM2ZwUEpPa0tTR0xoZHk1QysySzVCVmFlUmdMZDNZS0NDRHRDNTY1OVRXall4a3VrY3JQSHR6aGgvZTdCcTVwVTA1WE81TzhXcmFXTnBFdVpGbGo4d2tTSExSWnhram5GT2p0VEpOR0pKa2lVRWhONXllZjcyTzFaaXVJTjZUNWRtSEI3a2oweDJycXJteHQ3YXpobWNieXlCOGhnUnoyT09oK3RPVk8raGs2dkwxdGNpdjNtZ3QwdGx2UzhJT2NKd2hJN2dkeFhOMk1Odm1SMmJjTjQ0SzV3TStocTBXUjJDb3B6MUNqa2YvV0ZSM2tEeHd4c0pGQmt6bFNjRmZyVTh0bWh3YTF0MTFPa3ViN1RwTG4vU29qTWpjQll3RjNBZGlSMHJqOVhhR2RjV3F5Q0JlQUhPU3VPeEk2MW5zdHhKZXh3QmR2eTVMRTdRbzlBZlUxTGVzNnpSUTlPQVN2WW10N3JRZXFzdWxpbFoyZG9aMGxrRTI4WUxqdHNCNmozcjNlNmJTL3RaZXpoM3hSd0x1YzkyYnVjVjR4UEpjUnRzVkZWZTRCejFxUzFrdXJXS2RJNVNpU0g1bFZzOU85Q2t0VTF1WnU5MDAzcDA2Rjd4TGRYRjNxa2VOMG9pVlVFdU9vQTdWVHNMTXFyeXo0eTUrWCtFWTkvZW5Xc1Fkaklrek1OMk1uZ2o2MXFmWkZNWkRTZ1pQekhiemo2MUtnbm9XbnFoTDI5SkVVaVFSUmxTRk93SG5IR1FEbmsxbWIyYUF2ZzVMWXdCamcrdE9uaFVzb0xCMUJBem5yNzRxeDlrazVLeUJrM0JTQWNkTzFWeUpXR3Z3UFU3UHhQcHphUGN3eHdUTDVPMk80WmtEN0N3NCtZL3A2VjVCYzZkRWJ0akRJN0FrRld5Y1l4MDVxN2Eyc25rNnRLVy9jeVRMbFFmbU8wZDg5UlhNM053anpQaVdSRkFDZ1l3TUQyck5xS0ZhMStYcTlTMEdrbHZzRnVNNDU2TUI3RHZXOXB0dmNmYUg4dVlNaHlDVDNQcG4ycW5heFJxMFFSeTVZSDZVNjBuV0tWMzNNb1VZQ2daejYxRFdobGQzUFJZM0VDS200T3hCTGUzMHJtYnFBU1NGWm5rVkNNcUFlRDZuM3JTbXM0cExIejEzelNPMlVJYmFQbHJsaExlVGhKeXlCNGY0Sk9GSE5PMEdra09NcmJzZk5kUlNlVkNHVUZjWUlHMDBwaFVJSlp4Z0VrSG5INjFRM3kzdXJ5TklvODRoZDJ3Y0FBZHEwcm1QejBFY2Uwb0dKWWZTdHRyZWdhU1dqSVJab2tpelJFTHlBd0xFbHZjRWRxMldKa2k4bWI3bUN5NTlqMC9Ha2NtT3dSb0o4NUcxbEs4akhwNzFpZnZvNDVKWkhWZUJ0M2RUNzQ5NnVNVmNtOXR5UWgwVndreDJzd1lLM08wam5nMUo5cExXLzd5NUNrZkx0VWRBZmZ2V0ZETE1pc3crVkdHUm52OUtoaXVQUGtmSzVRTUIweHpWdW4xN0VPWGtkSlp5bUs5eUkybTR4endmeHJ2VWZKblIwVnN0bkI1WURyaGE1bTFkbmJlSFg1VC9FY0hIb0t5VXZUSTVlSVpVUGdzQVNBM1RyVFQ1bFlhWGtkSnFWL0d0dHRVWXdNKzllTmVQekVQaDVxc3JRSThzcUJkNEh6cmc5alhXdGMvYTdtU0pZbmJ5Z3pNNjg0QTlhNC94Y0xVK0FkZkwrYTh4VkRHRmJLcTJlaEh2U2hGSnBlWTdOT1BxZmxyYmxzbmNwWlZZRmw5cTYrNGxpV0pSQmN2dXo5eHh5RlBjR3VpdHJDNnRZYnFhY3EzN2dEYUZ5ZHo5c2owNzE1VktaeVNEeGc0UHZXMmtudURUVzUwQ3pYRXFsOGg0K2hMZGlQYXVndGRRTnczbFRNZGh4K0JIQS9DdVh0bzd6N083WlVSaGh2ejNxL3BUNllaV1M1RXNhc2ZsbmlPU25zVlBVVkVrdXhrOVRlVXp0Y2VXU2ZOWG5HT2dIVG1vcm1WbkNzNFlHTWtESEFycWJXYXozeHNTenV1NVFjZmVYR0FhbzZoYlhERGRBU0FQbExZd0Q3bXNXOVE1V2NOUGV6UmZMbmRubmNSMSt0VUV2NUIxQUk5SzZlMTA5ekdUSXJPeFlqSFllNXpUSmJOczdsaFZRby9XcnZFZG1ZbjJ5WUtOdUZHZWg5YUh1SkptM00rQ0IxN0hIYWxLSkpJMjhiVzl1QitWVld0U3hIN3dmbi9BSTAxWWxYSXhjUDVpaHM0VThqL0FCcmVrTUx4Uk92MzA2anVmcFdOY3Q1WWorYmQ4dkp3T3Z2VWtFa0x4ajVTR3oxNmptbll0WHVkbXBrdTdNckN1MGc3MkR0Z0FBWUE5eWE1UXp1aWhDdTM1amtkRCtWZFBibUR6OXFad3FETEtjbmQrTmRCZGFiRGZlWmRidGdpWGM1UGNqMEE2MUVaTzlyR3JTUEltZmRONWhHUXB3QlhvT25ReVBaVGhVM2c0Y2tEb1JXT05NWmtlU05DeDZrRThqM3hXd3NyL3dCbU9CdWk1Q3R0NDNmalJKcGtyVmxBeVJRQjFUZHRjRGV1YzhlL3ZXbmZSUS9aTEY0bzlvZEdKT2Z2WU9LejRZNGZzNUxoczd1b1BZK3RiRTkvaXpzWVViQWlqSTVBNnNjMVBVMlRza2VjU1dzdmxxVUJZNU83MnowclV0TEhmYk9EdFZ1Y3NUMHIwQ3dzWkRETEU3UjVidDBmSTZZbzBtQ09TZWFGVkplV05vMjNEN3JldjBySjE5L0k1M0hSSEYyR21lVmM0bE1nQXhsaGpBejA1OTYyWHVMeXpieS9MTHhKS1R1QUdSNmcxb1MyODFwQ2tFdmxqeWVoeUgzTi9nS3EyT3FxSjNFdnptY2dOempCOVNPbFZ6T1YzdWhCUEk3Mkx5VzdZVmljSTRHNzN3YWZwR3BRckg1ZHhINXFuaFNRQXkvaldocVZ3b244cUhJalVZUUZCdEhyeDcxemx0Y1dxempmaU1nQUhjTXFENmpGT0t2RjNRYW82SjlVYUNhT08zamlTRkRsbGFQZG5CejFQZXVZdTV6YzNNZ1NYYUdKSjNENWZ3cmZoc3JIN0hlWEJMeXZsU3VNaGNFODRxQ0dEVDFqODNJVndjcXIvTXJlM0hTaUtqZDZEdTdGSkxTSnJUL1crVU9veWVIUHNLcTJyUTdnQnFVUVlIa2VXM0h0bXF6Mmx4UGVOSk5jTHRHVGhlM3NCNlZ0UncybHJjcktpTWR5ZktEMDNIdm4wRkRhWFVoeWFaZXVMSFREY1FlWUhVN2h2K2Jia0h1QjJyYTFHeWlzSXo1Q3JMSEt2eU5ISUhPZlE5ODF6ZHZZWE54ZnVTenR1QkpKR2MrNHErMmxheFp5dmkzazhsaU9UMFlIdU1kS3dkbTE3M1RZWE1yclV4cmViVVluamtQbUY4bmdnalA0VjBMT2JxeTM1YnpBeGJEY043NFBjVlc4cjkrOFJua0lIWmpsZ1ByN1ZRdTRKaTZrVHF1M3BnY21sZE8zYzFUYVRHMk9yWDFwTWZMZGd3Y01PcEovR3V2aHViYTR2NXJ0djNEbFN4akdQTExIZ2tlbWZTc1dIU2J5U056c0tuYUhEWkFEaXFraFdLRjNJaURsaDhweVE1SFg2VkRjVzlOOWhXWmo2aURITTRqZjkwV3lWQjRCUGNVMW9MZERINUlsZGoxTEFiVlBwa1ZiVm92S21ra2lCR0Q1Zm9IL0FQclZQOW0xSllZNVZBd1IrZWZZVnNudC9WeUhaV0pOSG5nWFVDYmkyZG5YNVk5cElPODl6Nml0Vy8xYlVRbDBrOHlNTm9Iei9meDIyWXJua2VhMXVrbGxKVjF5ZHBISU9PQ00xa1R3V3p5R2Q3b1NTTVB1cUR4N21ueXhjcnRkUFVTbTI5dERiT3AyMXpickZCYmlGK044aklDVzk5M2I2VmZ0eGJMRkx0bS9oK1g1Q1hkaDZIb0JYSld6UXZtTnd4QlhoNHowUHFmV3RxU0hVVkN1a0xlUXNZUm1BNEdlNTl6VGxGYmJGcDJXaEkyb1R2SElzeU1YejhvWWo4eldqcE1vdHBvNVlYa1c1TERZeVNZQ0gycnFFMHkwU0tHT2VFSks2QmxjSDVzK2pDdlA3NjBHbmxIeWZtSndHSEErdUtoT0wwWFVpVW5kYW5TM2phcXQ3UGRTWFFFc3Vjc1NTZDNybjFyczd5Ni90SmRPU1ZkMDBVWWFSczh0SUIzL0FBNjF3SDJyekVpTWRzRlZzRWtaSnorTmMvZHJPMGJYQWMrWWMvS0NRZU91Y1ZueWMxdWxodE5yYzZ4OWJ2blc0UzRiTVR2eUFNRUVkd2UxTnN0UWRSTUM1YUpqdUlQTGZVNTYxaTZUSERmV2MyKzVlSnNIQUs3a1lxTWdFOXMrdFhiRjdLT0dZWFRNc1JRZ2JCOHdic0I3VmNvcXowMjZGUWpabTVlYW1rMGNGdk5FZ1JnUG1YR1dQcWNldFFteDBxSW1KSm1jc2g0UFVqMEJIcFhHdmV3SWtXM0RSL2Q1WGpqdC93RFhxeEhaUVN5NzN1UEtROTF5K00rbUtYSlpkVWdhVExHbzZlZFBrampsMmVaSWdJQ3NDVkhiY1IwSnJ2SWJDemZSSlZ0MkQzQ01pdVNjbDkzWGI5TzFjUGRmWW1NZHZGNXN6SXUzZTR3eDlsSGF0UFREckZ1NEJnOGlNSGh5TjJTZU1malY4cmNWcnF0UktMUmJ0dExpa0F0N2hKVmtUTEVPZG9iMHhtdTAwYTlIMnU5amVGMzh1MVpZK2M3QWVQMHJWdDdqVjdBd1JYVUExRVR0bGJXVkRJRkM4NFp4OTNIWWRhZ3VUS2RUVzR0N1JJWldCRDI0a0RCMUp4dEJIT1IyelhMVWI2OWR0UytWdFhSUkdvend3cGJOdkk2QmdlZHZZOCtsY3UxdmM2dEpNcHUyTWtVVGVTRjQzN1RraGovU3VoMXByZThhRUJmS2tjNFpUa1kyOVFRZjRoV041NzZmZFNlUklHeWhRY2JSaytnOVJUak52MUU0TkZqUjduVXJQelhTNWpzaEhIOHl1eFpwQ09jRUQrZmFvTDNXTDNXWTVMbVcxZ2FkQ0hTVUo1VTYrKzlPR0hzd3J6Q1dWcExwMUxTTTduRzVXNysrZXRlajZQZlhoMFNhRHlTZm1NUU9PU1Q3akhUM3JxYXNyMlhRRTNaR2RkejZjOXNKRzA1UFBJd0pDNFdUbnVRbkI5alZIU2ZKdFpFbWJkSTBnSU1aUEJCOWUvTlhJdEpacHBQdGtyUWhDQXZtRHFUMjQ3ZTlYcDlNbnRiWDdUNTBKS3VGUUtEdmRQN3lucGlwYzQ3WE5tK3BvNmRwL2hCR3VwTHUydVpXeGxJb3o4d2IwTEhnRDNxeEo0ZzBkU0xkWUVnOUNzclNGU09tNFl4eFdkTFpSU1NSUEhmU1FGOFp3cFlxRDFEQmV0YzlleWFQYkJyWVR5M0RxU1ZJaUVZMzkrVHlhU1NmV1Q4dXhtNU50YUZXWWViZEJGK1ZDd0pLbmR5ZS9OZHpQNGUxalViS0FKY3M4TVB5d3h4eG5vVGtrOWhrOVRYVmVHdkMzMjdUWWIzVWJJSmJSbmRIODVpYVhIWEJ4ODFhUDl1V0tSWHl4d05hNmZBQnYydHZhUWs4TGp2bnZXVTZydnl4M1cvVXJrbDBPSFczc0xHWHlMeUdGMlZodWozNUI5Q0dIR2FvM1JXMmx1REJDUjhwMktUd0ZQMDYxMVppMFMrdEpyMnpoanQyVWdCYm5tSStxako0UHBYU2FIb2p5cXJ2cGo1My93Q3NqRE9DVDBDZjNxNTNOSlhkL05NbHhiZHJuSytHNWZFTUUwNWJVTGkzak5zWGtpaU8zS2tZQllIam50V2UzMnUrUzNrK3pvRlpmM2p2eHRQVElMZGNWOVplRi9CTmpkelNRZjJXK0RHV2tnZFdhZDNIUHpnSDd2OEFLdCthNTFDd2hpdElkRjA2R0ZaRDVhU3h4N2puK0RlNU9CWEs4UXViM1k2L2NkQ28zaXJzK1VGaDF1M3dzYlhGeEU2NGpkRmJhNVh1T2d4OWFnMDZEV2RQMHk3a2tpdWtaNUZFU2pJQ29EOHgzRHB6MnI2UTFUeEI0bTFHU1N6dk5MdDdyZWpMYUxHMjRwZ2RGOHZBeXZYbXZuUFU5TDFpeVNCcHRUV1BmSVUySTVtTzd2OEFMSDFQclcxT2JkMDB2enVLcFNlbks3OXluWTZ4YVdOMXVrc3A4ckp2VUVIS2s5ZHBIYzFuNnBhYXJLMXhmQ0VsSlczSks1R1VHZU9EbkdLMExuVXRhMHl5TWMxNTVyUGdpTUxzNC8ybTlmYW83QzVzOVUwOHhReFhjY3J5TUxpZFhESUdQVGZHZU5vOXVhMWluZTZYV3paaE9NcmFtL3BjdW90cERSeDNqWGlvUG5paDVUQjZzVjlleHA1OEszRTRNeXhKYTJ1OEVDUWhUdUk2S3ArOVhtMmdMcW1rU1hUcmNMSElBNi9LMjFTUFgzRmVxYWJybGtaN1dlK0huVFFsRnhPMlF5dDFQSGM5aFZUak9Nbnl0V05Zd2pLTm0zYzRTRFJZTFZHbWl2Vys4eWhsd3VjbnY5SzUrN2p1RWRwSkg1azVSc2pHUjF5T3hyb3ZHMWpaUTZoYzJ1bHkzTDI4a3U1Q011b0RjN2NnZnduaXVTWFNybUFXNjNNK0kyVXM1M1pZWS9oeWU1cmVuZTEyOXptbEd6c1V6bzJwU1c2M0xKQ2tjbVNqTys1bkkvdWl1U24xTFVTajIyNTRvMllGd2dJTEFkQjlLN1N4dUxpQ0ZZMmp5akVnZVoySHNQNjFTbVkrZkxFSkRJQVB2Ti9DTzJmOGE2dVpYczBuWXhjTE81eTlzSjFqYVg3T2ZMN3FvKzkvdm12cmJRWUxhYTEwZnlnc01VWVpteHdOekx3c2luN3c5NjRYUTlIMFk2VmNMUE9XdW80eTNsTGtSc0dQWnM4a0N1ZXZQRUV1blJSR0R5VWk4c0FBb1MwZzlEbml1ZWI5bzJsdW1kZEs2dTJyWFJZWHd2OEFFRzUxNHhXdGpIdUVtQkloQ3dNRDMzSEFyNlcwL3dDR05yNGJOdkhxWGpDeWplWXJLYkZUSUZaeHlTekRnMTgwMm54TTFDNGt0b29kT3NrbkRmTEl5T1ZSeDBiYVR0eVBYRlV6SnF1citJSnJ2VWRRVnBNWWQ1SkJsbVVZNEhRQ29xUXJOV2NsRkphMlc1MktkT0xUVjJ6Njc4VitPdnM0dFlZN2lTNHMwWVJ0QkZDSTRzWXhrS2VUajFQV3ZCN3JYZFJlV2J6R1JvRlJUSGo1bmM5a1hINml1ZmkxVzZ0TEZqY01zNnk3UWt6a0JsWlQwQUhVZTlaZmhYVUlvZFJ0L1BzWDhxS1V0NXFGZzh1NC9jQlBINVZ6d3B4aW03WHQrSnBPdEtjck43bWw0UjFIeExjNnFxV01BWXlUQjUva0E4eE04N21QUlFLKy9QRXQyTmE4RkpmMkhsenJaN1lwOW9COHVWVGxIQTUrVmgxcjVsdkxqVGdyQ0hUM3NreWQ2T2RwQWJrREhvYTJQQWVyMkZuZFgwMHQ5SWtNY1c0V2lMOHR6M3cvdG52MnJLYVZTU255MmNkbDNONlZvUnM5ZWEycDdWWWVOclhXOUVpaXZvSVE5M2JUVzBxeFc0RFNGUjhuN3hjWUdlcW44SzhudHpwR24zK242bk5jUGJmWjdSWTJSMTNNV1Z1R1FkY0QxTmVmM2ZpMjhtMTYyMUZVUzN0d3ppRkZVQkViUEdCMkh2M3JhbThRNk5KYmh0VTFtUDdYZlBoWklJdDVjSWVjK2g3WnFJMCtXOFZHeWQ5amVNb3kzdG9leitJclhUOVdLWGtseEdVZ2RaaEpIaFZ6SU1BREhyM0ZmT0VVOEE4VjNjK3BYMTAwSmlhTVFvRk9SamJ3V0l4anNhTmI4YVc5blp6MnR1bytaaS9QSWpRZEdZZDJQcFdYYjJsaEw0ZHV0ZmNGcEVpOHBBM0t1MHZKSkhxb0hGVlNpNHBKM3MxWmZNdW80UzIzVzU2NThPTDVCNDB0cmUwdGZLdDNZcXJ1ZDVJQTZaSEJiRmZwTnNEc2dTTGtaVVlKK1llaEhxSy9HcjRlNnZQTjRpMGl4dDUzQ05NdTZSY3FkMmEvVys3dVYwK0NHNGhrY3NDUTJUbGl4NHorRmVyQ0hMSThxczIzVHR2clk2aXlUVk0zdm43UHM0a1VJRlB6S1R4akFydG1hTVFiQUZWZXZQM3Npdk10SnQ3QzlTU1kzY2pTRnNzaE8wdVBmRmR1b0Z1a2pMQ0FBdUFHeWNIOGEzbHRvU3RIcjBNKzNsdTdlOGFRVFE1Ym9HSEdEeGpGWWx4YUpZQ0Z3NmxYM2JoNkVIT2F5THE1U2FWOXJoWENia0xBN2NqcDFyemlYeEpja2lPVkVCUml6WlBVZFBsOVRXTnJyWTE1a3BibmZtTjVVWm0yTjV1Zm16Z2pIYmppdU4xSDdSSForVWtyeDdEbG1IOFEvd0FCWEl0NHZ1OXJScmN3SW00N2RpWUsvd0QxNnRhenJGbE5hdjVOL3dDYVdWRjI3Y0VzS2ZzbW1uYmRtVXFpZGtqeGZ4SXhqRnBNcnQ1aExxejU1SVBXdlFGaXRJTEswa2pnbUVNa0dJM1BRc3ZjZXVhK1hQRWV1M1p2NDQzWmNlWnRDRGpBenlNZHEra1c4VXhhbnROekI1QmloQ3dMR05vVXFNQWdkcTdHdVdKeVR2cDFYVXo0TlZtanRibXk4cFAzeEJabVg1MDIrOWFmMkhVNDQwUm4yVzAzekkremx5T3dyaXJLMW5rbG1Fa2tobHdTSk05YzlqWHJjYWFJbmhhVVNYTXJhakFSdFRlQ21EMTQ2NXBLRTVYSWJoRi9EdkpONlgxN25tTnphU1BjRUFpWTQrOXR4alBiM3BSS3EzQlc1dDBCQ2JjTUR0OU04VnZhVnBOL2V3M0hrTWhaZVFDeDNqUFFBZDgxTGMyZW9YTXBpYlR2c1pqWEVyUDh1L0E1NGJxVFRzNHhUYTA3amJpNU5KN2IrUndUWldIeXk3UEZ5M2xqSlVIMUFxaEhHaklRVklEREF6eGpIclhWUWFacUQyYzkxSGJPTGVJaFdtSTRHZWdOUXcyVjFOSGtCUW9iQmJzTTl2cWF5a3paSmJKcmZYMU1aYmNuR1lzSXpZRFk2bWdhZTNtT1drMmpnNS9wWFhYNVo0WUkzTExjUnNGd1ZDcDVRN2oxYk5jZlBCSWt1MVpOd1k4RUhxYWlNbTdHY3IyZGlDYnpuZFVkOXNVWkhMSEFiQjdEdlhlYVhkM2x1WkdTUWJTdTF0dzZqMnFocHNWb3pva3BBa1FmS1diaGgzeDcxTE0yNlZVOHNoYy9MNys5T2NsTFF1TnpidUwweVRRbGdpN1Fjc3ZCUDFyR251cll5azdsWlFwL2gybGo3aWxXQ1NaWForeEdGeGdFK2xZODZIT3hvaUJuSFRPUHhyRnhTTjR2YzdWdGN0VzAyemlqc1hTNFZ6NWtwZktsVDA0N1ZreVRTU1RNR01aRGNnajJyRXQ3a0F1a2I0eWNjOVBTcmF1aU9OeWpkNjloVWNxN0dFbTI3RnlTK25qaVZVTEJWT1NGUEdmV2l6dXdWdUdtbWRtMjVRREJ6OVQxcVdlMmtsVjJUNzNvT0Jpc1cyVE11d3g5amdFZEtTaXJscHZhNTBhYWk4a0EzRmdpOHFoT2ZtcW96SVEveXNDeWpILzY2akorejdsWUxrRGpQYk5VM3VMbVJZNDl4UXNkcWpJMjR6eVRXdkpyZEdqYVNzYXFUWGthZ3hTanpDVkc0bitHcnIzcEx1OXc1ZVRCQk9mMVUxemwxdWdtSVdaSk5vR1JuZzBpUmk0eVMyUWM1R2NrZXdxWkpJeTVtUnRjM3NsNGJnTmdBOE0velp4eHhucFZYOTg4N0ZpT3VXeHhuM3BkUWprUlFtODViaFFmU3NpM2ppalJZMlpnNE9RT3Y1bXRhU1Z6T2IxVmp2bzdtU1hhbXdzUWM1UHA2VjZMYXlNVWFKWGZZUXpIR0FRUU94UGF2TW9pc0VXVENyRWtuZGs1SVBiMHEzUEpKSXVReCtaUmdEOWFKd1hZMmhMUzF6ckV2N2FHS1hhQzBoQkI1NDZmenJFdFpaTE96YUdKbWZlMjkyYmtuUDhBU21hVjV6czYrVUFCa2xpUU1BZXVlOVRKY1JRQ2Z6WTNrTWk0UXJqTzczOXE1b3dselh0Y3FUaTczWkZLTmlPU3B5UUNXemdBZTlhUGgvVnhiL2E0WmJXM21NcXFCSklOeEgrNmUyYTV1YmZLQkM4Vy9jUUFySElIdFdzZElNY1pkMVhaOG8ycWMrMWRzWU9TZGtja25HMnIwdXREMVB3eDRvbjhQWFQzcVc3eklGSUtodHFjOGZqV1o0bThRUitKcG52THg0b1AzZUE2cno4dlFLQjFQdWE4MGprUlR0d3pJU3d3VDBBcktXMmNTazUzQUFsY1ZVVTFHMWpSeWp6WDJrMWEvVTZuUnZFY2xqYlRRMnQ0ViswL2ZRSEJZRGpudHpXWlBEYVR4SHpDUTdqaGlQdWtWbHlYTm5DcU5zQ0FNQTN5QnZ1OThmV3JKMWkzdXAyM0FLeEIvaDJqMjJqMHJscythM1ExbExSdEdkUEpxY3JLc2x5YmhZRUN4N3VkcSsxUHQ3ZVJ3RTJuYXBKKzZPQ2F0eFFNQTI1eGlUR08rQlhZV1N5TE1FQVFSc1F1OWg4byt1SzZKUjBSenA5aWpZeWFsYUl5ZkxtVWhmTVVINU80T2V4clB1ZFFjM1R4dUJJdkJVS2VRdzRKL0d1cnUwbU9Oak95SEFZRDdwUHJYRGFoQjVOOUlyUTdtUlFXYkhZOGpBN0dvZE5NVGxaNmpMMmFOV3g1WERzTTVQRGdjbklIVEFxcERkS3FGWWo1Y2ZtZmN4bkkrcHBzanhCQXlyc2NuZ2RnZmNtb0lZNWlvT0FXenlDT2hOYlJTNVVtak9MdDFPa2YremxBbGxaWW5LRXFpNTI1OTZmWStJRUVzWWRZWGJhUUNFd0NSNit1SzVlOWltRVozWkh5NUpBd09mcldYWXFESEt3SFFEbGpnbjZWRHA4c3RUU05TTTEwT292cjArVVNzeGtrMzdzRkFBQ2ZUSHBXVExGZUZrTEJ5R0k3OFpxZTNpbFdOOElCdUc0cm5zTytlMWFEM2dsa2hqOG5BVmVnUFUvaFVOTyt4YzNzakJsZHJiNWh4SU9vWmNOLytxdlJkS1BoN1ZOQ1dLNWVLQ2Z6UWNuSk9PN01SMjlCMnJ6Q2Rvek9CS1ZZbHNoaWVwOUs5WTB1R3dTR1NaQkM2NUFhTXJ0Y25IVWUxVExUZEV3V2kxZDlIb2M3cWRycGRvNWpKeWl0dURrbGpqSEFCN2ozckpSWUx0Y0JOc2lqT1QraHJLbm10VE5PV1ZuWm1CUTd5QWdIYkhlcEFHQU1xajVpQ0NjOWo2ZWxacUxaMlhWckV0bkJNeXpiMnk0eWRvSEJBOXZXb0dqVTI4VGVmbVNSOGJjWUdQVStsYU1HdFhHbTNNTWdramFWRUF3Y05nSG9HK3RjN2VhdERjNmtXQWlpZVg1dkxVWVhQZmJRNHU1Z203dE5hZDduVFNSU1JwYm9rZ3d4eUZ3QWMvWHZVZW9TaU1MaVRNbWZ1OXg5YXhvbWkvdEY1V2Nna2dnZHZ5OWEzN3g0M1FoU295T3h3ZmZyV3lUVVRHOTVITXlHUllSSnZHQTIzT2VjOStQU3U0OE1ScmZXczk1TThjSVZ0aDNuQUpIYkE2NXJoMEJmekd3cEdBdTFmNTgxdlFrVzlvdHZsUXUvZmpHU1NlNU5UZmU1czAwdHlkNEp0MnhZOWpGbk9DU1JqM05jcGFRS2J0cEhLc0ErMWtLbmF3eDFCRmQxYlhsOU8yRlluNWNIYXZHQjJxdUNKTFM0OG1UWTR3R2NFRC9nUHRVdFhaWE1jb2c4cWZiSHlBM3lBZ2ZsWGMyVUt5UWxwR1R6Q2NoTWRQcFhNUFl5QzNRb21HQURFLzhBMTZoKzArV3drZVFuMEE1R00xcmFLUzZtTjIyZE5hRU5lS3Nrb2lUS2c1SEJHZStPMVFhLy9aTjNyVjNiMlEydEdBUXlITUIvM2M4MW5Ock5wTmNvOGFNR3p4bm5wUzNWckkwLzJnZklKUjhyQUFBanVPTzlXNHhVZ1RkbjNzY25GUGNXdDdHMmN0Z2dxZVFSNjgxMnNRUnJoVEZuYkx5RTdnZ2M5S29UMjFzWkd3M0NBWTNmZXhXeEhOY1doSmlKM1BHVlVoY2todW9GVEozdFpEaXJSSXBaakZIOHljS1NWWTRBckxiYmw4NTNPQWR4NS9TbWZhSllzSzZzV3dRb2JvdnFhclNtYVU4T0hjbjZaejZWb29KTzVEazdFOGNMWGJrdEtDRTZNUmpqc01DblFXck5KSW9kVkF3VDJ5VDI1NjFYS1hzY2FScGJuZndTcDlQOGFrdEZtTFBJNkhhZU1NZS9xS0pTM0xTVmpzM2hzdktpRVVJVjFBVXR1SjNlckgwTlkwa2FReXpJcmwxWWc3UU5xNTc1OWZhcDVvNFN5Q01uY3dHOG5pckROSEhKR1R1YkI2OXF3aW51UzJ6ekY3WjdhNTgxcE1CaVFCbmtBKzladmpEU3RRUGdqV0xrdUlvVlZEOG5MRmkzVWl1bTFrRVRJeWxRRG5BYmtZOWNWYjhaU2FrbnczMVVRWDBLUUxDdTVXSVpwQVQwVWRSVnY0bzM3bWtISzhkVnVmRVNmYlpkSmpXenRpV2I1V3dmbVppY1l4WGhlcjZiZXc2eTltc1psbkRBYlVHNGxqMkFGYkVjbW9RYWdKbHVjYmNOOTRqcU9SeFhZVzNpRjk0aWk4cUNhV01xTGpHSkNwN2J1MUh2UmJzcm8xbDd5T0pleGcwOUZXN1oybWZPK09QQktmN09lbWZXdVJ2THBwSlZJVkVHQmhVR01BZXZ2WFkzOW5lcGNDM01iN3l3NXhuZG5vUVJYT1hkb3R0Zk5GY0s0WkdBYi9EbXRZYTc2bk00MlpzYVpxbjJhYU9KMitWL3ZaR1NNOUFLN0pOZWlqWmttQmNFWTI0SUJBL3oxcnpUVUxKWUhqbGpsV1paUVdHQnl2c3c5YWhubDh5RUh6VHU0RzMwcE9DZW8xYzlFbTFtRmlteUFMdHlGeWNnVTc3WTBrWjNqSXhnRWRCWG44VU0wMHI5bFZRZWVNMTB0bkRPc0xqbklHU005QWVoSU5aU2lrZ3U5am90TzBtRFVKZHF5S3NqWTRiSzVQc2VsWjkvb2FXcU1qVERmazdlK0FPMVpkamRDMWtGdzhqTXFOMkhScTdiVUx4QlBhT2loL05SWkFjWnhtbGFWd1NWamdCbzhrcTd2TFo4OERiMUpwcjZSZTJ4MnRFNDQrNlJuSi9DdmQ5UDEyQ3p0QjVxODNDR1NQQUFCSTR4WElXR3EzRnhkbUZXQlpnV2tZcG5BQTU1N0NpTXB0dTYwNkUvRHV6eTZGWnplL0l5b3NiQmlwT3pjQjlhNys2ajFSZEwxT1pvREVobmppeC92RGNOdnQ3MXoyb1h0bzdsbnR3U1RnNTZWNk5ZNnZZeCtFSTdPNmplUVNYQmRWRFlLcXZBeG5yajByWFd5MEhKdlRUcWVjMldweXhIYTJUdEJLbkhOU1MzeXpsRmJHMGRGcXZxYytueHlBMjBjaGpLN2lIQTNmcFZDM3VyUXdJNWhZc1dJQTY1eFdmSjFzRWR6UmQwV0Z3V0pYUFFmeXJQZ2VGdzNJNi9URlc3eUZZYkR6U3lZa2NoWXM1Y1k3OGRxeklwdEsyaG1EQXNCOGl0Z0wvam1xUzBOVHJZTlllVzZ6TC9BQXNNdm5qQStsYW1zWHBta2xlMGpNU2JRL0hCY2pxZnBYRHlhUHFOdGJDYVdNcEV6QTdzOGtOME9QU3JjbHFTSkMwZzJxQmtFbmtlMk85Yy9KQzZhTXVaMnN6SGl2V2t1bGtmZHYzWklKNEkvd0FhMUpMYUw3VGdad1RrYyt2TlhkT3NiQ2FHNHhJKzlUOG16bHYxcXphbUJyVE1pRWtNUnVVYyt3Tk55U2VpWUpYWk5IQ2JvUnQrOVFvQ01xTjNBcXBmYUtxb1pvcEJLSEgzaGxUdTlDcHA4TjNERmNxVWFZS3BHVTI1L1d2UzdXNHQ1WkFoTUlISkt5Y3NQcFVTbEtMVFd4dGFQS3p6N1N0UXVZck80dFpZdUNBeUVkbTlQeHF4OW5rdTNFNm9GY241d09EbGU0ejJycnJpOTB1M2lZZVdmTUkrVVlCQjk2eTdLOWJaSHZ0NDJpeWNzN2JjKzNITlFxamZNMUd4enlWbWlBMmxwSSsxRmRKV0dWVnVlUjNIcG4wcklndDU1WkpFbHlRRkpFWStZN3ZUanBYZE9iU1c5eE5hbFl5bnl2R3haazl5ZTljbWtsdGEzVHlpVE9WWmNuZyt6Y1ZtcE4zOUM1clJhRTBlcDZqRERFQ0dDTDh1NGNjZWxhZG5KcWtrTndMZG1aaUdmbk9TQjZlOWMxcUdzM0Z6cHlJV1pncEpMWUdNanBqMHJvb0wrNnRQN1A4QUt1R2xhZFZZQUx0MiszdlZXZHRsZTVNWW1OSGVKdmVWMXd4VVpKWHFmOGF3N2thdGNUbEFtNEQ1bEFPUmpyMnJTMU9aNU5aZDJRYlpHK1lZd3A5ZnhydTdLSFRIanVJVEdZSk5uN3AxWW5jeDZDbHpjdG55N3Ixc1Uxb3poNHJpNWw4dmV4RFJjRk9vR1Bha3ZwN1Y1WUM4SmpDazd1VGc1Ny9TdE43S1d3dTh5TVVCRzFaVi92SHN3OS9XdUp1ZnRVcU1XeVN1NEZjK2xVck9TYTJKVDZGdEk1YmpDeHlvMkNUeWVvclZDWDF2RTVlUUFBQUFBNURCdjd0UXcrTE5XRmpIWkxMQ0lBb1hhWWxVNDlDUU0xeWF6M0l2a0c0TU0vVUFWdWxMWFltVnJIWE5jSkpIc1lNd3h3R081aDY0TlpVRm5ERE1wWmR5bmtxQ2VCNkUxcmt5TW9jTHRqM0RIeTlhenJ5V1ZweWliWHlCamp0N1ZPcTBSUExveTNqVDQ3aFpZbzNqOHNnam5kdC94L0d2UXJiV3RHdWJlYUNXQ1YwVEJ6akc3MVBIZk5lWjZaOXJpMUVNa0htS3FsWGpJNEtucUNLNlM2dFlYS3BERzZRNEpRNTllb3o2aXM1S0xhdmYxdVVrcmJtN3JXb1dOM0NzME0rSlk4RHl5aFFBRHArTmM4bXEyZDVIREZQR3BrUW5CeVdWdnFLV1NlQkxLR0Y1V1JsWnM1T1NSMkJOYzY5aERGY3RJck50WmNnanJuK2xMbGphMnZrSnFOMW9lcCtIdEhYVUx3UHZTTUlkbTBrS0dVOVF0WkdzYWZGYjMxMURISVZDSDVPTTdnZW5UbXVRbDFlY3d4d1JJb2FCRDh3UExBbkpOWXYyL3dDWGUwek5JM0NnbkordFp4aE8rL2xZMXVranN0T3NKUkoveC9KRTZmZUJZS2prZEJYS2EvRk1McVl4b0dBeG5CeU1uMEk0SXBiT0czbDFDM1V5QUdUUERIZ0hzRDlhNjY5R21ReVNXNy9OeU53VCs4T3d4MUgwcmVONHl2djhnaXIzUEdIY0lxb1MyM09UeDNyUmlsa2dkSkluSTV6ejJyczc3VFl3MlFpeHRnRWM1ejdFZGpXY3VreGZaUHRFN0h5em5DamdrajB6WFI3U050UldkN0YxTlR1UE5FaVN3eVNQajV1aEg0K3RYWTd2VTUzT0dWT1RoaWNBT1A0c21xR25SYVlzTEtiRnkrNGZ2UkxnWVBzZUtkcXYyU0NVeHd6N2tJQkJQUDE1clBTOWtnZDlqb2JyV2RUU0g3TXQ5STI3NzVFbnlGdTdER0ttOE91MXZyRnRMTElydHY1VmNuSVBUT09jVng5ak1rZVhZUEl1ZU52SEk3WnIwVFJkZnNiTTdqWXJGSTRZUElRUnZ6MlBiTlROZTQwbDBIZG85SjFLT1c5Ujd1NnZiY05ITGpLRWJsejBCQjV6N212S0wxNDVON2kzbFdKVzJ0SytDR2Z0MCs3VTdYV2svd0JwbWFKcmtHUnYzaWtCbzJVOWM0Nml1MGo4VEpic3dGdll5UWlNd3lBeGtyTEgyREFkMS9oYnFLNG9SY2VqZmxzUG01b25sTm1VTXlTZloxRG93TzdxQVFldjFycklkWHVZN2lkb29GUlpIK2JldTFXUHJ0ckkxRFdkUGtiZW1uckVpTVBuaitUbjNGZG5vdW53WGtIMnlDMCswUEN3TTBEU0JKQ0QwSzdpQVIrdGRFN1d2SmI2R1RhNjZMdVQzZm4zTnNrcHZGM0w4c3Z5N2xDbnNNOURXN2UvYTU3YXdqdG5pY3hSbFdQbEJOdzllVHlSM3JqN3g0Yk8zbUFEeHhGeTBpek9ISlkvdzRYdlRvdFN0WndvdHJxM3Q0Z0ZKV1lIRzlmUThubXVYa2E5TDlqb2pHUFZucCtqV25sM01qWE1XbjM2TkVjcThwaVFCZTRZWStZVmZ0dkRKdmtrc2lVaFM0SU80b0dhREp5U1NlZWxlVmFsNHN0MFp4Rkdyd3lyaWVGMEFBWWZ4UnNPM2V1cThPYTlwMXJCTEpmdExkM0RLRnQ1bC9kcXNmWXVmNG1CNCtsUzQxRXVidnNqcWlvWCtSNmZmNlRwUm5YVFArRWhrbXRyU1BZNHVYWklRY2NpUGFPTWU5ZVozVVhoU3luK3dYZHkwOFFWakJIRk52WHpUMExCUmtqNjFuUTNjZW94U1RUM0t0Y21kbGtpYktqWjJaUU1aQjZFMU5NTGhFZElOTDArTll3ZDhxbG5hTEhjc2NFR3FVSlhWMnpucVZGeldzYXd0dE11b1JiR3lrWmo4cUtxNXczOVB4ckV1ZFExWFM3ZEl6UGNpMWlrMmVSRXhCVTkxQjdWaVJIVjlTa2lDdkhIR3B5WmlmS1VMOVc1T2UxUjM5alBiM2tKTWJQR0NXbUpMQUFEb2ZRRTFrMHVaSnRQeU0zSzdSZG44YTNWdmV3eVcxeGQrZEZJSkVjVEhjb0hUQlBQMUhlbDFQNGo2dnEyc3h6WEVFTEdTVVNTQkI1Zm1ucDh3SEc3SGNWNTVyMm9hWkpzS1d2bGJHSmhtUWxnUjNCOVNLb1M2aFozRnJCS0lIUzRpWEJuWEFHQjArWDE5NjdZVW9XaTNEL2dCR2JpN0puMS93Q2ZvMFF0dFFhYTZoa0prbGpXZTR3Z2pRYlRnanR6MXI1b3VMNDNjcFN3YVJCenNSVjI1eWMvS1I2MWthaEUrc1IyMDhFOHJUcEZ0bURjb0VYZ0JWOVBXcmt1ZEVzSTFrYVlyY2JnOHNUQlhqWmVnWHFlTzRQV2txY1k2S1YyM3QyTjNVVHZxUS8ydE5IZStWTFBKRXJZamtobEFiQTc0ejBQb2FyM0duM050NXNjTTVTQnlaUklPZHhYa0I4ZERqcFduRksxNWJ3M04xZVJSUk0yeEoyaExsaU9vS2o3MzlLMDc2SFIxaGx2UmN5WDRoVmZ0TVZzdmtaWCtGbTNjN2ZVaXJXblR5dDVpazlEbjdqVlJxVjFBVXMxMktvTWlBLzYxdmY2MTJjV29hYkRHdDFKYlNOY01PZDJHMkRwOG1PNTZlMWVNdHF5Tk1UaExhSEoyUXdqZS9QcVQxUHZYckdrMzlqZDJYa0pwODdMSDl5U1FibVdRK3d3QVBXblVpMWJSMk9mbmRoYnZ4THFkK3J5V1Z4TllxY2hyY3VFSnh4NmQvZXNieTd5KzAyM2hsbVFHQXNDTjJTek1lQjcxYW10cmFLVU5MQ3pYQkozUjdzcVQ5T3AvQ3NDZlVyVzFUTVNvSk10dERBN2tKNHp4NmRxVWRiSkxyb1pTY3IzTFU5Mnp4dEFxcEkwZnlzejRCQkhaVDZVOGFJOXpCRE9rcm1SVlBtd0JkekFkaUNPb3JEMDZWSkM1bFF5WVhKNEE0N2ZqWFNSYWxZVytreXRMT3FURWtSeHFENXJnOVFXSFJhcHByWkZ1OWtPbHVJY3dSVFJEOTJnVVNuNVpBRDA0SGNWaVhxYVU0blZydWNJZ0FRU0tTeWsrbmJGZEJhYTdvOWxMSkMwNlN4K1Q4enRGbVZOM0pDRTljVnlWMWZXRXNNaXROTVpsVUxDU0FvTVo1dzJPL3BTaXBKN01ITG9YSmJHNDB6eXJxT1dNcXlueUxoRXp2eU1FRWRoNzFtMmR6cUZ6Y1d5V3NNY3M4N0ZOckViQ1J6M3hpc3FPOG5XMFJKRmthM1Z0MjA1K1hQWG4wTlhYbDA0RlhnWVJQZ2pZY3NvejNCOVRYUWsrcXUrNEp1MmhvWDBkK25tU3ZhS2hWaHVRUHZUOENLMExYeE5FbGhIQ3U0c0pBNnJ1SldObDZGZmVzZDlSbGEwK3pxWGFFSExSaGNESjR6WFcrRnZBdXFlSUw4MjJuMnNCbGppTXdpbm1FUmtBNnF1Y1piMEZaempGTDNyV1JldTQ2K3Y3bC9ENXVWbk1sek5NVEtXZmNSamdLVjk2NCt4MVRVYlV5Q1JkcnJnRUU5QWUySzBOUjAyV0M1YTNXMmFPWEpCWGZ1VElPTVpQS3NPNE5aTnJwMGNVN2k4dm9vblJnUEx5Wkh6M0lDLzQxZE9NYmJiNmljcWx5WHpieTUvZG1UYkhqN21EbkI2c01kYWl2MXNyZG9KQWI4aEUyeE5LZ2pRZ0hrSjN4WFhYVVRYVnJNdG5lRnpDaE1mbWZ1WGNMMUNyM3g2VnljdWx6WDFna3NtcEdUYmd2Q3hZN1FmVFBmMXJaVytSU245NTBlaEhSZFFodVh1RzhpTlltREdYQUc0amdxdzV6bnFLN3lMVUx5MjBHeGlubjIyTXZtR09JNDJ0aGNBZ2Z5elh6N0hwTTB0NURiZVd3RE9GQXprblBjZXRmVG5pZlc5QTBtRFNMWjlLanZUWTIvbGxISkNzVC9HMjNxZld1U3NselJTVGQraDBRcU9Qek81K0dIZ3pWSnZFZWs2akJwc24yQVhHNWJ2Y3FvV3hqdVIwUHBYNll0bzZSUnRGSThyc1hZN3ljSDV1dWZhdnlsMExYN2k5MW16ajgyV1dPeHVJSkxZY2hQTGtPR2pVZHNaNEZmcnBEZTI2UUJGbVI1UUZZcWV3OURXOU9HanU3c3FvM2VMTXpUYkc1V2NlU2RrWUFHU2VjajJxU1NTOWl2SkxWUURKTTVZRmdjRUhpcjhUTkxjSytGQ0szeVlOYk0rbndTM3YyeDVTSFNQYXFnWi9HcWkwcGF2U3czcW0vSXJhbHBnc2RNbkV0eWtreFJWVWJUdHdmVDNyNVAxVzMzWFRCM1dJUmhzbk9BVDlLK25OWnZKSXRQbDN1NTJrZnZNWlVaNkQ2MThqYTVxZGk4TTB0dEl6VHhraHlNWUEvSHFhNllwSlhSeU5TNnY1bVBlWFF1TGkyU08zampXT0xheklQbWM1NnRYSDNrMzJlNkNTS1EyOVNRaDVIdjlhN3J3aHBEWG45b1hOd1c4cUMzZVpERVFUbGZYUFlkNnV0YmFMZjZyQ21uSXlSek1uTW1HWXNlclo3RFBhbnEzYXhpK1ZQbGpmelo4MGF2Wk5OcTdwRUdtZmZ3eEdEZ25xZjYxN0xaNmZxTUd0b2tqS3hFSVZneHpnRVZGcTFyZU40cHY0VnVvQlA1dTBzemJFT1BRL3dCSzNMR3cxaTF1ZjlORWNXK1VZbUozSGIwNHgxRmJOTlE1cmFFS2FiNWJxOXRudWJWdHFkdmF6K1FsdTBtM2R5QmdIUHY3VmdyY3pDOGtKS2hzRWtEQitXdFRWN2VLSzVpMlNxeXRJVmJQQzdmZjByeURWdFVzTEcrbW0zYitkaUJSbjVmV3NWSnlSdEdLV3A3ZnBQeFAwTHc3ZGVVK212YzN4SWVPU05EOG00WXcrUFR0VXMvalhWdFQxRmwxR00vWjN5MFFLQUhrOXoxNDdWOGRhajRtMWk2dWpCOXFaSWR3MnFBRjRIYkk1cjNEUm80MEVDdmFUaGlCbGRqSE9lNUxWVlJ2azVlaEtpbFBtUzFmVTlqaXVoR2s5dEg1ekxLZVlnY2h5T1JrZHZyVmU2dVo1WWhIQnAza2VUaVNSUTI3a2QyTktqV2RyNXBrZ2xDRmh3cmJHQTdnSDFyWTAvVy9Dc1VGMExxTFVJWGt5SXlpcElyREhHN29RZld1SnJ5dWRTdHZZNFc2bXZKbkV0eGNGRkhJeUJrRS9XdDNTenBzRVUxd3pLNmlQbE1mTnVIWmZlbmF6cWRtMXFxVzkxdWpZQXNyUUFGSEhjRTgxeG1qUk5mYW5EYXJNZDhyRUFub0c2Z3RXUDNvcHRjcnV0RWRGcE1CMVh4QmJCMDhyejJKWUVCUW85UjZWOUkrSS9DV2gyV2gvYVE2ck1YQUVkdVRJaEE5UWVoK2xmUHJlR2RTaDFlT0dSb1VtSUxLeGM3R0E2OGorVlhqcnVzVzZuVGJsb2IyM0dXTWtMa05HZjdtRDk0aXRaUTkyNjdtVVpSdWtuMFRzUGdnaFQ3UzdrY0ViVlU4bkp4eG4wNzFwYWJvdXNhbGNYY2tFREMxUmRzanV2QTQ2WnB1aDNTUzNCaWxWYmEzd2YzampjUzNvUlV5emF2QkpjTEZlczhJTzBJai9JUWU0K3RaWDN2Mk5kV21sby9OSEh5NlpDMkhTTUVRTmhwT1NvendDYXNDekdHUjVRVlZzQndNZys0cmJ0NEk0ck80Ky9JenNBQm5DaHZjVnVTV3U2MVhhaUxsUVdBNEk5ZVBhb2kvekhLeXQ1bkJscElWWVI3cFZHT01IcDZjVTZOcmk2YU5CR2drQzV5b3dTVDJQclc2WVpWZ2tNRndZMWJnbFR5UWV2NTF5MS80ajAzUjlaMDkvd0N6N3lSWENDUTI0OHdqSFV0bnBWeWpvMnVnMDBtcm90MjM5bXp2UEpQZXFwWEtzcnFReW4wQXBUYjZUSnVCdTJHY2JDVitVQ3Uxc1BCMXRyTjVjYWhwV3AyMEduU0ZtdUh1blV0RTNWZzZPYzU5NjhwOFVhLzROYldyZURRSlV2bWdVTE1ZMUlqM2s4a04zRkNVcEtMVnlGVXB5azFHNzc2ZkQ2akwrMU1kcUlaR3lRM3loZS9QQkpxbmIrYTJGV0JzaGVOcDYxZnc5ejlva01SQlBLa2phRDJ5dnNLa1pZN0pnWW5CTEtPRDZuMnJYN05tUmRKaEpxU1JPUStYa1JSdUk1MjU3VlRlOXRwUXhSbEI5MXhnMTBlbTZkTmNTdENrQ1NTM0JWQUdPRGs4Y1pyWjFMd1ZxdWlvMzJtS0ptVWtNb2JjVVBvUlZ4anBjd2xLUFBhNlQ2STRMZE8vQ3ZuY0FBcDQvV3RXM2lTMktNQ1djbkJ5T25zS2dpRG5QT09lRjlEK05UTGMzVFNFZVI4cWY4dE04VnNuZGFrV2xjMkRjRnBYMzQrWWNEdCtWWDRsWXhLVlBLcmptc3EwbFo3aU15eU1VSU8xY2RCbnJYYnhDMHcrM1l4QkczMVAxcTRSaTNZS2ttbzNPS01jc0k4eGl3enh3Zlh2V29rMTFLQW9tMmpIQTQ1eDYxMHprTGJOSTRYRzdBSkhHYTg5aE0xMU82d3dsOXVTZGd6ajNKN1ZxNHFFdE9welU2am1uZFdzOXpvL0poekVKR0FQUEE3MXJYc3RoYjJlNk5BV3huQjU1SHI3VjVsT3l4c3VDMjVDUVEyUitWYXR6Tk1rWms4dmtLT0c2L1hGWEdyRGxhNVZkb1RvVGRTTGNuWlBZejVCS1kyZWJCSkJJUFFEZFd0NU1ETEhzQVp0Z0p4MTZWemNpWDA4c2FMQzd5TW5Uc005TWpzSzVPSTY1SHFGdWtkb1RiaDI4NlVaRzNIYko0cmtTVGJmWTdwT3lzZDNIUEtIS2pjRnh4bnArVmJGbmYzS1FwS2tlNlBjVlB6SG5udm1zVkpsTXpET0NBU3ZHYy9qV2xaM2NxT2lHUWZMMFVqZ24xTlc3V01ZM3RjN1lTM2oya3MwY2FiVXl4UXZ0T0I2ZXRjM0RmWE54RDVyeHFDK1NUdnlYQTZEbm5pcVYxZHZFd1VuYzc5V0o0SDRDdENPL1oySG53eHlvUmpBKzhENjhVdWJ5TlhGU1RJQ3FzNFZ0cWh1bzc4K2xRUkt5WFM4L0t2WEg2VkI5cEVFaStZdytiSzVKK1laNlZUKzNSVzB1V0gzdU1ldFVrbWtjOGx5eGFXcDZocVZ5ZzBuUGxDUWdZSVBRMTQ2dHRQZVhTUlJ3bVNSMU1tMUJ3cXIzUG9mU3RXODhRUi9ZdktmWWlIaGR6QVo5aDYxeStuZUpadEkxSVhkdkEwckJQbmkya21SZjdxKy9wWFJKeG5PS2V4bFNwVGhSbHlSVitpZTF6b29wVkpkTHFVMnNzSXlxU2twdUh0NjFud3p3U1NPeXFSNyt0ZXYzRTYrSjlOZ3YwOE9UdUk1TjUrMEtWZGNkTm9QSkZlUmExcCtzMkpGMU5ZdEhEY054SXBCVlQ2RURwVXlwS25KdS9NdlEwcDFsVmpGTktNOVU0M1QxS2NrQWtkVndBYzlmU3RpQzd1RlNLMVJzdmtnUDBIUFBQdFhPU3JzSVVNUUZPU2M4bk5SZVk2THZ4ZzhZUDhBam5vSzQ1U1VqcDFWckdwTEU2a0FLTXRuSUJ6a2pyU3RhTkM2T3I3bUkrWmV2NEd1RHQ3M1U3clZUSGFhWGVTYmVOOFVaWVpQdjB3YTNJYjI0anVwNEpvWjRaNG5DeUk2bGVUMDYwS3lneHh2ejJ1dnZMTTA0eVE2a09Sd29HTStuTmN1OFl0TCtKaTVrM0x4bmpHVDJyb3BKMWtrWlR5eThBTDYxazZnMDF3OXNKZ3YzdjNiWjZEM3h6V1pvNzJadVJYSG1OSjBCQjdEUDVWZUZ4Sk9yT29BU01keDFyTHR6Yng0WGNIVVk1SEIvQ3Q1cm5HNEw4cUFjQVk1UFdwY3JJaU1kTGtGZzdTWExBcXlic2tucndQNVZOUFBLMHdDamQyNTdaNys5WnNkN2J1KzlwUnVicWUrZnBXeThkdGphajViakI3SDhSV2FxUmJzaTV3ZGxjMVo0NWJkYmEyVmlyT0ZkdHA1NTZjaitWUVhSU09VaEkxSHlnTms1TE5VU1RNbHlHTGZNQUJuR2VnNm1xYzl5OGtyUElCanIwd0NhMmlyTkdkMmxZMmY3UVNPQW9YWUhHY0JTUVMzYjJGWmhTNWFVeXFGSU1mekFqaFFPK0tsc0x6eUhiTGJWbEkzWjZFZi9XcXpyV2szRnFrTncwNWFPU1BLWllad1R4d09TS21WdVpYZm9URlBZcGFmWS9iSFlSRlBNalVzRG5idXg2ZS90U1NYbHpBVlhQS3RsdHk4SDE0cHRnbHdJZk5XSXFjbjk0ZU1ZNzFEYTNxeGFtM21MOW9NcWJTeW5sU2U2OXM0cW0rdTVmSzAzcWI5cWkzSmttbG5CWmtPVkFDNDI5QUt5bWVkWnYzYlp3Q0J5VGluRmhFK1ViZnljRmx3ZnhBcXFKNVFrbTF2TDNqRzhqdDdWcXJXMFJDdnJxYWNMMmtxYlpDakhvU0R6LzhBcUZkOURwR2d3YlpYdk44WXdRRkdTZmF1QzBmU29qQzdiNHhoK0M1dzNQVWoyclVzN3FYekp3Z1g3T3JsRkhHVGp2ait0WlNxT0xWK28xQnl2cTdIUTYzcWxyYzNOc3R0YkVDTUZjbk80Ky90WFBMZFJrK1dHQWZrZk1jY2pzRFhRM1YwMzJkUExNYjV4a2hjTUNQWDZWeHc4bGk1TWhKT1NEMUdSMnJOM2J2M0tjVW9xMTlDM0ZxVm1ZaTVjcmdzRnd2REdwbGprYU9NNUxaT2NEcU1WenN6UW1SUXdKNTVBSEJ4NlZ2NVl3NUREQTVHUDVWYXVURk1wM3k3cGw4cHd4SEJ5bzR6NjF4L2pTM3RsOEpYZ2xoYVNSb2p0S25BRGRzL1d1cXVydUpFQVpUNWdISVVaL1AzcmtmRzJ0V2NQZzdWWVNyWmxpQVFFL01lYzVGZEVVbXhKVFRqWlBmMFB6b3ZKSTlqUXlBd3VxbmNDcEJCOS9hdVowKzhsdHJpT1YwU1ZJeWNKSnlwL0N1czA3TjlJc2N6bVVPNFFLZUNQWG4wQXBOUXNOS3Q0MmRVbklabThvWStVZ0hIV2hOSjJOcEs2OGpxVTFHNzFaMFdOTGVBS005ZHFqMzcxdzBsc3p6U0Rlc3JKOHg4d2xTMzB6MXF2WTNJVXlBUmJGQXljSHI5YUJkUlhkNHpFQW5hZm1ZNDI0N0NuMUtpb25XUXdRWEZrZkpVS1ZRK2FBQ1NNOWlhNDBiSWlkc2FOdDlQWDNxRVhjUWtkeEs2U2RBQjBQMXJRc2JyVHRqeDNXNzVqMGo0NTlUbnJScWhTc1c3ZTQxVGNyUlc3eUVEakNiL0FPV2F6WnByMVoyYVpWRWhHY01QbUlxM0hKWlc4aGVDN21CSjR3eFFnZmhYVXo2azk3cHpMS3B1QkdCc2NnR1JTVDYrbEsza1RZNGQ1QVFkb0VaYmg5emNDdWp0TG0xaXRRWkhaL0t5Z1lIKzkyckR1WkxjZ3FZRkhBeG5sZ1JVWGxLWW1US1J4TVF4NTVKSG9LYmhvTFk2VTNrRWtGajVybll1NUl5VHdnejN4WFUycGlETkxHMjFrVGEyTTRJUEc2dWRrMCszaDBxTEVNc2lidUdBQk81djZWWXNiTzF0Y0c0bWVFOWhua0tmVWYwclBSZmVaeWk1R0hxY3R1amVTakt6bi9XU3N1T1BRRDI5YXR6QzBtOG9QY3VrVU1XMkpWVGN6TitQQXJkbjAyd3VKajVVclRSSGhXaUlKQlA5NEVZeFhuMDhNa1RPR1psOHM5Q09EOUt0V3NWYTFqbzdEVHIvQUZDYU5ZNC9NN2ZJdVB6OTZudTlEdjdTVzNpZEZRU1NGaHowWHZXSlp5UEpJSFNTU05keThMK1djOXE5UTFaMHZJTEtDTXpHT0FzdTRFTks1UEpGQ1N1TnQzUjVMck9KcjhpRmNLRkNxVk9BUUsxYkRTSVk3Q0c0dVNpTE9XOG9Ia2tJY0UvblYrOWhZRVJ2RXNZVURjZ1BKUHBudlhUSFJMeTZ0cmRva2lWRlVvRmJ0ajB6OWFtVFNTVnkrcGo2cnFwbU1xUEtmS1pjQUFaT0FlTTF5dzg5aXJRWFRjY0hqQnFZNlZLenlCd0ViWnU1T09QYk5WQmJXa1FCYTVZNUgzQWVhNTQ4cVduNUdMVDZtekZxYS9aSkE4ZTZkSkFVY2ZMMnhnNHJHa3VMNEFZbUFCR1NvR0FEVnhEa0JoRVJnY0hHY2c5K0tpV3lhUm1IQ1BuK0x2bjNwcExYUVVkRVZMVXk3U0dtMnFUbm1yeVFTdmNxSmJnS0U1QnprbjZHcGhwVnhDVDVrVE1WSTNMMU9QOEFDcUFlVnBuZC92S2NnRGpqMHBYVHZabFh1anRyaTF2WmJKUXFPMndBcUF1TUQ4ZXRPYnhBVzAyMGh1TFpKRmlZOEt1eGoyNVlWbnZxODhwM0JpaXB4OTdKNmV0Y3BjTWQyNGJ1UVR0UDZHc1l3dnV1cEoxZHBxYVc5MEVqbmFKaUNCbmtxRDJOWk4xTTZNL0NPTTlSL0kxanhxbjJWWkR0Wnl5N2lSeU1mNDEwTm1zREJsWm5acEdKQUhBRlc0cGEyOVNyblZhVkhwOXpwTHRLeGpFWUl5UG1HZTJmUVU0M1RRVzF1VVJIbHQ5eXg0UEJEODVCOWpYTzJWdVVXOWpDTVZkY0VmVG9hdzQ1bThwQXVFQU9NOTJOYy9Lbko2OVMzSTM3OXBIc29USW1iZ3UyUUQ5d0gxK3RaMXJxSDJWUVNHYVJHQlJoL0tpelpQTS9lT29ZTjh6SHB4MHo2MVcxR2VPVzR5akZ3UHZOMFVuL0FHUjZWc2t0cmFHYmZXNXVEWExwbmVSVlJsZi9BRmdibnI2ZzlheXJqVVowYVNYeXh2SXdjREFJK2xaTVJJamxZeUFIT2VuYXM3N1pMNXU3SkM1Nlo3VmFoRytpQ0wxSHRkeDNJVlJEc2JQVWRLM3JPMG1VTStGWGFmdkZUai82OVZUZXhYTzFaRlFFZGdOaEk5OFZwQU9UaFcySnRISEpBSHY5YXQ3YldMdGRqN3BOU2UyalZCdVZ6bkdlZjE2VmgyZDdOQzYvSmlhT1JjTjE1QjcxczZpWTQ3dUR5SmQ0RWE3empJejN4N1ZOTnBLeFNKS0pvWkZKREtVYkpQdGpxRDlhaFNWdGVwTGV0ajFmVzdTZG1pdUxWSWxkNVFabHp0VTVBeXZGWkdvWEMyRWx4RDVLT3NZRExJdlpqenR6M3hUN3VOemFreUJpanlKSUNDZXd4amdZcm01N2lFeFRDUnB3c3ZSUVBrSUhybnFhNVY3MWllVkVXbzZoWXloSmxBYmNvTE1Gd1FUMTYrbFdORTA2Qy9Fc2swcGFHTlQ4c2JCUzU3S00vcldkYVdkaTFxeG04eFYzZnV6dEhQcUR6VmE0K3lSM3FwWkt3aFZRcHdjaG1QVW5QYXRMS3ppcitwU3N5RmRHdllwamhkNGNIQkhLOGZ3Z2pxYXh4YXhJNTNncTRKREt3NXF6ZFNTMnpPRXRaVlpqZ0grSDhLM2RQbXVkV01rTnpiZ3lSeDVTWlFBNEEvdms5Vi9XcWQxSG1iMEtWbG9jdkJCbWJmdTI3TzU2NCtsV0NJbmdra21aMVhJS2NjeUVlbjlhMkxjV1VTZ1NiM2t6d3B3VndEM0l4MXAxNUZOSktyU1cwZ2pZYlk0b3dTb0E3RHJ4VFV0UWQ3YUZHWFY1WlRIRUl3VllEQ2hjWkE5VFZYVWZFdDNQYUphR05NS1J0WThiQi9kWDJydWRNczcyTFRubmEwTGtaampqUEJVTjM1N1Y1bE5hM1FlNVM0dHl1ZWpGZnVrZGg3VTRlemxKKzZ2ZERtWkJhb3IrYkh2eXhYSzhFL042Y2V0ZWdYdmhuWHJUOTFlNmZMRTZ4aDFSaG5xTWdISFRJOWF3OUpzM0ZyTGVGY20zVlcyOUNVSndYQTlCWFcyUGlxN2t2SENxWlhEWktsamlSUjI1cnE5MTMxMkcyN3JielBONFpiMVowaEFLYjVGd3BHT2ZXdTkwOWxraHZyRzZ1RzJ4eTcxRGRReDY0L3JYVW0rdDlRMUZKMnNQM0tINVFSeWg2N1JVbXAyRmhLczBpTElqVHZ6S3dJNkRqYUQrdGMwbW11M29UZTZUWmhScGJXbWsza2tOdkw4MFpVaHhnQXR3Q0IxNXJqNElZRkN3VFNtMi9kWmFaMGJDc2VjRURuQnJWbWp2R0wyN1hDeUVLcWdCdHFnRG5yNjF1WE9pNmplMkRCYmlYZENQM2tiU2VZcFBZQmoxeFV4V3UrN0cycmRqZ2tlUlFpdkdaZk1CTVFYZ01vNzVQOHFTNGgxQXUyeGJnRFlDVHRiNWNkRGtkcXVMb2x3Z1I1SXc2cmovQUZiYzU5TWRxNm00MXk3dGtSZHNrWlZTdUMrRklQYmpyV2szSk5jcXVYRkozMXNjcmZMcURTUkxOTzl4SnRBSndlcDZEM05kSmFhV0lySXh6RHk1bnlXOHhTTm9IVFo2ayt0WjZUU1hWekZGNWplV3pMdFl2dEFKOWF2M2svbGtLMDdQNVRNTnhQY2U1NmlzSk9UU1FjcVZ6SnQ5UmswMlh6VGFwSVl5Uis4VGNBVDZnMXNKNGcxalZsVVBERExzWXRzTVdBRjlBVjVHSzNicTd0TDZPR1NaUXN4SHpzQVNyREdCbXVDZTF2YkdGLzNqb0pjNDJqQVlEM3FFNHZlTnBlWWxQVkk2TFdwN1lYa0QyMWswY3loY2xITElRQnlRVzZHdTBpOFh3Z3d0OHdkVkFWeVZHQU96bGV2NDFzZUhMUHdiYmFhbHg0a212bzVXVDl4WjJpS3pUWjZNNWZpTVZVOFplRGJXMmxUVXRMc0pHMCtkVkxLUjV2bEE4WkxMeG5OQ25CMmk3K1RDZnhiR1JhNmpJMTlETk5HSjNMZ3dveEJpYzU2UG50NlY2SjRvOFFYMnYyRUdqd3lKNXhiZVB1b2dJNThoY2R2VE5jcHAxdEpkYVhlZlo1bzVtVVIrYis1OHNLbWNESkdUZzFTdmRIdG9kTkpaeEZLbHd6bGt5emJkb3dPT3c5YTVueTg2OGlkV2p5ZU9DNGwyMnN5NGFFTTJHTzBJVDFCclJoaDE2M3NTNXNtV0NVaytZWXVxK3hQWVY3Slp6ZUN0VEtKUFBORGRTS0ZsdVlsSUFQUUYxT2QyZStPYXlOYjhFNjFwdDFOSDVyQVJjck83c1lwQVJuQysvcURYWnpxOW1rdlV5bEZwcGFYTUd6WCt5TEE2bTBxVDdrQ3dCUVFBN2NFTjZiYTh1dkxxTzRrWXMrUkxJTjRPY2M5eFhvVjdhWDhPbHlOUGJNTmtxS1FUZ0tEeUNCME9mYXVGK3cyN3p5TE0za0JqdUJEOUtkTzE1TzkzZmNwNkhlU1gra1hFRmxwNitZbjJlM0tveS9OKzl6bmR4MngxbzhHK0dMM1Z2RXFXY04rRkRzWTNtKzhNTUNjWUhKQnhpc29TYWREQkhGYmVaUE8zRTB3eG5aM1VZN24xcnBiVFNiMjJ1SUw2ekgyZUpIQldSNTlwWDFCQkFKeldsbTR0SzZ2M0xxTzhkSFoyM09MczlGc2t1N3FPNnZvN1JZNUh5UW0rUmdod0ZRRHVmWHRYZDIrdlE2WFlUaXpiWThoKys0dzRCNDVQZXRQeEczaE9TU09lU1lsbEJ3cUhHUTNPQ2U5Y1pONDB0N1dhT2EwczRUc0FBM0lHNmV1ZXRhS201V3VaOG1qTnV4MCtXNXRyalVKWWpGSEVoWXpiaXpQbmpDWjZIM3JnckdHd2trazhxNDVBTEtja25JNTV6V3BmL0V2V2J1NDN6VzhJaktnR1BaaFcvQVZvUStKTk5qVlpaZExSVmw0QlRxZlhqMHJYMmFTdGZjY2VhMnR2UkdUYWFoKytsZEl6TkdxZ09rampiK0E2bjhLcnkrSmJsSTdxQzF0N0pJWmlNaElnV3dQZHVSV2o1SGhlVjNacDU3ZDNYTVl3QXY4QVdxbzhMV0VqQVdsOUcwcFAvTFE3QWY4QUNwOW5IMUczcHNjcjUwaXlMY3dvV2tBSU9CdUtuNlZvNmJwQzZxWUkxalpaV0xaa1p3a1p4eWR6TmpHSzNCNGE4UTZYTVptc1ZsUmVSSWplWUIrVmVuVzFsRmRlRkpMK1pCOW91SlhoaWo4dkdBb3lYNllIUEZaemJpMGx2ZTF5RnFyclU4NXV0T250cmVWTGFSYmhJaU53am5Fak1PNDIrbjBybGJQUjcrOHVDc1Z0TEs4dURIaFR2R2ZaZXYwcjNPZjRVK0xvL0RYOXEzTnFxVzhBOHpkRlBINXpSa1pHRXprMWc2Yzk2bHJwOHpYTWxsQktXSllzUis3UEFKWWNnazlUU1VseTZTVDFOSXgzOGowalV0U2xqczlMMHFPMGtONWJEQVJnb0o3QSsvUHJUZkVYaHlEUzlhZXczWFV0OFJGNXpSNGpRRmwzTnNaaGx3aFBKRko4TGZDdW90NHYrMlh1MlMyc3JhNXVHWGNKSGxlUE93S09yQUhCejByZDhKM01mbTZucWhzektzQmt5OGhMUExQSWVBYzhBZHlCWE81UmdtbHJaYStyT3lDdTBJM2dudzdxZWtLSVRjQy9qa0JlUXN6SkltT2QyT2h6MDlhK1VkVnNialQ5UldHU1A1a2tJM3FweXdQSUhQY1Y3NTR0MS94UERkV2dzYmw3VVNqOTdGQ3dqems1REVEaXRtdzBlOU9oTlBxRjhKNXJscEpyVlpnQzhRajRMN3V1NG5vS2luS3BGY3psZFBaZFJ1SE5aSldhM09vc3ZERnplZkRUUk5XdVlJdDJuMzhscEpqQkpXVWJsT2ZYSnJ3Rk5FMGhMNlMzVHhETEE4YkFuN1JHQkh1WTlDVk9mclhwdHI0a20wN3dIZDJzdDdJeWFsZGlPVzJZWVYyaU9Wa1Evd0FKSGNpdk5NNlRiM2lTeWlZU3U1S3JKSDVwWUw2NS9TcXBPVnA2OVhiK21RbzdKOXoydnc5b2IrRmxPczZpaVRFTUV0N3VJR2VCRVk4a05IbmEzWWJzWXJ3UHg2K21YV3V6UzJkeVRGSmcrVnNPUUQ3azhpdll0RW0xR0c2dUw5Slo5UGpkUVpvMWNMRzZqczY0MjRQdnpXaG84ZmcvVTlRMUlKb3NFa2hDNXZabktXOXVwNVloZU11ZXc2VW8xTFM1bmR0TFd4VXFUVFQwVi94T2wrRWJXOXZwOTFxY05ySElZMFdPT0tmSExxMk41TFlHT3dyNzc4SGF0QnJra2FpTllaVjRsUmlOeEk5UFVWK2IzaXZ4WjRlMHF6L3NuU0xsQkZ1amRncWcrWU9wUW4zUE5mU0hoM1U1Tkgvc2RMMnl1aWw3R0pMZTZnQXlwY1p4K0I2MTFVdWIzM3k2UFZFT1VHa3IrODlqN3orejJ5VEZWTWU4RXJ0NzBzMFVnZUpBU3hQM2dPdzcxenZoeTZ2SkloY1RqRGdnc1NNOGV2MXJ1YnEwRjBWMkhDT2NzVkh6SC9BVnZKSnBOSW1Ea3RML0FEUFA5YjFmVDlRMGU3aGdSaERDZGp0akg1ZTlmRStxNlhvcVc1bHM3aVJtTWo3aEt1R0tqdmdWOWFlS2t0NGJDYUtIaU01UEhCZGgycjVQbnVKN0xVNERNOGFJUVYzeS9LZzNEdDZtcVV1bGlmWnRXcy9Nd2RiOFI2aVBEaldOaGJ3UXUwS3dBSTN6T2puSkk5elhyZnc3MExUOUlndHJpNnY0WkhpWGU2Nzg3U0JuYWM5NitKZFY4UjJVT3YzQmFKekV1Nk5HallaQytvejBOZlFuZ0N4Ri9veU1Md09WbURHTlJsanU0K1kvenJwdm9tWXlna3Q3THI1bkxhN1BiM2VweXRBcktaSnp0WW43MlQzcmJXUnJXMmptbTFkVGNSeVkreUZTeEErdlN1NTF6d2hKYWF0TUkxV1NQS2tlcWtqL0FCcnk3V2ROdjRqY1N6TDVXT294eWZwVzN1dUxNV3ZoNVpOSzkvWHkxT29jcE5lUmhMaGJsWkl0N2JNL3VtUDhKSGV1QTF1eCsyM0RQYnh4Q09KTnpCenR5RkhPQ2V0ZVdhTGU2ckhOTzl1NzUzRTVCNXgzcjFUeGo0N2h1L0E5bG80Z1JaTFpnUVZYREFFOG5OWnhVVzI5ckxZRzZpVUVselhsWnZzdTU1TzRWcnUyVjF6R2paVmw3OTYrbFlOZDFaTkpnT28zRThxVDVYVHdzaWphUjZqcVFLK2JOUGhsbEVHQ2R1T1RqblBTdnRUd1A0TnNMMnpEYWdqcTIzRU1tN2I1WVBVQUhqbXNwU2lrN202VGJXaTA3cjhqdmZEUGhxMDFUU3BYbmtIbk5HWFZXSkxmNzNQR0s4ZVRSUEZjdXUyemFoYjJpNmRiWEljTVcvZU9GNkE0L2hQcFgwOVBadzNFZHRGQkw1U3dyNVlkTUJtVWNjMTZ0cEhoU0I0NGpMR0pGM0RJY1lMRDFOY2NMdWQxcWJPRGlwT1V0SHN1eDhuZUl0WnZkVzFGSlRwUDJDQlFzUWNMbU5sSGYyRlpYMnEzOGsrVHRCVjl5U0lveWVNYysxZmYycTJlalg5dTlsUEdpUm9Ob1VZeCtsZk9lci9EclQ3SzBlU0NVSWlaeXBiT0I3WXJhZE5yV3lPYW00OHRyV1MwU1BseHJxOHVKaW9ZcnRVcWhMZEFmUSs5ZlFPblI2UG8rbnZjTnBjTnkwY0tBNWY1QXhHVGtkU1RYR1I2ZFpXdW12R3BtVzdlVXNrckFiTm1Pd1BmTmRCb3ZnbFY4Tm1lU2Nxek8yNUpQYy9lcUUwNHRXdWI2Nk5uQldFa1dyVFhEeHdBTTRaMWl5UVNPNFgxSXJMU3prakQ1dUdoaWNraGM0SXgxcnQwdDlXMGJWclpyVzZpUGtraFAzWVlqZndmd3JTMUxTOEV0dlF5UDFZY2pKNU5jN2paRzBwVzY2UFk4Nm4wMldNUkZib2xYQVpaRVk3dHZ1UFd1MHZiaTBnMGRXaXU0bGZiOHBrYm5QOEF0VlBhYVZwME4zQkZkYXJDRmwrK3c1RWFuK1ZiR3IvRGV6c2ZKbUdvSmN4VE9RRUpCQkdNZ2l0YWRPOU45Zk13cVAzb2F2OEF6UEU5UHY1NW9wQnVDdGtxR1hsU1BVRThHcE5PdFlKVG56RDh4NUJQT2ZYOGE5LzB6d3ZaWHVoSUxSNFd3RHl2USsyQjZWNWZvL2h1N3NydG81NUlwWndUdVNOU09NNXh6N1ZnMDFkUFE2WXg1MGNGcTJnNkxOY0NYK3psbUtnaVQ1aW9idnpqaXNDWmJ6VEhpdUl0SFZMUmdFU0pTTWsvM3M5Syt4SWRPUkkzYjdOdDQ1VVlZbjYxaytKUEJ5UzZaYlErWUF6Z3RJQTJBcFBUYUI3VW95YlM3RnlwMmFUYmQ5RHludzdvUDI3UXpOS3pxMGt6NGpCd1VIb005cWdrOEg2eExldTl2YlJ1TGFMZklaSkFueTlPQWVwK2xlN1dPbVIyZG5GRmFsUSswS1pHWWs5TUVnZEFhcFIzckJuV1g1eXN1TnpEcWZ4cm5WV2JiMDBMVkZhdnIwUEkwMHU4a210aThUS0JKamZuZ1k5eDNyM0hSL0NXbHlhSnExMWU2aE45b3hoQ3paSFBiYWVwTldyaXhzSUZtblNGcEpsTzhKd1FTZlVlMWVNK0liM1VidTdoUmdvdEN3T3dFcGxqMXpqcWE5VERWS2JpK1pYZlJIbTR1bFZrNHFENVkzVGI2NmREaHIxeElxUnJHd1pNNXdNNXg5UDVWUFBwV3N6bUdRSkhGYk12enNUZ013N0Fqb1RXdEpQZGFkZkxKWndMR1V3Umtid2MrdWMxMjhuaXE0MXUzamgxWENReHEyMk8zUll4dlA4QUVmVTFVckpNeWZ0SEpjcVZqeDZPOTArQys4dkVyeGpqWnd6RFA2VnJYYVhVY2pUUU9yUnFlUjZWMVhoalJ2Q2MrcENPOW5LUWhYeHp0Sk9QNzNwVE5mRVdsbU9GWVkxakxaaUkrYmVvNkU5VG10S2RQM1hOdlljcWlWUlU3Tzl0M3N6aGJuWFVsaEVLc1dZOEVjam4wcnZ0Q3ZZYkd5S3dQaHBnR2xPMHFRUi9CejI5NjRSb21uL2VibEp6eXFqb1BhdWhMcE5LaUc0bEl3cVJreGpkK08zcUt0eWJkeFJwUlNzMXB1eXZOZjJCUzRrdVlYQVVsWWdQbU80OU1rOWpXL1phRnJtcDJ2bld0c3hVdnNjWkJJeHlPcDc5cTZRZUYvQzhxc1pkYW04d0g1b2pEaE53L0t1azArKzAyR1pGY2hMYUFNQjVSQmQzeDFiSFQyb2RCcURiYVM2ZFNGWFVwZTRudnJkTmZtZU5hM05aV2xwZE1wa2p1dVkzM044dzllS1hRTE8xMTZTMDA5YnNXY1VqY21Sc0RrZXZjbnRXakg0ZjBKNEhtdTlTTnZjU3lIQ01wbExxZTVBL25VSnM0Yk9LM0N6SmNZWXNPTm9iSFFIMHJDaFQ1WmF1Nk41NnhhVjdwNzJPeDhjZUVmRDNoV0t6U0s1TXFTeDRNalBseVIxL0N2RDJsS014TzVZdU1PVUpJSCtlMWRoSGRKTGRYdHpmU0JKRTR0b28vbXdlNjVQU3ZSUEJPalJlSU5ha3RqTklzTVVIbUZYQzd0M3I3MTB1TVoxTFJzamt2S25oMjVOeWNWZHM4Z0YyTm96RVJ4dzBpbFdQNEdxc2VwN1pTU2lrWkh5aml2ZmRYOEZyci9pbHpIcWtjRmhZMlcxNDQvbm1kbDV5VjZWODVTVzgwRXN6QkM4U2s0a1pkb1pmcWU5S1ZQbGVvNlVtN3JyWk8zcWJFbHo5cktoSXRyZzhGZU9mcWE1aTZXZDhzNEt1R0M1STVCYnBWMnh1bnZHa2tnNThsZ0hkU05xSDM5NjdDMHNwTlR2MVdSL1BMSGhHY1Jsc2ZseFdFMjAxYnFkTVdydTdXbS9rVnA5THN0RXQ3YVdlT0s2dnR5bFJKR0hWQmpxTzFXMk1GN2R6VFMzU1c5eXdHMEpGaGVCbkFJNkdvNzlyTU5kMmtFamxZTUVrbnpDeDlFSTdDdFcxc1piZXphNmtpa0tzRklNZzJrRStnOTYxWE83NjZYT2Vxb3hqR1YvZXRaUDE2RnkzOFIzdW4ySmxOekpjdkUrM3ltWTRIdGtkYWRxK3JmMjdGRkZhNm1rQzQzdkYwUU5qa0hQWEZjRHJzcldjU1E4eDRCazJNQmtidTVJNm1xK2p2cFNhWkdJSVZONUxJUE1adVNWSjQyKzlhcVVsZUxmVFV6VUlXak5SVitqVnV2VXZ4YVZMREY1MTdLdHZFd1pWa1JkN09SMHdEMEJya0lRYmk1ay9pQ3NBV3p3LzB4NlY3ZjQvdVpaR3Q0SllBanJHZ1pWRzA1STYrd3J5azI5dEhFOFVJWUhlR0RNZWZ5RmNWU0ZxbGx0YmM2YU1uS0trK3ZUb2pvOU12YnpTcHdxMzByUVNrNWp5TUt3OXFzM1gyZWFJTEdwWm5sOHgzTEZwTnc0Nm50N1Z5MGxwSklDMnhoSENvTE1lK2V3cmNnL3RVMmtOeDVlWXp5dnlZd1BRMUZwTldSVHB3akxtMFRiOUxzdVd1bDZlNjNrUXVJL05kQ1RLMkYyanZnSHFUWGlsN1l3QzdpOGtzVnp0RE4yQTlhOVB2SWpNZ21kQ3hZbjVSd1FQV2x0OURubnQyblJDc0tmNng1TURKSFlBOWNVbEdTdjFOZWRLT3JLdXVhQmM2Wi9aNG5LQkpvaElraUVNckwzSXJ6clVkUWh0NUJIYmlWNVdVa2hWT0ZBNzVyMTJIVGJlV0I1WkxseUFwRUVhcm5KK2g2RDZWeTl4SkxidXNiSENqa2dxTS9VSCtsWlZkbmE2VDh5cVV0dXJYeVBJajRhaG51WXJ5NDh6ZHdWVlhLOEQxQTcxNjFwMXhiT3FiRU94ZUczTmsvaDBOVk5XczRwWWttVlM3RWJnVkpYQnJuN1FHSzl6SnVIQUhRODVyT25TNWJhdCtwVTUzWjNndTM4NENOSWdTZUNUdFlkdWxadDNOTE83ci9HQ2VPOWNIcnhlenZWdTBmSlFydHoxQTlxMjdMV0pyaU9LZG9CdVp5Q1YrVXQ5YTlHRUhhNWpLUzBmeU8ybXNJUmF4UEt6UnVPU2M0d285UWZXblRYT2h5MkZoSWtraGxWMjM1R1FRT20zTll0emVYRnpHc1RNTnJaVWc5bEg2NXIwSFJQRCtuQ0lTYWhNVXRnQnRHM0xIMUZhS25kR2NxaVNWcjZkam1mN1RtdTQ1b284djVoR1hZWUtLT29BOVRVRFd0dEZCSW9oWXV5L0l4WXJzUHI3NXIzVzZpMEcxMDVqWlF5K1V5OVNtRy9MclhjYUxZK0haZEVrbXZvcEhhWkFZNUFBeFFEdUI2MUtwWGVoSHRKY3VxYVBrZVNHOWpnRGJHNmZmN1k5YWoyMzExQ1BtQVJTTnpFY0QzNHIyTmJYUkx1L250N2k3bWlnaXlSSWNET09tVkhjMXZTd3hSV0VkdHBNYTNNampMcWdKT08rUWF1VVd0aE9kcHBjcis3VDd6bDQvRHRuYjZiSk5IY1NUc0FEdksvS0I5SzRvajdycXJrYnZsRzNHVDYxN2JvZmhQV0lMY1hTWFRidDdiNG1iaFJuN3ByMWV4MHVHNTM3N2N3eVkyZ29vSys1eWU5Wit6VW1uc1c2bkltMDc3bnhtVE90d3FnNzkvREl6YmNVcU1rTnc2RXFEbk9UeitkZlNQaVh3ZmFOWVN2QisrdUYrVmVPTTkrUjNyaXZEL2dhZVdBelhVeXB2Y29Zd2NrWUhVazFQczVONklmdG84dDJlY3lNenZHek9yRlFGVStuNFZYdVowODlkaXJ0SkFQYm52WHI4M2dsVnVWaGh1VVliYzcyNlk3ampxYWxYNGRtU1pZbHUxMkRuZnRKelRqVG5mWVNyUnR2MFBHV2EzamtiRWUrUnV3UFNzbnhocFZxL2dyVkxtVkNyUW9HajZINW00UDREMHIyK0xSZkQybTZxSXBENTBtMHN6RGdBRHRtdk52aWxMWi84SU5xMFMyM2tzUVBMWW5IUTVHYzFyN054ZW9ScUtjb3BON3AvSS9KdTNnbnM3aVZrK1liU0k4SE80bnZYYlRSWGR4RHBFRThXMEtTSDI4SDV6a25GY21HVkpJQ05wVjFKWWVtT3VEWGUzMnBXc2d0SGp2ZVhJTzdvVVVESFd1S2JkMTM3bmRHMW1MNGk4TWFmcDk0STdhOFNNVEp1WGNyRlhVKy9PS3lySHdydXYwU1FoTjQ0ZGVWQjdaSG9hMmRadkpwcmkydFRLMDJBVldjZ01TRzlQU3VTdGwxRzN2SGlGd1FZMlBESE8zRk84cmI5QnBSN0hWeitGMEtYY2NKVVhNUXk0RWZHMy9ZSjZHdkhaOU5tdFcybVdOdHd6dEoydCt0ZllWak5GcVdsU0dkRklSUUpHQndWWWZ4S1Q2MTVOcmVpYUY1NkNNM0dSeVdkZ3c1K29IRk9FMnZpTXBPTjlENTlaanlvVUVIK0VuT0sydFBuaHk2TkswUllZM0Q1aGoyR1JYc0tlRnRNdWJVeEpJcXlrZkxrOGsrM3BYTlhQaENTeFROemFZNDV4TGtqUFE0QjRyUlZJUHlNMDd2YzVHVzR0a3pINTMyZ0VqckZzUDU4MWF0SUlGdW9aWW5tQWZPTnBCSVA0anBYVTJtaFdvdGpPNi91eG5MTWVPUFNndlpveUdMeXlneGhFeXg5OENyVXQ5eXVWbW5GYTNzU0xrbFRIL3F1Y2xtNjV3T3RZazY2bExGbTRBa2pMRVplTXEyZnFldFB0cmhIdVdlNExRdzhoVExuaytnQXJvRzFXVkcyUlNDVkVJd29HVlg4VFdUM0o5NjVoMldsYXBwMG9saFdTQno4eWhod3crbmNWdHgyY09xelN0ZHpvamhTUUVBQ3MvcGp0bXR1NW4xaU5rdWJpNlpQTUl4bE54YjJDbnRUN25XOUptczNSWUhlNUxCZCsxWXNrK2dITllOejV0dm1QUnBJNDZ6dHBKcmlXMnYxbXRpaUh5NVVqNEpIVGY2L1VWMldtYk5MWUxNUmNzV0JEcnlGWCs4Y2pPYXN3NnE4Y2oyaXhSM1lRQldjUDhBT09Na0tmOEFaOXEzZE9sMDJhK250NXBHTEtoTENTUGErUFFrZGEyVDAxUnB5eFVyK1J5R3I2UmV6aU9lQ05abGFRc1NyYnRwUDhQNDlSWFV2cDhLS2tMcW9hTWZOZzV5Vyt0ZXFXRUNKcFFlRUtTT1VqWTRCQy8xcHMyaVEza3pUdnVET0ZKRzBFQSszdFdUZTNrUkpNK05KSGRyd2JtSitVZFRtdWMxTUFYajhDaWlycDdyME01SFMyZkdqWkhCM0FaclJSbSt3TWNuT1R6UlJVOVg2a3Jkbm9Xck8rTEk3amxsaUJPZXZIZXZIZFgvQU9RcmMvV2lpdVNoK2htdGtWWlArUGR2clU5eVNiU0lrNUlVQUh2UlJYWEhmNWxGblJ2bWU1RGNqWjBQUGVwTk5abHZZaXBJK2M5T0tLS1V2dGVoVWR5OWZzdzFDNTVQTWJacmtWWnRrZkpvb3JPTzMzRExjdkhsKy9YM3A0QTJMeDFSczBVVnIwUkQzZm9WSlB1SU8xZFlZby9zZG9kaS9OSWM4ZGZyUlJVdnA2bHg2bEpFUVhNV0ZIMy9BRTk2N1JGQnZiOEVBanllbjRpaWlwbjA5QzQ3SEtTS3ZQQTRJclB3QUJ3T0dvb29pUjFaN0Y0UXVKeWJpSXl2NWZtUi9KdU8zbjJyTDhUU3lQcTEwR2Rtd1NCazV4aWlpdk9qL3ZFaWZ0ZmVZR25xclF4YmdEODJPZWFzVzBNUzZ4YnFJMUMvYXNZQTR4UlJYb2QvVTFYeEZCbWFYVjdzdVM1K2Y3M1BmM3JQRE1xejRKSDdzZEtLS1V1dnlCN25iZUY0b21takRJcEJtUUhJemtlbGVpYTZUQlBHSWo1ZUZ3TnZ5OS9haWl1U3NhMDl2bWJjM3pRWG03bnAxNTdWeGRzUy9pQkVibFRHaEtua0U0OUtLSzVhWHd5OURPcDhiOVRKdlVSZFYycW9DL09NQVlHQ09sZWEzQ0lsOWxWQ25DOGdZb29yMDZlM3lJZjZIcUZzQi9ZZHUrUG0rMFkzZC96cXRGY1R5NmJmckpLN3JHUVVETVNGK21lbEZGY3kzbDZtUyt6L0FJank0QWZhbDRISjU5K2E5NjhNQURTMHdNWm5rQjl3QlJSWHBMZERxL0Q4enhieFN6RHhOS0FUamV2RlVkY1ZmdEVBd09vb29ycmxzdlF1bnRIMEsrb2NhdElCd0F5NEhweFhzV2hJa2w1YUIxREF4a2tNTThqdnpSUlhrMWY0WHlOMXVqaDU1cHY5SlR6RzJGK1Z5Y2RmU3ZUTnF2b0VRWUJnc3NlMEhuR1Qyb29ybTZmTkdGUDQzNkZMVVVRNnJEbFFkekxuanI5YTcyK3VKN1BXNFlyYVY0STJ1TnBTTmlpa2JRY0VMZ1lvb3JPWDhOZjRUcWw4U09Oc21hTFR2RS9sc1V6TXYzVGorTDJxZXc1dGRTenovd0FTOXp6NjQ2MFVVMzhUK1g1R01PcHdmZ3RFZjRnNktqS0NqVDIyVkl5RDh3Nml2dUR4cEpJK3AvRUNOblprUzczS2hPUUNEaklIWTBVVmVJK0tQK0g5VVV6NVI4VVNTSFR0SUJjbmRiT3g1Nm5QVSs5ZUVYanZKQ3BkaXhBUExIUGYzb29yYkRiZk01K2gyQzI5dXQ3cCsySkJsUVRoUU1uRllXc3lTQTREc0JsdU0rOUZGZXBUMllsMDlEaVl1WEdlZVIxcTdxQ0lzQ2JWQXlEbkF4UlJWdmRIUXRqRHRpVE5Gbm5pdmNOSWlpZTVnVmtWaHM2RVpIU2lpc0t1d2RQa2VmMzZnUno0QTRtY0QyRmNiY3UzbklkeHpnYzVvb3E2WWwrcDlEZUVycTUrM0xINXo3Q3E1WGNjSGowcjByNG5TeXhhZHBpeHV5TDVJNFU0SEo1NlVVVmpWL2lSSnBmRlA1SGtWamNUc3VtaHBYSU42eWtGaWVOdlQ2VjFQaXYvQUZ0NG44QUMvTDI2ZWxGRmMwUGlqNnY4enRsc3ZROTgrQTVKOGRlR3NuT2RMdVFmY2M4ZlN2WGZFc0VFQnRGaWpTTlpkVmhNZ1ZRb2M0UExZNm42MFVWeVYvaitTL00zcDdQMFg1bng1NDdSRjE2TlFvQVc3ZFZBSEFBZm9QYXZiUEVDcXRqcFRCUUdNWUJJSE9QU2lpcmw4RlAwZjVsMC90SHhONG5sbE05a2hkaWloOXE1NEdXN0N2ZXIvblNQRGtoNWZ5MStmK0xyanJSUld6K0NQek9lSFgxT1c4VXpURTZiR1pHS05kWVpjbkJISFVWMjhrRUsvRE9KbGpVRTMwd0pBQUpHYUtLeXBmd28vd0NJMG4vRVhvZk4wVVVYOXJTZkl2RXlBY2RCN1YraHh1SjQ5SzBrSks2aEl5Vnd4RzNLOXNkS0tLOU5kUFE0SDhTL3hIM0w0SG1sazBYU3k4ak1YaUc0a2s1NDcrdGZRRVFBallnWU93OGlpaXRGc0ZUNFdmT1d1OHlyN0pLUjlmV3ZrZnhxcXlBQndHQVpPRHoxK3RGRlJINHpwbDhLUGx6eFpEQ2tIeXhxdnpqb0FPMWVuL0IxM1djQldJeWV4eFJSWFpQNGZramdlNzlUNmcxaDNieEZBQ3hQM2VwOTZUeFdxdDRQMU5pQVcyZFQxNjBVVVJNSDlqMFI4WmFJQXR5MkJqOXdPbjBwMXlpRzR1TXFQK1BYUFNpaWt0elpHdDRZQU9vMlFJeUM4WUk3RVpyOURXQVcyZ0FHQjVoSEhwUlJYTFYrTkhYUzYvTTM5UGpqRjBnQ0FEelJ4aXZwQ0VuN0xCUlJUcGJ2MUhpZnNubFdxc1Zra3dTT1QwclJpQWUyY044dzJMd2VhS0s5S3Q4QzlEelk3Zk04N3VZWVcxV0hkR3B3R3hrQTR4NlY2aThhTnB4QlVFWTdpaWl2R28vRjhqMEtuOE9COHRlS0k0MDFXMzJJcS9NZWd4M3JaOFNLcWFldTBCY29PbkZGRmFQL0FERlA0YVI0bGZBZVVqWUc0anIzcjV5K0lGM2RyNGkwRUxQSUFzc1dBR0l4bjBvb3JXbCtoMXI0bDZNKy9QQlRFYW9pZ2tMNUxIQTZaSnIxNldLSVh6dHNYY2NaT09hS0s4MnB1emFpWHRQamp5eDJMbjZlOVpXcW9oaE9WQnd4eHg3VVVWbEQ0WDZJbXAvRWljSnBvQnVNRVpHeC93QktaZW9uMlN4K1VmTVNUeDErdEZGVDFSdXVoc2FiODB6NTV5cmRhNSs0ampONWJLVkJIbTlNY1VVVnBTK09QcWMxWForaHcvakNLT1BWN2JZaXJsT2NER2E0S05pYmlVRWtqY2VLS0s5YWV6T0NKd2QvSklMMXZuYmh6am11OTFFbHRWc2QzUDdtTHJ6UlJXVVB0K3FOSmJ4OUdUekFMckV3QXdCRU1ZcXpweUxtZHRvM0tvMm5ISStsRkZiUTZtYy8wUFFJZ0g4RDM3TnkyM09UeWMrdGVMK0huZnpHRzQ0S2M4OWVhS0s2c1Q4TkwvQWp6c0Z2aWY4QXI2L3lSNmRvaXErb3lzd0JJVlJrOG5GWUU2aDcyRldBWlRjZ1lQSXhtaWl1WmREMEZ1L1E1VjBSZkVEcXFnTHZiZ0RBcnBMWm1pbjN4c1VmekF1NVRnNElQR1Iyb29wdy9pUDFNWDhMOUNUdzFOS3R6ZGxaR0JJYkpCSVBTdlV0Smlqa2x0bzNSV1EyekVvd3l2WDBORkZieitFNWNWL0ZmL2J2NUhtR3AyTmxienVzTnRGR0pKMUxoRUNoajZuSFd2T2ZFSks2aFBnNHhnREhZWTZVVVZ5VlBoaWJVZjRqOVA4QUk5TitIWUNTWGUwQWZ1VlBIRmRMNGtsbE1rSUxzUVZiSUo2NG9vcnZwL3dGNm5sWWovZmw2TDhqd202L2V6eWVaOC8zZnZjOXZldGZUNG9sdmRPd2lqOTR2UVVVVkQrSm5weC9oeDlEdVgrZExobStadDU1UEo0cmtINXZCbis4S0tLNTZ2eGZJS2Z3ZklzSXpHNHZnU1NQUFRnMTExcExJM2hqVkFYWWdYaUFBbnA5S0tLTU44VS84TC9JakdmdzZQOEExK3AvbWpuZFVadkxpNVAzRi9XdWZERmdnWWtqWWVEelJSU2U3OURvWFF4cnBtNDVQQ05Yb3VpSWo2U2pNb1pnUmdrWkk0b29ybHFiUjlSdzJmb2NLU1NMakp6ODZmcWFxTXpIVjRNa250ejZZb29wdm9DM1o1MTR1VlJxVStBUDlhUitsVnRDQU1sbXA1QmtISGFpaXZUaDhLTTZud3M5am5pakYvY0FJb0FjZ2NkT0s2ZCtiV0hQWkFSN1VVVlVqbW9icjBSM1VCTGFQOHh6OHg2OC93QU5kZjRhQSt3eGowak9QYWlpbFMzK1JyaVA0VDlUenFDT050YjFnTW9JRWJFQWpQSUhXdWkrRERzMTdJR1luR01aT2NjMFVWakwrSjl4Yy80Yy93REQraDdiNGlKaXY1TmgyYjVHRDdlTndIVE9PdGRQZWtwb2xwdCtYS3NUampKb29yYVA2bUwrQmZJOG84TE16NnhIRzVMSVpISlU4ZzhlbGVtTkZFcjNJVkZBODVoZ0RIR0tLS3VPOGg0bmM1eXdSQXcrVWNSOGNkT2E1ZnhqTExGWnUwYnNoMmRWT0QxOXFLS3pZVWo1eDhZVFRJTkpaWkdVdk9nWWdrRmhqdjYxeVh4U2trZnd4ZDduTFlzUjFPZTlGRkhSL0k2Ri9FaDh6OHRJQ1Q5bnllMG4vb05UYUlxdERPR0FPT21lY1VVVnd2Wm0vWTlkOE5BT05VRC9BREJiQ1FnSGtBZ2pCRmN0cXZGeEN3NExSakpIVTg5NktLeiswYngyUGE3L0FPU1NOVStWV3RZZHdIQVBIZXZQL0ZQR29XUy93bFljanQwb29wOURrbDhTK1oxbWtBZmFWLzY3b0s2M3hmSEdEWmtJQm01QVBIVWVsRkZjNytORXgrTkhqbXBFbDVGSitVRVlIYnJXdmV3UVI2WGF1a2FLeGJCWUtBU1BxS0tLMjZJNm5zanpYVmZtMUVLM0lWVndEeUI5SzYzU2tRWEF3b0dYWFBGRkZheCt5U2FGNUpKSjRpbDN1VzJwOHVUbkhIYk5lVno4enN4NWJESEo2MFVVbjhUTUlkUDhLTkN4QUNLUndRekVIME5mUUdoRXZvZDNJM3pQNThZM25sc2VtYUtLVlRaZXAwZEdkZFprbThVRTVHd244YzE2N2JvaXZMdFVEN3ZRWTdVVVZ5U0hIOVQvMlE9PVwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/css/images/ac.jpeg\n");

/***/ }),

/***/ "./src/app/css/index.css":
/*!*******************************!*\
  !*** ./src/app/css/index.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./index.css */ \"./node_modules/css-loader/index.js!./src/app/css/index.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9pbmRleC5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Nzcy9pbmRleC5jc3M/NTIxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/css/index.css\n");

/***/ }),

/***/ "./src/app/css/nav.css":
/*!*****************************!*\
  !*** ./src/app/css/nav.css ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./nav.css */ \"./node_modules/css-loader/index.js!./src/app/css/nav.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9uYXYuY3NzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jc3MvbmF2LmNzcz9kZTA3Il0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL25hdi5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbmF2LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbmF2LmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/css/nav.css\n");

/***/ }),

/***/ "./src/app/css/project.css":
/*!*********************************!*\
  !*** ./src/app/css/project.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./project.css */ \"./node_modules/css-loader/index.js!./src/app/css/project.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2Nzcy9wcm9qZWN0LmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvY3NzL3Byb2plY3QuY3NzP2JiYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvamVjdC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvamVjdC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3Byb2plY3QuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/css/project.css\n");

/***/ }),

/***/ "./src/app/home.js":
/*!*************************!*\
  !*** ./src/app/home.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nvar _ac = __webpack_require__(/*! ./css/images/ac.jpeg */ \"./src/app/css/images/ac.jpeg\");\n\nvar _ac2 = _interopRequireDefault(_ac);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar css = __webpack_require__(/*! ./css/home.css */ \"./src/app/css/home.css\");\n\n\nvar style = {\n    width: \"100%\",\n    height: \"400px\",\n    backgroundImage: 'url(' + _ac2.default + ')'\n};\n\nvar Home = function (_React$Component) {\n    _inherits(Home, _React$Component);\n\n    function Home() {\n        _classCallCheck(this, Home);\n\n        return _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).apply(this, arguments));\n    }\n\n    _createClass(Home, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement('div', { style: style });\n        }\n    }]);\n\n    return Home;\n}(React.Component);\n\nmodule.exports = Home;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2hvbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC9ob21lLmpzPzc5MGUiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmxldCBjc3MgPSByZXF1aXJlKCcuL2Nzcy9ob21lLmNzcycpO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IEJhY2tncm91bmQgZnJvbSAnLi9jc3MvaW1hZ2VzL2FjLmpwZWcnO1xuXG52YXIgc3R5bGUgPSB7XG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgaGVpZ2h0OiBcIjQwMHB4XCIsXG4gIGJhY2tncm91bmRJbWFnZTogYHVybCgke0JhY2tncm91bmR9KWBcbn07XG5cbmNsYXNzIEhvbWUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuKFxuICAgICAgICAgICAgPGRpdiBzdHlsZT17c3R5bGV9PlxuICAgICAgICAgICAgICAgIHsvKiA8aW1nIHNyYz17Jy4vaW1hZ2VzL2JiOC5qcGVnJ30vPiAqL31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gSG9tZVxuIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBSkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBS0E7Ozs7QUFQQTtBQUNBO0FBV0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/home.js\n");

/***/ }),

/***/ "./src/app/index.js":
/*!**************************!*\
  !*** ./src/app/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nvar css = __webpack_require__(/*! ./css/index.css */ \"./src/app/css/index.css\");\n\n\n// modules\n\nvar Home = __webpack_require__(/*! ./home */ \"./src/app/home.js\");\nvar About = __webpack_require__(/*! ./about */ \"./src/app/about.js\");\nvar ProjectPage = __webpack_require__(/*! ./project */ \"./src/app/project.js\");\nvar NavBar = __webpack_require__(/*! ./nav */ \"./src/app/nav.js\");\n\nvar App = function (_React$Component) {\n    _inherits(App, _React$Component);\n\n    function App() {\n        _classCallCheck(this, App);\n\n        return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));\n    }\n\n    _createClass(App, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(NavBar, null),\n                React.createElement(\n                    _reactRouterDom.BrowserRouter,\n                    null,\n                    React.createElement(\n                        _reactRouterDom.Switch,\n                        null,\n                        React.createElement(_reactRouterDom.Route, { exact: true, path: '/', component: Home }),\n                        React.createElement(_reactRouterDom.Route, { exact: true, path: '/about', component: About }),\n                        React.createElement(_reactRouterDom.Route, { exact: true, path: '/projects', component: ProjectPage })\n                    )\n                )\n            );\n        }\n    }]);\n\n    return App;\n}(React.Component);\n\nReactDOM.render(React.createElement(App, null), document.getElementById('app'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvaW5kZXguanM/NmZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xubGV0IFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvaW5kZXguY3NzJyk7XG5pbXBvcnQgeyBCcm93c2VyUm91dGVyLCBSb3V0ZXIsIFJvdXRlLCBTd2l0Y2gsIExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuLy8gbW9kdWxlc1xuXG5sZXQgSG9tZSA9IHJlcXVpcmUoJy4vaG9tZScpO1xubGV0IEFib3V0ID0gcmVxdWlyZSgnLi9hYm91dCcpO1xubGV0IFByb2plY3RQYWdlID0gcmVxdWlyZSgnLi9wcm9qZWN0Jyk7XG5sZXQgTmF2QmFyID0gcmVxdWlyZSgnLi9uYXYnKTtcblxuXG5cbmNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4oXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxOYXZCYXIvPlxuICAgICAgICAgICAgICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICAgICAgICAgICAgICA8U3dpdGNoPiBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSb3V0ZSBleGFjdCBwYXRoPScvJyBjb21wb25lbnQ9e0hvbWV9PjwvUm91dGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Um91dGUgZXhhY3QgcGF0aD0nL2Fib3V0JyBjb21wb25lbnQ9e0Fib3V0fT48L1JvdXRlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGV4YWN0IHBhdGg9Jy9wcm9qZWN0cycgY29tcG9uZW50PXtQcm9qZWN0UGFnZX0+PC9Sb3V0ZT5cbiAgICAgICAgICAgICAgICAgICAgPC9Td2l0Y2g+XG4gICAgICAgICAgICAgICAgPC9Ccm93c2VyUm91dGVyPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoPEFwcC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpOyJdLCJtYXBwaW5ncyI6Ijs7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQUZBO0FBV0E7Ozs7QUFkQTtBQUNBO0FBZ0JBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/index.js\n");

/***/ }),

/***/ "./src/app/nav.js":
/*!************************!*\
  !*** ./src/app/nav.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar css = __webpack_require__(/*! ./css/nav.css */ \"./src/app/css/nav.css\");\n\nvar NavBar = function (_React$Component) {\n    _inherits(NavBar, _React$Component);\n\n    function NavBar(props) {\n        _classCallCheck(this, NavBar);\n\n        return _possibleConstructorReturn(this, (NavBar.__proto__ || Object.getPrototypeOf(NavBar)).call(this, props));\n    }\n\n    _createClass(NavBar, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'nav',\n                    null,\n                    React.createElement(\n                        'ul',\n                        { 'class': 'nav' },\n                        React.createElement(\n                            'li',\n                            { 'class': 'internal' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element home', href: '/' },\n                                'Home'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'internal' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element about', href: '/about' },\n                                'About'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'internal' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element projects', href: 'projects' },\n                                'Projects'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'external' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element linkedin', href: 'http://linkedin.com' },\n                                'Linkedin'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'external' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element github', href: 'http://github.com' },\n                                'Github'\n                            )\n                        ),\n                        React.createElement(\n                            'li',\n                            { 'class': 'external' },\n                            React.createElement(\n                                'a',\n                                { 'class': 'nav-element facebook', href: 'http://facebook.com' },\n                                'Facebook'\n                            )\n                        )\n                    )\n                )\n            );\n        }\n    }]);\n\n    return NavBar;\n}(React.Component);\n\nmodule.exports = NavBar;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL25hdi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwL25hdi5qcz9hOGYwIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5sZXQgY3NzID0gcmVxdWlyZSgnLi9jc3MvbmF2LmNzcycpO1xuXG5cbmNsYXNzIE5hdkJhciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8bmF2PlxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9J25hdic+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9J2ludGVybmFsJz48YSBjbGFzcz0nbmF2LWVsZW1lbnQgaG9tZScgaHJlZj0nLyc+SG9tZTwvYT48L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPSdpbnRlcm5hbCc+PGEgY2xhc3M9J25hdi1lbGVtZW50IGFib3V0JyBocmVmPScvYWJvdXQnPkFib3V0PC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9J2ludGVybmFsJz48YSBjbGFzcz0nbmF2LWVsZW1lbnQgcHJvamVjdHMnIGhyZWY9J3Byb2plY3RzJz5Qcm9qZWN0czwvYT48L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgey8qIDxsaSBjbGFzcz0naW50ZXJuYWwgbG9nbyc+PHNwYW4gY2xhc3M9J25hdi1lbGVtZW50Jz5NUzwvc3Bhbj48L2xpPiAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0nZXh0ZXJuYWwnPjxhIGNsYXNzPSduYXYtZWxlbWVudCBsaW5rZWRpbicgaHJlZj0naHR0cDovL2xpbmtlZGluLmNvbSc+TGlua2VkaW48L2E+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0nZXh0ZXJuYWwnPjxhIGNsYXNzPSduYXYtZWxlbWVudCBnaXRodWInIGhyZWY9J2h0dHA6Ly9naXRodWIuY29tJz5HaXRodWI8L2E+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0nZXh0ZXJuYWwnPjxhIGNsYXNzPSduYXYtZWxlbWVudCBmYWNlYm9vaycgaHJlZj0naHR0cDovL2ZhY2Vib29rLmNvbSc+RmFjZWJvb2s8L2E+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICA8L25hdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdkJhciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUEE7QUFEQTtBQURBO0FBY0E7Ozs7QUFyQkE7QUFDQTtBQXVCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/nav.js\n");

/***/ }),

/***/ "./src/app/project.js":
/*!****************************!*\
  !*** ./src/app/project.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reactRouterDom = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/es/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar css = __webpack_require__(/*! ./css/project.css */ \"./src/app/css/project.css\");\n\nvar projects = [{\n    name: \"name\",\n    desc: \"Sunt anim cillum ullamco est tempor magna. Ea dolore nisi anim ea et proident ullamco esse sunt qui adipisicing velit. Incididunt dolore Lorem velit id duis reprehenderit consectetur consectetur eiusmod magna sit id nulla. Irure eu minim duis incididunt pariatur. Aliquip velit aliqua mollit minim pariatur laboris sunt Lorem minim fugiat laboris eu elit incididunt. Est voluptate pariatur enim tempor velit pariatur. Eu incididunt consectetur dolore dolore aliqua id aliquip esse velit ex ad et reprehenderit.\",\n    link: \"http://google.com\",\n    pic: \"picture\"\n}, {\n    name: \"name2\",\n    desc: \"Velit non ipsum ea mollit eu Lorem occaecat non. Velit mollit minim amet labore magna cillum eu ea. Ipsum mollit cupidatat eiusmod officia non fugiat veniam. Reprehenderit culpa cillum exercitation minim labore proident velit id dolore. Cillum ad nostrud ut ea anim esse ut consectetur ullamco.\",\n    link: \"http://google.com\",\n    pic: \"picture\"\n}, {\n    name: \"name3\",\n    desc: \"Minim id veniam sit aute nisi anim occaecat. Laborum ad voluptate id laborum aliqua enim in nulla voluptate cupidatat culpa in nisi. Labore proident adipisicing occaecat est anim sit. Eiusmod duis commodo velit eu. Consequat commodo do minim sunt fugiat aliquip nisi proident consequat. Excepteur cupidatat do ea sunt ullamco eiusmod et laborum. Sint incididunt laborum nisi eu ad.\",\n    link: \"http://google.com\",\n    pic: \"https://images.pexels.com/photos/248797/pexels-photo-248797.jpeg?auto=compress&cs=tinysrgb&h=350\"\n}];\n\nvar ProjectPage = function (_React$Component) {\n    _inherits(ProjectPage, _React$Component);\n\n    function ProjectPage(props) {\n        _classCallCheck(this, ProjectPage);\n\n        return _possibleConstructorReturn(this, (ProjectPage.__proto__ || Object.getPrototypeOf(ProjectPage)).call(this, props));\n    }\n\n    _createClass(ProjectPage, [{\n        key: 'render',\n        value: function render() {\n            var projectDiv = projects.map(function (project) {\n                return React.createElement(Project, { name: project.name, desc: project.desc, pic: project.pic });\n            });\n\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'h1',\n                    null,\n                    'These are my projects'\n                ),\n                React.createElement(\n                    'div',\n                    null,\n                    projectDiv\n                )\n            );\n        }\n    }]);\n\n    return ProjectPage;\n}(React.Component);\n\nvar Project = function (_React$Component2) {\n    _inherits(Project, _React$Component2);\n\n    function Project() {\n        _classCallCheck(this, Project);\n\n        return _possibleConstructorReturn(this, (Project.__proto__ || Object.getPrototypeOf(Project)).apply(this, arguments));\n    }\n\n    _createClass(Project, [{\n        key: 'render',\n        value: function render() {\n            return React.createElement(\n                'div',\n                null,\n                React.createElement(\n                    'h2',\n                    null,\n                    this.props.name\n                ),\n                React.createElement(\n                    'p',\n                    null,\n                    this.props.desc\n                ),\n                React.createElement(\n                    'a',\n                    { href: this.props.link },\n                    'Link to it'\n                ),\n                React.createElement('img', { src: this.props.pic })\n            );\n        }\n    }]);\n\n    return Project;\n}(React.Component);\n\nmodule.exports = ProjectPage;\n\n//pro, name, desc, link, pic//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL3Byb2plY3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC9wcm9qZWN0LmpzPzY2YjIiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbmxldCBjc3MgPSByZXF1aXJlKCcuL2Nzcy9wcm9qZWN0LmNzcycpO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xubGV0IHByb2plY3RzID0gW3tcbiAgICBuYW1lOiBcIm5hbWVcIixcbiAgICBkZXNjOiBcIlN1bnQgYW5pbSBjaWxsdW0gdWxsYW1jbyBlc3QgdGVtcG9yIG1hZ25hLiBFYSBkb2xvcmUgbmlzaSBhbmltIGVhIGV0IHByb2lkZW50IHVsbGFtY28gZXNzZSBzdW50IHF1aSBhZGlwaXNpY2luZyB2ZWxpdC4gSW5jaWRpZHVudCBkb2xvcmUgTG9yZW0gdmVsaXQgaWQgZHVpcyByZXByZWhlbmRlcml0IGNvbnNlY3RldHVyIGNvbnNlY3RldHVyIGVpdXNtb2QgbWFnbmEgc2l0IGlkIG51bGxhLiBJcnVyZSBldSBtaW5pbSBkdWlzIGluY2lkaWR1bnQgcGFyaWF0dXIuIEFsaXF1aXAgdmVsaXQgYWxpcXVhIG1vbGxpdCBtaW5pbSBwYXJpYXR1ciBsYWJvcmlzIHN1bnQgTG9yZW0gbWluaW0gZnVnaWF0IGxhYm9yaXMgZXUgZWxpdCBpbmNpZGlkdW50LiBFc3Qgdm9sdXB0YXRlIHBhcmlhdHVyIGVuaW0gdGVtcG9yIHZlbGl0IHBhcmlhdHVyLiBFdSBpbmNpZGlkdW50IGNvbnNlY3RldHVyIGRvbG9yZSBkb2xvcmUgYWxpcXVhIGlkIGFsaXF1aXAgZXNzZSB2ZWxpdCBleCBhZCBldCByZXByZWhlbmRlcml0LlwiLFxuICAgIGxpbms6IFwiaHR0cDovL2dvb2dsZS5jb21cIixcbiAgICBwaWM6IFwicGljdHVyZVwiXG59LFxue1xuICAgIG5hbWU6XCJuYW1lMlwiLFxuICAgIGRlc2M6IFwiVmVsaXQgbm9uIGlwc3VtIGVhIG1vbGxpdCBldSBMb3JlbSBvY2NhZWNhdCBub24uIFZlbGl0IG1vbGxpdCBtaW5pbSBhbWV0IGxhYm9yZSBtYWduYSBjaWxsdW0gZXUgZWEuIElwc3VtIG1vbGxpdCBjdXBpZGF0YXQgZWl1c21vZCBvZmZpY2lhIG5vbiBmdWdpYXQgdmVuaWFtLiBSZXByZWhlbmRlcml0IGN1bHBhIGNpbGx1bSBleGVyY2l0YXRpb24gbWluaW0gbGFib3JlIHByb2lkZW50IHZlbGl0IGlkIGRvbG9yZS4gQ2lsbHVtIGFkIG5vc3RydWQgdXQgZWEgYW5pbSBlc3NlIHV0IGNvbnNlY3RldHVyIHVsbGFtY28uXCIsXG4gICAgbGluazogXCJodHRwOi8vZ29vZ2xlLmNvbVwiLFxuICAgIHBpYzogXCJwaWN0dXJlXCJcbn0sXG57XG4gICAgbmFtZTpcIm5hbWUzXCIsXG4gICAgZGVzYzogXCJNaW5pbSBpZCB2ZW5pYW0gc2l0IGF1dGUgbmlzaSBhbmltIG9jY2FlY2F0LiBMYWJvcnVtIGFkIHZvbHVwdGF0ZSBpZCBsYWJvcnVtIGFsaXF1YSBlbmltIGluIG51bGxhIHZvbHVwdGF0ZSBjdXBpZGF0YXQgY3VscGEgaW4gbmlzaS4gTGFib3JlIHByb2lkZW50IGFkaXBpc2ljaW5nIG9jY2FlY2F0IGVzdCBhbmltIHNpdC4gRWl1c21vZCBkdWlzIGNvbW1vZG8gdmVsaXQgZXUuIENvbnNlcXVhdCBjb21tb2RvIGRvIG1pbmltIHN1bnQgZnVnaWF0IGFsaXF1aXAgbmlzaSBwcm9pZGVudCBjb25zZXF1YXQuIEV4Y2VwdGV1ciBjdXBpZGF0YXQgZG8gZWEgc3VudCB1bGxhbWNvIGVpdXNtb2QgZXQgbGFib3J1bS4gU2ludCBpbmNpZGlkdW50IGxhYm9ydW0gbmlzaSBldSBhZC5cIixcbiAgICBsaW5rOiBcImh0dHA6Ly9nb29nbGUuY29tXCIsXG4gICAgcGljOiBcImh0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzI0ODc5Ny9wZXhlbHMtcGhvdG8tMjQ4Nzk3LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZoPTM1MFwiXG59XVxuXG5jbGFzcyBQcm9qZWN0UGFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpXG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBwcm9qZWN0RGl2ID0gcHJvamVjdHMubWFwKHByb2plY3QgPT4gPFByb2plY3QgbmFtZT17cHJvamVjdC5uYW1lfSBkZXNjPXtwcm9qZWN0LmRlc2N9IHBpYz17cHJvamVjdC5waWN9IC8+KVxuXG4gICAgICAgIHJldHVybihcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGgxPlRoZXNlIGFyZSBteSBwcm9qZWN0czwvaDE+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAge3Byb2plY3REaXZ9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNsYXNzIFByb2plY3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlciAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxoMj57dGhpcy5wcm9wcy5uYW1lfTwvaDI+XG4gICAgICAgICAgICAgICAgPHA+e3RoaXMucHJvcHMuZGVzY308L3A+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj17dGhpcy5wcm9wcy5saW5rfT5MaW5rIHRvIGl0PC9hPlxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPXt0aGlzLnByb3BzLnBpY30vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdFBhZ2VcblxuLy9wcm8sIG5hbWUsIGRlc2MsIGxpbmssIHBpY1xuIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7QUFDQTs7Ozs7OztBQUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQU9BOzs7O0FBaEJBO0FBQ0E7QUFrQkE7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUpBO0FBT0E7Ozs7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/project.js\n");

/***/ })

/******/ });